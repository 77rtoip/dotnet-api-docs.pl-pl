<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2085279f1ce1cd75258de47603b0a87d8e5a23b4" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68397393" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia dostęp do kolejki na serwerze usługi kolejkowania komunikatów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Technologia kolejkowania komunikatów umożliwia aplikacjom działającym w różnym czasie komunikowanie się między niejednorodnymi sieciami i systemami, które mogą być tymczasowo w trybie offline. Aplikacje wysyłają, odbierają lub wkraczają (odczytu bez usuwania) komunikatów z kolejek. Usługa kolejkowania komunikatów jest opcjonalnym składnikiem [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] systemu i Windows NT i musi być zainstalowana osobno.  
  
 <xref:System.Messaging.MessageQueue> Klasa jest otoką dookoła usługi kolejkowania komunikatów. Istnieje wiele wersji usługi kolejkowania komunikatów i użycie <xref:System.Messaging.MessageQueue> klasy może spowodować nieco inne zachowanie, w zależności od używanego systemu operacyjnego. Aby uzyskać informacje o konkretnych funkcjach poszczególnych wersji usługi kolejkowania komunikatów, zobacz temat "co nowego w usłudze kolejkowania komunikatów" w zestawie SDK platformy w witrynie MSDN.  
  
 <xref:System.Messaging.MessageQueue> Klasa zawiera odwołanie do kolejki usługi kolejkowania komunikatów. Możesz określić ścieżkę w <xref:System.Messaging.MessageQueue.%23ctor%2A> konstruktorze, aby połączyć się z istniejącym zasobem lub utworzyć nową kolejkę na serwerze. Przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, lub <xref:System.Messaging.MessageQueue.Receive%2A>, należy skojarzyć nowe wystąpienie <xref:System.Messaging.MessageQueue> klasy z istniejącą kolejką. W tym momencie można manipulować właściwościami kolejki, takimi jak <xref:System.Messaging.MessageQueue.Category%2A> i <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue>obsługuje dwa typy pobieranych komunikatów: synchroniczne i asynchroniczne. Metody <xref:System.Messaging.MessageQueue.Peek%2A> synchroniczne i <xref:System.Messaging.MessageQueue.Receive%2A>, powodują, że wątek procesu oczekuje określonego przedziału czasu na nadejście nowej wiadomości w kolejce. Metody <xref:System.Messaging.MessageQueue.BeginPeek%2A> asynchroniczne i <xref:System.Messaging.MessageQueue.BeginReceive%2A>umożliwiają kontynuowanie zadań głównych aplikacji w osobnym wątku do momentu odebrania komunikatu w kolejce. Metody te działają przy użyciu obiektów wywołania zwrotnego i obiektów stanu do przekazywania informacji między wątkami.  
  
 Gdy tworzysz nowe wystąpienie <xref:System.Messaging.MessageQueue> klasy, nie tworzysz nowej kolejki usługi kolejkowania komunikatów. Zamiast tego można użyć <xref:System.Messaging.MessageQueue.Create%28System.String%29>metod, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>i <xref:System.Messaging.MessageQueue.Purge%2A> do zarządzania kolejkami na serwerze.  
  
 <xref:System.Messaging.MessageQueue.Purge%2A>W przeciwieństwie <xref:System.Messaging.MessageQueue.Create%28System.String%29> do <xref:System.Messaging.MessageQueue.Delete%28System.String%29> elementów `static` i są członkami, więc można je wywoływać bez tworzenia nowego wystąpienia <xref:System.Messaging.MessageQueue> klasy.  
  
 <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.Label%2A>Właściwość obiektu można ustawić przy użyciu jednej z trzech nazw: przyjazna nazwa, <xref:System.Messaging.MessageQueue.FormatName%2A>lub. <xref:System.Messaging.MessageQueue.Path%2A> Przyjazna <xref:System.Messaging.MessageQueue.MachineName%2A> nazwa, która jest definiowana przez kolejki i `Private$` \\ \\ <xref:System.Messaging.MessageQueue.MachineName%2A> <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości, jest \\ <xref:System.Messaging.MessageQueue.QueueName%2A> dla kolejki publicznej i <xref:System.Messaging.MessageQueue.MachineName%2A> <xref:System.Messaging.MessageQueue.QueueName%2A> dla kolejki prywatnej. <xref:System.Messaging.MessageQueue.FormatName%2A> Właściwość zezwala na dostęp w trybie offline do kolejek komunikatów. Na koniec można użyć <xref:System.Messaging.MessageQueue.Label%2A> właściwości kolejki, aby ustawić <xref:System.Messaging.MessageQueue.Path%2A>kolejkę.  
  
 Aby uzyskać listę początkowych wartości właściwości dla wystąpienia <xref:System.Messaging.MessageQueue>, <xref:System.Messaging.MessageQueue.%23ctor%2A> Zobacz Konstruktor.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowe <xref:System.Messaging.MessageQueue> obiekty przy użyciu różnych typów składni nazw ścieżek. W każdym przypadku wysyła komunikat do kolejki, której ścieżka jest zdefiniowana w konstruktorze.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 Poniższy przykład kodu wysyła komunikat do kolejki i odbiera komunikat z kolejki przy użyciu klasy specyficznej dla aplikacji o nazwie `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> Tylko Metoda jest bezpieczna wątkowo.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy. Gdy Konstruktor bez parametrów Inicjuje nowe wystąpienie, należy ustawić <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość wystąpienia, aby można było użyć wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie <xref:System.Messaging.MessageQueue> klasy, które nie jest bezpośrednio powiązane z kolejką na serwerze usługi kolejkowania komunikatów. Przed użyciem tego wystąpienia należy połączyć je z istniejącą kolejką usługi kolejkowania komunikatów przez ustawienie <xref:System.Messaging.MessageQueue.Path%2A> właściwości. Alternatywnie można ustawić <xref:System.Messaging.MessageQueue> odwołanie <xref:System.Messaging.MessageQueue.Create%28System.String%29> do wartości zwracanej metody, tworząc nową kolejkę usługi kolejkowania komunikatów.  
  
 Konstruktor tworzy wystąpienie nowego wystąpienia <xref:System.Messaging.MessageQueue> klasy; nie tworzy nowej kolejki usługi kolejkowania komunikatów. <xref:System.Messaging.MessageQueue.%23ctor%2A>  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.MessageQueue>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Wartości ustawione przez konstruktora <xref:System.Messaging.DefaultPropertiesToSend> bez parametrów klasy.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Wartości ustawione przez konstruktora <xref:System.Messaging.MessagePropertyFilter> bez parametrów klasy. Wszystkie wartości filtru są ustawiane na `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowy <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizacja kolejki, do której odwołuje się <see cref="T:System.Messaging.MessageQueue" />ten.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Messaging.MessageQueue" /> klasy, która odwołuje się do kolejki usługi kolejkowania komunikatów w określonej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, gdy chcesz powiązać nowe <xref:System.Messaging.MessageQueue> wystąpienie z określoną kolejką usługi kolejkowania komunikatów, dla którego znasz ścieżkę, nazwę formatu lub etykietę. Aby udzielić wyłącznego dostępu do pierwszej aplikacji, która odwołuje się do kolejki, należy ustawić <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> właściwość na `true` lub użyć konstruktora, który przekazuje parametr ograniczenia dostępu do odczytu.  
  
 Konstruktor tworzy wystąpienie nowego wystąpienia <xref:System.Messaging.MessageQueue> klasy; nie tworzy nowej kolejki usługi kolejkowania komunikatów. <xref:System.Messaging.MessageQueue.%23ctor%2A> Aby utworzyć nową kolejkę w usłudze kolejkowania komunikatów, użyj <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Składnia `path` parametru zależy od typu kolejki, do której się odwołuje, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejka dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejka dzienników maszyn|`MachineName`\\`Journal$`|  
|Kolejka utraconych wiadomości komputera|`MachineName`\\`Deadletter$`|  
|Kolejka utraconych wiadomości transakcyjnych komputera|`MachineName`\\`XactDeadletter$`|  
  
 Alternatywnie można użyć <xref:System.Messaging.MessageQueue.FormatName%2A> lub <xref:System.Messaging.MessageQueue.Label%2A> do opisania ścieżki kolejki, jak pokazano w poniższej tabeli.  
  
|Tematy pomocy|Składnia|Przykład|  
|---------------|------------|-------------|  
|Nazwa formatu|`FormatName:`[ *nazwa formatu* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Etykieta|`Label:`[ *etykieta* ]|`Label:`TheLabel|  
  
 Aby działało w trybie offline, musisz użyć składni nazwy formatu, a nie składni nazwy ścieżki dla konstruktora. W przeciwnym razie jest zgłaszany wyjątek, ponieważ podstawowy kontroler domeny nie jest dostępny do rozpoznawania ścieżki do nazwy formatu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.MessageQueue>. Te wartości są oparte na właściwościach kolejki usługi kolejkowania komunikatów z ścieżką określoną przez `path` parametr.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Wartości ustawione przez konstruktora <xref:System.Messaging.DefaultPropertiesToSend> bez parametrów klasy.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`Jeśli ustawienie poziomu prywatności kolejki usługi kolejkowania komunikatów ma wartość "treść"; w przeciwnym razie. `false`|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Wartość właściwości Nazwa komputera kolejki usługi kolejkowania komunikatów.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Wartości ustawione przez konstruktora <xref:System.Messaging.MessagePropertyFilter> bez parametrów klasy.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, jeśli nie jest ustawiony przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, jeśli nie jest ustawiony przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, jeśli ustawienie dziennika obiektu usługi kolejkowania komunikatów jest włączone; w przeciwnym razie. `false`|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowe <xref:System.Messaging.MessageQueue> obiekty przy użyciu różnych typów składni nazw ścieżek. W każdym przypadku wysyła komunikat do kolejki, której ścieżka jest zdefiniowana w konstruktorze.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość jest nieprawidłowa, prawdopodobnie dlatego, że nie została ustawiona.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizacja kolejki, do której odwołuje się <see cref="T:System.Messaging.MessageQueue" />ten, co może być "." na komputerze lokalnym.</param>
        <param name="sharedModeDenyReceive"><see langword="true" />Aby udzielić wyłącznego dostępu do odczytu do pierwszej aplikacji, która uzyskuje dostęp do kolejki; w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Messaging.MessageQueue" /> klasy, która odwołuje się do kolejki usługi kolejkowania komunikatów w określonej ścieżce i z określonym ograniczeniem dostępu do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, gdy chcesz powiązać nowy <xref:System.Messaging.MessageQueue> z określoną kolejką usługi kolejkowania komunikatów, dla którego znasz ścieżkę, nazwę formatu lub etykietę. Jeśli chcesz udzielić wyłącznego dostępu do pierwszej aplikacji, która odwołuje się do kolejki, ustaw `sharedModeDenyReceive` parametr na `true`. W przeciwnym razie `sharedModeDenyReceive` Ustaw `false` lub Użyj `path` konstruktora, który ma tylko parametr.  
  
 Ustawienie `sharedModeDenyReceive`mawpływna wszystkie obiekty, które uzyskują dostęp do kolejki usługi kolejkowania komunikatów, łącznie z innymi aplikacjami. `true` Skutki parametru nie są ograniczone do tej aplikacji.  
  
 Konstruktor tworzy nowe wystąpienie <xref:System.Messaging.MessageQueue> klasy; nie tworzy nowej kolejki usługi kolejkowania komunikatów. <xref:System.Messaging.MessageQueue.%23ctor%2A> Aby utworzyć nową kolejkę w usłudze kolejkowania komunikatów, użyj <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Składnia `path` parametru zależy od typu kolejki.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejka dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejka dzienników maszyn|`MachineName`\\`Journal$`|  
|Kolejka utraconych wiadomości komputera|`MachineName`\\`Deadletter$`|  
|Kolejka utraconych wiadomości transakcyjnych komputera|`MachineName`\\`XactDeadletter$`|  
  
 Alternatywnie można użyć nazwy formatu lub etykiety kolejki usługi kolejkowania komunikatów do opisania ścieżki kolejki.  
  
|Tematy pomocy|Składnia|Przykład|  
|---------------|------------|-------------|  
|Nazwa formatu|`FormatName:`[ *nazwa formatu* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Etykieta|`Label:`[ *etykieta* ]|`Label:`TheLabel|  
  
 Aby działało w trybie offline, należy użyć składni nazwy formatu zamiast składni przyjaznej nazwy. W przeciwnym razie jest zgłaszany wyjątek, ponieważ podstawowy kontroler domeny (na którym znajdują się Active Directory) nie jest dostępny do rozpoznawania ścieżki do nazwy formatu.  
  
 `true` <xref:System.Messaging.MessageQueueException> <xref:System.Messaging.MessageQueue> Jeśli zostanie otwarta kolejka `sharedModeDenyReceive` z parametrem ustawionym na, wszystkie próby odczytu z kolejki generują z powodu naruszenia zasad współużytkowania. <xref:System.Messaging.MessageQueue> Występuje <xref:System.Messaging.MessageQueueException> również, <xref:System.Messaging.MessageQueue> gdy próbuje uzyskać dostęp do kolejki w trybie wyłączności, podczas <xref:System.Messaging.MessageQueue> gdy inny ma już niewyłączny dostęp do kolejki.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.MessageQueue>. Te wartości są oparte na właściwościach kolejki usługi kolejkowania komunikatów z ścieżką określoną przez `path` parametr.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Wartości ustawione przez konstruktora <xref:System.Messaging.DefaultPropertiesToSend> bez parametrów klasy.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`Jeśli ustawienie poziomu prywatności kolejki usługi kolejkowania komunikatów ma wartość "treść"; w przeciwnym razie. `false`|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Wartość właściwości Nazwa komputera kolejki usługi kolejkowania komunikatów.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Wartości ustawione przez konstruktora <xref:System.Messaging.MessagePropertyFilter> bez parametrów klasy.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, jeśli nie jest ustawiony przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, jeśli nie jest ustawiony przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Wartość `sharedModeDenyReceive` parametru.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, jeśli ustawienie dziennika obiektu usługi kolejkowania komunikatów jest włączone; w przeciwnym razie. `false`|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowy <xref:System.Messaging.MessageQueue> z wyłącznym dostępem, ustawia jego ścieżkę i wysyła komunikat do kolejki.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość jest nieprawidłowa, prawdopodobnie dlatego, że nie została ustawiona.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizacja kolejki, do której odwołuje się <see cref="T:System.Messaging.MessageQueue" />ten, co może być "." na komputerze lokalnym.</param>
        <param name="accessMode">Jedna z <see cref="T:System.Messaging.QueueAccessMode" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizacja kolejki, do której odwołuje się <see cref="T:System.Messaging.MessageQueue" />ten, co może być "." na komputerze lokalnym.</param>
        <param name="sharedModeDenyReceive"><see langword="true" />Aby udzielić wyłącznego dostępu do odczytu do pierwszej aplikacji, która uzyskuje dostęp do kolejki; w przeciwnym razie. <see langword="false" /></param>
        <param name="enableCache"><see langword="true" />Tworzenie i używanie pamięci podręcznej połączenia; w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy nowy <xref:System.Messaging.MessageQueue> z wyłącznym dostępem do odczytu i z włączonym buforowaniem połączeń.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizacja kolejki, do której odwołuje się <see cref="T:System.Messaging.MessageQueue" />ten, co może być "." na komputerze lokalnym.</param>
        <param name="sharedModeDenyReceive"><see langword="true" />Aby udzielić wyłącznego dostępu do odczytu do pierwszej aplikacji, która uzyskuje dostęp do kolejki; w przeciwnym razie. <see langword="false" /></param>
        <param name="enableCache"><see langword="true" />Tworzenie i używanie pamięci podręcznej połączenia; w przeciwnym razie. <see langword="false" /></param>
        <param name="accessMode">Jedna z <see cref="T:System.Messaging.QueueAccessMode" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą tryb dostępu dla kolejki.</summary>
        <value>Jedna z <see cref="T:System.Messaging.QueueAccessMode" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny tryb dostępu dla kolejki to `QueueAccessMode.SendAndReceive`, chyba że określisz inaczej podczas wywoływania konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kolejka akceptuje tylko wiadomości uwierzytelnione.</summary>
        <value><see langword="true" />Jeśli kolejka akceptuje tylko wiadomości uwierzytelnione; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie komunikatów umożliwia zapewnienie integralności komunikatów i zweryfikowanie, kto przysłał wiadomość. Aby zażądać uwierzytelniania, aplikacja wysyłająca ustawia poziom uwierzytelniania wiadomości.  
  
 Po ustawieniu <xref:System.Messaging.MessageQueue.Authenticate%2A> na `true`, ograniczasz dostęp do kolejki na serwerze, nie tylko dla tego <xref:System.Messaging.MessageQueue> wystąpienia. Wszyscy klienci, którzy pracują z tą samą kolejką usługi kolejkowania komunikatów.  
  
 Kolejka, która akceptuje tylko uwierzytelnione komunikaty, odrzuci komunikat nieuwierzytelniony. Aby zażądać powiadomienia o odrzuceniu komunikatu, aplikacja wysyłająca może ustawić <xref:System.Messaging.Message.AcknowledgeType%2A> Właściwość wiadomości. Ponieważ nie istnieje żadne inne wskazanie odrzucenia komunikatu, aplikacja wysyłająca może utracić komunikat, chyba że zostanie wysłane żądanie wysłania go do kolejki utraconych wiadomości.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.Authenticate%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia usługę kolejkowania komunikatów Priorytet podstawowy, która używa do kierowania komunikatów w kolejce publicznej za pośrednictwem sieci.</summary>
        <value>Podstawowy priorytet dla wszystkich wiadomości wysłanych do kolejki (publicznej). Wartość domyślna to zero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowy priorytet kolejki komunikatów określa sposób, w jaki komunikat w trasie do tej kolejki jest traktowany jako przenoszone przez sieć. <xref:System.Messaging.MessageQueue.BasePriority%2A> Właściwość można ustawić na wartość przyciągania wyższego lub niższego priorytetu do wszystkich komunikatów wysyłanych do określonej kolejki niż te wysyłane do innych kolejek. Ustawienie tej właściwości powoduje modyfikację kolejki usługi kolejkowania komunikatów. W związku z tym <xref:System.Messaging.MessageQueue> zmiana ma wpływ na wszystkie inne wystąpienia.  
  
 Kolejka <xref:System.Messaging.MessageQueue.BasePriority%2A> komunikatów nie jest powiązana <xref:System.Messaging.Message.Priority%2A> z właściwością komunikatu, która określa kolejność, w której umieszczany jest komunikat przychodzący do kolejki.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A>dotyczy tylko kolejek publicznych, których ścieżki są określone przy użyciu nazwy formatu. Priorytet podstawowy kolejki prywatnej jest zawsze równy zero (0).  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.BasePriority%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Priorytet podstawowy został ustawiony na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <summary>Inicjuje asynchroniczną operację wglądu, informując usługę kolejkowania komunikatów, aby rozpocząć wgląd w komunikat i powiadomić program obsługi zdarzeń po zakończeniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje asynchroniczną operację wglądu, która nie ma limitu czasu. Operacja nie zostanie zakończona do momentu udostępnienia komunikatu w kolejce.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Który identyfikuje ogłoszone żądanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku przetwarzania asynchronicznego służy <xref:System.Messaging.MessageQueue.BeginPeek%2A> do <xref:System.Messaging.MessageQueue.PeekCompleted> zgłaszania zdarzenia, gdy komunikat będzie dostępny w kolejce.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>jest również uruchamiany, jeśli komunikat już istnieje w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginPeek%2A>, Utwórz program obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznej i skojarz ją z delegatem zdarzenia. <xref:System.Messaging.MessageQueue.BeginPeek%2A>Inicjuje asynchroniczną operację wglądu; zostanie powiadomiony przez podnoszenie <xref:System.Messaging.MessageQueue.PeekCompleted> poziomu zdarzenia po nadejściu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Następnie może uzyskać dostęp do komunikatu przez wywołanie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lub przez <xref:System.Messaging.PeekCompletedEventArgs>pobranie wyniku przy użyciu. <xref:System.Messaging.MessageQueue>  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda wraca natychmiast, ale operacja asynchroniczna nie zostanie zakończona do momentu wywołania programu obsługi zdarzeń.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczna, można wywołać ją w celu wglądu do kolejki bez blokowania bieżącego wątku wykonywania. Aby synchronicznie wgląd do kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w programie obsługi zdarzeń, aby nadal otrzymywać powiadomienia.  
  
 <xref:System.IAsyncResult> Funkcja zwracającawartośćidentyfikujeasynchronicznąoperację<xref:System.Messaging.MessageQueue.BeginPeek%2A> uruchomioną przez metodę. Można jej użyć <xref:System.IAsyncResult> w okresie istnienia operacji, chociaż zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wywołania. Jeśli jednak uruchamiasz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określić, czy czekać na wszystkie operacje, czy dowolna operacja zostanie ukończona. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwości, <xref:System.IAsyncResult> aby zidentyfikować ukończoną operację.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>ma `false`wartość, zostanie zgłoszone zdarzenie ukończenia, ale podczas wywoływania zostanie zgłoszony wyjątek.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyPeekCompleted`, dołącza go <xref:System.Messaging.MessageQueue.PeekCompleted> do delegata programu obsługi zdarzeń i wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> do inicjowania asynchronicznej operacji wglądu do kolejki, która znajduje się w ścieżce ".\myQueue". <xref:System.Messaging.MessageQueue.PeekCompleted> Gdy zdarzenie jest zgłaszane, przykład służy do wglądu w komunikat i zapisywania jego treści na ekranie. Przykład następnie wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> ponownie w celu zainicjowania nowej asynchronicznej operacji wglądu.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Który wskazuje interwał czasu oczekiwania na udostępnienie komunikatu.</param>
        <summary>Inicjuje asynchroniczną operację wglądu, która ma określony limit czasu. Operacja nie zostanie zakończona do momentu udostępnienia komunikatu w kolejce lub przekroczenia limitu czasu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Który identyfikuje ogłoszone żądanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku przetwarzania asynchronicznego służy <xref:System.Messaging.MessageQueue.BeginPeek%2A> do <xref:System.Messaging.MessageQueue.PeekCompleted> zgłaszania zdarzenia, gdy komunikat będzie dostępny w kolejce lub po upływie określonego interwału czasu.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>jest również uruchamiany, jeśli komunikat już istnieje w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginPeek%2A>, Utwórz program obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznej i skojarz ją z delegatem zdarzenia. <xref:System.Messaging.MessageQueue.BeginPeek%2A>Inicjuje asynchroniczną operację wglądu; zostanie powiadomiony przez podnoszenie <xref:System.Messaging.MessageQueue.PeekCompleted> poziomu zdarzenia po nadejściu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Następnie może uzyskać dostęp do komunikatu przez wywołanie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lub przez <xref:System.Messaging.PeekCompletedEventArgs>pobranie wyniku przy użyciu. <xref:System.Messaging.MessageQueue>  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda wraca natychmiast, ale operacja asynchroniczna nie zostanie zakończona do momentu wywołania programu obsługi zdarzeń.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczna, można wywołać ją w celu wglądu do kolejki bez blokowania bieżącego wątku wykonywania. Aby synchronicznie wgląd do kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w programie obsługi zdarzeń, aby nadal otrzymywać powiadomienia.  
  
 <xref:System.IAsyncResult> Funkcja zwracającawartośćidentyfikujeasynchronicznąoperację<xref:System.Messaging.MessageQueue.BeginPeek%2A> uruchomioną przez metodę. Można jej użyć <xref:System.IAsyncResult> w okresie istnienia operacji, chociaż zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wywołania. Jeśli jednak uruchamiasz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określić, czy czekać na wszystkie operacje, czy dowolna operacja zostanie ukończona. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwości, <xref:System.IAsyncResult> aby zidentyfikować ukończoną operację.  
  
 To Przeciążenie określa limit czasu. Jeśli interwał określony przez `timeout` parametr wygaśnie, ten składnik <xref:System.Messaging.MessageQueue.PeekCompleted> zgłasza zdarzenie. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie metody <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> zgłosi wyjątek.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>ma `false`wartość, zostanie zgłoszone zdarzenie ukończenia, ale podczas wywoływania zostanie zgłoszony wyjątek.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchroniczną operację wglądu przy użyciu ścieżki kolejki ".\myQueue". Tworzy program obsługi `MyPeekCompleted`zdarzeń i dołącza go <xref:System.Messaging.MessageQueue.PeekCompleted> do delegata obsługi zdarzeń. <xref:System.Messaging.MessageQueue.BeginPeek%2A>jest wywoływana z limitem czasu z jednej minuty, aby zainicjować asynchroniczną operację wglądu. <xref:System.Messaging.MessageQueue.PeekCompleted> Gdy zdarzenie jest zgłaszane lub limit czasu wygaśnie, komunikat zostanie pobrany, jeśli taki istnieje, a jego treść jest zapisywana na ekranie. Następnie <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest wywoływana ponownie w celu zainicjowania nowej asynchronicznej operacji wglądu z tym samym limitem czasu.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Który wskazuje interwał czasu oczekiwania na udostępnienie komunikatu.</param>
        <param name="stateObject">Obiekt stanu określony przez aplikację, który zawiera informacje skojarzone z operacją asynchroniczną.</param>
        <summary>Inicjuje asynchroniczną operację wglądu, która ma określony limit czasu i określony obiekt State, który zawiera skojarzone informacje w okresie istnienia operacji. Operacja nie zostanie zakończona do momentu udostępnienia komunikatu w kolejce lub przekroczenia limitu czasu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Który identyfikuje ogłoszone żądanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku przetwarzania asynchronicznego służy <xref:System.Messaging.MessageQueue.BeginPeek%2A> do <xref:System.Messaging.MessageQueue.PeekCompleted> zgłaszania zdarzenia, gdy komunikat będzie dostępny w kolejce lub po upływie określonego interwału czasu.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>jest również uruchamiany, jeśli komunikat już istnieje w kolejce.  
  
 Użyj tego przeciążenia, aby skojarzyć informacje z operacją, która zostanie zachowana w okresie istnienia operacji. Program obsługi zdarzeń może uzyskać dostęp do tych informacji, przeglądając <xref:System.IAsyncResult.AsyncState%2A> Właściwość <xref:System.IAsyncResult> , która jest skojarzona z operacją.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginPeek%2A>, Utwórz program obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznej i skojarz ją z delegatem zdarzenia. <xref:System.Messaging.MessageQueue.BeginPeek%2A>Inicjuje asynchroniczną operację wglądu; zostanie powiadomiony przez podnoszenie <xref:System.Messaging.MessageQueue.PeekCompleted> poziomu zdarzenia po nadejściu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Następnie może uzyskać dostęp do komunikatu przez wywołanie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lub przez <xref:System.Messaging.PeekCompletedEventArgs>pobranie wyniku przy użyciu. <xref:System.Messaging.MessageQueue>  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda wraca natychmiast, ale operacja asynchroniczna nie zostanie zakończona do momentu wywołania programu obsługi zdarzeń.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczna, można wywołać ją w celu wglądu do kolejki bez blokowania bieżącego wątku wykonywania. Aby synchronicznie wgląd do kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w programie obsługi zdarzeń, aby nadal otrzymywać powiadomienia.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A><xref:System.IAsyncResult> zwraca identyfikującą operację asynchroniczną uruchomioną przez metodę. Można jej użyć <xref:System.IAsyncResult> w okresie istnienia operacji, chociaż zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wywołania. Jeśli jednak uruchamiasz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określić, czy czekać na wszystkie operacje, czy dowolna operacja zostanie ukończona. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwości, <xref:System.IAsyncResult> aby zidentyfikować ukończoną operację.  
  
 To Przeciążenie określa przekroczenie limitu czasu i obiektu stanu. Jeśli interwał określony przez `timeout` parametr wygaśnie, ten składnik <xref:System.Messaging.MessageQueue.PeekCompleted> zgłasza zdarzenie. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie metody <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> zgłosi wyjątek.  
  
 Obiekt State kojarzy informacje o stanie z operacją. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginPeek%2A> wiele razy, aby zainicjować wiele operacji, można zidentyfikować każdą operację za pomocą oddzielnego obiektu stanu, który definiujesz. Ilustracja przedstawiająca ten scenariusz znajduje się w sekcji przykład.  
  
 Można również użyć obiektu stanu do przekazywania informacji między wątkami procesów. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne znajduje się w innym wątku w scenariuszu asynchronicznym, obiekt stanu jest zorganizowany i przekazywany z powrotem wraz z informacjami ze zdarzenia.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>ma `false`wartość, zostanie zgłoszone zdarzenie ukończenia, ale podczas wywoływania zostanie zgłoszony wyjątek.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchroniczną operację wglądu przy użyciu ścieżki kolejki ".\myQueue". Tworzy program obsługi `MyPeekCompleted`zdarzeń i dołącza go <xref:System.Messaging.MessageQueue.PeekCompleted> do delegata obsługi zdarzeń. <xref:System.Messaging.MessageQueue.BeginPeek%2A>jest wywoływana, z limitem czasu z jednej minuty. Każde wywołanie <xref:System.Messaging.MessageQueue.BeginPeek%2A> ma unikatową skojarzoną liczbę całkowitą, która identyfikuje daną operację. <xref:System.Messaging.MessageQueue.PeekCompleted> Gdy zdarzenie jest zgłaszane lub upłynął limit czasu, komunikat, jeśli taki istnieje, jest pobierany, a jego treść i identyfikator liczby całkowitej specyficznej dla operacji są zapisywane na ekranie. Następnie <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest wywoływana ponownie w celu zainicjowania nowej asynchronicznej operacji wglądu z tym samym limitem czasu i skojarzoną liczbą całkowitą operacji po prostu ukończonej.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Który wskazuje interwał czasu oczekiwania na udostępnienie komunikatu.</param>
        <param name="stateObject">Obiekt stanu określony przez aplikację, który zawiera informacje skojarzone z operacją asynchroniczną.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> To spowoduje odebranie powiadomienia o ukończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje asynchroniczną operację wglądu, która ma określony limit czasu i określony obiekt State, który zawiera skojarzone informacje w okresie istnienia operacji. To Przeciążenie odbiera powiadomienie przy użyciu wywołania zwrotnego tożsamości programu obsługi zdarzeń dla operacji. Operacja nie zostanie zakończona do momentu udostępnienia komunikatu w kolejce lub przekroczenia limitu czasu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Który identyfikuje ogłoszone żądanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku użycia tego przeciążenia wywołania zwrotne określone w parametrze wywołania zwrotnego są wywoływane bezpośrednio po udostępnieniu komunikatu w kolejce lub upływie określonego interwału czasu. <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie nie zostało zgłoszone. Inne przeciążenia programu <xref:System.Messaging.MessageQueue.BeginPeek%2A> polegają na tym składniku w celu <xref:System.Messaging.MessageQueue.PeekCompleted> podniesienia zdarzenia.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>jest również uruchamiany, jeśli komunikat już istnieje w kolejce.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda wraca natychmiast, ale operacja asynchroniczna nie zostanie zakończona do momentu wywołania programu obsługi zdarzeń.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczna, można wywołać ją w celu wglądu do kolejki bez blokowania bieżącego wątku wykonywania. Aby synchronicznie wgląd do kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w programie obsługi zdarzeń, aby nadal otrzymywać powiadomienia.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A><xref:System.IAsyncResult> zwraca identyfikującą operację asynchroniczną uruchomioną przez metodę. Można jej użyć <xref:System.IAsyncResult> w okresie istnienia operacji, chociaż zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wywołania. Jeśli jednak uruchamiasz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określić, czy czekać na wszystkie operacje, czy dowolna operacja zostanie ukończona. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwości, <xref:System.IAsyncResult> aby zidentyfikować ukończoną operację.  
  
 Obiekt State kojarzy informacje o stanie z operacją. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginPeek%2A> wiele razy, aby zainicjować wiele operacji, można zidentyfikować każdą operację za pomocą oddzielnego obiektu stanu, który definiujesz.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchroniczną operację wglądu. Przykładowy kod wysyła komunikat do lokalnej kolejki komunikatów, a następnie wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, przekazując: wartość limitu czasu wynoszącą dziesięć sekund; unikatową liczbę całkowitą, która identyfikuje określony komunikat, oraz nowe <xref:System.AsyncCallback> wystąpienie, które identyfikuje program obsługi zdarzeń, `MyPeekCompleted`. <xref:System.Messaging.MessageQueue.PeekCompleted> Gdy zdarzenie jest zgłaszane, program obsługi zdarzeń wgląd w komunikat i zapisuje treść komunikatu oraz identyfikator wiadomości całkowitej na ekranie.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Który wskazuje interwał czasu oczekiwania na udostępnienie komunikatu.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który utrzymuje określone położenie w kolejce komunikatów.</param>
        <param name="action">Jedna z <see cref="T:System.Messaging.PeekAction" /> wartości. Wskazuje, czy ma być wgląd w bieżącą wiadomość w kolejce, czy następny komunikat.</param>
        <param name="state">Obiekt stanu określony przez aplikację, który zawiera informacje skojarzone z operacją asynchroniczną.</param>
        <param name="callback">, <see cref="T:System.AsyncCallback" /> Który odbiera powiadomienie o ukończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje asynchroniczną operację wglądu, która ma określony limit czasu i używa określonego kursora, określonej akcji wglądu i określonego obiektu stanu. Obiekt State zawiera powiązane informacje w okresie istnienia operacji. To Przeciążenie odbiera powiadomienie przy użyciu wywołania zwrotnego tożsamości programu obsługi zdarzeń dla operacji. Operacja nie zostanie zakończona do momentu udostępnienia komunikatu w kolejce lub przekroczenia limitu czasu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Który identyfikuje ogłoszone żądanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku użycia tego przeciążenia wywołania zwrotne określone w parametrze wywołania zwrotnego są wywoływane bezpośrednio po udostępnieniu komunikatu w kolejce lub po upływie określonego interwału czasu. <xref:System.Messaging.MessageQueue.PeekCompleted> Zdarzenie nie zostało zgłoszone. Inne przeciążenia programu <xref:System.Messaging.MessageQueue.BeginPeek%2A> polegają na tym składniku w celu <xref:System.Messaging.MessageQueue.PeekCompleted> podniesienia zdarzenia.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>jest również uruchamiany, jeśli komunikat już istnieje w kolejce.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda wraca natychmiast, ale operacja asynchroniczna nie zostanie zakończona do momentu wywołania programu obsługi zdarzeń.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczna, można wywołać ją w celu wglądu do kolejki bez blokowania bieżącego wątku wykonywania. Aby synchronicznie wgląd do kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w programie obsługi zdarzeń, aby nadal otrzymywać powiadomienia.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A><xref:System.IAsyncResult> zwraca identyfikującą operację asynchroniczną uruchomioną przez metodę. Można jej użyć <xref:System.IAsyncResult> w okresie istnienia operacji, chociaż zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wywołania. Jeśli jednak uruchamiasz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określić, czy czekać na wszystkie operacje, czy dowolna operacja zostanie ukończona. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwości, <xref:System.IAsyncResult> aby zidentyfikować ukończoną operację.  
  
 Obiekt State kojarzy informacje o stanie z operacją. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginPeek%2A> wiele razy, aby zainicjować wiele operacji, można zidentyfikować każdą operację za pomocą oddzielnego obiektu stanu, który definiujesz.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość inna niż <see langword="PeekAction.Current" /> lub <see langword="PeekAction.Next" /> została określona dla <paramref name="action" /> parametru.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="cursor" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <summary>Inicjuje asynchroniczną operację odbierania, informując usługę kolejkowania komunikatów o rozpoczęciu odbierania komunikatu i powiadamiania programu obsługi zdarzeń po zakończeniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje asynchroniczną operację odbierania, która nie ma limitu czasu. Operacja nie zostanie zakończona do momentu udostępnienia komunikatu w kolejce.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Który identyfikuje ogłoszone żądanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku przetwarzania asynchronicznego służy <xref:System.Messaging.MessageQueue.BeginReceive%2A> do <xref:System.Messaging.MessageQueue.ReceiveCompleted> zgłaszania zdarzenia po usunięciu komunikatu z kolejki.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>jest również uruchamiany, jeśli komunikat już istnieje w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Utwórz program obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznej i skojarz ją z delegatem zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A>Inicjuje asynchroniczną operację odbierania; zostanie powiadomiony przez podnoszenie <xref:System.Messaging.MessageQueue.ReceiveCompleted> poziomu zdarzenia po nadejściu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Następnie może uzyskać dostęp do komunikatu przez wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>. <xref:System.Messaging.MessageQueue>  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda wraca natychmiast, ale operacja asynchroniczna nie zostanie zakończona do momentu wywołania programu obsługi zdarzeń.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczny, można wywołać go, aby odebrać komunikat z kolejki bez blokowania bieżącego wątku wykonywania. Aby synchronicznie odebrać komunikat, użyj <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w programie obsługi zdarzeń, aby nadal otrzymywać powiadomienia.  
  
 <xref:System.IAsyncResult> Funkcja zwracającawartośćidentyfikujeasynchronicznąoperację<xref:System.Messaging.MessageQueue.BeginReceive%2A> uruchomioną przez metodę. Można jej użyć <xref:System.IAsyncResult> w okresie istnienia operacji, chociaż zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wywołania. Jeśli jednak uruchamiasz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określić, czy czekać na wszystkie operacje, czy dowolna operacja zostanie ukończona. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwości, <xref:System.IAsyncResult> aby zidentyfikować ukończoną operację.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>ma `false`wartość, zostanie zgłoszone zdarzenie ukończenia, ale podczas wywoływania zostanie zgłoszony wyjątek.  
  
 Nie używaj wywołania <xref:System.Messaging.MessageQueue.BeginReceive%2A> asynchronicznego z transakcjami. Jeśli chcesz wykonać transakcyjną operację asynchroniczną, wywołaj <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieść transakcję oraz metodę (synchroniczną) <xref:System.Messaging.MessageQueue.Receive%2A> w ramach procedury obsługi zdarzeń utworzonej dla operacji wglądu. Program obsługi zdarzeń może zawierać funkcje, jak pokazano w poniższym C# kodzie.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu łańcuchuje asynchroniczne żądania. Przyjęto założenie, że na komputerze lokalnym istnieje kolejka o nazwie "Moja kolejka". Funkcja rozpoczyna operację asynchroniczną, która jest obsługiwana `MyReceiveCompleted` przez procedurę. `Main` `MyReceiveCompleted`przetwarza bieżący komunikat i rozpoczyna nową asynchroniczną operację odbierania.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 Poniższy przykład kodu kolejkuje asynchroniczne żądania. Wywołanie <xref:System.Messaging.MessageQueue.BeginReceive%2A> przy użyciu wartości zwracanej przez <xref:System.IAsyncResult.AsyncWaitHandle%2A> . `Main` Procedura czeka na zakończenie wszystkich operacji asynchronicznych przed wyjściem.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Który wskazuje interwał czasu oczekiwania na udostępnienie komunikatu.</param>
        <summary>Inicjuje asynchroniczną operację odbierania, która ma określony limit czasu. Operacja nie zostanie zakończona do momentu udostępnienia komunikatu w kolejce lub przekroczenia limitu czasu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Który identyfikuje ogłoszone żądanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku przetwarzania asynchronicznego służy <xref:System.Messaging.MessageQueue.BeginReceive%2A> do <xref:System.Messaging.MessageQueue.ReceiveCompleted> zgłaszania zdarzenia, gdy komunikat będzie dostępny w kolejce lub po upływie określonego interwału czasu.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>jest również uruchamiany, jeśli komunikat już istnieje w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Utwórz program obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznej i skojarz ją z delegatem zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A>Inicjuje asynchroniczną operację odbierania; zostanie powiadomiony przez podnoszenie <xref:System.Messaging.MessageQueue.ReceiveCompleted> poziomu zdarzenia po nadejściu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Następnie może uzyskać dostęp do komunikatu przez wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub <xref:System.Messaging.ReceiveCompletedEventArgs>pobranie wyniku przy użyciu. <xref:System.Messaging.MessageQueue>  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda wraca natychmiast, ale operacja asynchroniczna nie zostanie zakończona do momentu wywołania programu obsługi zdarzeń.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczny, można wywołać go, aby odebrać komunikat z kolejki bez blokowania bieżącego wątku wykonywania. Aby synchronicznie odebrać komunikat, użyj <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w programie obsługi zdarzeń, aby nadal otrzymywać powiadomienia.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>ma `false`wartość, zostanie zgłoszone zdarzenie ukończenia, ale podczas wywoływania zostanie zgłoszony wyjątek.  
  
 <xref:System.IAsyncResult> Funkcja zwracającawartośćidentyfikujeasynchronicznąoperację<xref:System.Messaging.MessageQueue.BeginReceive%2A> uruchomioną przez metodę. Można jej użyć <xref:System.IAsyncResult> w okresie istnienia operacji, chociaż zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wywołania. Jeśli jednak uruchamiasz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określić, czy czekać na wszystkie operacje, czy dowolna operacja zostanie ukończona. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwości, <xref:System.IAsyncResult> aby zidentyfikować ukończoną operację.  
  
 To Przeciążenie określa limit czasu. Jeśli interwał określony przez `timeout` parametr wygaśnie, ten składnik <xref:System.Messaging.MessageQueue.ReceiveCompleted> zgłasza zdarzenie. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie metody <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> zgłosi wyjątek.  
  
 Nie używaj wywołania <xref:System.Messaging.MessageQueue.BeginReceive%2A> asynchronicznego z transakcjami. Jeśli chcesz wykonać transakcyjną operację asynchroniczną, wywołaj <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieść transakcję oraz metodę (synchroniczną) <xref:System.Messaging.MessageQueue.Receive%2A> w ramach procedury obsługi zdarzeń utworzonej dla operacji wglądu. Program obsługi zdarzeń może zawierać funkcje, jak pokazano w poniższym C# kodzie.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchroniczną operację odbierania. Przykładowy kod tworzy program obsługi `MyReceiveCompleted`zdarzeń i dołącza go <xref:System.Messaging.MessageQueue.ReceiveCompleted> do delegata obsługi zdarzeń. Przykładowy kod wysyła komunikat do lokalnej kolejki komunikatów, a następnie wywołuje <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>i przekazuje wartość limitu czasu wynoszącą dziesięć sekund. <xref:System.Messaging.MessageQueue.ReceiveCompleted> Gdy zdarzenie jest zgłaszane, program obsługi zdarzeń odbiera komunikat i zapisuje treść komunikatu na ekranie.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie dlatego, że reprezentuje liczbę ujemną.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Który wskazuje interwał czasu oczekiwania na udostępnienie komunikatu.</param>
        <param name="stateObject">Obiekt stanu określony przez aplikację, który zawiera informacje skojarzone z operacją asynchroniczną.</param>
        <summary>Inicjuje asynchroniczne operacje odbierania z określonym limitem czasu i określonym obiektem stanu, który zawiera skojarzone informacje w okresie istnienia operacji. Operacja nie zostanie zakończona do momentu udostępnienia komunikatu w kolejce lub przekroczenia limitu czasu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Który identyfikuje ogłoszone żądanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku przetwarzania asynchronicznego służy <xref:System.Messaging.MessageQueue.BeginReceive%2A> do <xref:System.Messaging.MessageQueue.ReceiveCompleted> zgłaszania zdarzenia, gdy komunikat będzie dostępny w kolejce lub po upływie określonego interwału czasu.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>jest również uruchamiany, jeśli komunikat już istnieje w kolejce.  
  
 Użyj tego przeciążenia, aby skojarzyć informacje z operacją, która zostanie zachowana w okresie istnienia operacji. Program obsługi zdarzeń może wykryć te informacje, przeglądając <xref:System.IAsyncResult.AsyncState%2A> Właściwość <xref:System.IAsyncResult> , która jest skojarzona z operacją.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Utwórz program obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznej i skojarz ją z delegatem zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A>Inicjuje asynchroniczną operację odbierania; zostanie powiadomiony przez podnoszenie <xref:System.Messaging.MessageQueue.ReceiveCompleted> poziomu zdarzenia po nadejściu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Następnie może uzyskać dostęp do komunikatu przez wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub <xref:System.Messaging.ReceiveCompletedEventArgs>pobranie wyniku przy użyciu. <xref:System.Messaging.MessageQueue>  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda wraca natychmiast, ale operacja asynchroniczna nie zostanie zakończona do momentu wywołania programu obsługi zdarzeń.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczny, można wywołać go, aby odebrać komunikat z kolejki bez blokowania bieżącego wątku wykonywania. Aby synchronicznie odebrać komunikat, użyj <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w programie obsługi zdarzeń, aby nadal otrzymywać powiadomienia.  
  
 <xref:System.IAsyncResult> Funkcja zwracającawartośćidentyfikujeasynchronicznąoperację<xref:System.Messaging.MessageQueue.BeginReceive%2A> uruchomioną przez metodę. Można jej użyć <xref:System.IAsyncResult> w okresie istnienia operacji, chociaż zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wywołania. Jeśli jednak uruchamiasz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określić, czy czekać na wszystkie operacje, czy dowolna operacja zostanie ukończona. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwości, <xref:System.IAsyncResult> aby zidentyfikować ukończoną operację.  
  
 To Przeciążenie określa przekroczenie limitu czasu i obiektu stanu. Jeśli interwał określony przez `timeout` parametr wygaśnie, ten składnik <xref:System.Messaging.MessageQueue.ReceiveCompleted> zgłasza zdarzenie. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie metody <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> zgłosi wyjątek.  
  
 Obiekt State kojarzy informacje o stanie z operacją. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginReceive%2A> wiele razy, aby zainicjować wiele operacji, można zidentyfikować każdą operację za pomocą oddzielnego obiektu stanu, który definiujesz.  
  
 Można również użyć obiektu stanu do przekazywania informacji między wątkami procesów. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne znajduje się w innym wątku w scenariuszu asynchronicznym, obiekt stanu jest zorganizowany i przekazywany z powrotem wraz z informacjami ze zdarzenia.  
  
 Nie używaj wywołania <xref:System.Messaging.MessageQueue.BeginReceive%2A> asynchronicznego z transakcjami. Jeśli chcesz wykonać transakcyjną operację asynchroniczną, wywołaj <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieść transakcję oraz metodę (synchroniczną) <xref:System.Messaging.MessageQueue.Receive%2A> w ramach procedury obsługi zdarzeń utworzonej dla operacji wglądu. Program obsługi zdarzeń może zawierać funkcje, jak pokazano w poniższym C# kodzie.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchroniczną operację odbierania. Przykładowy kod tworzy program obsługi `MyReceiveCompleted`zdarzeń i dołącza go <xref:System.Messaging.MessageQueue.ReceiveCompleted> do delegata obsługi zdarzeń. W przykładzie kodu jest wysyłany komunikat do lokalnej kolejki komunikatów, a następnie <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>wywołań, przekazywania w przekroczeniu limitu czasu wynoszącym dziesięć sekund i unikatowej liczby całkowitej, która identyfikuje określony komunikat. <xref:System.Messaging.MessageQueue.ReceiveCompleted> Gdy zdarzenie jest zgłaszane, program obsługi zdarzeń odbiera komunikat i zapisuje treść komunikatu oraz identyfikator wiadomości liczb całkowitych na ekranie.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Który wskazuje interwał czasu oczekiwania na udostępnienie komunikatu.</param>
        <param name="stateObject">Obiekt stanu określony przez aplikację, który zawiera informacje skojarzone z operacją asynchroniczną.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> To spowoduje odebranie powiadomienia o ukończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje asynchroniczne operacje odbierania z określonym limitem czasu i określonym obiektem stanu, który zawiera skojarzone informacje w okresie istnienia operacji. To Przeciążenie odbiera powiadomienie przy użyciu wywołania zwrotnego tożsamości programu obsługi zdarzeń dla operacji. Operacja nie zostanie zakończona do momentu udostępnienia komunikatu w kolejce lub przekroczenia limitu czasu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Który identyfikuje ogłoszone żądanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku użycia tego przeciążenia wywołania zwrotne określone w parametrze wywołania zwrotnego są wywoływane bezpośrednio po udostępnieniu komunikatu w kolejce lub upływie określonego interwału czasu. <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie nie zostało zgłoszone. Inne przeciążenia programu <xref:System.Messaging.MessageQueue.BeginReceive%2A> polegają na tym składniku w celu <xref:System.Messaging.MessageQueue.ReceiveCompleted> podniesienia zdarzenia.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>jest również uruchamiany, jeśli komunikat już istnieje w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Utwórz program obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznej i skojarz ją z delegatem zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A>Inicjuje asynchroniczną operację odbierania; zostanie powiadomiony przez podnoszenie <xref:System.Messaging.MessageQueue.ReceiveCompleted> poziomu zdarzenia po nadejściu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Następnie może uzyskać dostęp do komunikatu przez wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub <xref:System.Messaging.ReceiveCompletedEventArgs>pobranie wyniku przy użyciu. <xref:System.Messaging.MessageQueue>  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda wraca natychmiast, ale operacja asynchroniczna nie zostanie zakończona do momentu wywołania programu obsługi zdarzeń.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczny, można wywołać go, aby odebrać komunikat z kolejki bez blokowania bieżącego wątku wykonywania. Aby synchronicznie odebrać komunikat, użyj <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w programie obsługi zdarzeń, aby nadal otrzymywać powiadomienia.  
  
 <xref:System.IAsyncResult> Funkcja zwracającawartośćidentyfikujeasynchronicznąoperację<xref:System.Messaging.MessageQueue.BeginReceive%2A> uruchomioną przez metodę. Można jej użyć <xref:System.IAsyncResult> w okresie istnienia operacji, chociaż zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wywołania. Jeśli jednak uruchamiasz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określić, czy czekać na wszystkie operacje, czy dowolna operacja zostanie ukończona. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwości, <xref:System.IAsyncResult> aby zidentyfikować ukończoną operację.  
  
 Obiekt State kojarzy informacje o stanie z operacją. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginReceive%2A> wiele razy, aby zainicjować wiele operacji, można zidentyfikować każdą operację za pomocą oddzielnego obiektu stanu, który definiujesz.  
  
 Można również użyć obiektu stanu do przekazywania informacji między wątkami procesów. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne znajduje się w innym wątku w scenariuszu asynchronicznym, obiekt stanu jest zorganizowany i przekazywany z powrotem wraz z informacjami ze zdarzenia.  
  
 Nie używaj wywołania <xref:System.Messaging.MessageQueue.BeginReceive%2A> asynchronicznego z transakcjami. Jeśli chcesz wykonać transakcyjną operację asynchroniczną, wywołaj <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieść transakcję oraz metodę (synchroniczną) <xref:System.Messaging.MessageQueue.Receive%2A> w ramach procedury obsługi zdarzeń utworzonej dla operacji wglądu. Program obsługi zdarzeń może zawierać funkcje, jak pokazano w poniższym C# kodzie.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchroniczną operację odbierania. Przykładowy kod wysyła komunikat do lokalnej kolejki komunikatów, a następnie wywołuje <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, przekazując: wartość limitu czasu wynoszącą dziesięć sekund; unikatową liczbę całkowitą, która identyfikuje określony komunikat, oraz nowe <xref:System.AsyncCallback> wystąpienie, które identyfikuje program obsługi zdarzeń, `MyReceiveCompleted`. <xref:System.Messaging.MessageQueue.ReceiveCompleted> Gdy zdarzenie jest zgłaszane, program obsługi zdarzeń odbiera komunikat i zapisuje treść komunikatu oraz identyfikator wiadomości liczb całkowitych na ekranie.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> , Który wskazuje interwał czasu oczekiwania na udostępnienie komunikatu.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który utrzymuje określone położenie w kolejce komunikatów.</param>
        <param name="state">Obiekt stanu określony przez aplikację, który zawiera informacje skojarzone z operacją asynchroniczną.</param>
        <param name="callback">, <see cref="T:System.AsyncCallback" /> Który odbiera powiadomienie o ukończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje asynchroniczną operację odbierania, która ma określony limit czasu i używa określonego kursora i określonego obiektu stanu. Obiekt State zawiera powiązane informacje w okresie istnienia operacji. To Przeciążenie odbiera powiadomienie przy użyciu wywołania zwrotnego tożsamości programu obsługi zdarzeń dla operacji. Operacja nie zostanie zakończona do momentu udostępnienia komunikatu w kolejce lub przekroczenia limitu czasu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Który identyfikuje ogłoszone żądanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku użycia tego przeciążenia wywołania zwrotne określone w parametrze wywołania zwrotnego są wywoływane bezpośrednio po udostępnieniu komunikatu w kolejce lub upływie określonego interwału czasu. <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie nie zostało zgłoszone. Inne przeciążenia programu <xref:System.Messaging.MessageQueue.BeginReceive%2A> polegają na tym składniku w celu <xref:System.Messaging.MessageQueue.ReceiveCompleted> podniesienia zdarzenia.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>jest również uruchamiany, jeśli komunikat już istnieje w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Utwórz program obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznej i skojarz ją z delegatem zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A>Inicjuje asynchroniczną operację odbierania; zostanie powiadomiony przez podnoszenie <xref:System.Messaging.MessageQueue.ReceiveCompleted> poziomu zdarzenia po nadejściu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Następnie może uzyskać dostęp do komunikatu przez wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub <xref:System.Messaging.ReceiveCompletedEventArgs>pobranie wyniku przy użyciu. <xref:System.Messaging.MessageQueue>  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda wraca natychmiast, ale operacja asynchroniczna nie zostanie zakończona do momentu wywołania programu obsługi zdarzeń.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczny, można wywołać go, aby odebrać komunikat z kolejki bez blokowania bieżącego wątku wykonywania. Aby synchronicznie odebrać komunikat, użyj <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w programie obsługi zdarzeń, aby nadal otrzymywać powiadomienia.  
  
 <xref:System.IAsyncResult> Funkcja zwracającawartośćidentyfikujeasynchronicznąoperację<xref:System.Messaging.MessageQueue.BeginReceive%2A> uruchomioną przez metodę. Można jej użyć <xref:System.IAsyncResult> w okresie istnienia operacji, chociaż zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wywołania. Jeśli jednak uruchamiasz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określić, czy czekać na wszystkie operacje, czy dowolna operacja zostanie ukończona. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwości, <xref:System.IAsyncResult> aby zidentyfikować ukończoną operację.  
  
 Obiekt State kojarzy informacje o stanie z operacją. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginReceive%2A> wiele razy, aby zainicjować wiele operacji, można zidentyfikować każdą operację za pomocą oddzielnego obiektu stanu, który definiujesz.  
  
 Można również użyć obiektu stanu do przekazywania informacji między wątkami procesów. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne znajduje się w innym wątku w scenariuszu asynchronicznym, obiekt stanu jest zorganizowany i przekazywany z powrotem wraz z informacjami ze zdarzenia.  
  
 Nie używaj wywołania <xref:System.Messaging.MessageQueue.BeginReceive%2A> asynchronicznego z transakcjami. Jeśli chcesz wykonać transakcyjną operację asynchroniczną, wywołaj <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieść transakcję oraz metodę (synchroniczną) <xref:System.Messaging.MessageQueue.Receive%2A> w ramach procedury obsługi zdarzeń utworzonej dla operacji wglądu. Program obsługi zdarzeń może zawierać funkcje, jak pokazano w poniższym C# kodzie.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="cursor" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Messaging.MessageQueue" /> można odczytać.</summary>
        <value><see langword="true" />Jeśli istnieje, a aplikacja może z niej odczytywać; <see langword="false" />w przeciwnym razie. <see cref="T:System.Messaging.MessageQueue" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A>wskazuje, czy aplikacja może wgląd i odbierać komunikaty z kolejki. Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `true` ,<xref:System.Messaging.MessageQueue> może odbierać lub wglądać komunikaty z kolejki. W przeciwnym razie nie może.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A>czy kolejka jest już otwarta z wyłącznym dostępem do odczytu (lub jeśli jest otwarta z dostępem niewyłącznym i to <xref:System.Messaging.MessageQueue> żąda dostępu wyłącznego) lub jeśli aplikacja nie ma wystarczających uprawnień, aby uzyskać do niej dostęp. `false` Jeśli aplikacja próbuje odczytać z kolejki w przypadku, <xref:System.Messaging.MessageQueue.CanRead%2A> gdy `false`jest, odmowa dostępu.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.MessageQueue.CanRead%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Messaging.MessageQueue" /> może być zapisywana.</summary>
        <value><see langword="true" />Jeśli istnieje, a aplikacja może zapisywać w niej; <see langword="false" />w przeciwnym razie. <see cref="T:System.Messaging.MessageQueue" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A>wskazuje, czy aplikacja może wysyłać komunikaty do kolejki. Jeśli <xref:System.Messaging.MessageQueue.CanWrite%2A> jest `true` ,<xref:System.Messaging.MessageQueue> może wysyłać komunikaty do kolejki. W przeciwnym razie nie może.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A>czy kolejka jest już otwarta z wyłącznym dostępem do zapisu (lub jeśli jest otwarta z dostępem niewyłącznym i to <xref:System.Messaging.MessageQueue> żąda dostępu wyłącznego) lub jeśli aplikacja nie ma wystarczających uprawnień, aby uzyskać do niej dostęp. `false` Jeśli aplikacja próbuje wykonać zapis do kolejki, gdy <xref:System.Messaging.MessageQueue.CanWrite%2A> jest `false`, jest odmowa dostępu.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.MessageQueue.CanWrite%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kategorię kolejki.</summary>
        <value><see cref="T:System.Guid" /> Reprezentujący kategorię kolejki (identyfikator typu usługi kolejkowania komunikatów), która umożliwia aplikacji kategoryzowanie kolejek. Wartość domyślna to <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kategoria kolejki umożliwia aplikacji kategoryzowanie kolejek. Można na przykład umieścić wszystkie kolejki rozliczeń w jednej kategorii i wszystkie kolejki kolejności w innej.  
  
 Właściwość zapewnia dostęp do właściwości identyfikatora typu usługi kolejkowania komunikatów (czyli odczytu/zapisu) dostępnej za pośrednictwem okna dialogowego **właściwości kolejki** w konsoli Zarządzanie komputerem. <xref:System.Messaging.MessageQueue.Category%2A> Można zdefiniować nową kategorię. Chociaż można użyć <xref:System.Guid.NewGuid%2A> do utworzenia wartości kategorii, która jest unikatowa dla wszystkich <xref:System.Guid> wartości, takie działanie jest niepotrzebne. Wartość kategorii musi być odrębna tylko od innych kategorii, nie ze wszystkich innych <xref:System.Guid> wartości. {00000000-0000-0000-0000-000000000001} Na przykład można przypisać <xref:System.Messaging.MessageQueue.Category%2A> jako dla jednego zestawu kolejek i {00000000-0000-0000-0000-000000000002} jako <xref:System.Messaging.MessageQueue.Category%2A> dla innego zestawu.  
  
 Nie trzeba ustawiać <xref:System.Messaging.MessageQueue.Category%2A>. Wartość może być `null`równa.  
  
 Ustawienie tej właściwości powoduje modyfikację kolejki usługi kolejkowania komunikatów. W związku z tym <xref:System.Messaging.MessageQueue> zmiana ma wpływ na wszystkie inne wystąpienia.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.Category%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kategoria kolejki została ustawiona na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści pamięć podręczną połączeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wywoływania <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, nazwy formatów przechowywane w pamięci podręcznej są usuwane, a uchwyty otwarte i przechowywane w pamięci podręcznej są zamknięte.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Yes|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod wywołuje <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby przydzielone przez <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A>Zwalnia wszystkie zasoby skojarzone z, w <xref:System.Messaging.MessageQueue>tym udostępnione zasoby, jeśli jest to konieczne. System ponownie uzyskuje te zasoby automatycznie, jeśli są nadal dostępne, na przykład w przypadku wywołania <xref:System.Messaging.MessageQueue.Send%28System.Object%29> metody, jak w poniższym C# kodzie.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Po wywołaniu <xref:System.Messaging.MessageQueue.Close%2A>, wszystkie <xref:System.Messaging.MessageQueue> właściwości, które bezpośrednio uzyskują dostęp do kolejki usługi kolejkowania komunikatów, są wyczyszczone. ,, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> <xref:System.Messaging.MessageQueue.Path%2A> ,I<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> wszystkie pozostają w takiej postaci, w jakiej się znajdowały. <xref:System.Messaging.MessageQueue.Formatter%2A>  
  
 <xref:System.Messaging.MessageQueue.Close%2A>nie zawsze zwalnia dojścia odczytu i zapisu do kolejki, ponieważ mogą one być udostępniane. Aby upewnić się, że <xref:System.Messaging.MessageQueue.Close%2A> wszystkie uchwyty odczytu i zapisu do kolejki są zwolnione, można wykonać dowolną z następujących czynności:  
  
-   <xref:System.Messaging.MessageQueue> Utwórz z wyłącznym dostępem. Aby to zrobić, wywołaj <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> `sharedModeDenyReceive` Konstruktor <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> lub, a następnie ustaw parametr na `true`.  
  
-   <xref:System.Messaging.MessageQueue> Utwórz wyłączone buforowanie połączeń. Aby to zrobić, wywołaj <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> konstruktora i `enableConnectionCache` ustaw parametr na `false`.  
  
-   Wyłącz buforowanie połączeń. Aby to zrobić, należy ustawić <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> właściwość na `false`.  
  
 Należy wywołać <xref:System.Messaging.MessageQueue.Close%2A> dla kolejki przed usunięciem kolejki na serwerze usługi kolejkowania komunikatów. W przeciwnym razie komunikaty wysyłane do kolejki mogą generować wyjątki lub znajdować się w kolejce utraconych wiadomości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Tak|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu zamyka kolejkę kolejkowania komunikatów.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową kolejkę w określonej ścieżce na serwerze usługi kolejkowania komunikatów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka kolejki do utworzenia.</param>
        <summary>Tworzy nietransakcyjną kolejkę kolejkowania komunikatów w określonej ścieżce.</summary>
        <returns><see cref="T:System.Messaging.MessageQueue" /> Reprezentujący nową kolejkę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nietransakcyjną kolejkę kolejkowania komunikatów.  
  
 Aby utworzyć nowe wystąpienie <xref:System.Messaging.MessageQueue> klasy w aplikacji i powiązać je z istniejącą kolejką, <xref:System.Messaging.MessageQueue.%23ctor%2A> Użyj konstruktora. Aby utworzyć nową kolejkę w usłudze kolejkowania komunikatów, wywołaj <xref:System.Messaging.MessageQueue.Create%28System.String%29>polecenie.  
  
 Składnia `path` parametru zależy od typu kolejki, do której się odwołuje, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
  
 Użyj "." na komputerze lokalnym. Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwość.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kolejki publiczne i prywatne. Wysyła komunikat do wybranych kolejek.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest<see langword="null" /> lub jest pustym ciągiem ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka już istnieje w określonej ścieżce.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka kolejki do utworzenia.</param>
        <param name="transactional"><see langword="true" />Aby utworzyć kolejkę transakcyjną; <see langword="false" /> aby utworzyć nietransakcyjną kolejkę.</param>
        <summary>Tworzy transakcyjną lub nietransakcyjną kolejkę kolejkowania komunikatów w określonej ścieżce.</summary>
        <returns><see cref="T:System.Messaging.MessageQueue" /> Reprezentujący nową kolejkę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tego przeciążenia można utworzyć kolejkę transakcyjną w usłudze kolejkowania komunikatów. Można utworzyć kolejkę nietransakcyjną, ustawiając `transactional` parametr na `false` lub <xref:System.Messaging.MessageQueue.Create%28System.String%29>wywołując inne przeciążenia.  
  
 Aby utworzyć nowe wystąpienie <xref:System.Messaging.MessageQueue> klasy w aplikacji i powiązać je z istniejącą kolejką, <xref:System.Messaging.MessageQueue.%23ctor%2A> Użyj konstruktora. Aby utworzyć nową kolejkę w usłudze kolejkowania komunikatów, wywołaj <xref:System.Messaging.MessageQueue.Create%28System.String%29>polecenie.  
  
 Składnia `path` parametru zależy od typu kolejki, do której się odwołuje, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
  
 Użyj "." na komputerze lokalnym. Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwość.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy publiczną i prywatną kolejkę transakcyjną. Wysyła komunikat do wybranych kolejek.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest<see langword="null" /> lub jest pustym ciągiem ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka już istnieje w określonej ścieżce.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.Messaging.Cursor" /> dla bieżącej kolejki komunikatów.</summary>
        <returns>Nowy <see cref="T:System.Messaging.Cursor" /> dla bieżącej kolejki komunikatów. Ten kursor służy do obsługi określonej lokalizacji w kolejce podczas odczytywania komunikatów w kolejce.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera datę i godzinę utworzenia kolejki w usłudze kolejkowania komunikatów.</summary>
        <value><see cref="T:System.DateTime" /> Reprezentuje datę i godzinę utworzenia kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A>odwołuje się do kolejki na serwerze usługi kolejkowania komunikatów, a nie <xref:System.Messaging.MessageQueue> w wystąpieniu.  
  
 Jeśli kolejka istnieje, ta właściwość reprezentuje godzinę utworzenia kolejki, dostosowaną do czasu lokalnego serwera, na którym istnieje kolejka.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.MessageQueue.CreateTime%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartości właściwości komunikatów, które mają być używane domyślnie, gdy aplikacja wysyła komunikaty do kolejki.</summary>
        <value>A <see cref="T:System.Messaging.DefaultPropertiesToSend" /> , który zawiera domyślne wartości właściwości komunikatów usługi kolejkowania komunikatów używane, gdy aplikacja wysyła obiekty inne niż <see cref="T:System.Messaging.Message" /> wystąpienia do kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wysłaniu dowolnego obiektu, który nie jest typu <xref:System.Messaging.Message> do kolejki <xref:System.Messaging.MessageQueue> , wstawia obiekt do komunikatu usługi kolejkowania komunikatów. W tym czasie <xref:System.Messaging.MessageQueue> ma zastosowanie do komunikatu wartości właściwości określonych <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> we właściwości. Z drugiej strony, Jeśli wyślesz <xref:System.Messaging.Message> do kolejki, te właściwości są już określone dla wystąpienia, więc <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> jest ignorowany dla <xref:System.Messaging.Message>.  
  
 Chociaż właściwości są ustawiane za pomocą <xref:System.Messaging.MessageQueue> obiektu, odwołuje się do właściwości komunikatów, które są wysyłane do kolejki, a <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> nie do samej kolejki.  
  
 Wartości domyślne właściwości są pokazane w poniższej tabeli.  
  
|Właściwość|Wartość domyślna|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Zero (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|Pusty ciąg ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Tak|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu używa priorytetu komunikatu, aby określić domyślne właściwości do wysłania wiadomości.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie można ustawić właściwości domyślnych dla kolejki, prawdopodobnie dlatego, że jedna z właściwości jest nieprawidłowa.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizacja kolejki, która ma zostać usunięta.</param>
        <summary>Usuwa kolejkę na serwerze usługi kolejkowania komunikatów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnia `path` parametru zależy od typu kolejki.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
  
 Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwość.  
  
 Alternatywnie można użyć <xref:System.Messaging.MessageQueue.FormatName%2A> lub <xref:System.Messaging.MessageQueue.Label%2A> do opisania ścieżki kolejki.  
  
|Tematy pomocy|Składnia|  
|---------------|------------|  
|Nazwa formatu|Formatname: [ *nazwa formatu* ]|  
|Etykieta|Etykieta: [ *etykieta* ]|  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu Usuwa kolejkę kolejkowania komunikatów, jeśli istnieje.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest<see langword="null" /> lub jest pustym ciągiem ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Składnia <paramref name="path" /> parametru jest nieprawidłowa.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ma on <see cref="T:System.Messaging.MessageQueue" /> wyłączny dostęp do odbierania komunikatów z kolejki usługi kolejkowania komunikatów.</summary>
        <value><see langword="true" />Jeśli ma <see cref="T:System.Messaging.MessageQueue" /> ona wyłączne prawa do odbierania komunikatów z kolejki; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A>Określa tryb współużytkowany kolejki, do której odwołuje się <xref:System.Messaging.MessageQueue>ten. Ustaw <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.Path%2A>na `true` , aby wskazać, że tylko powinien mieć dostęp do wglądu lub odbierania wiadomości z kolejki z określonym. Jeśli inna <xref:System.Messaging.MessageQueue> lub inna aplikacja jest skojarzona z tym samym zasobem kolejki, to wystąpienie lub aplikacja nie będzie w stanie uzyskać wglądu lub odebrać wiadomości, ale nadal może je wysłać.  
  
 Jeśli <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> jest`false`, kolejka jest dostępna dla wielu aplikacji do wysyłania, wglądu lub otrzymywania wiadomości.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Yes|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Usuwa zasoby (inne niż pamięć) używane przez <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> po zakończeniu korzystania z <xref:System.Messaging.MessageQueue>. <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> Metoda<xref:System.Messaging.MessageQueue> pozostawia w stanie niezdatnym do użytku. Po wywołaniu <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>należy wydać wszystkie odwołania <xref:System.Messaging.MessageQueue> do, aby pamięć, która zajmowała się, mogła być odzyskiwana przez wyrzucanie elementów bezużytecznych.  
  
 Należy wywołać <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> przed wydaniem ostatniego odwołania <xref:System.Messaging.MessageQueue>do. W przeciwnym razie zasoby, <xref:System.Messaging.MessageQueue> które są używane, nie zostaną zwolnione do momentu <xref:System.Messaging.MessageQueue> wywołania destruktora obiektu przez wyrzucanie elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy pamięć podręczna połączeń będzie obsługiwana przez aplikację.</summary>
        <value><see langword="true" />Tworzenie i używanie pamięci podręcznej połączenia; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pamięć podręczna połączeń jest listą odwołań do struktur, które zawierają uchwyty odczytu lub zapisu do kolejek. Gdy <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> tak `true`jest, <xref:System.Messaging.MessageQueue> pożyczki są obsługiwane z pamięci podręcznej przy każdym <xref:System.Messaging.MessageQueue.Send%28System.Object%29>wywołaniu <xref:System.Messaging.MessageQueue.Peek%2A>,, <xref:System.Messaging.MessageQueue.Receive%2A>lub, zamiast otwierać nowe dojścia. Może to poprawić wydajność. Użycie pamięci podręcznej połączenia powoduje także <xref:System.Messaging.MessageQueue> izolowanie od zmian w topologii sieci.  
  
 W <xref:System.Messaging.MessageQueue> przypadku utworzenia nowego połączenia z kolejką, gdy pamięć podręczna połączenia jest pełna, zastępuje ona ostatnio używanej struktury nowym połączeniem. Możesz całkowicie wyczyścić pamięć podręczną, wywołując <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>na przykład, jeśli nazwy formatów kolejek, z którymi pracujesz, zostały zmienione, tak aby poprzednie uchwyty odczytu i zapisu nie były już prawidłowe.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Tak|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kolejka akceptuje tylko nieprywatne (nieszyfrowane) komunikaty.</summary>
        <value>Jedna z <see cref="T:System.Messaging.EncryptionRequired" /> wartości. Wartość domyślna to <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu, że szyfrowanie jest wymagane dla komunikatów wysyłanych do kolejki, szyfrowane są tylko treści komunikatów. Nie można zaszyfrować innych elementów członkowskich ( <xref:System.Messaging.Message.Label%2A> na <xref:System.Messaging.Message.SenderId%2A> przykład właściwości i).  
  
 Ustawienie tej właściwości powoduje modyfikację kolejki usługi kolejkowania komunikatów. W związku z tym <xref:System.Messaging.MessageQueue> zmiana ma wpływ na wszystkie inne wystąpienia.  
  
 Szyfrowanie wiadomości powoduje, że komunikat jest prywatny. Możesz określić wymaganie `None`szyfrowania kolejki, `Body`lub `Optional` ustawiając <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> odpowiednio właściwość. <xref:System.Messaging.Message.UseEncryption%2A> Ustawienie komunikatu musi odpowiadać wymaganiom szyfrowania kolejki. Jeśli komunikat nie jest szyfrowany, ale Kolejka określa `Body`lub jeśli komunikat jest szyfrowany, ale Kolejka określa `None`, komunikat zostanie odrzucony przez kolejkę. Jeśli aplikacja wysyłająca żąda negatywnego komunikatu potwierdzającego w tym zdarzeniu, usługa kolejkowania komunikatów wskazuje odrzucenie komunikatu do aplikacji wysyłającej. Jeśli właściwość to `true`, komunikat informujący o niepowodzeniu szyfrowania jest wysyłany do kolejki utraconych wiadomości. <xref:System.Messaging.Message.UseDeadLetterQueue%2A> W przeciwnym razie komunikat zostanie utracony.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Który identyfikuje asynchroniczną operację wglądu do końca i z której ma zostać pobrany wynik końcowy.</param>
        <summary>Kończy określoną asynchroniczną operację wglądu.</summary>
        <returns><see cref="T:System.Messaging.Message" /> Skojarzona z ukończoną operacją asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zdarzenie jest zgłaszane, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> kończy operację <xref:System.Messaging.MessageQueue.BeginPeek%2A> , która została zainicjowana przez wywołanie. <xref:System.Messaging.MessageQueue.PeekCompleted> W tym celu program <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wgląd w komunikat.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>można określić limit czasu, który powoduje, że <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie zostanie zgłoszone w przypadku upływu limitu czasu, zanim komunikat pojawi się w kolejce. Gdy limit czasu wypada bez komunikatu przychodzącego do kolejki, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wygeneruje wyjątek.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>służy do odczytywania komunikatu, który spowodował <xref:System.Messaging.MessageQueue.PeekCompleted> podniesienie zdarzenia.  
  
 Jeśli chcesz kontynuować asynchroniczne wgląd w wiadomości, możesz ponownie wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> po wywołaniu. <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyPeekCompleted`, dołącza go <xref:System.Messaging.MessageQueue.PeekCompleted> do delegata programu obsługi zdarzeń i wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> do inicjowania asynchronicznej operacji wglądu do kolejki, która znajduje się w ścieżce ".\myQueue". <xref:System.Messaging.MessageQueue.PeekCompleted> Gdy zdarzenie jest zgłaszane, przykład służy do wglądu w komunikat i zapisywania jego treści na ekranie. Przykład następnie wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> ponownie w celu zainicjowania nowej asynchronicznej operacji wglądu.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="asyncResult" /></exception>
        <exception cref="T:System.ArgumentException">Składnia <paramref name="asyncResult" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Identyfikuje asynchroniczną operację odbierania i z której ma zostać pobrany wynik końcowy.</param>
        <summary>Kończy określoną asynchroniczną operację odbierania.</summary>
        <returns><see cref="T:System.Messaging.Message" /> Skojarzona z ukończoną operacją asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zdarzenie jest zgłaszane, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> kończy operację <xref:System.Messaging.MessageQueue.BeginReceive%2A> , która została zainicjowana przez wywołanie. <xref:System.Messaging.MessageQueue.ReceiveCompleted> W tym <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> celu otrzymuje komunikat.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>można określić limit czasu, który powoduje, że <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie zostanie zgłoszone w przypadku upływu limitu czasu, zanim komunikat pojawi się w kolejce. Gdy limit czasu wypada bez komunikatu przychodzącego do kolejki, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wygeneruje wyjątek.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>służy do odczytywania (usuwania z kolejki) wiadomości, która spowodowała wygenerowanie <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenia.  
  
 Jeśli chcesz kontynuować asynchroniczne odbieranie komunikatów, możesz ponownie wywołać <xref:System.Messaging.MessageQueue.BeginReceive%2A> po wywołaniu. <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu łańcuchuje asynchroniczne żądania. Przyjęto założenie, że na komputerze lokalnym istnieje kolejka o nazwie "Moja kolejka". Funkcja rozpoczyna operację asynchroniczną, która jest obsługiwana `MyReceiveCompleted` przez procedurę. `Main` `MyReceiveCompleted`przetwarza bieżący komunikat i rozpoczyna nową asynchroniczną operację odbierania.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="asyncResult" /></exception>
        <exception cref="T:System.ArgumentException">Składnia <paramref name="asyncResult" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizacja kolejki do znalezienia.</param>
        <summary>Określa, czy kolejka usługi kolejkowania komunikatów istnieje w określonej ścieżce.</summary>
        <returns><see langword="true" />Jeśli istnieje kolejka z określoną ścieżką; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.Messaging.MessageQueue.Exists%28System.String%29> określa, czy kolejka kolejkowania komunikatów istnieje w określonej ścieżce. Żadna metoda nie istnieje, aby określić, czy istnieje kolejka z określoną nazwą formatu. Aby uzyskać więcej informacji na temat składni nazwy formatu i innych formularzy składni ścieżki, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwość.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>jest kosztowną operacją. Użyj go tylko wtedy, gdy jest to konieczne w aplikacji.  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Metoda nie obsługujeprefiksu<xref:System.Messaging.MessageQueue.FormatName%2A> .  
  
 Składnia `path` parametru zależy od typu kolejki, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>nie można wywołać w celu zweryfikowania istnienia zdalnej kolejki prywatnej.  
  
 Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwość.  
  
 Alternatywnie można użyć <xref:System.Messaging.MessageQueue.Label%2A> do opisania ścieżki kolejki.  
  
|Tematy pomocy|Składnia|  
|---------------|------------|  
|Etykieta|Etykieta: [ `label` ]|  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Nie|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, czy istnieje kolejka kolejkowania komunikatów, a następnie ją usuwa.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Składnia jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.  
  
—lub— 
<see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> Metoda jest wywoływana w zdalnej kolejce prywatnej</exception>
        <exception cref="T:System.InvalidOperationException">Składnia nazwy formatu używanej przez aplikację podczas weryfikowania istnienia kolejki.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatową nazwę kolejki, która jest generowana przez usługę kolejkowania komunikatów w momencie tworzenia kolejki.</summary>
        <value>Nazwa kolejki, która jest unikatowa w sieci.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A> Właściwość zawiera nazwę formatu kolejki. Usługa kolejkowania komunikatów używa nazwy formatu do identyfikowania, która kolejka ma zostać otwarta i jak uzyskać do niej dostęp. W przeciwieństwie do większości właściwości kolejki, nazwa formatu nie jest właściwością kolejki aplikacji usługi kolejkowania komunikatów, więc nie można uzyskać do niej dostępu za pośrednictwem narzędzia do zarządzania usługą kolejkowania komunikatów. Nazwa formatu jest po prostu unikatową nazwą kolejki, która usługa kolejkowania komunikatów generuje, gdy tworzy kolejkę lub którą aplikacja generuje później.  
  
 W przypadku określenia ścieżki przy użyciu składni nazwy ścieżki (takiej jak `myComputer\myQueue`) zamiast używania składni nazwy formatu podczas odczytu lub zapisu do kolejki podstawowy kontroler domeny (który używa Active Directory) tłumaczy <xref:System.Messaging.MessageQueue.Path%2A> na skojarzone <xref:System.Messaging.MessageQueue.FormatName%2A> przed uzyskaniem dostępu do kolejki. Jeśli aplikacja działa w trybie offline, należy użyć składni nazwy formatu; w przeciwnym razie podstawowy kontroler domeny nie będzie dostępny do przeprowadzenia translacji ścieżki.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Tak|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.MessageQueue.FormatName%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> Nie ustawiono.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia program formatujący służący do serializacji obiektu do lub deserializacji obiektu z treści komunikatu odczytanego lub zarejestrowanego w kolejce.</summary>
        <value><see cref="T:System.Messaging.IMessageFormatter" /> Tworzy strumień do zapisu lub odczytu z treści wiadomości. Wartość domyślna to <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A> Właściwość zawiera wystąpienie obiektu programu formatującego, który przekształca komunikaty, gdy aplikacja odczytuje lub zapisuje dane do kolejki.  
  
 Gdy aplikacja wysyła komunikat do kolejki, program formatujący serializować obiekt do strumienia i wstawia go do treści komunikatu. Podczas odczytywania z kolejki program formatujący deserializacjije dane komunikatu do <xref:System.Messaging.Message.Body%2A> właściwości. <xref:System.Messaging.Message>  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno sprzężony, więc nie trzeba mieć tego samego typu obiektu na nadawcy i odbiorniku podczas korzystania z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> I<xref:System.Messaging.BinaryMessageFormatter> serializować dane do reprezentacji binarnej. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany podczas wysyłania lub otrzymywania składników com.  
  
 <xref:System.Messaging.BinaryMessageFormatter>i <xref:System.Messaging.ActiveXMessageFormatter> zapewniają szybszą przepływność <xref:System.Messaging.XmlMessageFormatter>niż. <xref:System.Messaging.ActiveXMessageFormatter> Umożliwia współdziałanie z aplikacjami usługi kolejkowania komunikatów Visual Basic 6,0.  
  
 Gdy aplikacja wysyła komunikaty do kolejki, <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> ma zastosowanie tylko do tych komunikatów, które używają domyślnych <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>właściwości komunikatów. W przypadku wysłania <xref:System.Messaging.Message> do kolejki usługa kolejkowania komunikatów używa programu formatującego zdefiniowanego <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> we właściwości do serializacji treści.  
  
 Klasa zawsze będzie <xref:System.Messaging.Message> używać do odbierania lub wglądu w komunikat z kolejki. <xref:System.Messaging.MessageQueue> Komunikat jest deserializowany przy użyciu <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje formatowanie treści komunikatu przy użyciu <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Poniższy przykład kodu demonstruje formatowanie treści komunikatu przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie komunikaty znajdujące się w kolejce.</summary>
        <returns>Tablica typu <see cref="T:System.Messaging.Message" /> , która reprezentuje wszystkie komunikaty w kolejce w takiej samej kolejności, w jakiej występują w kolejce usługi kolejkowania komunikatów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>zwraca statyczną migawkę komunikatów w kolejce, a nie linki dynamiczne do tych komunikatów. W związku z tym nie można użyć tablicy do modyfikacji komunikatów w kolejce. Jeśli chcesz, aby interakcja dynamiczna w czasie rzeczywistym z kolejką (na przykład możliwość usuwania wiadomości), wywołaj <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> metodę, która zwraca dynamiczną listę komunikatów w kolejce.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.GetAllMessages%2A> zwraca kopię komunikatów w kolejce w momencie wywołania metody, tablica nie odzwierciedla nowych komunikatów, które docierają do kolejki lub komunikatów usuniętych z kolejki.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>Pobiera tylko te właściwości, które nie zostały odfiltrowane przez <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> właściwość.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wylicza komunikaty w kolejce. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" />jest przestarzały. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />należy zamiast tego użyć.</summary>
        <returns>A <see cref="T:System.Collections.IEnumerator" /> , który zapewnia dynamiczne połączenie z wiadomościami w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nazwa komputera, na którym znajduje się kolejka, bez dwóch poprzedzających ukośników odwrotnych\\(\\).</param>
        <summary>Pobiera identyfikator komputera, na którym znajduje się kolejka, do której <see cref="T:System.Messaging.MessageQueue" /> się odwołuje.</summary>
        <returns><see cref="T:System.Guid" /> Reprezentuje unikatowy identyfikator komputera, na którym znajduje się kolejka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć identyfikatora komputera do dwóch celów, między innymi: odczytywanie dziennika komputera i Ustawianie certyfikatów zabezpieczeń. Nie można jednak wywołać <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> komputera zdalnego podczas pracy w trybie offline, ponieważ aplikacja musi mieć dostęp do usługi katalogowej na kontrolerze domeny.  
  
 Identyfikator komputera (lub identyfikator maszyny) to <xref:System.Guid> usługa kolejkowania komunikatów tworzona po dodaniu komputera do przedsiębiorstwa. Usługa kolejkowania komunikatów łączy identyfikator komputera ze `Machine` słowami kluczowymi i `Journal` , aby utworzyć nazwę formatu dziennika komputera, która ma składnię `Machine=<computeridentifier>;Journal`. Dziennik komputera, który jest również znany jako kolejka dziennika, jest kolejką systemową, która przechowuje kopie komunikatów generowanych przez aplikację, <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> gdy właściwość `true`jest.  
  
 Ta składnia dla dziennika jest prawidłowa tylko w przypadku konstruowania nazwy formatu dla kolejki. Składnia nazwy ścieżki to `MachineName`. \\ `Journal$`  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Nazwa komputera lokalnego i bezpośredniego|Nie|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod wywołuje <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Nie można pobrać identyfikatora komputera, prawdopodobnie z powodu niedostępności usługi katalogowej. na przykład jeśli pracujesz w trybie offline.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt modułu wyliczającego dla wszystkich komunikatów w kolejce. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />jest przestarzały. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />należy zamiast tego użyć.</summary>
        <returns><see cref="T:System.Messaging.MessageEnumerator" /> Przechowywanie komunikatów znajdujących się w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A>tworzy dynamiczną listę wszystkich komunikatów w kolejce. Można usunąć z kolejki komunikat w bieżącym położeniu modułu wyliczającego, wywołując <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> <xref:System.Messaging.MessageEnumerator> dla zwracanych danych <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> .  
  
 Ponieważ kursor jest skojarzony z dynamiczną listą komunikatów w kolejce, Wyliczenie odzwierciedla wszelkie zmiany wprowadzone do komunikatów w kolejce, jeśli wiadomość wykracza poza bieżącą pozycję kursora. Na przykład moduł wyliczający może automatycznie uzyskiwać dostęp do komunikatu o niższym priorytecie poza bieżącą pozycją kursora, ale nie został wstawiony komunikat o wyższym priorytecie przed tą pozycją. Można jednak zresetować Wyliczenie, a tym samym przenieść kursor z powrotem do początku listy, wywołując <xref:System.Messaging.MessageEnumerator.Reset%2A> <xref:System.Messaging.MessageEnumerator>polecenie.  
  
 Kolejność komunikatów w wyliczeniu odzwierciedla ich kolejność w kolejce, więc komunikaty o wyższym priorytecie będą wyświetlane przed niższymi priorytetami.  
  
 Jeśli chcesz utworzyć statyczną migawkę komunikatów w kolejce, a nie do ich połączenia dynamicznego, wywołaj <xref:System.Messaging.MessageQueue.GetAllMessages%2A>polecenie. Ta metoda zwraca tablicę <xref:System.Messaging.Message> obiektów, która reprezentuje komunikaty w momencie wywołania metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Tak|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera dynamiczną listę komunikatów w kolejce i zlicza wszystkie komunikaty z <xref:System.Messaging.Message.Priority%2A> właściwością ustawioną na. <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt modułu wyliczającego dla wszystkich komunikatów w kolejce.</summary>
        <returns><see cref="T:System.Messaging.MessageEnumerator" /> Przechowywanie komunikatów znajdujących się w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>tworzy dynamiczną listę wszystkich komunikatów w kolejce. Można usunąć z kolejki komunikat w bieżącym położeniu modułu wyliczającego, wywołując <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> <xref:System.Messaging.MessageEnumerator> dla zwracanych danych <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> .  
  
 Ponieważ kursor jest skojarzony z dynamiczną listą komunikatów w kolejce, Wyliczenie odzwierciedla wszelkie zmiany wprowadzone do komunikatów w kolejce, jeśli wiadomość wykracza poza bieżącą pozycję kursora. Na przykład moduł wyliczający może automatycznie uzyskiwać dostęp do komunikatu o niższym priorytecie poza bieżącą pozycją kursora, ale nie został wstawiony komunikat o wyższym priorytecie przed tą pozycją. Można jednak zresetować Wyliczenie, a tym samym przenieść kursor z powrotem do początku listy, wywołując <xref:System.Messaging.MessageEnumerator.Reset%2A> <xref:System.Messaging.MessageEnumerator>polecenie.  
  
 Kolejność komunikatów w wyliczeniu odzwierciedla ich kolejność w kolejce, więc komunikaty o wyższym priorytecie będą wyświetlane przed niższymi priorytetami.  
  
 Jeśli chcesz utworzyć statyczną migawkę komunikatów w kolejce, a nie do ich połączenia dynamicznego, wywołaj <xref:System.Messaging.MessageQueue.GetAllMessages%2A>polecenie. Ta metoda zwraca tablicę <xref:System.Messaging.Message> obiektów, która reprezentuje komunikaty w momencie wywołania metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Yes|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt modułu wyliczającego dla dynamicznej listy kolejek publicznych w sieci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia semantykę kursora tylko do przodu, aby wyliczyć wszystkie kolejki publiczne w sieci.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> , który zapewnia dynamiczną listę wszystkich publicznych kolejek komunikatów w sieci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> zwraca Wyliczenie wszystkich kolejek publicznych, które znajdują się w sieci.  
  
 Ze względu na to, że kursor jest skojarzony z listą dynamiczną, Wyliczenie odzwierciedla wszelkie modyfikacje wprowadzone do listy kolejek dla kolejek usuniętych lub dodanych poza bieżącą pozycję kursora. Dodawanie lub usuwanie kolejek znajdujących się przed bieżącą pozycją kursora nie są uwzględniane. Na przykład moduł wyliczający może automatycznie uzyskiwać dostęp do kolejki, która jest dołączana poza pozycją kursora, ale nie wstawioną przed tą pozycją. Można jednak zresetować Wyliczenie, a tym samym przenieść kursor z powrotem do początku listy, wywołując <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> <xref:System.Messaging.MessageQueueEnumerator>polecenie.  
  
 W sieci nie ma zdefiniowanej kolejności kolejek. Moduł wyliczający nie porządkuje ich, na przykład według komputera, etykiety, statusu publicznego lub prywatnego, ani żadnych innych dostępnych kryteriów.  
  
 Jeśli chcesz, aby migawka była statyczna kolejek w sieci, a nie z połączenia dynamicznego, wywołaj <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> lub <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Każda z tych dwóch metod zwraca tablicę <xref:System.Messaging.MessageQueue> obiektów, która reprezentuje kolejki w momencie wywołania metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Nazwa komputera lokalnego i bezpośredniego|Nie|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu iteruje przez wszystkie kolejki komunikatów w sieci i bada ścieżkę dla każdej kolejki. Na koniec wyświetla liczbę kolejek publicznych w sieci.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A <see cref="T:System.Messaging.MessageQueueCriteria" /> , który zawiera kryteria używane do filtrowania dostępnych kolejek komunikatów.</param>
        <summary>Zapewnia semantykę kursora tylko do przodu, aby wyliczyć wszystkie kolejki publiczne w sieci spełniające określone kryteria.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> , który zapewnia dynamiczną listę publicznych kolejek komunikatów w sieci, które spełniają ograniczenia określone <paramref name="criteria" /> przez parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> zwraca listę wszystkich kolejek publicznych w sieci, które spełniają kryteria zdefiniowane w kryteriach aplikacji. Możesz określić kryteria do uwzględnienia, na przykład, tworzenie lub modyfikowanie kolejki, nazwa komputera, etykieta, Kategoria lub dowolną ich kombinację.  
  
 Ponieważ kursor jest skojarzony z listą dynamiczną, Wyliczenie odzwierciedla wszelkie modyfikacje wprowadzone do kolejki, która występuje poza bieżącą pozycją kursora. Zmiany w kolejkach znajdujących się przed bieżącą pozycją kursora nie są uwzględniane. Na przykład moduł wyliczający może automatycznie uzyskiwać dostęp do kolejki, która jest dołączana poza pozycją kursora, ale nie wstawioną przed tą pozycją. Można jednak zresetować Wyliczenie, a tym samym przenieść kursor z powrotem do początku listy, wywołując <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> <xref:System.Messaging.MessageQueueEnumerator>polecenie.  
  
 W sieci nie ma zdefiniowanej kolejności kolejek. Moduł wyliczający nie porządkuje ich, na przykład według komputera, etykiety, statusu publicznego lub prywatnego, ani żadnych innych dostępnych kryteriów.  
  
 Jeśli chcesz, aby migawka była statyczna kolejek w sieci, a nie z ich połączeniem dynamicznym, określ kryteria <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> dla lub <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>wywołania. Każda z tych dwóch metod zwraca tablicę <xref:System.Messaging.MessageQueue> obiektów, która reprezentuje kolejki w momencie wywołania metody. <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>Wywoływanie <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>,, <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> lub zapewnia te same <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> <xref:System.Messaging.MessageQueue.Label%2A> <xref:System.Messaging.MessageQueue.MachineName%2A>wyniki, co wywołanie z kryteriami filtrowania odpowiednio ,,i.<xref:System.Messaging.MessageQueue.Category%2A>  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Nazwa komputera lokalnego i bezpośredniego|Nie|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu iteruje kolejki komunikatów i wyświetla ścieżkę każdej kolejki, która została utworzona w ostatnim dniu i która istnieje na komputerze "MójKomputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, z którego mają zostać pobrane kolejki prywatne.</param>
        <summary>Pobiera wszystkie kolejki prywatne na określonym komputerze.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów odwołujących się do pobranych kolejek prywatnych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>Pobiera statyczną migawkę kolejek na określonym komputerze.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Tak|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera listy kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr jest lub <see langword="null" /> jest pustym ciągiem (""). <paramref name="machineName" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wszystkie kolejki publiczne w sieci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wszystkie kolejki publiczne w sieci.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów odwołujących się do pobranych kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, jeśli chcesz uzyskać pełną listę wszystkich kolejek publicznych w sieci. Jeśli chcesz ograniczyć listę według określonych kryteriów, takich jak <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>lub czas ostatniej modyfikacji, użyj innego przeciążenia tej metody. (Alternatywnie można użyć <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, lub <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>Pobiera statyczną migawkę kolejek. Aby współużytkować z dynamiczną listą kolejek <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>, użyj.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Nazwa komputera lokalnego i bezpośredniego|Nie|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera listy kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A <see cref="T:System.Messaging.MessageQueueCriteria" /> , który zawiera kryteria używane do filtrowania kolejek.</param>
        <summary>Pobiera wszystkie kolejki publiczne w sieci spełniające określone kryteria.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów odwołujących się do pobranych kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz filtrować wszystkie kolejki publiczne w sieci według etykiety, kategorii lub nazwy komputera <xref:System.Messaging.MessageQueue> , Klasa zawiera konkretne metody, które zapewniają tę funkcjonalność (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>i <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, odpowiednio). Użyj tego przeciążenia, aby uzyskać listę wszystkich kolejek publicznych w sieci, które spełniają więcej niż jedno z tych kryteriów (na przykład, jeśli chcesz określić zarówno etykietę, jak i kategorię). Można również filtrować według kryteriów wiadomości innych niż <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>i <xref:System.Messaging.MessageQueue.MachineName%2A>. Na przykład można użyć tego przeciążenia do filtrowania według czasu ostatniej modyfikacji kolejki. Po prostu Utwórz nowe wystąpienie <xref:System.Messaging.MessageQueueCriteria> klasy, ustaw odpowiednie właściwości w wystąpieniu i przekaż wystąpienie `criteria` jako parametr.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>Pobiera statyczną migawkę kolejek. Aby współużytkować z dynamiczną listą kolejek <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>, użyj.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Nazwa komputera lokalnego i bezpośredniego|Nie|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera listy kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">A <see cref="T:System.Guid" /> , który grupuje zestaw kolejek do pobrania.</param>
        <summary>Pobiera wszystkie kolejki publiczne w sieci należące do określonej kategorii.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów odwołujących się do pobranych kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odfiltrować kolejki publiczne według kategorii. <xref:System.Messaging.MessageQueue.Category%2A> Właściwość zapewnia dostęp do właściwości identyfikatora typu usługi kolejkowania komunikatów (czyli odczytu/zapisu) określonej kolejki. Chociaż można użyć <xref:System.Guid.NewGuid%2A> do utworzenia wartości kategorii, która jest unikatowa dla wszystkich <xref:System.Guid> wartości, nie jest to konieczne. Wartość kategorii musi być odrębna tylko od innych kategorii, nie ze wszystkich innych <xref:System.Guid> wartości. {00000000-0000-0000-0000-000000000001} Na przykład można przypisać <xref:System.Messaging.MessageQueue.Category%2A> jako dla jednego zestawu kolejek i {00000000-0000-0000-0000-000000000002} jako <xref:System.Messaging.MessageQueue.Category%2A> dla innego zestawu.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>Pobiera statyczną migawkę kolejek. Aby współużytkować z dynamiczną listą kolejek <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>, użyj. Możesz określić kategorię jako część <xref:System.Messaging.MessageQueueCriteria> przekazana do metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Nazwa komputera lokalnego i bezpośredniego|Nie|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera listy kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Etykieta grupująca zestaw kolejek do pobrania.</param>
        <summary>Pobiera wszystkie kolejki publiczne w sieci, które zawierają określoną etykietę.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów odwołujących się do pobranych kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odfiltrować kolejki publiczne według etykiety.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>Pobiera statyczną migawkę kolejek. Aby współużytkować z dynamiczną listą kolejek <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>, użyj. Możesz określić etykietę jako część <xref:System.Messaging.MessageQueueCriteria> przekazana do metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Nazwa komputera lokalnego i bezpośredniego|Nie|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera listy kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="label" /></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nazwa komputera, który zawiera zestaw kolejek publicznych do pobrania.</param>
        <summary>Pobiera wszystkie kolejki publiczne, które znajdują się na określonym komputerze.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów odwołujących się do kolejek publicznych na komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odfiltrować kolejki publiczne według komputera.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>Pobiera statyczną migawkę kolejek. Aby współużytkować z dynamiczną listą kolejek <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>, użyj. Możesz określić nazwę komputera jako część <xref:System.Messaging.MessageQueueCriteria> przekazana do metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Nazwa komputera lokalnego i bezpośredniego|Nie|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera listy kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> Parametr ma niepoprawną składnię.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kontekst zabezpieczeń, który usługa MSMQ kojarzy z bieżącym użytkownikiem (tożsamość wątku) w czasie tego wywołania.</summary>
        <returns><see cref="T:System.Messaging.SecurityContext" /> Obiekt, który zawiera kontekst zabezpieczeń.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator usługi kolejkowania komunikatów w kolejce.</summary>
        <value><see cref="P:System.Messaging.MessageQueue.Id" /> Reprezentuje identyfikator komunikatu wygenerowanego przez aplikację usługi kolejkowania komunikatów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów ustawia <xref:System.Messaging.MessageQueue.Id%2A> właściwość podczas tworzenia kolejki. Ta właściwość jest dostępna tylko dla kolejek publicznych.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.MessageQueue.Id%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że dla kolejki nie istnieje ograniczenie rozmiaru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski jest często używany podczas <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> ustawiania <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>lub.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.InfiniteQueueSize> elementu członkowskiego.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że limit czasu nie istnieje dla metod, które pobierają lub odbierają wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue>obsługuje dwa typy pobieranych komunikatów: synchroniczne i asynchroniczne. Metody <xref:System.Messaging.MessageQueue.Peek%2A> synchroniczne i <xref:System.Messaging.MessageQueue.Receive%2A>, powodują, że wątek procesu oczekuje określonego przedziału czasu na nadejście nowej wiadomości w kolejce. Jeśli określony przedział czasu to <xref:System.Messaging.MessageQueue.InfiniteTimeout>, wątek procesu pozostaje zablokowany do momentu udostępnienia nowej wiadomości. Z drugiej strony <xref:System.Messaging.MessageQueue.BeginPeek%2A> i <xref:System.Messaging.MessageQueue.BeginReceive%2A> (metody asynchroniczne) Zezwól, aby główne zadania aplikacji były kontynuowane w osobnym wątku do momentu odebrania komunikatu w kolejce.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.InfiniteTimeout> elementu członkowskiego.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia opis kolejki.</summary>
        <value>Etykieta kolejki komunikatów. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maksymalna długość etykiety kolejki komunikatów to 124 znaków.  
  
 <xref:System.Messaging.MessageQueue.Label%2A> Właściwość nie musi być unikatowa we wszystkich kolejkach. Jeśli jednak wiele kolejek współużytkuje <xref:System.Messaging.MessageQueue.Label%2A>te same, nie można <xref:System.Messaging.MessageQueue.Send%28System.Object%29> użyć metody do rozgłaszania komunikatów do wszystkich z nich. Jeśli używasz składni etykiety dla <xref:System.Messaging.MessageQueue.Path%2A> właściwości podczas wysyłania wiadomości, zostanie zgłoszony wyjątek, <xref:System.Messaging.MessageQueue.Label%2A> Jeśli nie jest unikatowa.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.Label%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Etykieta została ustawiona na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas ostatniej modyfikacji właściwości kolejki.</summary>
        <value>Wskazuje <see cref="T:System.DateTime" /> , kiedy ostatnio zmodyfikowano właściwości kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas ostatniej modyfikacji uwzględnia moment utworzenia kolejki oraz <xref:System.Messaging.MessageQueue> Właściwość modyfikującą kolejkę kolejkowania komunikatów, na <xref:System.Messaging.MessageQueue.BasePriority%2A>przykład. Wartość <xref:System.Messaging.MessageQueue.LastModifyTime%2A> właściwości reprezentuje czas systemowy komputera lokalnego.  
  
 Przed <xref:System.Messaging.MessageQueue.Refresh%2A> <xref:System.Messaging.MessageQueue> pobraniem właściwości należy wywołać metodę; w przeciwnym razie czas modyfikacji skojarzony z tym może nie być aktualny. <xref:System.Messaging.MessageQueue.LastModifyTime%2A>  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.MessageQueue.LastModifyTime%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komputera, na którym znajduje się kolejka usługi kolejkowania komunikatów.</summary>
        <value>Nazwa komputera, na którym znajduje się kolejka. Domyślna wartość kolejkowania komunikatów to ".", komputer lokalny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest integralnym składnikiem składni przyjaznej nazwy kolejki <xref:System.Messaging.MessageQueue.Path%2A>. <xref:System.Messaging.MessageQueue.MachineName%2A> W poniższej tabeli przedstawiono składnię, która powinna być używana dla kolejki określonego typu, gdy chcesz identyfikować ścieżkę kolejki przy użyciu przyjaznej nazwy.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejka dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejka dzienników maszyn|`MachineName`\\`Journal$`|  
|Kolejka utraconych wiadomości komputera|`MachineName`\\`Deadletter$`|  
|Kolejka utraconych wiadomości transakcyjnych komputera|`MachineName`\\`XactDeadletter$`|  
  
 Użyj "." komputera lokalnego podczas określania <xref:System.Messaging.MessageQueue.MachineName%2A>. Dla tej właściwości jest rozpoznawana tylko nazwa komputera, na przykład `Server0`. <xref:System.Messaging.MessageQueue.MachineName%2A> Właściwość nie obsługuje formatu adresu IP.  
  
 Jeśli zdefiniujesz <xref:System.Messaging.MessageQueue.Path%2A> pod względem <xref:System.Messaging.MessageQueue.MachineName%2A>, aplikacja zgłasza wyjątek podczas pracy w trybie offline, ponieważ kontroler domeny jest wymagany do translacji ścieżki. W związku z tym należy użyć <xref:System.Messaging.MessageQueue.FormatName%2A> <xref:System.Messaging.MessageQueue.Path%2A> do składni podczas pracy w trybie offline.  
  
 Właściwości <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, i<xref:System.Messaging.MessageQueue.QueueName%2A> są powiązane. <xref:System.Messaging.MessageQueue.MachineName%2A> Zmiana właściwości <xref:System.Messaging.MessageQueue.Path%2A> powoduje zmianę właściwości. Jest ona tworzona na podstawie nowych <xref:System.Messaging.MessageQueue.MachineName%2A> <xref:System.Messaging.MessageQueue.QueueName%2A>i. Zmiana (na przykład w celu użycia składni nazwy formatu) <xref:System.Messaging.MessageQueue.MachineName%2A> resetuje właściwości i <xref:System.Messaging.MessageQueue.QueueName%2A> , aby odwołać się do nowej kolejki. <xref:System.Messaging.MessageQueue.Path%2A> Jeśli właściwość jest pusta, jest ustawiona na kolejkę dziennika określonego przez użytkownika. <xref:System.Messaging.MessageQueue.Path%2A> <xref:System.Messaging.MessageQueue.QueueName%2A>  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Tak|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.MachineName%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.MachineName" /> Ma<see langword="null" />wartość.        
—lub—

Nazwa komputera jest nieprawidłowa, prawdopodobnie z powodu nieprawidłowej składni.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar kolejki dziennika.</summary>
        <value>Maksymalny rozmiar kolejki dziennika (w kilobajtach). Domyślnie usługa kolejkowania komunikatów określa, że nie istnieje żaden limit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>zapewnia dostęp do limitu magazynowania dziennika usługi kolejkowania komunikatów. Ma to zastosowanie tylko wtedy <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> , `true`gdy jest. Ustawienie tej właściwości powoduje modyfikację kolejki usługi kolejkowania komunikatów. W związku z tym <xref:System.Messaging.MessageQueue> zmiana ta ma wpływ na wszystkie inne wystąpienia.  
  
 Jeśli komunikaty są przechowywane w dzienniku lub w kolejce utraconych wiadomości, należy okresowo wyczyścić kolejkę, aby usunąć komunikaty, które nie są już potrzebne. Komunikaty w takiej kolejce są wliczane do przydziału komunikatów na komputerze, na którym znajduje się kolejka. (Administrator ustawia limit przydziału komputera).  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Maksymalny rozmiar kolejki dziennika został ustawiony na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar kolejki.</summary>
        <value>Maksymalny rozmiar kolejki (w kilobajtach). Domyślnie usługa kolejkowania komunikatów określa, że nie istnieje żaden limit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> Zapewnia dostęp do limitu magazynowania komunikatów usługi kolejkowania komunikatów, który jest oddzielony od limitu przydziału komunikatów komputera zdefiniowanego przez administratora. Aby uzyskać więcej informacji na temat limitu przydziału wiadomości <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>, zobacz.  
  
 Ustawienie tej właściwości powoduje modyfikację kolejki usługi kolejkowania komunikatów. W związku z tym <xref:System.Messaging.MessageQueue> zmiana ta ma wpływ na wszystkie inne wystąpienia.  
  
 Jeśli zostanie podjęta próba przekroczenia maksymalnego rozmiaru kolejki lub limitu przydziału komunikatów komputera, komunikaty mogły zostać utracone. Po osiągnięciu przydziału kolejki usługa kolejkowania komunikatów powiadamia kolejkę administracyjną aplikacji wysyłającej o to, aby wskazać, że kolejka jest pełna, zwracając komunikat z potwierdzeniem negatywnym. Usługa kolejkowania komunikatów nadal wysyła potwierdzenia negatywne do momentu, aż całkowity rozmiar komunikatów w kolejce spadnie poniżej limitu.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Maksymalny rozmiar kolejki zawiera wartość ujemną.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia filtr właściwości na potrzeby otrzymywania lub wglądu w wiadomości.</summary>
        <value><see cref="T:System.Messaging.MessagePropertyFilter" /> Używany przez kolejkę do filtrowania zestawu właściwości otrzymywanych lub wglądu dla każdego komunikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten filtr jest zestawem wartości logicznych, które <xref:System.Messaging.MessageQueue> ograniczają właściwości komunikatów odbierane lub wglądne. Gdy odbiera lub pobiera komunikat z kolejki serwera, pobiera tylko te właściwości, dla <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> których wartość jest `true`. <xref:System.Messaging.MessageQueue>  
  
 Poniżej przedstawiono początkowe wartości <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> właściwości właściwości. Te ustawienia są identyczne z wywoływaniem <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> <xref:System.Messaging.MessagePropertyFilter>na.  
  
|Właściwość|Wartość domyślna|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 bajtów|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 bajtów|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 bajtów|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Tak|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu używa w <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> celu ograniczenia odebranych właściwości komunikatów.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Filtr jest <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wprowadzone w usłudze MSMQ 3,0. Pobiera lub ustawia adres multiemisji skojarzony z kolejką.</summary>
        <value>A <see cref="T:System.String" /> , który zawiera prawidłowy adres multiemisji (w postaci pokazanej poniżej) <see langword="null" />lub, co oznacza, że kolejka nie jest skojarzona z adresem multiemisji.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Właściwość służy do kojarzenia kolejki nietransakcyjnej z adresem multiemisji, który może być używany podczas wysyłania wiadomości. Nie można skojarzyć kolejki transakcyjnej z adresem multiemisji. Gdy aplikacja wysyłająca wysyła komunikaty na adres multiemisji, usługa kolejkowania komunikatów wysyła kopię wiadomości do każdej kolejki skojarzonej z tym adresem.  
  
 Adresy multiemisji IP muszą należeć do zakresu klasy D od 224.0.0.0 do 239.255.255.255, co odnosi się do ustawienia pierwszych czterech bitów o wysokim stopniu równym 1110. Jednak tylko niektóre zakresy adresów z tego zakresu są niezastrzeżone i dostępne do wysyłania komunikatów multiemisji. Aby uzyskać najnowszą listę zastrzeżonych adresów multiemisji, zobacz stronę sieci Web Internet [Assigned Number Authority (IANA)](https://go.microsoft.com/fwlink/?linkid=3859) Internet. Nie ma żadnych ograniczeń dotyczących numeru portu.  
  
 Jeśli kilka komputerów źródłowych wysyła komunikaty multiemisji i dana kolejka ma odbierać komunikaty tylko z jednego komputera źródłowego, każdy komputer źródłowy musi wysyłać komunikaty do innej kombinacji adresów IP i numerów portów.  
  
 Aby usunąć skojarzenie kolejki z adresu multiemisji, należy ustawić <xref:System.Messaging.MessageQueue.MulticastAddress%2A> właściwość na ciąg o zerowej długości. Nie ustawiaj go na `null`, ponieważ spowoduje <xref:System.ArgumentNullException>to powstanie.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nie zainstalowano usługi MSMQ 3,0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ścieżkę kolejki. Ustawienie powoduje, <see cref="T:System.Messaging.MessageQueue" /> że wskazuje nową kolejkę. <see cref="P:System.Messaging.MessageQueue.Path" /></summary>
        <value>Kolejka, do której odwołuje <see cref="T:System.Messaging.MessageQueue" />się. Domyślnie zależy od tego, jakiego <see cref="M:System.Messaging.MessageQueue.#ctor" /> konstruktora używasz; <see langword="null" /> jest on lub jest <paramref name="path" /> określony przez parametr konstruktora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnia <xref:System.Messaging.MessageQueue.Path%2A> właściwości zależy od typu kolejki, do której wskazuje, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejka dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejka dzienników maszyn|`MachineName`\\`Journal$`|  
|Kolejka utraconych wiadomości komputera|`MachineName`\\`Deadletter$`|  
|Kolejka utraconych wiadomości transakcyjnych komputera|`MachineName`\\`XactDeadletter$`|  
  
 Użyj ".", aby reprezentować komputer lokalny.  
  
 Właściwości <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, i<xref:System.Messaging.MessageQueue.QueueName%2A> są powiązane. <xref:System.Messaging.MessageQueue.MachineName%2A> Zmiana właściwości <xref:System.Messaging.MessageQueue.Path%2A> powoduje zmianę właściwości. Jest ona tworzona na podstawie nowych <xref:System.Messaging.MessageQueue.MachineName%2A> <xref:System.Messaging.MessageQueue.QueueName%2A>i. Zmiana (na przykład w celu użycia składni nazwy formatu) <xref:System.Messaging.MessageQueue.MachineName%2A> resetuje właściwości i <xref:System.Messaging.MessageQueue.QueueName%2A> , aby odwołać się do nowej kolejki. <xref:System.Messaging.MessageQueue.Path%2A>  
  
 Alternatywnie można użyć <xref:System.Messaging.MessageQueue.FormatName%2A> lub <xref:System.Messaging.MessageQueue.Label%2A> do opisania ścieżki kolejki, jak pokazano w poniższej tabeli.  
  
|Tematy pomocy|Składnia|Przykład|  
|---------------|------------|-------------|  
|Nazwa formatu|`FormatName:`[ *nazwa formatu* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Etykieta|`Label:`[ *etykieta* ]|`Label:`TheLabel|  
  
 Jeśli używasz składni etykiety dla <xref:System.Messaging.MessageQueue.Path%2A> właściwości podczas wysyłania wiadomości, zostanie zgłoszony wyjątek, <xref:System.Messaging.MessageQueue.Label%2A> Jeśli nie jest unikatowa.  
  
 Aby działało w trybie offline, należy użyć składni nazwy formatu zamiast składni przyjaznej nazwy w pierwszej tabeli. W przeciwnym razie jest zgłaszany wyjątek, ponieważ podstawowy kontroler domeny (na którym znajdują się Active Directory) nie jest dostępny do rozpoznawania ścieżki do nazwy formatu.  
  
 Ustawienie nowej ścieżki zamyka kolejkę komunikatów i zwalnia wszystkie uchwyty.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Tak|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
> [!NOTE]
>  W trybie grupy roboczej można używać tylko kolejek prywatnych. Ścieżkę należy określić przy `MachineName`użyciu składni \\ `Private$` \\kolejki prywatnej.`QueueName`  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowe <xref:System.Messaging.MessageQueue> obiekty przy użyciu różnych typów składni nazw ścieżek. W każdym przypadku wysyła komunikat do kolejki, której ścieżka jest zdefiniowana w konstruktorze.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka jest nieprawidłowa, prawdopodobnie z powodu nieprawidłowej składni.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <summary>Zwraca kopię pierwszego komunikatu w kolejce bez usuwania komunikatu z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca bez usuwania (wglądu) pierwszy komunikat w kolejce, do którego się odwołuje <see cref="T:System.Messaging.MessageQueue" />. <see cref="M:System.Messaging.MessageQueue.Peek" /> Metoda jest synchroniczna, dlatego blokuje bieżący wątek do momentu, gdy wiadomość nie zostanie udostępniona.</summary>
        <returns><see cref="T:System.Messaging.Message" /> Reprezentuje pierwszy komunikat w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia do wglądu w kolejkę lub zaczekaj, aż w kolejce zostanie wyświetlony komunikat.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Metoda odczytuje, ale nie usuwa, pierwszy komunikat z kolejki. W związku z tym powtórzone wywołania <xref:System.Messaging.MessageQueue.Peek%2A> zwracające ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda, z drugiej strony, odczytuje i usuwa pierwszy komunikat z kolejki. Powtórzone wywołania <xref:System.Messaging.MessageQueue.Receive%2A>do, w związku z tym zwracają różne komunikaty.  
  
 Komunikaty zamówień usługi kolejkowania komunikatów w kolejce są zależne od priorytetu i czasu nadejścia. Nowszy komunikat jest umieszczany przed starszym, tylko wtedy, gdy ma wyższy priorytet.  
  
 Użyj <xref:System.Messaging.MessageQueue.Peek%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Ponieważ to Przeciążenie nie określa limitu czasu, aplikacja może czekać w nieskończoność. Aby przetwarzanie aplikacji było kontynuowane bez oczekiwania, użyj metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginPeek%2A> . Alternatywnie możesz określić limit czasu dla komunikatu, który ma zostać przychodzący do kolejki przy użyciu przeciążenia <xref:System.Messaging.MessageQueue.Peek%2A> , które określa limit czasu.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 W poniższych przykładach użyto <xref:System.Messaging.MessageQueue.Peek%2A> metody z kolejki.  
  
 W pierwszym przykładzie aplikacja oczekuje do momentu udostępnienia komunikatu w kolejce. Należy zauważyć, że pierwszy przykład nie uzyskuje dostępu do komunikatu, który dotarł do; powoduje to jedynie wstrzymanie przetwarzania do momentu odebrania komunikatu. Jeśli komunikat już istnieje w kolejce, zostanie natychmiast zwrócony.  
  
 W drugim przykładzie komunikat zawierający klasę zdefiniowaną przez `Order` aplikację jest wysyłany do kolejki, a następnie wgląd z kolejki.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazujący maksymalny czas oczekiwania, aż kolejka będzie zawierać komunikat.</param>
        <summary>Zwraca bez usuwania (wglądu) pierwszy komunikat w kolejce, do którego się odwołuje <see cref="T:System.Messaging.MessageQueue" />. <see cref="M:System.Messaging.MessageQueue.Peek" /> Metoda jest synchroniczna, dlatego blokuje bieżący wątek do momentu udostępnienia komunikatu lub określonego limitu czasu.</summary>
        <returns><see cref="T:System.Messaging.Message" /> Reprezentuje pierwszy komunikat w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia do wglądu w kolejkę lub oczekiwania na określony czas do momentu, aż w kolejce zostanie wyświetlony komunikat. Metoda wraca natychmiast, jeśli komunikat już istnieje w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Metoda odczytuje, ale nie usuwa, pierwszy komunikat z kolejki. W związku z tym powtórzone wywołania <xref:System.Messaging.MessageQueue.Peek%2A> zwracające ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda, z drugiej strony, odczytuje i usuwa pierwszy komunikat z kolejki. Powtórzone wywołania <xref:System.Messaging.MessageQueue.Receive%2A>do, w związku z tym zwracają różne komunikaty.  
  
 Komunikaty zamówień usługi kolejkowania komunikatów w kolejce są zależne od priorytetu i czasu nadejścia. Nowszy komunikat jest umieszczany przed starszym, tylko wtedy, gdy ma wyższy priorytet.  
  
 Użyj <xref:System.Messaging.MessageQueue.Peek%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Wątek zostanie zablokowany do określonego czasu lub w nieskończoność, jeśli został wskazany <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Aby przetwarzanie aplikacji było kontynuowane bez oczekiwania, użyj metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginPeek%2A> .  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Messaging.MessageQueue.Peek%2A> metody z limitem czasu równym zero, aby sprawdzić, czy kolejka jest pusta.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazujący maksymalny czas oczekiwania, aż kolejka będzie zawierać komunikat.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który utrzymuje określone położenie w kolejce komunikatów.</param>
        <param name="action">Jedna z <see cref="T:System.Messaging.PeekAction" /> wartości. Wskazuje, czy ma być wgląd w bieżącą wiadomość w kolejce, czy następny komunikat.</param>
        <summary>Zwraca bez usuwania (wglądu) bieżącą lub następną wiadomość w kolejce przy użyciu określonego kursora. <see cref="M:System.Messaging.MessageQueue.Peek" /> Metoda jest synchroniczna, dlatego blokuje bieżący wątek do momentu udostępnienia komunikatu lub określonego limitu czasu.</summary>
        <returns><see cref="T:System.Messaging.Message" /> Reprezentuje komunikat w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia do wglądu w kolejkę lub oczekiwania na określony czas do momentu, aż w kolejce zostanie wyświetlony komunikat. Metoda wraca natychmiast, jeśli komunikat już istnieje w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Metoda odczytuje, ale nie usuwa komunikat z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda, z drugiej strony, odczytuje i usuwa komunikat z kolejki.  
  
 Użyj <xref:System.Messaging.MessageQueue.Peek%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Wątek jest blokowany do określonego czasu lub w nieskończoność, jeśli został wskazany <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Aby przetwarzanie aplikacji było kontynuowane bez oczekiwania, użyj metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginPeek%2A> .  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość inna niż <see langword="PeekAction.Current" /> lub <see langword="PeekAction.Next" /> została określona dla <paramref name="action" /> parametru.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="cursor" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa. Prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza lub równa. <see cref="F:System.TimeSpan.Zero" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dokonuje wglądu do wiadomości zgodnej z danym identyfikatorem korelacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomość do wglądu.</param>
        <summary>Wgląd w komunikat, który pasuje do podanego identyfikatora korelacji, i natychmiast wywołuje wyjątek, jeśli w kolejce nie istnieje żaden komunikat o określonym identyfikatorze korelacji.</summary>
        <returns>Który jest <see cref="T:System.Messaging.Message" /> zgodnyz<paramref name="correlationId" />przekazaniemparametru <see cref="P:System.Messaging.Message.CorrelationId" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje kolejkę, do której <xref:System.Messaging.MessageQueue> odwołuje się komunikat <xref:System.Messaging.Message.CorrelationId%2A> , którego dopasowanie `correlationId` jest zgodne z określonym parametrem. Jeśli nie zostanie znaleziony żaden komunikat zgodny z `correlationID` parametrem, zostanie zgłoszony wyjątek.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość służy do powiązania wiadomości wysyłanej do kolejki z odpowiedzią, raportem lub komunikatem potwierdzającym.  
  
 Dwie inne metody umożliwiają wgląd w wiadomości w kolejce. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> a metoda jest używana do pobierania komunikatu przez określenie jego unikatowego identyfikatora. <xref:System.Messaging.MessageQueue.Peek%2A>  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera komunikat zawierający zamówienie do i z kolejki. Zażąda pozytywnego potwierdzenia, gdy oryginalny komunikat osiągnie lub zostanie pobrany z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="correlationId" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="correlationId" /> określoną opcją.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomość do wglądu.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <summary>Wgląd w komunikat, który odpowiada danemu identyfikatorowi korelacji i czeka, aż komunikat o określonym identyfikatorze korelacji jest dostępny w kolejce lub limit czasu wygaśnie.</summary>
        <returns>Który jest <see cref="T:System.Messaging.Message" /> zgodnyz<paramref name="correlationId" />przekazaniemparametru <see cref="P:System.Messaging.Message.CorrelationId" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje kolejkę, do której <xref:System.Messaging.MessageQueue> odwołuje się komunikat <xref:System.Messaging.Message.CorrelationId%2A> , którego dopasowanie `correlationId` jest zgodne z określonym parametrem. Jeśli nie zostanie znaleziony żaden komunikat zgodny z `correlationID` parametrem i nie dociera nowy komunikat w kolejce w okresie określonym `timeout` przez parametr, zostanie zgłoszony wyjątek.  
  
 `timeout` Parametr nie określa łącznego czasu działania dla tej metody. Zamiast tego określa czas oczekiwania na nadejście nowej wiadomości w kolejce. Za każdym razem, gdy pojawi się nowy komunikat, ta metoda analizuje <xref:System.Messaging.Message.CorrelationId%2A> nową wiadomość, aby zobaczyć, czy jest zgodna z `correlationId` parametrem. W przeciwnym razie ta metoda zaczyna przekroczyć limit czasu i czeka na nadejście kolejnej nowej wiadomości. W związku z tym, jeśli nowe komunikaty nadal docierają do limitu czasu, możliwe jest, aby ta metoda kontynuowała działanie na czas nieokreślony, aż do upływu limitu czasu, w którym nie będą wysyłane żadne nowe komunikaty lub do momentu odebrania <xref:System.Messaging.Message.CorrelationId%2A> komunikatu dopasowuje `correlationId` parametr.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość służy do powiązania wiadomości wysyłanej do kolejki z odpowiedzią, raportem lub komunikatem potwierdzającym.  
  
 Dwie inne metody umożliwiają wgląd w wiadomości w kolejce. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> a metoda jest używana do pobierania komunikatu przez określenie jego unikatowego identyfikatora. <xref:System.Messaging.MessageQueue.Peek%2A>  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="correlationId" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="correlationId" /> elementem nie istnieje w kolejce i nie dotarł przed upływem limitu czasu.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość nie dotarła przed upływem limitu czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kopię komunikatu o określonym identyfikatorze komunikatu bez usuwania komunikatu z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" /> Wiadomość do wglądu.</param>
        <summary>Wgląd w komunikat, którego identyfikator wiadomości pasuje do <paramref name="id" /> parametru.</summary>
        <returns>Właściwość, która <see cref="T:System.Messaging.Message" /> pasuje do <paramref name="id" /> parametru. <see cref="P:System.Messaging.Message.Id" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> do odczytu, bez usuwania z kolejki, komunikatu o znanym identyfikatorze wiadomości. Identyfikator komunikatu jest unikatowy w całym przedsiębiorstwie usługi kolejkowania komunikatów, więc w kolejce będzie co najwyżej jeden komunikat zgodny z podanym `id` parametrem. To Przeciążenie zgłasza wyjątek, jeśli kolejka nie zawiera komunikatu.  
  
 Dwie dodatkowe metody umożliwiają wgląd w wiadomości w kolejce: <xref:System.Messaging.MessageQueue.Peek%2A> i. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zwraca pierwszy komunikat w kolejce; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> zwraca potwierdzenie, raport lub wygenerowany przez aplikację komunikat odpowiedzi, który został utworzony w wyniku wysłania wiadomości do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="id" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie istnieje żaden komunikat o <paramref name="id" /> określonym.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" /> Wiadomość do wglądu.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <summary>Wgląd w komunikat, którego identyfikator wiadomości pasuje do <paramref name="id" /> parametru. Czeka, aż komunikat pojawi się w kolejce lub przekroczy limit czasu.</summary>
        <returns>Właściwość, która <see cref="T:System.Messaging.Message" /> pasuje do <paramref name="id" /> parametru. <see cref="P:System.Messaging.Message.Id" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> do odczytu, bez usuwania z kolejki, komunikatu o znanym identyfikatorze wiadomości. Identyfikator komunikatu jest unikatowy w całym przedsiębiorstwie usługi kolejkowania komunikatów, więc w kolejce będzie co najwyżej jeden komunikat zgodny z podanym `id` parametrem. To Przeciążenie zgłasza wyjątek, jeśli kolejka aktualnie nie zawiera komunikatu, a nowy komunikat nie zostanie wyświetlony przed upływem limitu czasu.  
  
 `timeout` Parametr nie określa łącznego czasu działania dla tej metody. Zamiast tego określa czas oczekiwania na nadejście nowej wiadomości w kolejce. Za każdym razem, gdy pojawi się nowy komunikat, ta metoda analizuje <xref:System.Messaging.Message.Id%2A> nową wiadomość, aby zobaczyć, czy jest zgodna z `id` parametrem. W przeciwnym razie ta metoda zaczyna przekroczyć limit czasu i czeka na nadejście kolejnej nowej wiadomości. W związku z tym, jeśli nowe komunikaty nadal docierają do limitu czasu, możliwe jest, aby ta metoda kontynuowała działanie na czas nieokreślony, aż do upływu limitu czasu, w którym nie będą wysyłane żadne nowe komunikaty lub do momentu odebrania <xref:System.Messaging.Message.Id%2A> komunikatu dopasowuje `id` parametr.  
  
 Dwie dodatkowe metody umożliwiają wgląd w wiadomości w kolejce: <xref:System.Messaging.MessageQueue.Peek%2A> i. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zwraca pierwszy komunikat w kolejce; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> zwraca potwierdzenie, raport lub wygenerowany przez aplikację komunikat odpowiedzi, który został utworzony w wyniku wysłania wiadomości do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="id" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="id" /> elementem nie istnieje w kolejce i nie dotarł przed upływem czasu określonego <paramref name="timeout" /> przez parametr.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wprowadzone w usłudze MSMQ 3,0. Dokonuje wglądu w określoną wiadomość z kolejki. Komunikat może być określony przez identyfikator wyszukiwania lub przez jego pozycję na wierzchu lub na końcu kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId"><see cref="P:System.Messaging.Message.LookupId" /> Wiadomość do wglądu.</param>
        <summary>Wprowadzone w usłudze MSMQ 3,0. Wgląd w komunikat, który pasuje do podanego identyfikatora wyszukiwania z kolejki nietransakcyjnej.</summary>
        <returns>Właściwość, która jest <see cref="T:System.Messaging.Message" /> zgodna <paramref name="lookupId" /> z przekazaną parametrem. <see cref="P:System.Messaging.Message.LookupId" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat o znanym identyfikatorze wyszukiwania bez usuwania go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli wiadomość nie znajduje się w kolejce.  
  
 Właściwość komunikatu jest unikatowa dla kolejki, w której znajduje się komunikat, więc w kolejce będzie znajdować się co najwyżej jeden komunikat zgodny z podanym `lookupId` parametrem. <xref:System.Messaging.Message.LookupId%2A>  
  
 Aby odczytać komunikat z określonym identyfikatorem wyszukiwania i usunąć go z kolejki, użyj <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nie zainstalowano usługi MSMQ 3,0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="lookupId" /> określoną opcją.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Jedna z <see cref="T:System.Messaging.MessageLookupAction" /> wartości, określająca sposób odczytu wiadomości w kolejce. Określ jedną z następujących wartości: 
 <see langword="MessageLookupAction.Current" />: Wgląd w komunikat określony przez <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Next" />: Dokonuje wglądu w komunikat następujący po komunikacie <paramref name="lookupId" />określonym przez.  
  
 <see langword="MessageLookupAction.Previous" />: Wgląd w komunikat poprzedzający komunikat określony przez <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.First" />: Dokonuje wglądu do pierwszej wiadomości w kolejce. <paramref name="lookupId" /> Parametr musi mieć wartość 0.  
  
 <see langword="MessageLookupAction.Last" />: Dokonuje wglądu do ostatniej wiadomości w kolejce. <paramref name="lookupId" /> Parametr musi mieć wartość 0.</param>
        <param name="lookupId"><see cref="P:System.Messaging.Message.LookupId" /> Wiadomość do wglądu lub 0. wartość 0 jest używana podczas uzyskiwania dostępu do pierwszego lub ostatniego komunikatu w kolejce.</param>
        <summary>Wprowadzone w usłudze MSMQ 3,0. Dokonuje wglądu w określoną wiadomość z kolejki. Komunikat może być określony przez identyfikator wyszukiwania lub przez jego pozycję na wierzchu lub na końcu kolejki.</summary>
        <returns>Określone przez parametry<paramref name="lookupId" /> i <paramref name="action" />. <see cref="T:System.Messaging.Message" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat o znanym identyfikatorze wyszukiwania bez usuwania go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli wiadomość nie znajduje się w kolejce.  
  
 Właściwość komunikatu jest unikatowa dla kolejki, w której znajduje się komunikat, więc w kolejce będzie znajdować się co najwyżej jeden komunikat zgodny z podanym `lookupId` parametrem. <xref:System.Messaging.Message.LookupId%2A>  
  
 Aby odczytać komunikat z określonym identyfikatorem i usunąć go z kolejki, użyj <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nie zainstalowano usługi MSMQ 3,0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="lookupId" /> określoną opcją.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageLookupAction" /> z elementów członkowskich. <paramref name="action" /></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy komunikat zostanie odczytany bez usuwania z kolejki. Jest to wynik operacji <see cref="M:System.Messaging.MessageQueue.BeginPeek" />asynchronicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>jest używany w przetwarzaniu asynchronicznym w <xref:System.Messaging.MessageQueue.PeekCompleted> celu podniesienia zdarzenia, gdy komunikat jest dostępny w kolejce.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>służy do ukończenia operacji zainicjowanej przez wywołanie <xref:System.Messaging.MessageQueue.BeginPeek%2A> i wgląd w komunikat <xref:System.Messaging.MessageQueue.PeekCompleted> po wywołaniu zdarzenia.  
  
 Podczas tworzenia <xref:System.Messaging.PeekCompletedEventHandler> delegata należy określić metodę, która będzie obsługiwać zdarzenie. Aby skojarzyć zdarzenie z programem obsługi zdarzeń, Dodaj wystąpienie delegata do zdarzenia. Program obsługi zdarzeń jest wywoływany przy każdym wystąpieniu zdarzenia, o ile nie usunięto delegata. Aby uzyskać więcej informacji na temat delegatów obsługi zdarzeń, zobacz temat [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyPeekCompleted`, dołącza go <xref:System.Messaging.MessageQueue.PeekCompleted> do delegata programu obsługi zdarzeń i wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> do inicjowania asynchronicznej operacji wglądu do kolejki, która znajduje się w ścieżce ".\myQueue". <xref:System.Messaging.MessageQueue.PeekCompleted> Gdy zdarzenie jest zgłaszane, przykład służy do wglądu w komunikat i zapisywania jego treści na ekranie. Przykład następnie wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> ponownie w celu zainicjowania nowej asynchronicznej operacji wglądu  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie komunikaty znajdujące się w kolejce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeczyszczanie kolejki powoduje, że usługa kolejkowania komunikatów ustawia flagę modyfikacji kolejki, która ma <xref:System.Messaging.MessageQueue.LastModifyTime%2A> wpływ na właściwość. Komunikaty przeczyszczane z kolejki zostaną utracone; nie są one wysyłane do kolejki utraconych wiadomości ani do kolejki dziennika.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przyjazną nazwę, która identyfikuje kolejkę.</summary>
        <value>Nazwa, która identyfikuje kolejkę, do której <see cref="T:System.Messaging.MessageQueue" />odwołuje się ten. Wartość nie może być <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można połączyć <xref:System.Messaging.MessageQueue.QueueName%2A> za pomocą elementu, <xref:System.Messaging.MessageQueue.MachineName%2A> aby utworzyć przyjazną <xref:System.Messaging.MessageQueue.Path%2A> nazwę kolejki. Składnia dla przyjaznej odmiany <xref:System.Messaging.MessageQueue.Path%2A> nazwy właściwości zależy od typu kolejki, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejka dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Użyj ".", aby reprezentować komputer lokalny.  
  
 <xref:System.Messaging.MessageQueue.QueueName%2A> Zmiana właściwości <xref:System.Messaging.MessageQueue.Path%2A> wpływa na właściwość. Jeśli ustawisz <xref:System.Messaging.MessageQueue.QueueName%2A> bez <xref:System.Messaging.MessageQueue.MachineName%2A> ustawienia właściwości, <xref:System.Messaging.MessageQueue.Path%2A> Właściwość zmieni się.\\ `QueueName`. W przeciwnym `MachineName`razie <xref:System.Messaging.MessageQueue.Path%2A> zmieni się \\ .`QueueName`  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Tak|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa kolejki to <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera natywny uchwyt używany do odczytywania wiadomości z kolejki komunikatów.</summary>
        <value>Uchwyt do natywnego obiektu kolejki, który służy do wglądu i otrzymywania komunikatów z kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A> Zapewnia natywne dojście systemu Windows do obiektu kolejki komunikatów, który służy do wglądu i otrzymywania komunikatów z kolejki. Jeśli zmienisz ścieżkę kolejki, uchwyt zostanie zamknięty i ponownie otwarty z nową wartością.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <summary>Odbiera pierwszą wiadomość w kolejce, usuwając ją z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odbiera pierwszą wiadomość dostępną w kolejce, do której odwołuje <see cref="T:System.Messaging.MessageQueue" />się. To wywołanie jest synchroniczne i blokuje bieżący wątek wykonywania, dopóki komunikat nie będzie dostępny.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia do odebrania komunikatu z kolejki lub zaczekaj, aż w kolejce znajdują się komunikaty.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania programu <xref:System.Messaging.MessageQueue.Receive%2A> zwracają komunikaty, które są zgodne z kolejką lub nowe komunikaty o wyższym priorytecie.  
  
 Aby odczytać pierwszy komunikat w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Ponieważ to Przeciążenie <xref:System.Messaging.MessageQueue.Receive%2A> metody Określa nieskończony limit czasu, aplikacja może czekać w nieskończoność. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na komunikat, rozważ użycie metody <xref:System.Messaging.MessageQueue.BeginReceive%2A>asynchronicznej.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera komunikat z kolejki i wyświetla informacje o tym komunikacie na ekranie.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt.</param>
        <summary>Odbiera pierwszą wiadomość dostępną w kolejce transakcyjnej, do której <see cref="T:System.Messaging.MessageQueue" />odwołuje się. To wywołanie jest synchroniczne i blokuje bieżący wątek wykonywania, dopóki komunikat nie będzie dostępny.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby odebrać komunikat z kolejki transakcyjnej przy użyciu wewnętrznego kontekstu transakcji zdefiniowanego przez `transaction` parametr, lub poczekaj, aż w kolejce znajdują się komunikaty.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróciją komunikaty, które są zgodne z kolejką.  
  
 Ponieważ ta metoda jest wywoływana w kolejce transakcyjnej, otrzymany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Aby odczytać pierwszy komunikat w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć operacji wycofywania przez <xref:System.Messaging.MessageQueueTransaction.Abort%2A>wywołanie.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Ponieważ to Przeciążenie <xref:System.Messaging.MessageQueue.Receive%2A> metody Określa nieskończony limit czasu, aplikacja może czekać w nieskończoność. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na komunikat, rozważ użycie metody <xref:System.Messaging.MessageQueue.BeginReceive%2A>asynchronicznej.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu łączy się z kolejką transakcyjną na komputerze lokalnym i wysyła komunikat do kolejki. Następnie zostanie wyświetlony komunikat zawierający zamówienie. W przypadku napotkania kolejki nietransakcyjnej spowoduje to zgłoszenie i wyjątek i wycofanie transakcji.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.  
  
 —lub—  
  
 Kolejka nie jest transakcyjna.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Odbiera pierwszą wiadomość dostępną w kolejce, do której odwołuje <see cref="T:System.Messaging.MessageQueue" />się. To wywołanie jest synchroniczne i blokuje bieżący wątek wykonywania, dopóki komunikat nie będzie dostępny.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby odebrać komunikat z kolejki przy użyciu kontekstu transakcji zdefiniowanego przez `transactionType` parametr, lub poczekaj, aż w kolejce znajdują się komunikaty.  
  
 `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` , czy chcesz otrzymywać komunikat jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz otrzymywać komunikat z kolejki transakcyjnej poza kontekstem transakcji.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróciją komunikaty, które są zgodne z kolejką.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjnej, odebrany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Aby odczytać pierwszy komunikat w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć operacji wycofywania przez <xref:System.Messaging.MessageQueueTransaction.Abort%2A>wywołanie.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Ponieważ to Przeciążenie <xref:System.Messaging.MessageQueue.Receive%2A> metody Określa nieskończony limit czasu, aplikacja może czekać w nieskończoność. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na komunikat, rozważ użycie metody <xref:System.Messaging.MessageQueue.BeginReceive%2A>asynchronicznej.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <summary>Odbiera pierwszą wiadomość dostępną w kolejce, do której odwołuje <see cref="T:System.Messaging.MessageQueue" /> się i czeka, aż do momentu udostępnienia komunikatu w kolejce lub upływu limitu czasu.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby odebrać komunikat i zwrócić w określonym czasie w przypadku braku komunikatów w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania programu <xref:System.Messaging.MessageQueue.Receive%2A> zwracają komunikaty, które są zgodne z kolejką lub nowe komunikaty o wyższym priorytecie.  
  
 Aby odczytać pierwszy komunikat w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Wątek zostanie zablokowany przez dany okres lub w nieskończoność, jeśli określono wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` parametru. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na komunikat, rozważ użycie metody <xref:System.Messaging.MessageQueue.BeginReceive%2A>asynchronicznej.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera komunikat z kolejki i wyświetla informacje o tym komunikacie na ekranie. Przykład wstrzymuje wykonywanie przez maksymalnie pięć sekund podczas oczekiwania na nadejście komunikatu w kolejce.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość nie dotarła do kolejki przed upływem limitu czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który utrzymuje określone położenie w kolejce komunikatów.</param>
        <summary>Odbiera bieżącą wiadomość w kolejce przy użyciu określonego kursora. Jeśli żaden komunikat nie jest dostępny, ta metoda czeka, aż wiadomość zostanie udostępniona lub limit czasu wygaśnie.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość nie dotarła do kolejki przed upływem limitu czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów  
  
 Użyj tego przeciążenia, aby odebrać komunikat i zwrócić w określonym czasie w przypadku braku komunikatów w kolejce.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt.</param>
        <summary>Odbiera pierwszą wiadomość dostępną w kolejce transakcyjnej, do której <see cref="T:System.Messaging.MessageQueue" /> odwołuje się i czeka, aż do momentu udostępnienia komunikatu w kolejce lub upływu limitu czasu.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby odebrać komunikat z kolejki transakcyjnej przy użyciu wewnętrznego kontekstu transakcji zdefiniowanego przez `transaction` parametr i wrócić w określonym przedziale czasu, jeśli w kolejce nie ma żadnych komunikatów.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróciją komunikaty, które są zgodne z kolejką.  
  
 Ponieważ ta metoda jest wywoływana w kolejce transakcyjnej, otrzymany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Aby odczytać pierwszy komunikat w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć operacji wycofywania przez <xref:System.Messaging.MessageQueueTransaction.Abort%2A>wywołanie.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Wątek zostanie zablokowany przez dany okres lub w nieskończoność, jeśli określono wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` parametru. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na komunikat, rozważ użycie metody <xref:System.Messaging.MessageQueue.BeginReceive%2A>asynchronicznej.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej metody.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość nie dotarła do kolejki przed upływem limitu czasu.  
  
 —lub—  
  
 Kolejka nie jest transakcyjna.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Odbiera pierwszą wiadomość dostępną w kolejce, do której odwołuje <see cref="T:System.Messaging.MessageQueue" />się. To wywołanie jest synchroniczne i czeka, aż do momentu udostępnienia komunikatu w kolejce lub przekroczenia limitu czasu.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby odebrać komunikat z kolejki przy użyciu kontekstu transakcji zdefiniowanego przez `transactionType` parametr i wrócić w określonym przedziale czasu, jeśli w kolejce nie ma żadnych komunikatów.  
  
 `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` , czy chcesz otrzymywać komunikat jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz otrzymywać komunikat z kolejki transakcyjnej poza kontekstem transakcji.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróciją komunikaty, które są zgodne z kolejką.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjnej, odebrany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Aby odczytać pierwszy komunikat w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć operacji wycofywania przez <xref:System.Messaging.MessageQueueTransaction.Abort%2A>wywołanie.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Wątek zostanie zablokowany przez dany okres lub w nieskończoność, jeśli określono wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` parametru. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na komunikat, rozważ użycie metody <xref:System.Messaging.MessageQueue.BeginReceive%2A>asynchronicznej.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej metody.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość nie dotarła do kolejki przed upływem limitu czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który utrzymuje określone położenie w kolejce komunikatów.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt.</param>
        <summary>Odbiera bieżącą wiadomość w kolejce przy użyciu określonego kursora. Jeśli żaden komunikat nie jest dostępny, ta metoda czeka, aż wiadomość zostanie udostępniona lub limit czasu wygaśnie.</summary>
        <returns>Obiekt <see cref="T:System.Messaging.Message" /> , który odwołuje się do komunikatu w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby odebrać komunikat z kolejki transakcyjnej przy użyciu wewnętrznego kontekstu transakcji zdefiniowanego przez `transaction` parametr i wrócić w określonym przedziale czasu, jeśli w kolejce nie ma żadnych komunikatów.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwracające komunikaty, które są zgodne z kolejką.  
  
 Ponieważ ta metoda jest wywoływana w kolejce transakcyjnej, otrzymany komunikat jest zwracany do kolejki, jeśli transakcja została przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Aby odczytać komunikat w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa żadnych komunikatów w kolejce, nie ma niczego do wycofania przez <xref:System.Messaging.MessageQueueTransaction.Abort%2A>wywołanie.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Wątek jest blokowany przez dany okres lub w nieskończoność, jeśli określono wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` parametru. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na komunikat, rozważ użycie metody <xref:System.Messaging.MessageQueue.BeginReceive%2A>asynchronicznej.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="cursor" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="transaction" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa. Prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza lub równa. <see cref="F:System.TimeSpan.Zero" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość nie dotarła do kolejki przed upływem limitu czasu.  
  
 —lub—  
  
 Kolejka nie jest transakcyjna.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który utrzymuje określone położenie w kolejce komunikatów.</param>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości, która opisuje typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Odbiera bieżącą wiadomość w kolejce przy użyciu określonego kursora. Jeśli żaden komunikat nie jest dostępny, ta metoda czeka, aż wiadomość zostanie udostępniona lub limit czasu wygaśnie.</summary>
        <returns>Obiekt <see cref="T:System.Messaging.Message" /> , który odwołuje się do komunikatu w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby odebrać komunikat z kolejki przy użyciu kontekstu transakcji zdefiniowanego przez `transactionType` parametr i wrócić w określonym przedziale czasu, jeśli w kolejce nie ma żadnych komunikatów.  
  
 `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` , czy chcesz otrzymywać komunikat jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz otrzymywać komunikat z kolejki transakcyjnej poza kontekstem transakcji.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwracające komunikaty, które są zgodne z kolejką.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjnej, otrzymany komunikat jest zwracany do kolejki, jeśli transakcja została przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Aby odczytać komunikat w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa żadnych komunikatów w kolejce, nie ma niczego do wycofania przez <xref:System.Messaging.MessageQueueTransaction.Abort%2A>wywołanie.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> , gdy jest akceptowalny do zablokowania bieżącego wątku podczas oczekiwania na nadejście komunikatu w kolejce. Wątek jest blokowany przez dany okres lub w nieskończoność, jeśli określono wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` parametru. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na komunikat, rozważ użycie metody <xref:System.Messaging.MessageQueue.BeginReceive%2A>asynchronicznej.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="cursor" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa. Prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza lub równa. <see cref="F:System.TimeSpan.Zero" /></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość nie dotarła do kolejki przed upływem limitu czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczna wątkowo.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera komunikat zgodny z danym identyfikatorem korelacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomość do odebrania.</param>
        <summary>Odbiera komunikat, który pasuje do podanego identyfikatora korelacji (z kolejki nietransakcyjnej) i natychmiast wywołuje wyjątek, jeśli w kolejce nie istnieje żaden komunikat o określonym identyfikatorze korelacji.</summary>
        <returns>Który jest <see cref="T:System.Messaging.Message" /> zgodnyz<paramref name="correlationId" />przekazaniemparametru <see cref="P:System.Messaging.Message.CorrelationId" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda <xref:System.Messaging.MessageQueue> umożliwia przeszukanie kolejki nietransakcyjnej, do której odwołuje się <xref:System.Messaging.Message.CorrelationId%2A> dla komunikatu odpowiadającego określonemu `correlationId` parametrowi. Jeśli nie zostanie znaleziony żaden komunikat zgodny z `correlationID` parametrem, zostanie zgłoszony wyjątek. W przeciwnym razie wiadomość zostanie usunięta z kolejki i zwrócona do aplikacji.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość służy do powiązania wiadomości wysyłanej do kolejki z odpowiedzią, raportem lub komunikatem potwierdzającym.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> a Metoda pobiera komunikat przez określenie jego unikatowego identyfikatora. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat z określonym identyfikatorem korelacji bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera komunikat zawierający zamówienie do i z kolejki. Zażąda pozytywnego potwierdzenia, gdy oryginalny komunikat osiągnie lub zostanie pobrany z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="correlationId" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="correlationId" /> określoną opcją.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomość do odebrania.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt.</param>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora korelacji (z kolejki transakcyjnej) i natychmiast wywołuje wyjątek, jeśli w kolejce nie istnieje żaden komunikat o określonym identyfikatorze korelacji.</summary>
        <returns>Który jest <see cref="T:System.Messaging.Message" /> zgodnyz<paramref name="correlationId" />przekazaniemparametru <see cref="P:System.Messaging.Message.CorrelationId" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje kolejkę transakcyjną, do <xref:System.Messaging.MessageQueue> której odwołuje się <xref:System.Messaging.Message.CorrelationId%2A> komunikat, którego `correlationId` dopasowanie jest zgodne z określonym parametrem. Jeśli nie zostanie znaleziony żaden komunikat zgodny z `correlationID` parametrem, zostanie zgłoszony wyjątek. W przeciwnym razie wiadomość zostanie usunięta z kolejki i zwrócona do aplikacji przy użyciu wewnętrznego kontekstu transakcji zdefiniowanego przez `transaction` parametr.  
  
 Ponieważ ta metoda jest wywoływana w kolejce transakcyjnej, otrzymany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość służy do powiązania wiadomości wysyłanej do kolejki z odpowiedzią, raportem lub komunikatem potwierdzającym.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> a metoda jest używana do pobierania komunikatu przez określenie jego unikatowego identyfikatora. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat z określonym identyfikatorem korelacji bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć wycofywania, jeśli transakcja została przerwana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="correlationId" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="transaction" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="correlationId" /> określoną opcją.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka nie jest transakcyjna.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomość do odebrania.</param>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora korelacji i natychmiast wywołuje wyjątek, jeśli w kolejce nie istnieje komunikat o określonym identyfikatorze korelacji.</summary>
        <returns>Który jest <see cref="T:System.Messaging.Message" /> zgodnyz<paramref name="correlationId" />przekazaniemparametru <see cref="P:System.Messaging.Message.CorrelationId" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje kolejkę, do której <xref:System.Messaging.MessageQueue> odwołuje się komunikat <xref:System.Messaging.Message.CorrelationId%2A> , którego dopasowanie `correlationId` jest zgodne z określonym parametrem. Jeśli nie zostanie znaleziony żaden komunikat zgodny z `correlationID` parametrem, zostanie zgłoszony wyjątek. W przeciwnym razie wiadomość zostanie usunięta z kolejki i zwrócona do aplikacji przy użyciu kontekstu transakcji zdefiniowanego przez `transactionType` parametr.  
  
 `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` , czy chcesz otrzymywać komunikat jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz otrzymywać komunikat z kolejki transakcyjnej poza kontekstem transakcji.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjnej, odebrany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość służy do powiązania wiadomości wysyłanej do kolejki z odpowiedzią, raportem lub komunikatem potwierdzającym.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> a metoda jest używana do pobierania komunikatu przez określenie jego unikatowego identyfikatora. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat z określonym identyfikatorem korelacji bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć wycofywania, jeśli transakcja została przerwana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="correlationId" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="correlationId" /> określoną opcją.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomość do odebrania.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora korelacji (z kolejki nietransakcyjnej) i czeka, aż komunikat o określonym identyfikatorze korelacji jest dostępny w kolejce lub limit czasu wygaśnie.</summary>
        <returns>Który jest <see cref="T:System.Messaging.Message" /> zgodnyz<paramref name="correlationId" />przekazaniemparametru <see cref="P:System.Messaging.Message.CorrelationId" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda <xref:System.Messaging.MessageQueue> umożliwia przeszukanie kolejki nietransakcyjnej, do której odwołuje się <xref:System.Messaging.Message.CorrelationId%2A> dla komunikatu odpowiadającego określonemu `correlationId` parametrowi. Ta metoda wraca natychmiast, jeśli komunikat z identyfikatorem korelacji określonym przez `correlationId` parametr znajduje się w kolejce. W przeciwnym razie metoda czeka, aż otrzyma nowy komunikat. Jeśli nowa wiadomość nie zostanie odebrana przed upływem limitu czasu, zostanie zgłoszony wyjątek.  
  
 `timeout` Parametr nie określa łącznego czasu działania dla tej metody. Zamiast tego określa czas oczekiwania na nadejście nowej wiadomości w kolejce. Za każdym razem, gdy pojawi się nowy komunikat, ta metoda analizuje <xref:System.Messaging.Message.CorrelationId%2A> nową wiadomość, aby zobaczyć, czy jest zgodna z `correlationId` parametrem. W przeciwnym razie ta metoda zaczyna przekroczyć limit czasu i czeka na nadejście kolejnej nowej wiadomości. W związku z tym, jeśli nowe komunikaty nadal docierają do limitu czasu, możliwe jest, aby ta metoda kontynuowała działanie na czas nieokreślony, aż do upływu limitu czasu, w którym nie będą wysyłane żadne nowe komunikaty lub do momentu odebrania <xref:System.Messaging.Message.CorrelationId%2A> komunikatu dopasowuje `correlationId` parametr.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość służy do powiązania wiadomości wysyłanej do kolejki z odpowiedzią, raportem lub komunikatem potwierdzającym.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> a metoda jest używana do pobierania komunikatu przez określenie jego unikatowego identyfikatora. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat z określonym identyfikatorem korelacji bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="correlationId" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="correlationId" /> elementem nie istnieje w kolejce i nie dotarł przed upływem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomość do odebrania.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt.</param>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora korelacji (z kolejki transakcyjnej) i czeka, aż komunikat o określonym identyfikatorze korelacji jest dostępny w kolejce lub limit czasu wygaśnie.</summary>
        <returns>Który jest <see cref="T:System.Messaging.Message" /> zgodnyz<paramref name="correlationId" />przekazaniemparametru <see cref="P:System.Messaging.Message.CorrelationId" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje kolejkę transakcyjną, do <xref:System.Messaging.MessageQueue> której odwołuje się <xref:System.Messaging.Message.CorrelationId%2A> komunikat, którego `correlationId` dopasowanie jest zgodne z określonym parametrem. Ta metoda wraca natychmiast, jeśli komunikat z identyfikatorem korelacji określonym przez `correlationId` parametr znajduje się w kolejce, przy użyciu wewnętrznego kontekstu transakcji zdefiniowanego `transaction` przez parametr. W przeciwnym razie metoda czeka, aż otrzyma nowy komunikat. Jeśli nowa wiadomość nie zostanie odebrana przed upływem limitu czasu, zostanie zgłoszony wyjątek.  
  
 `timeout` Parametr nie określa łącznego czasu działania dla tej metody. Zamiast tego określa czas oczekiwania na nadejście nowej wiadomości w kolejce. Za każdym razem, gdy pojawi się nowy komunikat, ta metoda analizuje <xref:System.Messaging.Message.CorrelationId%2A> nową wiadomość, aby zobaczyć, czy jest zgodna z `correlationId` parametrem. W przeciwnym razie ta metoda zaczyna przekroczyć limit czasu i czeka na nadejście kolejnej nowej wiadomości. W związku z tym, jeśli nowe komunikaty nadal docierają do limitu czasu, możliwe jest, aby ta metoda kontynuowała działanie na czas nieokreślony, aż do upływu limitu czasu, w którym nie będą wysyłane żadne nowe komunikaty lub do momentu odebrania <xref:System.Messaging.Message.CorrelationId%2A> komunikatu dopasowuje `correlationId` parametr.  
  
 Ponieważ ta metoda jest wywoływana w kolejce transakcyjnej, otrzymany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość służy do powiązania wiadomości wysyłanej do kolejki z odpowiedzią, raportem lub komunikatem potwierdzającym.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> a metoda jest używana do pobierania komunikatu przez określenie jego unikatowego identyfikatora. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat z określonym identyfikatorem korelacji bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć wycofywania, jeśli transakcja została przerwana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="correlationId" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="transaction" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="correlationId" /> elementem nie istnieje w kolejce i nie dotarł przed upływem limitu czasu.  
  
—lub— 
Kolejka nie jest transakcyjna.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId"><see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomość do odebrania.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora korelacji i czeka, aż komunikat o określonym identyfikatorze korelacji jest dostępny w kolejce lub limit czasu wygaśnie.</summary>
        <returns>Który jest <see cref="T:System.Messaging.Message" /> zgodnyz<paramref name="correlationId" />przekazaniemparametru <see cref="P:System.Messaging.Message.CorrelationId" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje kolejkę, do której <xref:System.Messaging.MessageQueue> odwołuje się komunikat <xref:System.Messaging.Message.CorrelationId%2A> , którego dopasowanie `correlationId` jest zgodne z określonym parametrem. Ta metoda wraca natychmiast, jeśli komunikat z identyfikatorem korelacji określonym przez `correlationId` parametr znajduje się w kolejce, przy użyciu kontekstu transakcji zdefiniowanego `transactionType` przez parametr. W przeciwnym razie metoda czeka, aż otrzyma nowy komunikat. Jeśli nowa wiadomość nie zostanie odebrana przed upływem limitu czasu, zostanie zgłoszony wyjątek.  
  
 `timeout` Parametr nie określa łącznego czasu działania dla tej metody. Zamiast tego określa czas oczekiwania na nadejście nowej wiadomości w kolejce. Za każdym razem, gdy pojawi się nowy komunikat, ta metoda analizuje <xref:System.Messaging.Message.CorrelationId%2A> nową wiadomość, aby zobaczyć, czy jest zgodna z `correlationId` parametrem. W przeciwnym razie ta metoda zaczyna przekroczyć limit czasu i czeka na nadejście kolejnej nowej wiadomości. W związku z tym, jeśli nowe komunikaty nadal docierają do limitu czasu, możliwe jest, aby ta metoda kontynuowała działanie na czas nieokreślony, aż do upływu limitu czasu, w którym nie będą wysyłane żadne nowe komunikaty lub do momentu odebrania <xref:System.Messaging.Message.CorrelationId%2A> komunikatu dopasowuje `correlationId` parametr. `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` , czy chcesz otrzymywać komunikat jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz otrzymywać komunikat z kolejki transakcyjnej poza kontekstem transakcji.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjnej, odebrany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość służy do powiązania wiadomości wysyłanej do kolejki z odpowiedzią, raportem lub komunikatem potwierdzającym.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> a metoda jest używana do pobierania komunikatu przez określenie jego unikatowego identyfikatora. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat z określonym identyfikatorem korelacji bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć wycofywania, jeśli transakcja została przerwana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="correlationId" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="correlationId" /> określoną opcją.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="correlationId" /> elementem nie istnieje w kolejce i nie dotarł przed upływem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora, usuwając go z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" /> Wiadomość do odebrania.</param>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora z kolejki nietransakcyjnej i natychmiast wywołuje wyjątek, jeśli żaden komunikat o określonym identyfikatorze nie istnieje w kolejce.</summary>
        <returns>Właściwość, która jest <see cref="T:System.Messaging.Message" /> zgodna <paramref name="id" /> z przekazaną parametrem. <see cref="P:System.Messaging.Message.Id" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat z znanym identyfikatorem i usunąć go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli wiadomość nie znajduje się w kolejce.  
  
 Właściwość komunikatu jest unikatowa w całym przedsiębiorstwie usługi kolejkowania komunikatów, więc w kolejce będzie co najwyżej jeden komunikat zgodny z podanym `id` parametrem. <xref:System.Messaging.Message.Id%2A>  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> a metoda jest używana do pobierania potwierdzenia, raportu lub komunikatu odpowiedzi generowanego przez aplikację, który został utworzony w wyniku wysłania wiadomości do kolejki. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat o określonym identyfikatorze bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="id" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="id" /> określoną opcją.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" /> Wiadomość do odebrania.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt.</param>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora (z kolejki transakcyjnej) i natychmiast wywołuje wyjątek, jeśli żaden komunikat o określonym identyfikatorze nie istnieje w kolejce.</summary>
        <returns>Właściwość, która jest <see cref="T:System.Messaging.Message" /> zgodna <paramref name="id" /> z przekazaną parametrem. <see cref="P:System.Messaging.Message.Id" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat z znanym identyfikatorem i usunąć go z kolejki przy użyciu wewnętrznego kontekstu transakcji zdefiniowanego przez `transaction` parametr. Ta metoda zgłasza wyjątek natychmiast, jeśli wiadomość nie znajduje się w kolejce  
  
 Właściwość komunikatu jest unikatowa w całym przedsiębiorstwie usługi kolejkowania komunikatów, więc w kolejce będzie co najwyżej jeden komunikat zgodny z podanym `id` parametrem. <xref:System.Messaging.Message.Id%2A>  
  
 Ponieważ ta metoda jest wywoływana w kolejce transakcyjnej, otrzymany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> a metoda jest używana do pobierania potwierdzenia, raportu lub komunikatu odpowiedzi generowanego przez aplikację, który został utworzony w wyniku wysłania wiadomości do kolejki. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat o określonym identyfikatorze bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć wycofywania, jeśli transakcja została przerwana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="id" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="transaction" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="id" /> określoną opcją.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka nie jest transakcyjna.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" /> Wiadomość do odebrania.</param>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Odbiera komunikat, który pasuje do podanego identyfikatora, i natychmiast wywołuje wyjątek, jeśli żaden komunikat o określonym identyfikatorze nie istnieje w kolejce.</summary>
        <returns>Właściwość, która jest <see cref="T:System.Messaging.Message" /> zgodna <paramref name="id" /> z przekazaną parametrem. <see cref="P:System.Messaging.Message.Id" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat z znanym identyfikatorem i usunąć go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli wiadomość nie znajduje się w kolejce. W przeciwnym razie wiadomość zostanie usunięta z kolejki i zwrócona do aplikacji przy użyciu kontekstu transakcji zdefiniowanego przez `transactionType` parametr.  
  
 `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` , czy chcesz otrzymywać komunikat jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz otrzymywać komunikat z kolejki transakcyjnej poza kontekstem transakcji.  
  
 Właściwość komunikatu jest unikatowa w całym przedsiębiorstwie usługi kolejkowania komunikatów, więc w kolejce będzie co najwyżej jeden komunikat zgodny z podanym `id` parametrem. <xref:System.Messaging.Message.Id%2A> Jeśli komunikat o określonym identyfikatorze znajduje się w kolejce innej niż skojarzona z tym <xref:System.Messaging.MessageQueue> wystąpieniem, komunikat nie zostanie znaleziony.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjnej, odebrany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> a metoda jest używana do pobierania potwierdzenia, raportu lub komunikatu odpowiedzi generowanego przez aplikację, który został utworzony w wyniku wysłania wiadomości do kolejki. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat o określonym identyfikatorze bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć wycofywania, jeśli transakcja została przerwana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="id" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="id" /> określoną opcją.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" /> Wiadomość do odebrania.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora (z kolejki nietransakcyjnej) i czeka, aż komunikat o określonym identyfikatorze jest dostępny w kolejce lub upłynie limit czasu.</summary>
        <returns>Właściwość, która jest <see cref="T:System.Messaging.Message" /> zgodna <paramref name="id" /> z przekazaną parametrem. <see cref="P:System.Messaging.Message.Id" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat z znanym identyfikatorem i usunąć go z kolejki. Ta metoda wraca natychmiast, jeśli komunikat z identyfikatorem określonym przez `id` parametr znajduje się w kolejce. W przeciwnym razie metoda czeka, aż otrzyma nowy komunikat. Jeśli nowa wiadomość nie zostanie odebrana przed upływem limitu czasu, zostanie zgłoszony wyjątek.  
  
 `timeout` Parametr nie określa łącznego czasu działania dla tej metody. Zamiast tego określa czas oczekiwania na nadejście nowej wiadomości w kolejce. Za każdym razem, gdy pojawi się nowy komunikat, ta metoda analizuje <xref:System.Messaging.Message.Id%2A> nową wiadomość, aby zobaczyć, czy jest zgodna z `id` parametrem. W przeciwnym razie ta metoda zaczyna przekroczyć limit czasu i czeka na nadejście kolejnej nowej wiadomości. W związku z tym, jeśli nowe komunikaty nadal docierają do limitu czasu, możliwe jest, aby ta metoda kontynuowała działanie na czas nieokreślony, aż do upływu limitu czasu, w którym nie będą wysyłane żadne nowe komunikaty lub do momentu odebrania <xref:System.Messaging.Message.Id%2A> komunikatu dopasowuje `id` parametr.  
  
 Właściwość komunikatu jest unikatowa w całym przedsiębiorstwie usługi kolejkowania komunikatów, więc w kolejce będzie co najwyżej jeden komunikat zgodny z podanym `id` parametrem. <xref:System.Messaging.Message.Id%2A>  
  
 Użyj tego przeciążenia <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> , gdy jest akceptowalne, gdy bieżący wątek ma być zablokowany, tak długo, jak nowe komunikaty nadal docierają do kolejki w czasie określonym `timeout` przez parametr. Wątek zostanie zablokowany przez co najmniej określony czas lub w nieskończoność, jeśli określono wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` parametru lub jeśli nowe komunikaty będą nadal docierać do kolejki w określonym limicie czasu określony przez `timeout` konstruktora.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> a metoda jest używana do pobierania potwierdzenia, raportu lub komunikatu odpowiedzi generowanego przez aplikację, który został utworzony w wyniku wysłania wiadomości do kolejki. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat o określonym identyfikatorze bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="id" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="id" /> elementem nie dotarł do kolejki przed upływem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" /> Wiadomość do odebrania.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt.</param>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora (z kolejki transakcyjnej) i czeka, aż komunikat o określonym identyfikatorze jest dostępny w kolejce lub upłynie limit czasu.</summary>
        <returns>Właściwość, która jest <see cref="T:System.Messaging.Message" /> zgodna <paramref name="id" /> z przekazaną parametrem. <see cref="P:System.Messaging.Message.Id" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat z znanym identyfikatorem i usunąć go z kolejki przy użyciu wewnętrznego kontekstu transakcji zdefiniowanego przez `transaction` parametr. Ta metoda wraca natychmiast, jeśli komunikat z identyfikatorem określonym przez `id` parametr znajduje się w kolejce. W przeciwnym razie metoda czeka, aż otrzyma nowy komunikat. Jeśli nowa wiadomość nie zostanie odebrana przed upływem limitu czasu, zostanie zgłoszony wyjątek.  
  
 `timeout` Parametr nie określa łącznego czasu działania dla tej metody. Zamiast tego określa czas oczekiwania na nadejście nowej wiadomości w kolejce. Za każdym razem, gdy pojawi się nowy komunikat, ta metoda analizuje <xref:System.Messaging.Message.Id%2A> nową wiadomość, aby zobaczyć, czy jest zgodna z `id` parametrem. W przeciwnym razie ta metoda zaczyna przekroczyć limit czasu i czeka na nadejście kolejnej nowej wiadomości. W związku z tym, jeśli nowe komunikaty nadal docierają do limitu czasu, możliwe jest, aby ta metoda kontynuowała działanie na czas nieokreślony, aż do upływu limitu czasu, w którym nie będą wysyłane żadne nowe komunikaty lub do momentu odebrania <xref:System.Messaging.Message.Id%2A> komunikatu dopasowuje `id` parametr.  
  
 Właściwość komunikatu jest unikatowa w całym przedsiębiorstwie usługi kolejkowania komunikatów, więc w kolejce będzie co najwyżej jeden komunikat zgodny z podanym `id` parametrem. <xref:System.Messaging.Message.Id%2A>  
  
 Użyj tego przeciążenia <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> , gdy jest akceptowalne, gdy bieżący wątek ma być zablokowany, tak długo, jak nowe komunikaty nadal docierają do kolejki w czasie określonym `timeout` przez parametr. Wątek zostanie zablokowany przez co najmniej określony czas lub w nieskończoność, jeśli określono wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` parametru lub jeśli nowe komunikaty będą nadal docierać do kolejki w ramach `timeout` limitu czasu określonego przez konstruktora.  
  
 Ponieważ ta metoda jest wywoływana w kolejce transakcyjnej, otrzymany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> a metoda jest używana do pobierania potwierdzenia, raportu lub komunikatu odpowiedzi generowanego przez aplikację, który został utworzony w wyniku wysłania wiadomości do kolejki. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat o określonym identyfikatorze bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć wycofywania, jeśli transakcja została przerwana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="id" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="transaction" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="id" /> elementem nie dotarł do kolejki przed upływem limitu czasu.  
  
—lub— 
Kolejka nie jest transakcyjna.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.Messaging.Message.Id" /> Wiadomość do odebrania.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Wskazuje czas oczekiwania na udostępnienie nowej wiadomości do inspekcji.</param>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Odbiera komunikat pasujący do podanego identyfikatora i czeka, aż komunikat o określonym identyfikatorze jest dostępny w kolejce lub limit czasu wygaśnie.</summary>
        <returns>Właściwość, która jest <see cref="T:System.Messaging.Message" /> zgodna <paramref name="id" /> z przekazaną parametrem. <see cref="P:System.Messaging.Message.Id" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat z znanym identyfikatorem i usunąć go z kolejki. Ta metoda zwraca natychmiast, jeśli komunikat o identyfikatorze określonym przez `id` parametr znajduje się w kolejce, przy użyciu kontekstu transakcji zdefiniowanego `transactionType` przez parametr. W przeciwnym razie metoda czeka, aż otrzyma nowy komunikat. Jeśli nowa wiadomość nie zostanie odebrana przed upływem limitu czasu, zostanie zgłoszony wyjątek.  
  
 `timeout` Parametr nie określa łącznego czasu działania dla tej metody. Zamiast tego określa czas oczekiwania na nadejście nowej wiadomości w kolejce. Za każdym razem, gdy pojawi się nowy komunikat, ta metoda analizuje <xref:System.Messaging.Message.Id%2A> nową wiadomość, aby zobaczyć, czy jest zgodna z `id` parametrem. W przeciwnym razie ta metoda zaczyna przekroczyć limit czasu i czeka na nadejście kolejnej nowej wiadomości. W związku z tym, jeśli nowe komunikaty nadal docierają do limitu czasu, możliwe jest, aby ta metoda kontynuowała działanie na czas nieokreślony, aż do upływu limitu czasu, w którym nie będą wysyłane żadne nowe komunikaty lub do momentu odebrania <xref:System.Messaging.Message.Id%2A> komunikatu dopasowuje `id` parametr.  
  
 `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` , czy chcesz otrzymywać komunikat jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz otrzymywać komunikat z kolejki transakcyjnej poza kontekstem transakcji.  
  
 Właściwość komunikatu jest unikatowa w całym przedsiębiorstwie usługi kolejkowania komunikatów, więc w kolejce będzie co najwyżej jeden komunikat zgodny z podanym `id` parametrem. <xref:System.Messaging.Message.Id%2A> Jeśli komunikat o określonym identyfikatorze znajduje się w kolejce innej niż skojarzona z tym <xref:System.Messaging.MessageQueue> wystąpieniem, komunikat nie zostanie znaleziony.  
  
 Użyj tego przeciążenia <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> , gdy jest akceptowalne, gdy bieżący wątek ma być zablokowany, tak długo, jak nowe komunikaty nadal docierają do kolejki w czasie określonym `timeout` przez parametr. Wątek zostanie zablokowany przez co najmniej określony czas lub w nieskończoność, jeśli określono wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> `timeout` parametru lub jeśli nowe komunikaty będą nadal docierać do kolejki w określonym limicie czasu określony przez `timeout` konstruktora.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjnej, odebrany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. Metoda zwraca pierwszy komunikat w kolejce, <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> a metoda jest używana do pobierania potwierdzenia, raportu lub komunikatu odpowiedzi generowanego przez aplikację, który został utworzony w wyniku wysłania wiadomości do kolejki. <xref:System.Messaging.MessageQueue.Receive%2A>  
  
 Aby odczytać komunikat o określonym identyfikatorze bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, więc kolejne wywołania metody zwracają ten sam komunikat, chyba że w kolejce zostanie wyświetlony komunikat o wyższym priorytecie. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> program nie usuwa żadnych komunikatów w kolejce, nie będzie można cofnąć wycofywania, jeśli transakcja została przerwana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="id" /></exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa, prawdopodobnie <paramref name="timeout" /> jest <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />mniejsza <see cref="F:System.TimeSpan.Zero" /> lub równa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="id" /> elementem nie dotarł do kolejki przed upływem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wprowadzone w usłudze MSMQ 3,0. Odbiera określoną wiadomość z kolejki. Komunikat może być określony przez identyfikator wyszukiwania lub przez jego pozycję na wierzchu lub na końcu kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId"><see cref="P:System.Messaging.Message.LookupId" /> Wiadomość do odebrania.</param>
        <summary>Wprowadzone w usłudze MSMQ 3,0. Odbiera komunikat pasujący do podanego identyfikatora wyszukiwania z kolejki nietransakcyjnej.</summary>
        <returns>Właściwość, która jest <see cref="T:System.Messaging.Message" /> zgodna <paramref name="lookupId" /> z przekazaną parametrem. <see cref="P:System.Messaging.Message.LookupId" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat z znanym identyfikatorem wyszukiwania i usunąć go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli wiadomość nie znajduje się w kolejce.  
  
 Właściwość komunikatu jest unikatowa dla kolejki, w której znajduje się komunikat, więc w kolejce będzie znajdować się co najwyżej jeden komunikat zgodny z podanym `lookupId` parametrem. <xref:System.Messaging.Message.LookupId%2A>  
  
 Aby odczytać komunikat z określonym identyfikatorem wyszukiwania bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nie zainstalowano usługi MSMQ 3,0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="lookupId" /> określoną opcją.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Jedna z <see cref="T:System.Messaging.MessageLookupAction" /> wartości, określająca sposób odczytu wiadomości w kolejce. Określ jedną z następujących wartości: 
 <see langword="MessageLookupAction.Current" />: Odbiera komunikat określony przez <paramref name="lookupId" /> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Next" />: Odbiera komunikat następujący po komunikacie określonym przez <paramref name="lookupId" /> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Previous" />: Odbiera komunikat poprzedzający komunikat określony przez <paramref name="lookupId" /> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.First" />: Odbiera pierwszą wiadomość w kolejce i usuwa ją z kolejki. <paramref name="lookupId" /> Parametr musi mieć wartość 0.  
  
 <see langword="MessageLookupAction.Last" />: Odbiera ostatni komunikat w kolejce i usuwa go z kolejki. <paramref name="lookupId" /> Parametr musi mieć wartość 0.</param>
        <param name="lookupId"><see cref="P:System.Messaging.Message.LookupId" /> Wiadomość do odebrania lub 0. wartość 0 jest używana podczas uzyskiwania dostępu do pierwszego lub ostatniego komunikatu w kolejce.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt.</param>
        <summary>Wprowadzone w usłudze MSMQ 3,0. Odbiera określoną wiadomość z kolejki transakcyjnej. Komunikat może być określony przez identyfikator wyszukiwania lub przez jego pozycję na wierzchu lub na końcu kolejki.</summary>
        <returns>Określone przez parametry<paramref name="action" /> i <paramref name="lookupId" />. <see cref="T:System.Messaging.Message" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat o znanym identyfikatorze wyszukiwania i usunąć go z kolejki przy użyciu kontekstu transakcji zdefiniowanego przez `transaction` parametr. Ta metoda zgłasza wyjątek natychmiast, jeśli wiadomość nie znajduje się w kolejce.  
  
 Właściwość komunikatu jest unikatowa dla kolejki, w której znajduje się komunikat, więc w kolejce będzie znajdować się co najwyżej jeden komunikat zgodny z podanym `lookupId` parametrem. <xref:System.Messaging.Message.LookupId%2A>  
  
 Ponieważ ta metoda jest wywoływana w kolejce transakcyjnej, otrzymany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 Aby odczytać komunikat o określonym identyfikatorze bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metody. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> program nie usuwa żadnych komunikatów z kolejki, nie będzie można cofnąć wycofania, jeśli transakcja została przerwana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nie zainstalowano usługi MSMQ 3,0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="lookupId" /> określoną opcją.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.  
  
 —lub—  
  
 Kolejka nie jest transakcyjna.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageLookupAction" /> z elementów członkowskich. <paramref name="action" /></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Jedna z <see cref="T:System.Messaging.MessageLookupAction" /> wartości, określająca sposób odczytu wiadomości w kolejce. Określ jedną z następujących wartości: 
 <see langword="MessageLookupAction.Current" />: Odbiera komunikat określony przez <paramref name="lookupId" /> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Next" />: Odbiera komunikat następujący po komunikacie określonym przez <paramref name="lookupId" /> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Previous" />: Odbiera komunikat poprzedzający komunikat określony przez <paramref name="lookupId" /> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.First" />: Odbiera pierwszą wiadomość w kolejce i usuwa ją z kolejki. <paramref name="lookupId" /> Parametr musi mieć wartość 0.  
  
 <see langword="MessageLookupAction.Last" />: Odbiera ostatni komunikat w kolejce i usuwa go z kolejki. <paramref name="lookupId" /> Parametr musi mieć wartość 0.</param>
        <param name="lookupId"><see cref="P:System.Messaging.Message.LookupId" /> Wiadomość do odebrania lub 0. wartość 0 jest używana podczas uzyskiwania dostępu do pierwszego lub ostatniego komunikatu w kolejce.</param>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Wprowadzone w usłudze MSMQ 3,0. Odbiera określoną wiadomość z kolejki przy użyciu określonego kontekstu transakcji. Komunikat może być określony przez identyfikator wyszukiwania lub przez jego pozycję na wierzchu lub na końcu kolejki.</summary>
        <returns>Określone przez parametry<paramref name="lookupId" /> i <paramref name="action" />. <see cref="T:System.Messaging.Message" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby odczytać komunikat o znanym identyfikatorze wyszukiwania i usunąć go z kolejki przy użyciu kontekstu transakcji zdefiniowanego przez `transactionType` parametr. Ta metoda zgłasza wyjątek natychmiast, jeśli wiadomość nie znajduje się w kolejce.  
  
 Właściwość komunikatu jest unikatowa dla kolejki, w której znajduje się komunikat, więc w kolejce będzie znajdować się co najwyżej jeden komunikat zgodny z podanym `lookupId` parametrem. <xref:System.Messaging.Message.LookupId%2A>  
  
 Aby odczytać komunikat o określonym identyfikatorze bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metody. Brak kontekstu transakcji skojarzonego z komunikatem zwracanym przez wywołanie <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> program nie usuwa żadnych komunikatów z kolejki, nie będzie można cofnąć wycofania, jeśli transakcja została przerwana.  
  
 `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` , czy chcesz otrzymywać komunikat jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz otrzymywać komunikat z kolejki transakcyjnej poza kontekstem transakcji.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjnej, odebrany komunikat zostałby zwrócony do kolejki, jeśli transakcja zostanie przerwana. Wiadomość nie zostanie trwale usunięta z kolejki, dopóki transakcja nie zostanie zatwierdzona.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nie zainstalowano usługi MSMQ 3,0.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć komunikatu z <paramref name="lookupId" /> określoną opcją.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageLookupAction" /> z elementów członkowskich. <paramref name="action" />  
  
—lub— 
Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wiadomość została usunięta z kolejki. To zdarzenie jest wywoływane przez operację <see cref="M:System.Messaging.MessageQueue.BeginReceive" />asynchroniczną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>jest używany w przetwarzaniu asynchronicznym w <xref:System.Messaging.MessageQueue.ReceiveCompleted> celu podniesienia zdarzenia, gdy komunikat jest dostępny w kolejce.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>służy do ukończenia operacji zainicjowanej przez wywołanie <xref:System.Messaging.MessageQueue.BeginReceive%2A> i wgląd w komunikat <xref:System.Messaging.MessageQueue.ReceiveCompleted> po wywołaniu zdarzenia.  
  
 Podczas tworzenia <xref:System.Messaging.ReceiveCompletedEventHandler> delegata należy określić metodę, która będzie obsługiwać zdarzenie. Aby skojarzyć zdarzenie z programem obsługi zdarzeń, Dodaj wystąpienie delegata do zdarzenia. Program obsługi zdarzeń jest wywoływany przy każdym wystąpieniu zdarzenia, o ile nie usunięto delegata. Aby uzyskać więcej informacji na temat delegatów obsługi zdarzeń, zobacz temat [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyReceiveCompleted`, dołącza go <xref:System.Messaging.MessageQueue.ReceiveCompleted> do delegata programu obsługi zdarzeń i wywołuje <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodę inicjowania asynchronicznej operacji odbierania w kolejce, która znajduje się w ścieżce ".\myQueue". <xref:System.Messaging.MessageQueue.ReceiveCompleted> Gdy zdarzenie jest zgłaszane, przykład otrzymuje komunikat i zapisuje jego treść na ekranie. Przykład następnie wywołuje <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w celu zainicjowania nowej asynchronicznej operacji odbierania.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odświeża właściwości przedstawione przez, <see cref="T:System.Messaging.MessageQueue" /> aby odzwierciedlić bieżący stan zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A>synchronizuje właściwości <xref:System.Messaging.MessageQueue> z skojarzonym z nim zasobem serwera usługi kolejkowania komunikatów. Jeśli jakakolwiek właściwość, taka jak <xref:System.Messaging.MessageQueue.Label%2A> lub <xref:System.Messaging.MessageQueue.Category%2A>, została zmieniona na <xref:System.Messaging.MessageQueue> serwerze od czasu utworzenia, program <xref:System.Messaging.MessageQueue.Refresh%2A> aktualizuje <xref:System.Messaging.MessageQueue> nowe informacje.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje listę uprawnień do wartości domyślnych systemu operacyjnego. Usuwa wszystkie uprawnienia do kolejki, które zostały dołączone do listy domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu <xref:System.Messaging.MessageQueue.ResetPermissions%2A>należy zwrócić listę uprawnień do jej wartości domyślnych. Ogólnie rzecz biorąc, powoduje to przyznanie twórcy kolejki wszystkich uprawnień i nadaje grupie wszystkie następujące prawa:  
  
-   Pobierz właściwości kolejki.  
  
-   Uzyskaj uprawnienia do kolejki.  
  
-   Zapisz do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła obiekt do kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysłania do kolejki.</param>
        <summary>Wysyła obiekt do kolejki nietransakcyjnej, do której odwołuje się ten <see cref="T:System.Messaging.MessageQueue" />element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby wysłać komunikat zawierający `obj` parametr do kolejki, do której odwołuje <xref:System.Messaging.MessageQueue>się. Obiekt wysyłany do kolejki może być <xref:System.Messaging.Message> obiektem lub dowolnymi obiektami zarządzanymi. W przypadku wysłania dowolnego obiektu innego niż <xref:System.Messaging.Message>a obiekt zostanie Zserializowany i wstawiony do treści komunikatu.  
  
 Jeśli używasz tego przeciążenia do wysyłania komunikatów do kolejki transakcyjnej, komunikat zostanie wysłany do kolejki utraconych wiadomości. Jeśli chcesz, aby komunikat był częścią transakcji zawierającej inne komunikaty, Użyj przeciążenia, które przyjmuje <xref:System.Messaging.MessageQueueTransaction> lub <xref:System.Messaging.MessageQueueTransactionType> jako parametr.  
  
 Jeśli <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość nie zostanie ustawiona przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, program formatujący domyślnie przyjmowana <xref:System.Messaging.XmlMessageFormatter>jest wartość.  
  
 Właściwość ma zastosowanie do każdego obiektu innego <xref:System.Messaging.Message>niż. <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Jeśli określisz, na przykład, etykieta lub priorytet przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> elementu członkowskiego, te wartości mają zastosowanie do każdego komunikatu zawierającego obiekt, który nie jest typem <xref:System.Messaging.Message> , gdy aplikacja wysyła je do kolejki. Podczas <xref:System.Messaging.Message>wysyłania, wartości właściwości ustawione <xref:System.Messaging.Message> dla <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości ma pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i Właściwość komunikatu mają pierwszeństwo przed <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwością kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu łączy się z kolejką komunikatów i wysyła komunikat do kolejki.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 Poniższy przykład kodu wysyła klasy zdefiniowanej `Order` przez aplikację do kolejki, a następnie odbiera komunikat z tej kolejki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysłania do kolejki.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt.</param>
        <summary>Wysyła do kolejki transakcyjnej, do której odwołuje <see cref="T:System.Messaging.MessageQueue" />się ten obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia `obj` <xref:System.Messaging.MessageQueue>, aby wysłać komunikat zawierający parametr do kolejki transakcyjnej, do której odwołuje się, przy użyciu wewnętrznego kontekstu `transaction` transakcji zdefiniowanego przez parametr. Obiekt wysyłany do kolejki może być <xref:System.Messaging.Message> obiektem lub dowolnymi obiektami zarządzanymi. W przypadku wysłania dowolnego obiektu innego niż <xref:System.Messaging.Message>a obiekt zostanie Zserializowany i wstawiony do treści komunikatu.  
  
 W przypadku użycia tego przeciążenia do wysłania wiadomości do kolejki nietransakcyjnej komunikat może zostać wysłany do kolejki utraconych wiadomości bez zgłaszania wyjątku.  
  
 Jeśli <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość nie zostanie ustawiona przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, program formatujący domyślnie przyjmowana <xref:System.Messaging.XmlMessageFormatter>jest wartość.  
  
 Właściwość ma zastosowanie do każdego obiektu innego <xref:System.Messaging.Message>niż. <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Jeśli określisz, na przykład, etykieta lub priorytet przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> elementu członkowskiego, te wartości mają zastosowanie do każdego komunikatu zawierającego obiekt, który nie jest typem <xref:System.Messaging.Message> , gdy aplikacja wysyła je do kolejki. Podczas <xref:System.Messaging.Message>wysyłania, wartości właściwości ustawione <xref:System.Messaging.Message> dla <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości ma pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i Właściwość komunikatu mają pierwszeństwo przed <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwością kolejki.  
  
 <xref:System.Messaging.MessageQueueTransaction>jest wątkem wątków, dlatego jeśli stanem apartamentu jest `STA`, nie można używać transakcji w wielu wątkach. Visual Basic ustawia stan wątku głównego na `STA`, dlatego należy <xref:System.MTAThreadAttribute> zastosować w `Main` procedurze podrzędnej. W przeciwnym razie wysyłanie wiadomości transakcyjnej przy użyciu innego wątku <xref:System.Messaging.MessageQueueException> zgłasza wyjątek. Należy zastosować, <xref:System.MTAThreadAttribute> korzystając z poniższego fragmentu.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła ciąg do kolejki transakcyjnej, a następnie odbiera komunikat z tej kolejki.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="transaction" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
—lub— 
Aplikacja usługi kolejkowania komunikatów wykazała nieprawidłowe użycie transakcji.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysłania do kolejki.</param>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Wysyła do kolejki, do której odwołuje się <see cref="T:System.Messaging.MessageQueue" />ten obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia `obj` <xref:System.Messaging.MessageQueue>, aby wysłać komunikat zawierający parametr do kolejki, do której odwołuje się obiekt, przy użyciu kontekstu `transactionType` transakcji zdefiniowanego przez parametr. `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, którego chcesz użyć do wysłania wiadomości. Określ `Single` , czy chcesz wysłać wiadomość jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz wysłać wiadomość transakcyjną do wątku nietransakcyjnego.  
  
 Obiekt wysyłany do kolejki może być <xref:System.Messaging.Message> obiektem lub dowolnymi obiektami zarządzanymi. W przypadku wysłania dowolnego obiektu innego niż <xref:System.Messaging.Message>a obiekt zostanie Zserializowany i wstawiony do treści komunikatu.  
  
 Jeśli <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość nie zostanie ustawiona przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, program formatujący domyślnie przyjmowana <xref:System.Messaging.XmlMessageFormatter>jest wartość.  
  
 Właściwość ma zastosowanie do każdego obiektu innego <xref:System.Messaging.Message>niż. <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Jeśli określisz, na przykład, etykieta lub priorytet przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> elementu członkowskiego, te wartości mają zastosowanie do każdego komunikatu zawierającego obiekt, który nie jest typem <xref:System.Messaging.Message> , gdy aplikacja wysyła je do kolejki. Podczas <xref:System.Messaging.Message>wysyłania, wartości właściwości ustawione <xref:System.Messaging.Message> dla <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości ma pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i Właściwość komunikatu mają pierwszeństwo przed <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwością kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysłania do kolejki.</param>
        <param name="label">Etykieta komunikatu.</param>
        <summary>Wysyła obiekt do kolejki nietransakcyjnej, do której odwołuje <see cref="T:System.Messaging.MessageQueue" /> się to i określa etykietę wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby wysłać komunikat zawierający `obj` parametr do kolejki, do której odwołuje <xref:System.Messaging.MessageQueue>się. Za pomocą tego przeciążenia można określić etykietę ciągu, która identyfikuje komunikat. Obiekt <xref:System.Messaging.Message>, który można wysłać do kolejki, może być obiektem struktury, obiektu danych lub dowolnego obiektu zarządzanego. W przypadku wysłania dowolnego obiektu innego niż <xref:System.Messaging.Message>a obiekt zostanie Zserializowany i wstawiony do treści komunikatu.  
  
 Etykieta wiadomości różni się od etykiety kolejki komunikatów, ale obie są zależne od aplikacji i nie dziedziczą znaczenia dla usługi kolejkowania komunikatów.  
  
 Jeśli używasz tego przeciążenia do wysyłania komunikatów do kolejki transakcyjnej, komunikat zostanie wysłany do kolejki utraconych wiadomości. Jeśli chcesz, aby komunikat był częścią transakcji zawierającej inne komunikaty, Użyj przeciążenia, które przyjmuje <xref:System.Messaging.MessageQueueTransaction> lub <xref:System.Messaging.MessageQueueTransactionType> jako parametr.  
  
 Przed wysłaniem wiadomości <xref:System.Messaging.MessageQueue> należy określić Właściwośćdlategowystąpienia.<xref:System.Messaging.MessageQueue.Path%2A> Jeśli <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość nie zostanie ustawiona przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, program formatujący domyślnie przyjmowana <xref:System.Messaging.XmlMessageFormatter>jest wartość.  
  
 Właściwość ma zastosowanie do każdego obiektu innego <xref:System.Messaging.Message>niż. <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Jeśli określisz, na przykład, etykieta lub priorytet przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> elementu członkowskiego, te wartości mają zastosowanie do każdego komunikatu zawierającego obiekt, który nie jest typem <xref:System.Messaging.Message> , gdy aplikacja wysyła je do kolejki. Podczas <xref:System.Messaging.Message>wysyłania, wartości właściwości ustawione <xref:System.Messaging.Message> dla <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości ma pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i Właściwość komunikatu mają pierwszeństwo przed <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwością kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="label" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysłania do kolejki.</param>
        <param name="label">Etykieta komunikatu.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt.</param>
        <summary>Wysyła do kolejki transakcyjnej, do której odwołuje <see cref="T:System.Messaging.MessageQueue" /> się ten obiekt, i określa etykietę wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia `obj` <xref:System.Messaging.MessageQueue>, aby wysłać komunikat zawierający parametr do kolejki transakcyjnej, do której odwołuje się, przy użyciu wewnętrznego kontekstu `transaction` transakcji zdefiniowanego przez parametr. Za pomocą tego przeciążenia można określić etykietę ciągu, która identyfikuje komunikat. Obiekt <xref:System.Messaging.Message>, który można wysłać do kolejki, może być obiektem struktury, obiektu danych lub dowolnego obiektu zarządzanego. W przypadku wysłania dowolnego obiektu innego niż <xref:System.Messaging.Message>a obiekt zostanie Zserializowany i wstawiony do treści komunikatu.  
  
 Etykieta wiadomości różni się od etykiety kolejki komunikatów, ale obie są zależne od aplikacji i nie dziedziczą znaczenia dla usługi kolejkowania komunikatów.  
  
 W przypadku użycia tego przeciążenia do wysłania wiadomości do kolejki nietransakcyjnej komunikat może zostać wysłany do kolejki utraconych wiadomości bez zgłaszania wyjątku.  
  
 Jeśli <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość nie zostanie ustawiona przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, program formatujący domyślnie przyjmowana <xref:System.Messaging.XmlMessageFormatter>jest wartość.  
  
 Właściwość ma zastosowanie do każdego obiektu innego <xref:System.Messaging.Message>niż. <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Jeśli określisz, na przykład, etykieta lub priorytet przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> elementu członkowskiego, te wartości mają zastosowanie do każdego komunikatu zawierającego obiekt, który nie jest typem <xref:System.Messaging.Message> , gdy aplikacja wysyła je do kolejki. Podczas <xref:System.Messaging.Message>wysyłania, wartości właściwości ustawione <xref:System.Messaging.Message> dla <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości ma pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i Właściwość komunikatu mają pierwszeństwo przed <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwością kolejki  
  
 <xref:System.Messaging.MessageQueueTransaction>jest wątkem wątków, dlatego jeśli stanem apartamentu jest `STA`, nie można używać transakcji w wielu wątkach. Visual Basic ustawia stan wątku głównego na `STA`, dlatego należy <xref:System.MTAThreadAttribute> zastosować w `Main` procedurze podrzędnej. W przeciwnym razie wysyłanie wiadomości transakcyjnej przy użyciu innego wątku <xref:System.Messaging.MessageQueueException> zgłasza wyjątek. Należy zastosować, <xref:System.MTAThreadAttribute> korzystając z poniższego fragmentu.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="label" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="transaction" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
—lub— 
Aplikacja usługi kolejkowania komunikatów wykazała nieprawidłowe użycie transakcji.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysłania do kolejki.</param>
        <param name="label">Etykieta komunikatu.</param>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Wysyła do kolejki, do której odwołuje się <see cref="T:System.Messaging.MessageQueue" /> ten obiekt, i określa etykietę wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia `obj` <xref:System.Messaging.MessageQueue>, aby wysłać komunikat zawierający parametr do kolejki, do której odwołuje się obiekt, przy użyciu kontekstu `transactionType` transakcji zdefiniowanego przez parametr. `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, którego chcesz użyć do wysłania wiadomości. Określ `Single` , czy chcesz wysłać wiadomość jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz wysłać wiadomość transakcyjną do wątku nietransakcyjnego.  
  
 Obiekt wysyłany do kolejki może być <xref:System.Messaging.Message> obiektem lub dowolnymi obiektami zarządzanymi. W przypadku wysłania dowolnego obiektu innego niż <xref:System.Messaging.Message>a obiekt zostanie Zserializowany i wstawiony do treści komunikatu. Za pomocą tego przeciążenia można określić etykietę ciągu, która identyfikuje komunikat.  
  
 Etykieta wiadomości różni się od etykiety kolejki komunikatów, ale obie są zależne od aplikacji i nie dziedziczą znaczenia dla usługi kolejkowania komunikatów.  
  
 Jeśli <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość nie zostanie ustawiona przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, program formatujący domyślnie przyjmowana <xref:System.Messaging.XmlMessageFormatter>jest wartość.  
  
 Właściwość ma zastosowanie do każdego obiektu innego <xref:System.Messaging.Message>niż. <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Jeśli określisz, na przykład, etykieta lub priorytet przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> elementu członkowskiego, te wartości mają zastosowanie do każdego komunikatu zawierającego obiekt, który nie jest typem <xref:System.Messaging.Message> , gdy aplikacja wysyła je do kolejki. Podczas <xref:System.Messaging.Message>wysyłania, wartości właściwości ustawione <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> <xref:System.Messaging.Message> dla pierwszeństwa przed i <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> Właściwość komunikatu mają pierwszeństwo przed <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwością kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="label" /></exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Aplikacja usługi kolejkowania komunikatów wykazała nieprawidłowe użycie transakcji.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje uprawnienia do bieżącego zestawu. Kontrolki, które mają prawa dostępu do właściwości kolejki i komunikatów w kolejce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl"><see cref="T:System.Messaging.AccessControlList" /> Zawiera co najmniej jeden wpis kontroli dostępu, który określa stron zaufanych i uprawnienia do udzielenia.</param>
        <summary>Przypisuje prawa dostępu do kolejki w oparciu o zawartość listy kontroli dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby udzielić, odmówić lub odwołać prawa przy użyciu kolekcji wpisów kontroli dostępu, aby określić informacje o powierniku i uprawnieniach. Służy to na przykład do przyznawania uprawnień wielu użytkownikom w tym samym czasie.  
  
 Zarządca określony podczas konstruowania `ace` parametru może być pojedynczym użytkownikiem, grupą użytkowników lub komputerem. Jeśli powiernik jest osobą indywidualną, użyj formatu `DOMAIN`. \\ `user` W celu wskazania komputera lokalnego można określić wartość ".".  
  
 Uprawnienia, które można przypisać <xref:System.Messaging.MessageQueue.SetPermissions%2A> poprzez dodawanie praw do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę, a grupa domeny Wszyscy ma uprawnienia do uzyskiwania właściwości kolejki, uzyskiwania uprawnień i zapisu do kolejki. Po wywołaniu <xref:System.Messaging.MessageQueue.SetPermissions%2A>, informacje o użytkowniku i uprawnieniach są dołączane na końcu istniejącej listy.  
  
 System sprawdza każdą <xref:System.Messaging.AccessControlEntry> sekwencję, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa <xref:System.Messaging.AccessControlEntry> dostępu jawnie odrzuca wszystkie żądane prawa dostępu do jednego z stron zaufanych wymienionych w tokenie dostępu wątku.  
  
-   Co najmniej jeden element dozwolony <xref:System.Messaging.AccessControlEntry> przez dostęp dla stron zaufanych wymieniony w tokenie dostępu wątku jawnie przyznaje wszystkie żądane prawa dostępu.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i nadal istnieje co najmniej jedna żądana prawa dostępu, która nie została jawnie dozwolona, w takim przypadku dostęp jest niejawnie zabroniony.  
  
 Podczas konstruowania `dacl` parametru należy dodać <xref:System.Messaging.AccessControlEntry> wystąpienia do <xref:System.Messaging.AccessControlList> kolekcji. Podczas konstruowania każdego wpisu kontroli dostępu można określić ogólne lub standardowe prawa dostępu. Prawa do kolejki mogą być dowolną kombinacją następujących elementów:  
  
-   Usuwanie  
  
-   Zabezpieczenia odczytu  
  
-   Zabezpieczenia zapisu  
  
-   Zsynchronizuj  
  
-   Modyfikuj właściciela  
  
-   Odczyt  
  
-   Write  
  
-   Wykonana  
  
-   Wymagane  
  
-   Wszystkie  
  
-   Brak  
  
 Te prawa to zbiór flag bitowych, które można połączyć za pomocą operatora OR.  
  
-   Pełna kontrola  
  
-   Usuń komunikat  
  
-   Odbierz wiadomość  
  
-   Wgląd do wiadomości  
  
-   Odbierz wiadomość dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustawianie właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejmij własność kolejki  
  
-   Napisz wiadomość  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Yes|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">A <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> , który określa użytkownika, typ dostępu i typ uprawnienia.</param>
        <summary>Przypisuje prawa dostępu do kolejki na podstawie zawartości wpisu kontroli dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby udzielić, odmówić lub odwołać prawa przy użyciu wpisu kontroli dostępu w celu określenia informacji o powierniku i prawach.  
  
 Zarządca określony podczas konstruowania `ace` parametru może być pojedynczym użytkownikiem, grupą użytkowników lub komputerem. Jeśli powiernik jest osobą indywidualną, użyj formatu `DOMAIN`. \\ `user` W celu wskazania komputera lokalnego można określić wartość ".".  
  
 Uprawnienia, które można przypisać <xref:System.Messaging.MessageQueue.SetPermissions%2A> poprzez dodawanie praw do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę, a grupa domeny Wszyscy ma uprawnienia do uzyskiwania właściwości kolejki, uzyskiwania uprawnień i zapisu do kolejki. Po wywołaniu <xref:System.Messaging.MessageQueue.SetPermissions%2A>, informacje o użytkowniku i uprawnieniach są dołączane na końcu istniejącej listy.  
  
 System sprawdza każdą <xref:System.Messaging.AccessControlEntry> sekwencję, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa <xref:System.Messaging.AccessControlEntry> dostępu jawnie odrzuca wszystkie żądane prawa dostępu do jednego z stron zaufanych wymienionych w tokenie dostępu wątku.  
  
-   Co najmniej jeden element dozwolony <xref:System.Messaging.AccessControlEntry> przez dostęp dla stron zaufanych wymieniony w tokenie dostępu wątku jawnie przyznaje wszystkie żądane prawa dostępu.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i nadal istnieje co najmniej jedna żądana prawa dostępu, która nie została jawnie dozwolona, w takim przypadku dostęp jest niejawnie zabroniony.  
  
 Prawa do kolejki, która została określona w `rights` parametrze podczas <xref:System.Messaging.MessageQueueAccessControlEntry>konstruowania, może być dowolną kombinacją następujących elementów:  
  
-   Pełna kontrola  
  
-   Usuń komunikat  
  
-   Odbierz wiadomość  
  
-   Wgląd do wiadomości  
  
-   Odbierz wiadomość dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustawianie właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejmij własność kolejki  
  
-   Napisz wiadomość  
  
 Parametr określony w konstruktorze `ace` dla parametru <xref:System.Messaging.MessageQueueAccessRights> jest flagą wyliczenia. `rights` Reprezentuje zestaw flag bitowych, które można połączyć przy użyciu operatora bitowego lub podczas kompilowania `rights` parametru.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Osoba, Grupa lub komputer, który uzyskuje dodatkowe prawa do kolejki.</param>
        <param name="rights">Wskazuje <see cref="T:System.Messaging.MessageQueueAccessRights" /> zestaw praw do kolejki, którą usługa kolejkowania komunikatów przypisuje <paramref name="user" /> do przesłanego elementu.</param>
        <summary>Przyznaje komputerowi, grupie lub użytkownikowi określone prawa dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby przyznać określone prawa użytkownikowi. Użytkownik może być dowolnym prawidłowym zarządcą, który obejmuje poszczególnych użytkowników, grupy użytkowników lub komputery. Jeśli użytkownik jest użytkownikiem `DOMAIN` indywidualnym, użyj formatu \\ `user` `user` parametru. Można określić `user` parametr "." dla parametru wskazującego komputer lokalny.  
  
 Uprawnienia, które można przypisać <xref:System.Messaging.MessageQueue.SetPermissions%2A> poprzez dodawanie praw do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę, a grupa domeny Wszyscy ma uprawnienia do uzyskiwania właściwości kolejki, uzyskiwania uprawnień i zapisu do kolejki. Po wywołaniu <xref:System.Messaging.MessageQueue.SetPermissions%2A>, informacje o użytkowniku i uprawnieniach są dołączane na końcu istniejącej listy.  
  
 System sprawdza każdą <xref:System.Messaging.AccessControlEntry> sekwencję, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa <xref:System.Messaging.AccessControlEntry> dostępu jawnie odrzuca wszystkie żądane prawa dostępu do jednego z stron zaufanych wymienionych w tokenie dostępu wątku.  
  
-   Co najmniej jeden element dozwolony <xref:System.Messaging.AccessControlEntry> przez dostęp dla stron zaufanych wymieniony w tokenie dostępu wątku jawnie przyznaje wszystkie żądane prawa dostępu.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i nadal istnieje co najmniej jedna żądana prawa dostępu, która nie została jawnie dozwolona, w takim przypadku dostęp jest niejawnie zabroniony.  
  
 Prawa do kolejki, określonej w `rights` parametrze, mogą być dowolną kombinacją następujących elementów:  
  
-   Pełna kontrola  
  
-   Usuń komunikat  
  
-   Odbierz wiadomość  
  
-   Wgląd do wiadomości  
  
-   Odbierz wiadomość dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustawianie właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejmij własność kolejki  
  
-   Napisz wiadomość  
  
 Wyliczenie reprezentuje zestaw flag bitowych, które można połączyć przy użyciu operatora bitowego lub do `rights` kompilowania parametru. <xref:System.Messaging.MessageQueueAccessRights>  
  
 Za pomocą tego przeciążenia można udzielać tylko uprawnień; nie można ich odwołać ani odmówić. Należy użyć innego przeciążenia, aby jawnie udzielić <xref:System.Messaging.AccessControlEntryType> innego niż. `Allow`  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="user" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Osoba, Grupa lub komputer, który uzyskuje dodatkowe prawa do kolejki.</param>
        <param name="rights">Wskazuje <see cref="T:System.Messaging.MessageQueueAccessRights" /> zestaw praw do kolejki, którą usługa kolejkowania komunikatów przypisuje <paramref name="user" /> do przesłanego elementu.</param>
        <param name="entryType">A <see cref="T:System.Messaging.AccessControlEntryType" /> , który określa, czy udzielić, odmówić lub odwołać uprawnienia określone <paramref name="rights" /> przez parametr.</param>
        <summary>Przyznaje komputerowi, grupie lub użytkownikowi określone prawa dostępu, z określonym typem kontroli dostępu (Zezwalaj, Odmów, odwoływania lub ustawiania).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia do udzielenia, odmowy lub odwołania określonych praw dla pojedynczego użytkownika. Użytkownik może być dowolnym prawidłowym zarządcą, który obejmuje poszczególnych użytkowników, grupy użytkowników lub komputery. Jeśli użytkownik jest użytkownikiem `DOMAIN` indywidualnym, użyj formatu \\ `user` `user` parametru. Można określić `user` parametr "." dla parametru wskazującego komputer lokalny.  
  
 Uprawnienia, które można przypisać <xref:System.Messaging.MessageQueue.SetPermissions%2A> poprzez dodawanie praw do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę, a grupa domeny Wszyscy ma uprawnienia do uzyskiwania właściwości kolejki, uzyskiwania uprawnień i zapisu do kolejki. Po wywołaniu <xref:System.Messaging.MessageQueue.SetPermissions%2A>, informacje o użytkowniku i uprawnieniach są dołączane na końcu istniejącej listy.  
  
 System sprawdza każdą <xref:System.Messaging.AccessControlEntry> sekwencję, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa <xref:System.Messaging.AccessControlEntry> dostępu jawnie odrzuca wszystkie żądane prawa dostępu do jednego z stron zaufanych wymienionych w tokenie dostępu wątku.  
  
-   Co najmniej jeden element dozwolony <xref:System.Messaging.AccessControlEntry> przez dostęp dla stron zaufanych wymieniony w tokenie dostępu wątku jawnie przyznaje wszystkie żądane prawa dostępu.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i nadal istnieje co najmniej jedna żądana prawa dostępu, która nie została jawnie dozwolona, w takim przypadku dostęp jest niejawnie zabroniony.  
  
 Prawa do kolejki, określonej w `rights` parametrze, mogą być dowolną kombinacją następujących elementów:  
  
-   Pełna kontrola  
  
-   Usuń komunikat  
  
-   Odbierz wiadomość  
  
-   Wgląd do wiadomości  
  
-   Odbierz wiadomość dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustawianie właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejmij własność kolejki  
  
-   Napisz wiadomość  
  
 Wyliczenie reprezentuje zestaw flag bitowych, które można połączyć przy użyciu operatora bitowego lub do `rights` kompilowania parametru. <xref:System.Messaging.MessageQueueAccessRights>  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który kierujący wywołanie programu obsługi zdarzeń wynikający ze <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> zdarzenia or. <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /></summary>
        <value>A <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, który reprezentuje obiekt kierujący wywołanie programu obsługi zdarzeń wynikający <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> ze zdarzenia lub <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> . Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lub wynik zdarzenia z<xref:System.Messaging.MessageQueue.BeginReceive%2A> lub<xref:System.Messaging.MessageQueue.BeginPeek%2A> odpowiednio do określonego wątku. <xref:System.Messaging.MessageQueue.PeekCompleted> <xref:System.Messaging.MessageQueue.ReceiveCompleted> Zazwyczaj <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> jest ustawiana, gdy jej składnik powiązany jest umieszczony wewnątrz kontrolki lub formularza, ponieważ te składniki są powiązane z określonym wątkiem.  
  
 Zazwyczaj synchronizowanie obiektu kierowanie wywołania metody do pojedynczego wątku.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kolejka akceptuje tylko transakcje.</summary>
        <value><see langword="true" />Jeśli kolejka akceptuje tylko wiadomości wysyłane w ramach transakcji; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transakcyjna obsługa komunikatów dotyczy sprzęgania kilku powiązanych komunikatów w pojedynczą transakcję. Wysyłanie komunikatów w ramach transakcji gwarantuje, że komunikaty są dostarczane w kolejności, dostarczane tylko raz i pomyślnie pobrane z kolejki docelowej.  
  
 Jeśli kolejka jest transakcyjna, akceptuje tylko komunikaty wysyłane w ramach transakcji. Jednak komunikat nietransakcyjny może być wysyłany lub odbierany z lokalnej kolejki transakcji bez jawnego użycia transakcyjnych <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>i <xref:System.Messaging.MessageQueueTransaction.Abort%2A> składni. Jeśli komunikat nietransakcyjny jest wysyłany do kolejki transakcyjnej, ten składnik tworzy dla niego transakcję pojedynczego komunikatu, z wyjątkiem sytuacji, w której odwołuje się do kolejki na komputerze zdalnym przy użyciu nazwy formatu bezpośredniego. W tej sytuacji, jeśli nie określisz kontekstu transakcji podczas wysyłania wiadomości, nie zostanie on utworzony dla Ciebie, a komunikat zostanie wysłany do kolejki utraconych wiadomości.  
  
 Jeśli wyślesz nietransakcyjny komunikat do kolejki transakcyjnej, nie będziesz w stanie wycofać komunikatu w zdarzeniu wyjątku.  
  
 <xref:System.Messaging.MessageQueueTransaction>jest wątkem wątków, dlatego jeśli stanem apartamentu jest `STA`, nie można używać transakcji w wielu wątkach. Visual Basic ustawia stan wątku głównego na `STA`, dlatego należy <xref:System.MTAThreadAttribute> zastosować w `Main` procedurze podrzędnej. W przeciwnym razie wysyłanie wiadomości transakcyjnej przy użyciu innego wątku <xref:System.Messaging.MessageQueueException> zgłasza wyjątek. Należy zastosować, <xref:System.MTAThreadAttribute> korzystając z poniższego fragmentu.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Tak|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.MessageQueue.Transactional%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy odebrane komunikaty są kopiowane do kolejki dziennika.</summary>
        <value><see langword="true" />Jeśli komunikaty odebrane z kolejki są kopiowane do kolejki dziennika; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy aplikacja usługi kolejkowania komunikatów tworzy nową kolejkę aplikacji, automatycznie tworzy skojarzoną kolejkę dziennika w tej samej lokalizacji. Kolejka dziennika służy do śledzenia komunikatów usuniętych z kolejki. Ustawienie tej właściwości powoduje modyfikację kolejki usługi kolejkowania komunikatów. W związku z tym <xref:System.Messaging.MessageQueue> zmiana ma wpływ na wszystkie inne wystąpienia.  
  
 Kolejka dziennika nie śledzi komunikatów usuniętych z kolejki, ponieważ ich czas wygaśnięcia upłynął lub nie śledzi komunikatów przeczyszczonych z kolejki przy użyciu usługi katalogowej kolejkowania komunikatów (Magazyn informacji lub Active Directory).  
  
 Aplikacje nie mogą wysyłać komunikatów do kolejek dziennika; są one ograniczone do dostępu tylko do odczytu tych kolejek. Ponadto usługa kolejkowania komunikatów nigdy nie usuwa komunikatów z kolejek dzienników. Aplikacja korzystająca z kolejki musi wyczyścić te komunikaty przez ich odbiór lub przez wyczyszczenie kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> właściwości kolejki komunikatów.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt macierzysty używany do wysyłania komunikatów do kolejki komunikatów.</summary>
        <value>Uchwyt do natywnego obiektu kolejki, który jest używany do wysyłania komunikatów do kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A> Zapewnia natywne dojście systemu Windows do obiektu kolejki komunikatów, który jest używany do wysyłania komunikatów do kolejki. Jeśli zmienisz ścieżkę kolejki, uchwyt zostanie zamknięty i ponownie otwarty z nową wartością.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Tryb grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Nazwa komputera lokalnego i bezpośredniego|Yes|  
|Komputer zdalny|Nie|  
|Nazwa komputera zdalnego i bezpośredniego|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka komunikatów nie jest dostępna do zapisu.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>
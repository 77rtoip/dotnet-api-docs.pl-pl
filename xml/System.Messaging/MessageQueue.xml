<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8e7d61300c9cf64adf3ca60830f03308af35ee5a" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51889686" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia dostęp do kolejki na serwerze usługi kolejkowania komunikatów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Technologia usługi kolejkowania komunikatów umożliwia uruchamianie aplikacji w różnym czasie do komunikowania się za pośrednictwem sieci heterogenicznych oraz systemów, które mogą być tymczasowo w trybie offline. Aplikacji wysyłanie, odbieranie i wybieranie (Odczyt, bez usuwania) komunikaty z kolejki. Usługa kolejkowania komunikatów jest opcjonalnym składnikiem [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] i Windows NT i musi zostać zainstalowany oddzielnie.  
  
 <xref:System.Messaging.MessageQueue> Klasa jest otokę wokół usługi kolejkowania komunikatów. Istnieje wiele wersji usługi kolejkowania komunikatów i korzystania z <xref:System.Messaging.MessageQueue> klasy może spowodować nieco inaczej, w zależności od systemu operacyjnego używasz. Aby uzyskać informacje dotyczące określonych funkcji dla każdej wersji usługi kolejkowania komunikatów zobacz temat "What's New in Usługa kolejkowania komunikatów" w zestawie SDK platformy w witrynie MSDN.  
  
 <xref:System.Messaging.MessageQueue> Klasy zawiera odwołanie do kolejki usługi kolejkowania komunikatów. Można określić ścieżkę w <xref:System.Messaging.MessageQueue.%23ctor%2A> konstruktora, aby nawiązać połączenie z istniejącego zasobu, lub można utworzyć nową kolejkę na serwerze. Przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, lub <xref:System.Messaging.MessageQueue.Receive%2A>, należy skojarzyć nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy przy użyciu istniejącej kolejki. W tym momencie można manipulować właściwości kolejki takich jak <xref:System.Messaging.MessageQueue.Category%2A> i <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> obsługuje dwa typy odebrania komunikatu: synchroniczne i asynchroniczne. Synchroniczne metody <xref:System.Messaging.MessageQueue.Peek%2A> i <xref:System.Messaging.MessageQueue.Receive%2A>, spowodować, że wątek procesu oczekiwania przez określony okres czasu dla nowych komunikatów w kolejce. Metod asynchronicznych, <xref:System.Messaging.MessageQueue.BeginPeek%2A> i <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Zezwalaj, aby kontynuować w oddzielnym wątku, dopóki umieszczeniu komunikatu w kolejce zadania głównej aplikacji. Te metody pracy przy użyciu obiekty wywołania zwrotnego i stanu do przekazywania informacji między wątkami.  
  
 Podczas tworzenia nowego wystąpienia <xref:System.Messaging.MessageQueue> klasy, nie tworzysz nowy kolejki usługi kolejkowania komunikatów. Zamiast tego można użyć <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, i <xref:System.Messaging.MessageQueue.Purge%2A> metody do kolejki na serwerze zarządzania.  
  
 W odróżnieniu od <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> i <xref:System.Messaging.MessageQueue.Delete%28System.String%29> są `static` elementów członkowskich, dzięki czemu można je wywoływać bez tworzenia nowego wystąpienia klasy <xref:System.Messaging.MessageQueue> klasy.  
  
 Możesz ustawić <xref:System.Messaging.MessageQueue> obiektu <xref:System.Messaging.MessageQueue.Path%2A> właściwość z jednej z trzech nazw: Przyjazna nazwa <xref:System.Messaging.MessageQueue.FormatName%2A>, lub <xref:System.Messaging.MessageQueue.Label%2A>. Przyjazna nazwa, która jest zdefiniowana przez kolejkę <xref:System.Messaging.MessageQueue.MachineName%2A> i <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości jest <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> do kolejki publicznej i <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> dla kolejki prywatnej. <xref:System.Messaging.MessageQueue.FormatName%2A> Właściwość umożliwia dostęp w trybie offline w kolejkach komunikatów. Ponadto można użyć kolejki <xref:System.Messaging.MessageQueue.Label%2A> właściwości do ustawienia kolejki <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Aby uzyskać listę początkowe wartości właściwości wystąpienia <xref:System.Messaging.MessageQueue>, zobacz <xref:System.Messaging.MessageQueue.%23ctor%2A> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowy <xref:System.Messaging.MessageQueue> obiektów przy użyciu różnych typów Składnia nazwy ścieżki. W każdym przypadku wysyła komunikat do kolejki, których ścieżka jest zdefiniowana w konstruktorze.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 Poniższy przykład kodu, wysyła komunikat do kolejki i otrzymuje komunikat z kolejki, za pomocą klasy specyficzne dla aplikacji o nazwie `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tylko <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> metody jest bezpieczny dla wątków.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy. Po Konstruktor domyślny inicjuje nowe wystąpienie, należy ustawić wystąpienia <see cref="P:System.Messaging.MessageQueue.Path" /> właściwości, zanim będzie można użyć wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasę, która nie jest bezpośrednio związany z kolejką na serwer usługi kolejkowania komunikatów. Przed rozpoczęciem korzystania z tego wystąpienia, musisz połączyć go do istniejącej kolejki usługi kolejkowania komunikatów przez ustawienie <xref:System.Messaging.MessageQueue.Path%2A> właściwości. Alternatywnie, można ustawić <xref:System.Messaging.MessageQueue> odwołanie do <xref:System.Messaging.MessageQueue.Create%28System.String%29> wartość zwracaną metody, tworząc w ten sposób nowej kolejki usługi kolejkowania komunikatów.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor tworzy nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy; nie powoduje utworzenia nowej kolejki usługi kolejkowania komunikatów.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.Messaging.MessageQueue>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Wartości ustawione przez domyślny konstruktor obiektu <xref:System.Messaging.DefaultPropertiesToSend> klasy.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Wartości ustawione przez domyślny konstruktor obiektu <xref:System.Messaging.MessagePropertyFilter> klasy. Wszystkie wartości filtru są ustawione na `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nową <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizację kolejki przywoływane przez to <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasę, która odwołuje się do kolejki usługi kolejkowania komunikatów w określonej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia powiązać nowy <xref:System.Messaging.MessageQueue> wystąpienia do określonej kolejki usługi kolejkowania komunikatów, dla którego znasz ścieżka, nazwa formatu lub etykiety. Jeśli chcesz przyznanie wyłącznego dostępu do pierwszego wniosku odwołujący się kolejce, należy ustawić <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> właściwości `true` lub użyj konstruktora, który przekazuje parametr ograniczenie dostępu do odczytu.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor tworzy nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy; nie powoduje utworzenia nowej kolejki usługi kolejkowania komunikatów. Aby utworzyć nową kolejkę w usługi kolejkowania komunikatów, należy użyć <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Składnia `path` parametru zależy od typu kolejki jego odwołania, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejki dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejki dziennika komputera|`MachineName`\\`Journal$`|  
|Kolejka utraconych wiadomości komputera|`MachineName`\\`Deadletter$`|  
|Kolejki utraconych wiadomości transakcyjnych maszyn|`MachineName`\\`XactDeadletter$`|  
  
 Alternatywnie, można użyć <xref:System.Messaging.MessageQueue.FormatName%2A> lub <xref:System.Messaging.MessageQueue.Label%2A> do opisania na ścieżkę kolejki, jak pokazano w poniższej tabeli.  
  
|Tematy pomocy|Składnia|Przykład|  
|---------------|------------|-------------|  
|Nazwa formatu|`FormatName:` [ *nazwę formatu* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Etykieta|`Label:` [ *etykiety* ]|`Label:` TheLabel|  
  
 Praca w trybie offline, należy użyć składni nazwę formatu, nie Składnia nazwy ścieżki dla konstruktora. W przeciwnym razie jest zgłaszany wyjątek, ponieważ podstawowy kontroler domeny nie jest dostępny, można rozpoznać ścieżki do nazwy formatu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.Messaging.MessageQueue>. Wartości te są oparte na właściwości kolejki usługi kolejkowania komunikatów za pomocą ścieżka określona przez plik `path` parametru.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Wartości ustawione przez domyślny konstruktor obiektu <xref:System.Messaging.DefaultPropertiesToSend> klasy.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, jeśli ustawienie poziomu prywatności kolejki usługi kolejkowania komunikatów "Treść"; w przeciwnym razie `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Wartość właściwości Nazwa komputera kolejki usługi kolejkowania komunikatów.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Wartości ustawione przez domyślny konstruktor obiektu <xref:System.Messaging.MessagePropertyFilter> klasy.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, jeśli nie zostanie ustawiona przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, jeśli nie zostanie ustawiona przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, jeśli obiekt usługi kolejkowania komunikatów dziennika ustawienie jest włączone; w przeciwnym razie `false`.|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowy <xref:System.Messaging.MessageQueue> obiektów przy użyciu różnych typów Składnia nazwy ścieżki. W każdym przypadku wysyła komunikat do kolejki, których ścieżka jest zdefiniowana w konstruktorze.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie jest prawidłowy, prawdopodobnie ponieważ nie została ustawiona.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizację kolejki przywoływane przez to <see cref="T:System.Messaging.MessageQueue" />, który może być "." na komputerze lokalnym.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> Aby udzielić wyłączny dostęp do odczytu do pierwszej aplikacji, który uzyskuje dostęp do tej kolejki; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasę, która odwołuje się do kolejki usługi kolejkowania komunikatów w określonej ścieżce i z określonym ograniczeniem dostęp do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia powiązać nowy <xref:System.Messaging.MessageQueue> do określonej kolejki usługi kolejkowania komunikatów, dla którego znasz ścieżka, nazwa formatu lub etykiety. Jeśli chcesz przyznanie wyłącznego dostępu do pierwszego wniosku, odwołuje się do kolejki, ustaw `sharedModeDenyReceive` parametr `true`. W przeciwnym wypadku ustaw `sharedModeDenyReceive` do `false` lub użyj konstruktora, który ma tylko `path` parametru.  
  
 Ustawienie `sharedModeDenyReceive` do `true` ma wpływ na wszystkie obiekty, uzyskujących dostęp do kolejki usługi kolejkowania komunikatów, łącznie z innych aplikacji. Efekty parametru nie są ograniczone do tej aplikacji.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor tworzy nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy; nie powoduje utworzenia nowej kolejki usługi kolejkowania komunikatów. Aby utworzyć nową kolejkę w usługi kolejkowania komunikatów, należy użyć <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Składnia `path` parametru zależy od typu kolejki.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejki dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejki dziennika komputera|`MachineName`\\`Journal$`|  
|Kolejka utraconych wiadomości komputera|`MachineName`\\`Deadletter$`|  
|Kolejki utraconych wiadomości transakcyjnych maszyn|`MachineName`\\`XactDeadletter$`|  
  
 Alternatywnie można użyć formatu nazwy lub etykiety, kolejki usługi kolejkowania komunikatów do opisania na ścieżkę kolejki.  
  
|Tematy pomocy|Składnia|Przykład|  
|---------------|------------|-------------|  
|Nazwa formatu|`FormatName:` [ *nazwę formatu* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Etykieta|`Label:` [ *etykiety* ]|`Label:` TheLabel|  
  
 Aby praca w trybie offline, należy użyć Składnia nazwy formatu, zamiast składni przyjazną nazwę. W przeciwnym razie jest zgłaszany wyjątek, ponieważ nie jest można rozpoznać ścieżki do nazwy formatu podstawowego kontrolera domeny (na którym usługa Active Directory).  
  
 Jeśli <xref:System.Messaging.MessageQueue> otwiera kolejka o `sharedModeDenyReceive` parametr `true`, any <xref:System.Messaging.MessageQueue> , następnie próbuje odczytany z kolejki generuje <xref:System.Messaging.MessageQueueException> ze względu na naruszenie zasad współużytkowania. A <xref:System.Messaging.MessageQueueException> również jest generowany, jeśli <xref:System.Messaging.MessageQueue> próbuje uzyskać dostęp w kolejce w trybie wyłączności podczas drugiego <xref:System.Messaging.MessageQueue> ma już otwarty dostęp do kolejki.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.Messaging.MessageQueue>. Wartości te są oparte na właściwości kolejki usługi kolejkowania komunikatów za pomocą ścieżka określona przez plik `path` parametru.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Wartości ustawione przez domyślny konstruktor obiektu <xref:System.Messaging.DefaultPropertiesToSend> klasy.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, jeśli ustawienie poziomu prywatności kolejki usługi kolejkowania komunikatów "Treść"; w przeciwnym razie `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Wartość właściwości Nazwa komputera kolejki usługi kolejkowania komunikatów.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Wartości ustawione przez domyślny konstruktor obiektu <xref:System.Messaging.MessagePropertyFilter> klasy.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, jeśli nie zostanie ustawiona przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, jeśli nie zostanie ustawiona przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Wartość `sharedModeDenyReceive` parametru.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, jeśli obiekt usługi kolejkowania komunikatów dziennika ustawienie jest włączone; w przeciwnym razie `false`.|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nową <xref:System.Messaging.MessageQueue> wyłączny dostęp, ustawia jego ścieżkę i wysyła komunikat do kolejki.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie jest prawidłowy, prawdopodobnie ponieważ nie została ustawiona.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizację kolejki przywoływane przez to <see cref="T:System.Messaging.MessageQueue" />, który może być "." na komputerze lokalnym.</param>
        <param name="accessMode">Jedną z <see cref="T:System.Messaging.QueueAccessMode" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizację kolejki przywoływane przez to <see cref="T:System.Messaging.MessageQueue" />, który może być "." na komputerze lokalnym.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> Aby udzielić wyłączny dostęp do odczytu do pierwszej aplikacji, który uzyskuje dostęp do tej kolejki; w przeciwnym razie <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> Tworzenie i używanie pamięci podręcznej połączenia; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy nową <xref:System.Messaging.MessageQueue> z wyłącznego dostępu do odczytu i włączone buforowanie połączenia.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizację kolejki przywoływane przez to <see cref="T:System.Messaging.MessageQueue" />, który może być "." na komputerze lokalnym.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> Aby udzielić wyłączny dostęp do odczytu do pierwszej aplikacji, który uzyskuje dostęp do tej kolejki; w przeciwnym razie <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> Tworzenie i używanie pamięci podręcznej połączenia; w przeciwnym razie <see langword="false" />.</param>
        <param name="accessMode">Jedną z <see cref="T:System.Messaging.QueueAccessMode" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje poziom dostępu dla kolejki.</summary>
        <value>Jedną z <see cref="T:System.Messaging.QueueAccessMode" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to domyślny tryb dostępu do kolejki `QueueAccessMode.SendAndReceive`, chyba że określono inaczej podczas wywoływania konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kolejka akceptuje wyłącznie uwierzytelnione komunikaty.</summary>
        <value>
          <see langword="true" /> Jeśli kolejka akceptuje wyłącznie uwierzytelnione komunikaty w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie wiadomości stanowi sposób zapewnienia integralności komunikatu i upewnić się, która wysłała komunikat. Aby żądać uwierzytelniania, aplikacja wysyłająca ustawia poziom uwierzytelniania wiadomości.  
  
 Po ustawieniu <xref:System.Messaging.MessageQueue.Authenticate%2A> do `true`, masz ograniczony dostęp do kolejki na serwerze, a nie tylko do tego <xref:System.Messaging.MessageQueue> wystąpienia. Wszyscy klienci działa z tej samej kolejki usługi kolejkowania komunikatów będzie to miało wpływu.  
  
 Kolejka akceptuje wyłącznie uwierzytelnione komunikaty spowoduje odrzucenie wiadomości bez uwierzytelnienia. Aby zażądać powiadomienie o odrzuceniu wiadomości, można ustawić aplikacji wysyłającej <xref:System.Messaging.Message.AcknowledgeType%2A> właściwość komunikatu. Ponieważ nie istnieje żadne oznaki odrzucenia wiadomości, aplikacji wysyłającej może utracić wiadomości, chyba że w przypadku żądania, wysłania do kolejki utraconych wiadomości.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.Authenticate%2A> właściwości.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podstawowy priorytet, którego używa Usługa Kolejkowanie komunikatów do rozsyłania wiadomości z kolejki publicznej za pośrednictwem sieci.</summary>
        <value>Pojedynczy podstawowy priorytet dla wszystkich komunikatów wysłanych do kolejki (publicznej). Wartością domyślną jest zero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Priorytet podstawowy kolejki komunikatów Określa jak wiadomość w drodze do tej kolejki jest traktowany jako przesyłane za pośrednictwem sieci. Możesz ustawić <xref:System.Messaging.MessageQueue.BasePriority%2A> właściwość przyznaje wyższy lub niższy priorytet wszystkich komunikatów wysłanych do określonej kolejki niż te są wysyłane do innych kolejek. Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym, inne <xref:System.Messaging.MessageQueue> wystąpienia ma wpływ zmiany.  
  
 Kolejki komunikatów <xref:System.Messaging.MessageQueue.BasePriority%2A> nie jest powiązana z <xref:System.Messaging.Message.Priority%2A> właściwości komunikatu, który określa kolejność, w której wiadomości przychodzących jest umieszczany w kolejce.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> ma zastosowanie tylko do publicznej kolejki, których ścieżki są określane za pomocą nazwy formatu. Priorytet podstawowy kolejki prywatnej jest zawsze zero (0).  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.BasePriority%2A> właściwości.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Priorytet podstawowy został ustawiony na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <summary>Inicjuje operację asynchroniczną podglądu, informuje MSMQ rozpocząć wgląd do wiadomości i powiadomienia po zakończeniu obsługi zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje operację asynchronicznego wglądu, która ma nie ma limitu. Operacja nie została zakończona, aż komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Określający przesłanego żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego używasz <xref:System.Messaging.MessageQueue.BeginPeek%2A> podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, gdy komunikat o stanie się dostępny w kolejce.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> jest także generowany, jeśli istnieje już wiadomość w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginPeek%2A>, utworzyć program obsługi zdarzeń, która przetwarza wyniki operacji asynchronicznych i skojarzyć go z Twojego delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Inicjuje operację asynchroniczną podglądu; <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, po umieszczeniu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Mogą następnie uzyskiwać dostęp do wiadomości, wywołując <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lub pobierając przy użyciu wynik <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończone, dopóki program obsługi zdarzeń jest wywoływany.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczna, można wywołać go do wglądu kolejki bez blokuje bieżący wątek wykonywania. Aby synchronicznie wgląd w kolejce, należy użyć <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w program obsługi zdarzeń, aby nadal mieć dostęp do powiadomień.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> Zwraca identyfikuje operację asynchroniczną, która metoda pracę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, mimo że można zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest wywoływana. Jednak jeśli uruchomisz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy, określając, czy czekać na wszystkie operacje lub inne czynności do wykonania. W tym przypadku używasz <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, wywoływane jest zdarzenie zakończenia, ale zostanie zgłoszony wyjątek podczas wywoływania <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyPeekCompleted`, dołącza go do <xref:System.Messaging.MessageQueue.PeekCompleted> delegata obsługi zdarzeń i wywołania <xref:System.Messaging.MessageQueue.BeginPeek%2A> można zainicjować operacji asynchronicznych wglądu w kolejce, która znajduje się w ścieżce ". \myQueue". Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane, w przykładzie dokonuje wiadomości i zapisuje jego treść na ekranie. Przykład następnie wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> ponownie, aby zainicjować nową operację asynchroniczną podglądu.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> oznacza to, interwał czasu oczekiwania na udostępnienie wiadomości.</param>
        <summary>Inicjuje operację asynchronicznego wglądu, która ma określony limit czasu. Operacja nie została zakończona, aż upłynie limit czasu lub komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Określający przesłanego żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego używasz <xref:System.Messaging.MessageQueue.BeginPeek%2A> podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, kiedy wiadomość staje się dostępna w kolejce lub określony przedział czasu utracił ważność.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> jest także generowany, jeśli istnieje już wiadomość w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginPeek%2A>, utworzyć program obsługi zdarzeń, która przetwarza wyniki operacji asynchronicznych i skojarzyć go z Twojego delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Inicjuje operację asynchroniczną podglądu; <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, po umieszczeniu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Mogą następnie uzyskiwać dostęp do wiadomości, wywołując <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lub pobierając przy użyciu wynik <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończone, dopóki program obsługi zdarzeń jest wywoływany.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczna, można wywołać go do wglądu kolejki bez blokuje bieżący wątek wykonywania. Aby synchronicznie wgląd w kolejce, należy użyć <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w program obsługi zdarzeń, aby nadal mieć dostęp do powiadomień.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> Zwraca identyfikuje operację asynchroniczną, która metoda pracę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, mimo że można zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest wywoływana. Jednak jeśli uruchomisz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy, określając, czy czekać na wszystkie operacje lub inne czynności do wykonania. W tym przypadku używasz <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 To przeciążenie określa limit czasu. Jeśli interwał określony przez `timeout` wygasa parametr, ten składnik wywołuje <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> spowoduje zgłoszenie wyjątku.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, wywoływane jest zdarzenie zakończenia, ale zostanie zgłoszony wyjątek podczas wywoływania <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy operacji asynchronicznych wglądu, przy użyciu ścieżki kolejki ". \myQueue". Tworzy program obsługi zdarzeń `MyPeekCompleted`i dołącza je do <xref:System.Messaging.MessageQueue.PeekCompleted> delegata obsługi zdarzeń. <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest wywoływana z limitem czasu w jednej minuty można zainicjować operacji asynchronicznych podglądu. Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane lub limit czasu upłynie, wiadomość zostanie pobrana, jeśli istnieje, a jego treści są zapisywane do ekranu. Następnie <xref:System.Messaging.MessageQueue.BeginPeek%2A> wywoływana jest ponownie zainicjować nową operację asynchroniczną podglądu przy użyciu tego samego limitu czasu.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> oznacza to, interwał czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="stateObject">Obiekt stanu określonym przez aplikację, która zawiera informacje związane z operacją asynchroniczną.</param>
        <summary>Inicjuje operację asynchronicznego wglądu, która ma określony limit czasu i obiektu określonego stanu, który zawiera skojarzone informacje w okresie istnienia wykonać operację. Operacja nie została zakończona, aż upłynie limit czasu lub komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Określający przesłanego żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego używasz <xref:System.Messaging.MessageQueue.BeginPeek%2A> podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, kiedy wiadomość staje się dostępna w kolejce lub określony przedział czasu utracił ważność.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> jest także generowany, jeśli istnieje już wiadomość w kolejce.  
  
 To przeciążenie umożliwia kojarzenie informacji za pomocą operacji, które zostaną zachowane w okresie istnienia wykonać operację. Program obsługi zdarzeń mogą uzyskiwać dostęp do tych informacji, analizując <xref:System.IAsyncResult.AsyncState%2A> właściwość <xref:System.IAsyncResult> skojarzony z operacją.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginPeek%2A>, utworzyć program obsługi zdarzeń, która przetwarza wyniki operacji asynchronicznych i skojarzyć go z Twojego delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Inicjuje operację asynchroniczną podglądu; <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, po umieszczeniu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Mogą następnie uzyskiwać dostęp do wiadomości, wywołując <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lub pobierając przy użyciu wynik <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończone, dopóki program obsługi zdarzeń jest wywoływany.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczna, można wywołać go do wglądu kolejki bez blokuje bieżący wątek wykonywania. Aby synchronicznie wgląd w kolejce, należy użyć <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w program obsługi zdarzeń, aby nadal mieć dostęp do powiadomień.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Zwraca <xref:System.IAsyncResult> który identyfikuje operację asynchroniczną, która metoda pracę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, mimo że można zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest wywoływana. Jednak jeśli uruchomisz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy, określając, czy czekać na wszystkie operacje lub inne czynności do wykonania. W tym przypadku używasz <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 To przeciążenie określa limit czasu i obiektu stanu. Jeśli interwał określony przez `timeout` wygasa parametr, ten składnik wywołuje <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> spowoduje zgłoszenie wyjątku.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginPeek%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielny stan, który zdefiniujesz. Ilustracja tego scenariusza znajduje się w sekcji przykład.  
  
 Obiekt stanu można również użyć do przekazywania informacji między wątkami procesu. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne jest w innym wątku asynchronicznego scenariusza, obiekt stanu jest zorganizowany i przekazywane ponownie wraz z informacjami od zdarzenia.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, wywoływane jest zdarzenie zakończenia, ale zostanie zgłoszony wyjątek podczas wywoływania <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy operacji asynchronicznych wglądu, przy użyciu ścieżki kolejki ". \myQueue". Tworzy program obsługi zdarzeń `MyPeekCompleted`i dołącza je do <xref:System.Messaging.MessageQueue.PeekCompleted> delegata obsługi zdarzeń. <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest wywoływana, przy użyciu limitu czasu w jednej minuty. Każde wywołanie <xref:System.Messaging.MessageQueue.BeginPeek%2A> ma unikatowy skojarzone liczba całkowita, która identyfikuje tej określonej operacji. Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane lub upłynął limit czasu, wiadomość, jeśli istnieje, zostanie pobrana, a jego treści i identyfikator całkowitą określonych operacji, które są zapisywane do ekranu. Następnie <xref:System.Messaging.MessageQueue.BeginPeek%2A> wywoływana jest ponownie zainicjować nową operację asynchroniczną podglądu przy użyciu tego samego limitu czasu i skojarzone całkowitej po prostu ukończoną operację.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> oznacza to, interwał czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="stateObject">Obiekt stanu określonym przez aplikację, która zawiera informacje związane z operacją asynchroniczną.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Który będą otrzymywać powiadomienia o zakończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje operację asynchronicznego wglądu, która ma określony limit czasu i obiektu określonego stanu, który zawiera skojarzone informacje w okresie istnienia wykonać operację. To przeciążenie odbiera powiadomienie za pośrednictwem wywołania zwrotnego, tożsamość programu obsługi zdarzeń dla tej operacji. Operacja nie została zakończona, aż upłynie limit czasu lub komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Określający przesłanego żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy używasz tego przeciążenia, wywołania zwrotnego, określona w parametrze wywołania zwrotnego jest bezpośrednio wywoływany, gdy komunikat o stanie się dostępny, w kolejce lub określony przedział czasu upłynął; <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane w nie. Inne przeciążenia <xref:System.Messaging.MessageQueue.BeginPeek%2A> zależą od tego składnika, aby podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> jest także generowany, jeśli istnieje już wiadomość w kolejce.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończone, dopóki program obsługi zdarzeń jest wywoływany.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczna, można wywołać go do wglądu kolejki bez blokuje bieżący wątek wykonywania. Aby synchronicznie wgląd w kolejce, należy użyć <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w program obsługi zdarzeń, aby nadal mieć dostęp do powiadomień.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Zwraca <xref:System.IAsyncResult> który identyfikuje operację asynchroniczną, która metoda pracę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, mimo że można zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest wywoływana. Jednak jeśli uruchomisz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy, określając, czy czekać na wszystkie operacje lub inne czynności do wykonania. W tym przypadku używasz <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginPeek%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielny stan, który zdefiniujesz.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy operacji asynchronicznych podglądu. Następnie wywołuje kod przykład wysyła komunikat do kolejki wiadomości lokalnych <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, przekazując: wartość limitu czasu w ciągu dziesięciu sekund; unikatowa liczba całkowita, która identyfikuje tego konkretnego komunikatu; i nowe wystąpienie klasy <xref:System.AsyncCallback> programu obsługi zdarzeń, które identyfikują `MyPeekCompleted`. Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane, program obsługi zdarzeń dokonuje wglądu do wiadomości i zapisuje treści komunikatu i identyfikator wiadomości liczby całkowitej do ekranu.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> oznacza to, interwał czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określonej pozycji w kolejce komunikatów.</param>
        <param name="action">Jedną z <see cref="T:System.Messaging.PeekAction" /> wartości. Wskazuje, czy wglądu do bieżącej wiadomości w kolejce lub następny komunikat.</param>
        <param name="state">Obiekt stanu określonym przez aplikację, która zawiera informacje związane z operacją asynchroniczną.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> , Która otrzymuje powiadomienia o zakończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje operację asynchroniczną podglądu zawierający określony limit czasu i które używa określonego kursora, akcji określonym wglądu i obiektu określonego stanu. Obiekt stanu informacje skojarzone w okresie istnienia operacji. To przeciążenie odbiera powiadomienie za pośrednictwem wywołania zwrotnego, tożsamość programu obsługi zdarzeń dla tej operacji. Operacja nie została zakończona, aż upłynie limit czasu lub komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Określający przesłanego żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy używasz tego przeciążenia, wywołanie zwrotne, określona w parametrze wywołania zwrotnego jest wywoływana bezpośrednio, gdy komunikat o stanie się dostępny, w kolejce lub określony przedział czasu utracił ważność. <xref:System.Messaging.MessageQueue.PeekCompleted> Zdarzenie jest zgłaszane w nie. Inne przeciążenia <xref:System.Messaging.MessageQueue.BeginPeek%2A> zależą od tego składnika, aby podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> jest także generowany, jeśli istnieje już wiadomość w kolejce.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończone, dopóki program obsługi zdarzeń jest wywoływany.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczna, można wywołać go do wglądu kolejki bez blokuje bieżący wątek wykonywania. Aby synchronicznie wgląd w kolejce, należy użyć <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w program obsługi zdarzeń, aby nadal mieć dostęp do powiadomień.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Zwraca <xref:System.IAsyncResult> który identyfikuje operację asynchroniczną, uruchamiany przez metodę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, mimo że można zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest wywoływana. Jednak jeśli uruchomisz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy, określając, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginPeek%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielny stan, który zdefiniujesz.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość inną niż <see langword="PeekAction.Current" /> lub <see langword="PeekAction.Next" /> określono <paramref name="action" /> parametru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <summary>Inicjuje asynchronicznego odbioru operacji przez informuje MSMQ zacząć odbierać wiadomości i powiadomienia po zakończeniu obsługi zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje asynchroniczne otrzymują operacji, która ma nie ma limitu. Operacja nie została zakończona, aż komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Określający przesłanego żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego używasz <xref:System.Messaging.MessageQueue.BeginReceive%2A> podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, kiedy wiadomość została usunięta z kolejki.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> jest także generowany, jeśli istnieje już wiadomość w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, utworzyć program obsługi zdarzeń, która przetwarza wyniki operacji asynchronicznych i skojarzyć ją z Twojej delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Inicjuje asynchroniczne otrzymywać operacji. <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, po umieszczeniu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Mogą następnie uzyskiwać dostęp do wiadomości, wywołując <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończone, dopóki program obsługi zdarzeń jest wywoływany.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczna, można wywołać go do odebrania komunikatu z kolejki, bez blokuje bieżący wątek wykonywania. Aby synchronicznie pojawi się komunikat, należy użyć <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w program obsługi zdarzeń, aby nadal mieć dostęp do powiadomień.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Zwraca identyfikuje operację asynchroniczną, która metoda pracę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, mimo że można zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest wywoływana. Jednak jeśli uruchomisz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy, określając, czy czekać na wszystkie operacje lub inne czynności do wykonania. W tym przypadku używasz <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, wywoływane jest zdarzenie zakończenia, ale zostanie zgłoszony wyjątek podczas wywoływania <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Nie należy używać wywołania asynchronicznego <xref:System.Messaging.MessageQueue.BeginReceive%2A> z transakcji. Jeśli chcesz przeprowadzić transakcyjnych operację asynchroniczną, wywołaj <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieścić (synchronicznego) i transakcji <xref:System.Messaging.MessageQueue.Receive%2A> metody w ramach programu obsługi zdarzeń, możesz utworzyć dla operacji podglądu. Procedury obsługi zdarzenia może zawierać funkcji, jak pokazano w poniższym kodzie języka C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy powiązanie żądań asynchronicznych. Założono, że istnieje kolejki na komputerze lokalnym, o nazwie "myQueue". `Main` Funkcja rozpoczyna operację asynchroniczną, która jest obsługiwana przez `MyReceiveCompleted` procedury. `MyReceiveCompleted` przetwarza bieżącego komunikatu i rozpoczyna nową asynchronicznych operacji odbioru.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 Poniższy przykład kodu ustawia w kolejce żądań asynchronicznych. Wywołanie <xref:System.Messaging.MessageQueue.BeginReceive%2A> używa <xref:System.IAsyncResult.AsyncWaitHandle%2A> w zwracanej wartości. `Main` Procedury czeka, aż wszystkie operacje asynchroniczne, należy wykonać przed zamknięciem.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> oznacza to, interwał czasu oczekiwania na udostępnienie wiadomości.</param>
        <summary>Inicjuje asynchroniczne otrzymują operacji, który ma określony limit czasu. Operacja nie została zakończona, aż upłynie limit czasu lub komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Określający przesłanego żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego używasz <xref:System.Messaging.MessageQueue.BeginReceive%2A> podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, kiedy wiadomość staje się dostępna w kolejce lub określony przedział czasu utracił ważność.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> jest także generowany, jeśli istnieje już wiadomość w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, utworzyć program obsługi zdarzeń, która przetwarza wyniki operacji asynchronicznych i skojarzyć ją z Twojej delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Inicjuje asynchroniczne otrzymywać operacji. <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, po umieszczeniu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Mogą następnie uzyskiwać dostęp do wiadomości, wywołując <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub pobierania za pomocą wynik <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończone, dopóki program obsługi zdarzeń jest wywoływany.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczna, można wywołać go do odebrania komunikatu z kolejki, bez blokuje bieżący wątek wykonywania. Aby synchronicznie pojawi się komunikat, należy użyć <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w program obsługi zdarzeń, aby nadal mieć dostęp do powiadomień.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, wywoływane jest zdarzenie zakończenia, ale zostanie zgłoszony wyjątek podczas wywoływania <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Zwraca identyfikuje operację asynchroniczną, która metoda pracę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, mimo że można zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest wywoływana. Jednak jeśli uruchomisz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy, określając, czy czekać na wszystkie operacje lub inne czynności do wykonania. W tym przypadku używasz <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 To przeciążenie określa limit czasu. Jeśli interwał określony przez `timeout` wygasa parametr, ten składnik wywołuje <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> spowoduje zgłoszenie wyjątku.  
  
 Nie należy używać wywołania asynchronicznego <xref:System.Messaging.MessageQueue.BeginReceive%2A> z transakcji. Jeśli chcesz przeprowadzić transakcyjnych operację asynchroniczną, wywołaj <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieścić (synchronicznego) i transakcji <xref:System.Messaging.MessageQueue.Receive%2A> metody w ramach programu obsługi zdarzeń, możesz utworzyć dla operacji podglądu. Procedury obsługi zdarzenia może zawierać funkcji, jak pokazano w poniższym kodzie języka C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchronicznej operacji odbioru. Przykład kodu tworzy program obsługi zdarzeń `MyReceiveCompleted`i dołącza je do <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegata obsługi zdarzeń. Następnie wywołuje kod przykład wysyła komunikat do kolejki wiadomości lokalnych <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, przekazując wartość limitu czasu w ciągu dziesięciu sekund. Gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane, program obsługi zdarzeń odbiera komunikat i zapisuje treść komunikatu do ekranu.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie ponieważ reprezentuje on liczbą ujemną.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> oznacza to, interwał czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="stateObject">Obiekt stanu określonym przez aplikację, która zawiera informacje związane z operacją asynchroniczną.</param>
        <summary>Inicjuje asynchronicznego odbioru operacji, która ma określony limit czasu i obiektu określonego stanu, który zawiera skojarzone informacje w okresie istnienia wykonać operację. Operacja nie została zakończona, aż upłynie limit czasu lub komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Określający przesłanego żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego używasz <xref:System.Messaging.MessageQueue.BeginReceive%2A> podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, kiedy wiadomość staje się dostępna w kolejce lub określony przedział czasu utracił ważność.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> jest także generowany, jeśli istnieje już wiadomość w kolejce.  
  
 To przeciążenie umożliwia kojarzenie informacji za pomocą operacji, które zostaną zachowane w okresie istnienia wykonać operację. Program obsługi zdarzeń może wykryć te informacje, analizując <xref:System.IAsyncResult.AsyncState%2A> właściwość <xref:System.IAsyncResult> skojarzony z operacją.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, utworzyć program obsługi zdarzeń, która przetwarza wyniki operacji asynchronicznych i skojarzyć ją z Twojej delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Inicjuje asynchroniczne otrzymywać operacji. <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, po umieszczeniu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Mogą następnie uzyskiwać dostęp do wiadomości, wywołując <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub pobierania za pomocą wynik <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończone, dopóki program obsługi zdarzeń jest wywoływany.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczna, można wywołać go do odebrania komunikatu z kolejki, bez blokuje bieżący wątek wykonywania. Aby synchronicznie pojawi się komunikat, należy użyć <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w program obsługi zdarzeń, aby nadal mieć dostęp do powiadomień.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Zwraca identyfikuje operację asynchroniczną, która metoda pracę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, mimo że można zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest wywoływana. Jednak jeśli uruchomisz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy, określając, czy czekać na wszystkie operacje lub inne czynności do wykonania. W tym przypadku używasz <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 To przeciążenie określa limit czasu i obiektu stanu. Jeśli interwał określony przez `timeout` wygasa parametr, ten składnik wywołuje <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> spowoduje zgłoszenie wyjątku.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginReceive%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielny stan, który zdefiniujesz.  
  
 Obiekt stanu można również użyć do przekazywania informacji między wątkami procesu. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne jest w innym wątku asynchronicznego scenariusza, obiekt stanu jest zorganizowany i przekazywane ponownie wraz z informacjami od zdarzenia.  
  
 Nie należy używać wywołania asynchronicznego <xref:System.Messaging.MessageQueue.BeginReceive%2A> z transakcji. Jeśli chcesz przeprowadzić transakcyjnych operację asynchroniczną, wywołaj <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieścić (synchronicznego) i transakcji <xref:System.Messaging.MessageQueue.Receive%2A> metody w ramach programu obsługi zdarzeń, możesz utworzyć dla operacji podglądu. Procedury obsługi zdarzenia może zawierać funkcji, jak pokazano w poniższym kodzie języka C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchronicznej operacji odbioru. Przykład kodu tworzy program obsługi zdarzeń `MyReceiveCompleted`i dołącza je do <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegata obsługi zdarzeń. Następnie wywołuje kod przykład wysyła komunikat do kolejki wiadomości lokalnych <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, przekazując wartość limitu czasu w ciągu dziesięciu sekund oraz unikatowa liczba całkowita, która identyfikuje tego konkretnego komunikatu. Gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane, program obsługi zdarzeń odbiera komunikat i zapisuje treści komunikatu i identyfikator wiadomości liczby całkowitej do ekranu.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> oznacza to, interwał czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="stateObject">Obiekt stanu określonym przez aplikację, która zawiera informacje związane z operacją asynchroniczną.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Który będą otrzymywać powiadomienia o zakończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje asynchronicznego odbioru operacji, która ma określony limit czasu i obiektu określonego stanu, który zawiera skojarzone informacje w okresie istnienia wykonać operację. To przeciążenie odbiera powiadomienie za pośrednictwem wywołania zwrotnego, tożsamość programu obsługi zdarzeń dla tej operacji. Operacja nie została zakończona, aż upłynie limit czasu lub komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Określający przesłanego żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy używasz tego przeciążenia, wywołania zwrotnego, określona w parametrze wywołania zwrotnego jest bezpośrednio wywoływany, gdy komunikat o stanie się dostępny, w kolejce lub określony przedział czasu upłynął; <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane w nie. Inne przeciążenia <xref:System.Messaging.MessageQueue.BeginReceive%2A> zależą od tego składnika, aby podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> jest także generowany, jeśli istnieje już wiadomość w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, utworzyć program obsługi zdarzeń, która przetwarza wyniki operacji asynchronicznych i skojarzyć ją z Twojej delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Inicjuje asynchroniczne otrzymywać operacji. <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, po umieszczeniu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Mogą następnie uzyskiwać dostęp do wiadomości, wywołując <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub pobierania za pomocą wynik <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończone, dopóki program obsługi zdarzeń jest wywoływany.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczna, można wywołać go do odebrania komunikatu z kolejki, bez blokuje bieżący wątek wykonywania. Aby synchronicznie pojawi się komunikat, należy użyć <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w program obsługi zdarzeń, aby nadal mieć dostęp do powiadomień.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Zwraca identyfikuje operację asynchroniczną, która metoda pracę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, mimo że można zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest wywoływana. Jednak jeśli uruchomisz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy, określając, czy czekać na wszystkie operacje lub inne czynności do wykonania. W tym przypadku używasz <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginReceive%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielny stan, który zdefiniujesz.  
  
 Obiekt stanu można również użyć do przekazywania informacji między wątkami procesu. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne jest w innym wątku asynchronicznego scenariusza, obiekt stanu jest zorganizowany i przekazywane ponownie wraz z informacjami od zdarzenia.  
  
 Nie należy używać wywołania asynchronicznego <xref:System.Messaging.MessageQueue.BeginReceive%2A> z transakcji. Jeśli chcesz przeprowadzić transakcyjnych operację asynchroniczną, wywołaj <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieścić (synchronicznego) i transakcji <xref:System.Messaging.MessageQueue.Receive%2A> metody w ramach programu obsługi zdarzeń, możesz utworzyć dla operacji podglądu. Procedury obsługi zdarzenia może zawierać funkcji, jak pokazano w poniższym kodzie języka C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchronicznej operacji odbioru. Następnie wywołuje kod przykład wysyła komunikat do kolejki wiadomości lokalnych <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, przekazując: wartość limitu czasu w ciągu dziesięciu sekund; unikatowa liczba całkowita, która identyfikuje tego konkretnego komunikatu; i nowe wystąpienie klasy <xref:System.AsyncCallback> programu obsługi zdarzeń, które identyfikują `MyReceiveCompleted`. Gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane, program obsługi zdarzeń odbiera komunikat i zapisuje treści komunikatu i identyfikator wiadomości liczby całkowitej do ekranu.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> oznacza to, interwał czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określonej pozycji w kolejce komunikatów.</param>
        <param name="state">Obiekt stanu określonym przez aplikację, która zawiera informacje związane z operacją asynchroniczną.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> , Która otrzymuje powiadomienia o zakończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje asynchronicznego odbioru operacji, która ma określony limit czasu i korzysta z określonego kursora i obiektu określonego stanu. Obiekt stanu informacje skojarzone w okresie istnienia operacji. To przeciążenie odbiera powiadomienie za pośrednictwem wywołania zwrotnego, tożsamość programu obsługi zdarzeń dla tej operacji. Operacja nie została zakończona, aż upłynie limit czasu lub komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Określający przesłanego żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy używasz tego przeciążenia, wywołania zwrotnego, określona w parametrze wywołania zwrotnego jest bezpośrednio wywoływany, gdy komunikat o stanie się dostępny, w kolejce lub określony przedział czasu upłynął; <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane w nie. Inne przeciążenia <xref:System.Messaging.MessageQueue.BeginReceive%2A> zależą od tego składnika, aby podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> jest także generowany, jeśli istnieje już wiadomość w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, utworzyć program obsługi zdarzeń, która przetwarza wyniki operacji asynchronicznych i skojarzyć ją z Twojej delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Inicjuje asynchroniczne otrzymywać operacji. <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, po umieszczeniu komunikatu w kolejce. <xref:System.Messaging.MessageQueue> Mogą następnie uzyskiwać dostęp do wiadomości, wywołując <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub pobierania za pomocą wynik <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończone, dopóki program obsługi zdarzeń jest wywoływany.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczna, można wywołać go do odebrania komunikatu z kolejki, bez blokuje bieżący wątek wykonywania. Aby synchronicznie pojawi się komunikat, należy użyć <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, można wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w program obsługi zdarzeń, aby nadal mieć dostęp do powiadomień.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Zwraca identyfikuje operację asynchroniczną, która metoda pracę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, mimo że można zwykle nie jest używana do momentu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest wywoływana. Jednak jeśli uruchomisz kilka operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy, określając, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołasz <xref:System.Messaging.MessageQueue.BeginReceive%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielny stan, który zdefiniujesz.  
  
 Obiekt stanu można również użyć do przekazywania informacji między wątkami procesu. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne jest w innym wątku asynchronicznego scenariusza, obiekt stanu jest zorganizowany i przekazywane ponownie wraz z informacjami od zdarzenia.  
  
 Nie należy używać wywołania asynchronicznego <xref:System.Messaging.MessageQueue.BeginReceive%2A> z transakcji. Jeśli chcesz przeprowadzić transakcyjnych operację asynchroniczną, wywołaj <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieścić (synchronicznego) i transakcji <xref:System.Messaging.MessageQueue.Receive%2A> metody w ramach programu obsługi zdarzeń, możesz utworzyć dla operacji podglądu. Procedury obsługi zdarzenia może zawierać funkcji, jak pokazano w poniższym kodzie języka C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Messaging.MessageQueue" /> może zostać odczytany.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Messaging.MessageQueue" /> istnieje i aplikacji może odczytywać dane z; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> Wskazuje, czy aplikacja jest w stanie wgląd ani odbierać wiadomości z kolejki. Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `true`, <xref:System.Messaging.MessageQueue> może odbierać lub wgląd do wiadomości z kolejki. W przeciwnym razie nie.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false` Jeśli kolejka jest już otwarty z wyłącznego dostępu do odczytu (lub jeśli jest on otwarty z dostępem do niewyłączną i to <xref:System.Messaging.MessageQueue> żądań wyłącznego dostępu), czy aplikacja nie ma wystarczających praw dostępu do niego. Jeśli Twoja aplikacja próbuje odczytany z kolejki po <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, dostęp jest zabroniony.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.CanRead%2A> właściwości.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Messaging.MessageQueue" /> mogą być zapisywane.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Messaging.MessageQueue" /> istnieje i aplikacja może zapisywać do niego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> Wskazuje, czy aplikacja może wysyłać komunikaty do kolejki. Jeśli <xref:System.Messaging.MessageQueue.CanWrite%2A> jest `true`, <xref:System.Messaging.MessageQueue> może wysyłać komunikaty do kolejki. W przeciwnym razie nie.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> jest `false` Jeśli kolejka jest już otwarty z wyłączny dostęp do zapisu (lub jeśli jest on otwarty z dostępem do niewyłączną i to <xref:System.Messaging.MessageQueue> żądań wyłącznego dostępu), czy aplikacja nie ma wystarczających praw dostępu do niego. Jeśli Twoja aplikacja próbuje zapisać do kolejki po <xref:System.Messaging.MessageQueue.CanWrite%2A> jest `false`, dostęp jest zabroniony.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.CanWrite%2A> właściwości.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kategorię kolejki.</summary>
        <value>A <see cref="T:System.Guid" /> reprezentujący kategorii kolejki (usługi kolejkowania komunikatów typu identifier), która umożliwia aplikacji do kategoryzowania kolejkach. Wartość domyślna to <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kategoria kolejki umożliwia aplikacji do kategoryzowania kolejkach. Na przykład można umieścić wszystkie kolejki rozliczeń w jednej kategorii i wszystkich kolejek zamówienia w innym.  
  
 <xref:System.Messaging.MessageQueue.Category%2A> Właściwości zapewnia dostęp do właściwości identyfikator typu usługi kolejkowania komunikatów (czyli odczytu/zapisu), dostępne za pośrednictwem **właściwości kolejki** okno dialogowe, w konsoli zarządzania komputerem. Można zdefiniować nową kategorię. Chociaż można używać <xref:System.Guid.NewGuid%2A> można utworzyć wartości kategorii, która jest unikatowa dla wszystkich <xref:System.Guid> wartości, taka akcja nie jest konieczne. Wartość kategorii musi się różnić tylko z innych kategoriach, a nie od wszystkich pozostałych <xref:System.Guid> wartości. Na przykład możesz przypisać {00000000-0000-0000-0000-000000000001} jako <xref:System.Messaging.MessageQueue.Category%2A> dla jednego zestawu, kolejek i {00000000-0000-0000-0000-000000000002} jako <xref:System.Messaging.MessageQueue.Category%2A> dla innego zestawu.  
  
 Nie jest konieczne ustawić <xref:System.Messaging.MessageQueue.Category%2A>. Wartość może być `null`.  
  
 Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym, inne <xref:System.Messaging.MessageQueue> wystąpienia ma wpływ zmiany.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.Category%2A> właściwości.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kategoria kolejka została ustawiona na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści pamięć podręczną połączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wywołujesz <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>nazwy formatu, przechowywane w pamięci podręcznej są usuwane i obsługuje otwarte i przechowywane w pamięci podręcznej są zamknięte.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy kod wywoła przykład <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby przydzielone przez <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> zwalnia wszystkie zasoby skojarzone z <xref:System.Messaging.MessageQueue>, łącznie z udostępnionych zasobów, jeśli to stosowne. System ponownie uzyskuje te zasoby automatycznie, jeśli są one nadal dostępne, na przykład gdy wywołujesz <xref:System.Messaging.MessageQueue.Send%28System.Object%29> metodę, tak jak w poniższym kodzie języka C#.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Gdy wywołujesz <xref:System.Messaging.MessageQueue.Close%2A>, wszystkie <xref:System.Messaging.MessageQueue> właściwości, które uzyskiwania bezpośredniego dostępu do kolejki usługi kolejkowania komunikatów są wyczyszczone. <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, I <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> pozostawienie wszystkich znajdowały się.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> nie zawsze bezpłatnych odczytu i zapisu dojścia do kolejki, ponieważ mogą one być udostępniane. Można wykonać jedną z następujących czynności, aby upewnić się, że <xref:System.Messaging.MessageQueue.Close%2A> zwalnia obsługuje Odczyt i zapis do kolejki:  
  
-   Utwórz <xref:System.Messaging.MessageQueue> z wyłącznego dostępu. Aby to zrobić, należy wywołać <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> lub <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> konstruktora, a następnie ustaw `sharedModeDenyReceive` parametr `true`.  
  
-   Utwórz <xref:System.Messaging.MessageQueue> przy użyciu połączenia buforowania wyłączone. Aby to zrobić, należy wywołać <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i zestaw `enableConnectionCache` parametr `false`.  
  
-   Wyłącz buforowanie połączenia. Aby to zrobić, należy ustawić <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> właściwość `false`.  
  
 Należy wywołać <xref:System.Messaging.MessageQueue.Close%2A> kolejki przed usunięciem kolejki na serwer usługi kolejkowania komunikatów. W przeciwnym razie komunikatów wysłanych do kolejki może zgłaszać wyjątki lub pojawiają się w kolejce wiadomości utraconych.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu zamyka kolejki usługi kolejkowania komunikatów.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową kolejkę w określonej ścieżce na serwerze usługi kolejkowania komunikatów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do kolejki, która zostanie utworzona.</param>
        <summary>Tworzy nietransakcyjnej kolejki usługi kolejkowania komunikatów w określonej ścieżce.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueue" /> reprezentujący nową kolejkę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia utworzenie nietransakcyjnej kolejki usługi kolejkowania komunikatów.  
  
 Aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy w aplikacji i powiązać istniejącej kolejki, użyj <xref:System.Messaging.MessageQueue.%23ctor%2A> konstruktora. Aby utworzyć nową kolejkę w usługi kolejkowania komunikatów, należy wywołać <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Składnia `path` parametru zależy od typu kolejki jego odwołania, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
  
 Użyj "." na komputerze lokalnym. Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kolejek publicznych i prywatnych. Wysyła komunikat do wybranych kolejek.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest <see langword="null" /> lub jest pustym ciągiem ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka jest już istnieje w określonej ścieżce.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do kolejki, która zostanie utworzona.</param>
        <param name="transactional">
          <see langword="true" /> Aby utworzyć kolejkę transakcyjną; <see langword="false" /> można utworzyć kolejki nietransakcyjnej.</param>
        <summary>Tworzy transakcyjnej lub nietransakcyjnej kolejki usługi kolejkowania komunikatów w określonej ścieżce.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueue" /> reprezentujący nową kolejkę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby utworzyć kolejkę transakcyjną w usługi kolejkowania komunikatów, można użyć tego przeciążenia. Można utworzyć kolejkę nietransakcyjnej, ustawiając `transactional` parametr `false` lub przez wywołanie innego przeciążenia <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy w aplikacji i powiązać istniejącej kolejki, użyj <xref:System.Messaging.MessageQueue.%23ctor%2A> konstruktora. Aby utworzyć nową kolejkę w usługi kolejkowania komunikatów, należy wywołać <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Składnia `path` parametru zależy od typu kolejki jego odwołania, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
  
 Użyj "." na komputerze lokalnym. Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy transakcyjnych kolejek publicznych i prywatnych. Wysyła komunikat do wybranych kolejek.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest <see langword="null" /> lub jest pustym ciągiem ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka jest już istnieje w określonej ścieżce.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Messaging.Cursor" /> bieżącego kolejki wiadomości.</summary>
        <returns>Nowy <see cref="T:System.Messaging.Cursor" /> bieżącego kolejki wiadomości. Ten kursor jest używany do obsługi określonych lokalizacji w kolejce, podczas czytania wiadomości z kolejki.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera godzinę i datę utworzenia kolejki kolejkowania komunikatów.</summary>
        <value>A <see cref="T:System.DateTime" /> reprezentujący datę i godzinę utworzenia kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> odwołuje się do kolejki na serwer usługi kolejkowania komunikatów nie <xref:System.Messaging.MessageQueue> wystąpienia.  
  
 Jeśli kolejka istnieje, ta właściwość reprezentuje czas utworzenia kolejki dostosowana do czasu lokalnego serwera, na którym znajduje się kolejka.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.CreateTime%2A> właściwości.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia komunikat o wartości właściwości, używany domyślnie, gdy aplikacja wysyła komunikaty do kolejki.</summary>
        <value>A <see cref="T:System.Messaging.DefaultPropertiesToSend" /> zawierający kolejkowania wiadomości właściwości wartości domyślne używane, gdy aplikacja wysyła obiektów innych niż <see cref="T:System.Messaging.Message" /> wystąpień do kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wyślesz do dowolnego obiektu, który nie jest typu <xref:System.Messaging.Message> do kolejki, <xref:System.Messaging.MessageQueue> wstawia obiektu do komunikatów usługi kolejkowania komunikatów. W tym czasie <xref:System.Messaging.MessageQueue> dotyczy komunikat wartości właściwości określonej w <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> właściwości. Z drugiej strony Jeśli wyślesz <xref:System.Messaging.Message> do kolejki, te właściwości są już określone dla tego wystąpienia, więc <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> jest ignorowany dla <xref:System.Messaging.Message>.  
  
 Mimo że można ustawić właściwości, za pośrednictwem <xref:System.Messaging.MessageQueue> obiektu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> odwołuje się do właściwości wiadomości, które są wysyłane do kolejki, a nie samej kolejki.  
  
 W poniższej tabeli przedstawiono wartości domyślne dla właściwości.  
  
|Właściwość|Wartość domyślna|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Zero (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|Pusty ciąg ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu używa priorytetu wiadomości, aby określić domyślne właściwości do wysyłania wiadomości.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Domyślne właściwości nie można ustawić dla kolejki, prawdopodobnie ponieważ jedna z właściwości jest nieprawidłowa.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizacja kolejki do usunięcia.</param>
        <summary>Usuwa kolejkę na serwerze usługi kolejkowania komunikatów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnia `path` parametru zależy od typu kolejki.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
  
 Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwości.  
  
 Alternatywnie, można użyć <xref:System.Messaging.MessageQueue.FormatName%2A> lub <xref:System.Messaging.MessageQueue.Label%2A> do opisania na ścieżkę kolejki.  
  
|Tematy pomocy|Składnia|  
|---------------|------------|  
|Nazwa formatu|FormatName: [ *nazwę formatu* ]|  
|Etykieta|Etykieta: [ *etykiety* ]|  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa kolejki usługi kolejkowania komunikatów, jeśli taki istnieje.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest <see langword="null" /> lub jest pustym ciągiem ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Składnia <paramref name="path" /> parametr jest nieprawidłowy.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy to <see cref="T:System.Messaging.MessageQueue" /> ma już wyłączny dostęp do odbierania komunikatów z kolejki usługi kolejkowania komunikatów.</summary>
        <value>
          <see langword="true" /> Jeśli ten <see cref="T:System.Messaging.MessageQueue" /> ma prawa wyłączności do odbierania komunikatów z kolejki; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Określa tryb udostępniania kolejki przywoływane przez to <xref:System.Messaging.MessageQueue>. Ustaw <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> do `true` aby wskazać, że tylko to <xref:System.Messaging.MessageQueue> powinni mieć dostęp do wglądu i odbiera komunikaty z kolejki z określonym <xref:System.Messaging.MessageQueue.Path%2A>. Jeśli w kolejnym <xref:System.Messaging.MessageQueue> lub innej aplikacji jest skojarzony z tego samego zasobu kolejki tego wystąpienia lub aplikacja nie będzie wgląd ani odbierać wiadomości, ale nadal można wysyłać je.  
  
 Jeśli <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> jest `false`, kolejka jest dostępne dla wielu aplikacji do wysyłania, wgląd i odbierania komunikatów.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> właściwości.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Usuwa zasoby (inne niż pamięć) używane przez <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> po zakończeniu przy użyciu <xref:System.Messaging.MessageQueue>. <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> Pozostawia metoda <xref:System.Messaging.MessageQueue> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, trzeba zwolnić wszystkie odwołania do <xref:System.Messaging.MessageQueue> , dzięki czemu można odzyskać pamięć zajmowaną przez jej przez wyrzucanie elementów bezużytecznych.  
  
 Należy wywołać <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> przed publikacją swoje ostatnie odwołanie do <xref:System.Messaging.MessageQueue>. W przeciwnym razie zasoby <xref:System.Messaging.MessageQueue> jest przy użyciu nie zostanie zwolniona, aż do wywołania kolekcji wyrzucania elementów <xref:System.Messaging.MessageQueue> destruktor obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy pamięć podręczną w połączeń będzie obsługiwany przez aplikację.</summary>
        <value>
          <see langword="true" /> Tworzenie i używanie pamięci podręcznej połączenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pamięć podręczna połączenia znajduje się lista odwołania do struktury, które zawierają odczytu lub zapisu dojścia do kolejki. Gdy <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> jest `true`, <xref:System.Messaging.MessageQueue> pożycza uchwyty z pamięci podręcznej w każdym wywołaniu <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, lub <xref:System.Messaging.MessageQueue.Receive%2A>, zamiast otwartych dojść nowe. Może to poprawić wydajność. Używanie pamięci podręcznej połączenia również powoduje, że <xref:System.Messaging.MessageQueue> od zmian w topologii sieci.  
  
 Jeśli tworzysz nowe połączenie do kolejki po zapełnieniu pamięci podręcznej połączenia <xref:System.Messaging.MessageQueue> zastępuje co najmniej ostatnio używanych struktury o nowe połączenie. Należy wyczyścić pamięć podręczną całkowicie przez wywołanie metody <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, na przykład, jeśli nazwy formatu kolejki pracujesz z zostały zmienione, tak aby poprzedniego odczytu i zapisu, dojścia nie są już prawidłowe.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> właściwości.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kolejka akceptuje tylko nieprywatny (niezaszyfrowane) wiadomości.</summary>
        <value>Jedną z <see cref="T:System.Messaging.EncryptionRequired" /> wartości. Wartość domyślna to <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kiedy określasz, że szyfrowanie jest wymagane dla komunikatów wysyłanych do kolejki, są szyfrowane tylko treści wiadomości. Inni członkowie (na przykład <xref:System.Messaging.Message.Label%2A> i <xref:System.Messaging.Message.SenderId%2A> właściwości) nie może być szyfrowana.  
  
 Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym, inne <xref:System.Messaging.MessageQueue> wystąpienia ma wpływ zmiany.  
  
 Szyfrowania wiadomości sprawia, że wiadomości prywatnej. Można określić wymaganie szyfrowania kolejki być `None`, `Body`, lub `Optional` , ustawiając <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> właściwość odpowiednio. <xref:System.Messaging.Message.UseEncryption%2A> Ustawienie komunikacie musi odpowiadać Wymaganie szyfrowania kolejki. Jeśli komunikat nie jest zaszyfrowane, ale Określa kolejki `Body`, czy komunikat jest zaszyfrowane, ale Określa kolejki `None`, komunikat zostanie odrzucone przez kolejkę. Jeśli żądań aplikacji wysyłającej wiadomość potwierdzająca, w tym zdarzeniu, kolejkowania wskazuje odrzucenia wiadomości do aplikacji wysyłającej. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwość `true`, komunikat, który zakończy się niepowodzeniem, szyfrowanie jest wysyłany do kolejki utraconych wiadomości. W przeciwnym razie komunikat zostanie utracony.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> właściwości.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Określający na zakończenie operacji asynchronicznej wglądu i z których można pobrać wynik końcowy.</param>
        <summary>Wykonuje operację określonego podglądu asynchronicznego.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Skojarzone z ukończoną operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> zakończeniu operacji, który został zainicjowany przez <xref:System.Messaging.MessageQueue.BeginPeek%2A> wywołania. Aby to zrobić, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> dokonuje wiadomości.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> można określić limit czasu, co powoduje, że <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenia wywoływane, jeśli limit czasu upłynie, zanim zostanie wyświetlony komunikat w kolejce. Gdy upłynie limit czasu bez wiadomości przychodzącej w kolejce, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> zgłasza wyjątek.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> Służy do odczytywania komunikatów, który spowodował <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenia.  
  
 Jeśli chcesz nadal asynchronicznie podglądu komunikatów, możesz ponownie wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> po wywołaniu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyPeekCompleted`, dołącza go do <xref:System.Messaging.MessageQueue.PeekCompleted> delegata obsługi zdarzeń i wywołania <xref:System.Messaging.MessageQueue.BeginPeek%2A> można zainicjować operacji asynchronicznych wglądu w kolejce, która znajduje się w ścieżce ". \myQueue". Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane, w przykładzie dokonuje wiadomości i zapisuje jego treść na ekranie. Przykład następnie wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> ponownie, aby zainicjować nową operację asynchroniczną podglądu.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Składnia <paramref name="asyncResult" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Określający asynchroniczną otrzymywać na zakończenie operacji i z których można pobrać wynik końcowy.</param>
        <summary>Kończy określony asynchronicznych operacji odbioru.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Skojarzone z ukończoną operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> zakończeniu operacji, który został zainicjowany przez <xref:System.Messaging.MessageQueue.BeginReceive%2A> wywołania. Aby to zrobić, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> odbiera komunikat.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> można określić limit czasu, co powoduje, że <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenia wywoływane, jeśli limit czasu upłynie, zanim zostanie wyświetlony komunikat w kolejce. Gdy upłynie limit czasu bez wiadomości przychodzącej w kolejce, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> zgłasza wyjątek.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest używany do odczytu (usuwania z kolejki), wiadomości, który spowodował <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenia.  
  
 Jeśli chcesz kontynuować asynchronicznie otrzymywać wiadomości, można ponownie wywołać <xref:System.Messaging.MessageQueue.BeginReceive%2A> po wywołaniu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy powiązanie żądań asynchronicznych. Założono, że istnieje kolejki na komputerze lokalnym, o nazwie "myQueue". `Main` Funkcja rozpoczyna operację asynchroniczną, która jest obsługiwana przez `MyReceiveCompleted` procedury. `MyReceiveCompleted` przetwarza bieżącego komunikatu i rozpoczyna nową asynchronicznych operacji odbioru.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Składnia <paramref name="asyncResult" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizacja kolejki, aby znaleźć.</param>
        <summary>Określa, czy kolejka usługi kolejkowania komunikatów istnieje w określonej ścieżce.</summary>
        <returns>
          <see langword="true" /> Jeśli istnieje kolejka o określonej ścieżki w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Metoda określa, czy kolejka usługi kolejkowania komunikatów istnieje w określonej ścieżce. Nie istnieje metoda można określić, czy istnieje kolejka o nazwie określonego formatu. Aby uzyskać więcej informacji na temat składni nazwy formatu i inne formy składnia ścieżki, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwości.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> jest kosztowną operacją. Go użyć tylko w przypadku, gdy jest to konieczne w aplikacji.  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Nie obsługuje metody <xref:System.Messaging.MessageQueue.FormatName%2A> prefiks.  
  
 Składnia `path` parametru zależy od typu kolejki, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Nie można wywołać sprawdzał, czy zdalny kolejki prywatnej.  
  
 Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwości.  
  
 Alternatywnie, można użyć <xref:System.Messaging.MessageQueue.Label%2A> do opisania na ścieżkę kolejki.  
  
|Tematy pomocy|Składnia|  
|---------------|------------|  
|Etykieta|Etykieta: [ `label` ]|  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, czy kolejka usługi kolejkowania komunikatów istnieje, a następnie usuwa je.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Składnia jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.  
  
—lub— 
<see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> Metoda jest wywoływana w zdalnym kolejki prywatnej</exception>
        <exception cref="T:System.InvalidOperationException">Aplikacja używa Składnia nazwy formatu podczas weryfikowania istnienie kolejki.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę unikatowy kolejki usługi kolejkowania komunikatów generowane podczas tworzenia kolejki.</summary>
        <value>Nazwa kolejki, która jest unikatowa w sieci.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A> Właściwość zawiera nazwę formatu kolejki. Usługa kolejkowania komunikatów używa nazwy formatu do identyfikowania kolejki, które można otworzyć i uzyskiwania dostępu do niego. W przeciwieństwie do większości właściwości kolejki nazwę formatu nie jest właściwością usługi kolejkowania komunikatów kolejki aplikacji, dzięki czemu za pomocą narzędzia do zarządzania usługi kolejkowania komunikatów nie można do niego dostęp. Nazwa formatu jest po prostu unikatową nazwę dla tej kolejki usługi kolejkowania komunikatów generowany podczas tworzenia kolejki lub generująca później w aplikacji.  
  
 Jeśli określisz ścieżki, za pomocą składni nazwy ścieżki (takie jak `myComputer\myQueue`) zamiast używania Składnia nazwy formatu podczas odczytu lub zapisu w kolejce, wykonuje translację na podstawowym kontrolerze domeny (który używa usługi Active Directory) <xref:System.Messaging.MessageQueue.Path%2A> do skojarzonego <xref:System.Messaging.MessageQueue.FormatName%2A> przed uzyskaniem dostępu do kolejki. Jeśli aplikacja działa w trybie offline, należy użyć składni nazwy formatu; w przeciwnym razie nie będzie dostępny, aby wykonać tłumaczenie ścieżki podstawowego kontrolera domeny.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.FormatName%2A> właściwości.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Nie jest ustawiona.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element formatujący używany do serializacji obiektu na lub deserializacji obiektu z treści wiadomości, odczytać lub zapisywane do kolejki.</summary>
        <value>
          <see cref="T:System.Messaging.IMessageFormatter" /> Która wytwarza strumień być zapisywane lub odczytać ich z treści wiadomości. Wartość domyślna to <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A> Właściwość zawiera wystąpienie obiektu programu formatującego, który przekształca wiadomości, gdy aplikacja odczytuje lub zapisuje do kolejki.  
  
 Gdy aplikacja wysyła komunikat do kolejki, element formatujący serializuje obiekt w strumieniu i wstawia je do treści wiadomości. Podczas czytania z kolejki, element formatujący deserializuje dane wiadomości do <xref:System.Messaging.Message.Body%2A> właściwość <xref:System.Messaging.Message>.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno powiązane, więc nie ma tego samego obiektu, wpisz na nadawcy i odbiorcy, korzystając z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> i <xref:System.Messaging.BinaryMessageFormatter> serializowania danych do reprezentacji binarnej. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany podczas wysyłania lub odbierania składników COM.  
  
 <xref:System.Messaging.BinaryMessageFormatter> i <xref:System.Messaging.ActiveXMessageFormatter> zapewniają większą przepustowość, niż <xref:System.Messaging.XmlMessageFormatter>. <xref:System.Messaging.ActiveXMessageFormatter> Umożliwia współdziałanie z aplikacjami usługi kolejkowania komunikatów w języku Visual Basic 6.0.  
  
 Gdy aplikacja wysyła komunikaty do kolejki, <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> ma zastosowanie tylko do tych wiadomości, które domyślne właściwości wiadomości, użyj <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Jeśli wyślesz <xref:System.Messaging.Message> do kolejki usługi kolejkowania komunikatów używa program formatujący zdefiniowane w <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwość, aby zamiast tego zserializować treść.  
  
 <xref:System.Messaging.MessageQueue> Zawsze będzie korzystać z klasy <xref:System.Messaging.Message> odbierać lub wgląd do wiadomości z kolejki. Komunikat jest deserializacji za pomocą <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, formatowania w treści wiadomości przy użyciu <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Poniższy przykład kodu demonstruje, formatowania w treści wiadomości przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie komunikaty, które znajdują się w kolejce.</summary>
        <returns>Tablica typu <see cref="T:System.Messaging.Message" /> reprezentujący wszystkie komunikaty w kolejce, w tej samej kolejności, w jakiej występują w kolejki usługi kolejkowania komunikatów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Zwraca statycznej migawki wiadomości w kolejce, linki nie dynamicznie te komunikaty. W związku z tym nie można używać tablicy do modyfikowania wiadomości w kolejce. Jeśli w czasie rzeczywistym, dynamicznych interakcji z kolejki (na przykład możliwość usunięcia wiadomości), należy wywołać <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> metody, która zwraca dynamiczną listę komunikatów w kolejce.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.GetAllMessages%2A> zwraca kopię wiadomości w kolejce w momencie wywołania tej metody, tablica nie uwzględnia nowych wiadomości przychodzące w kolejce lub wiadomości, które są usuwane z kolejki.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> pobiera tylko te właściwości, które nie zostały odfiltrowane przez <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wylicza komunikaty w kolejce. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> jest przestarzały. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> należy użyć.</summary>
        <returns>A <see cref="T:System.Collections.IEnumerator" /> zapewniającej połączenia dynamicznego do wiadomości w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nazwa komputera, który zawiera kolejki, bez dwóch poprzednich ukośniki odwrotne (\\\\).</param>
        <summary>Pobiera identyfikator komputera, na którym kolejki odwołuje się ten <see cref="T:System.Messaging.MessageQueue" /> znajduje się.</summary>
        <returns>A <see cref="T:System.Guid" /> który reprezentuje unikatowy identyfikator dla komputera, na którym znajduje się kolejka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator komputera można użyć do dwóch celów, między innymi: do odczytywania dziennika komputera i ustaw opcję certyfikaty zabezpieczeń. Jednak nie można wywołać <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> dla komputera zdalnego, podczas pracy w trybie offline, ponieważ aplikacja musi mieć dostęp do usługi katalogowej na kontrolerze domeny.  
  
 Identyfikator komputera (lub identyfikatora urządzenia) jest <xref:System.Guid> tworzącą usługi kolejkowania komunikatów po dodaniu komputera do organizacji. Usługa kolejkowania komunikatów łączy identyfikator komputera za pomocą `Machine` i `Journal` słów kluczowych, aby utworzyć nazwę formatu dziennika maszyny, która ma składnię `Machine=<computeridentifier>;Journal`. Komunikaty arkusza komputera, który jest również znane jako kolejki dziennika jest kolejką systemu, która przechowuje kopie generowanych przez aplikację, kiedy <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> właściwość `true`.  
  
 Ta składnia dla dziennika jest prawidłowy tylko podczas tworzenia nazwy formatu kolejki. Składnia nazwy ścieżki jest `MachineName` \\ `Journal$`.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośrednią nazwą formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy kod wywoła przykład <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Identyfikator komputera nie można pobrać, prawdopodobnie ponieważ usługa katalogowa nie jest dostępna; na przykład, jeśli praca w trybie offline.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt modułu wyliczającego dla wszystkich komunikatów w kolejce. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> jest przestarzały. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> należy użyć.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" /> Komunikatów, które są zawarte w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> tworzy dynamiczne listę wszystkich komunikatów w kolejce. Możesz usunąć z kolejki komunikat wyświetlany u bieżącej pozycji modułu wyliczającego, wywołując <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> dla <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> zwraca.  
  
 Ponieważ kursor jest skojarzony z dynamiczną listę komunikatów w kolejce, wyliczenia odzwierciedla wszelkie zmiany wprowadzone do wiadomości w kolejce wiadomości jest wyższy niż w bieżącej pozycji kursora. Na przykład moduł wyliczający mogą automatycznie uzyskiwać dostęp komunikat niższym priorytecie umieszczone poza bieżącej pozycji kursora, ale nie komunikat o wyższym priorytecie wstawiany przed tej pozycji. Jednak można zresetować wyliczenia, a tym samym przenieść kursor powrót do początku listy, przez wywołanie metody <xref:System.Messaging.MessageEnumerator.Reset%2A> dla <xref:System.Messaging.MessageEnumerator>.  
  
 Kolejność komunikatów w wyliczeniu odzwierciedla ich kolejność, w kolejce, dzięki czemu komunikaty o wyższym priorytecie pojawi się przed tymi niższym priorytecie.  
  
 Chcąc statycznej migawki do nich wiadomości w kolejce, a nie połączenia dynamicznego, należy wywołać <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Ta metoda zwraca tablicę <xref:System.Messaging.Message> obiektów, które reprezentują wiadomości w czasie, w wywołaniu metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera dynamiczną listę komunikatów w kolejce i zlicza wszystkie komunikaty z <xref:System.Messaging.Message.Priority%2A> właściwością <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt modułu wyliczającego dla wszystkich komunikatów w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" /> Komunikatów, które są zawarte w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> tworzy dynamiczne listę wszystkich komunikatów w kolejce. Możesz usunąć z kolejki komunikat wyświetlany u bieżącej pozycji modułu wyliczającego, wywołując <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> dla <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> zwraca.  
  
 Ponieważ kursor jest skojarzony z dynamiczną listę komunikatów w kolejce, wyliczenia odzwierciedla wszelkie zmiany wprowadzone do wiadomości w kolejce wiadomości jest wyższy niż w bieżącej pozycji kursora. Na przykład moduł wyliczający mogą automatycznie uzyskiwać dostęp komunikat niższym priorytecie umieszczone poza bieżącej pozycji kursora, ale nie komunikat o wyższym priorytecie wstawiany przed tej pozycji. Jednak można zresetować wyliczenia, a tym samym przenieść kursor powrót do początku listy, przez wywołanie metody <xref:System.Messaging.MessageEnumerator.Reset%2A> dla <xref:System.Messaging.MessageEnumerator>.  
  
 Kolejność komunikatów w wyliczeniu odzwierciedla ich kolejność, w kolejce, dzięki czemu komunikaty o wyższym priorytecie pojawi się przed tymi niższym priorytecie.  
  
 Chcąc statycznej migawki do nich wiadomości w kolejce, a nie połączenia dynamicznego, należy wywołać <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Ta metoda zwraca tablicę <xref:System.Messaging.Message> obiektów, które reprezentują wiadomości w czasie, w wywołaniu metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt modułu wyliczającego dla dynamiczną listę kolejek publicznych w sieci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia semantykę tylko do przodu kursora, aby wyliczyć wszystkich kolejek publicznych w sieci.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> który zapewnia dynamiczną listę wszystkich kolejek publicznych komunikatów w sieci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> zwraca wyliczenie wszystkich kolejek publicznych, które znajdują się w sieci.  
  
 Ponieważ kursor jest skojarzony z dynamiczną listę, wyliczenia odzwierciedla wszelkie zmiany wprowadzone na listę kolejek dla kolejek, usunięte lub dodane po bieżącej pozycji kursora. Dodatki lub usuwanie kolejek znajdujących się przed bieżącą pozycją kursora nie są uwzględniane. Na przykład moduł wyliczający mogą automatycznie uzyskiwać dostęp kolejki dołączany poza pozycja kursora, ale nie w jednym wstawiany przed tej pozycji. Jednak można zresetować wyliczenia, a tym samym przenieść kursor powrót do początku listy, przez wywołanie metody <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> dla <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Nie ma zdefiniowanej kolejności kolejek w sieci. Moduł wyliczający nie uporządkować je, na przykład według komputera, etykiety, stan publicznych lub prywatnych lub innych kryteriów dostępny.  
  
 Chcąc statycznej migawki kolejek na sieć zamiast połączenia dynamicznego do nich wywołać <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> lub <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Każda z tych dwóch metod zwraca tablicę <xref:System.Messaging.MessageQueue> obiektów, które reprezentują kolejki w momencie wywołania tej metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośrednią nazwą formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy kod wykonuje iterację przez wszystkie kolejki komunikatów w sieci i sprawdza, czy ścieżka dla każdej kolejki. Na koniec Wyświetla liczbę kolejek publicznych w sieci.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Element <see cref="T:System.Messaging.MessageQueueCriteria" /> zawierający kryteria używane do filtrowania kolejek komunikatów dostępne.</param>
        <summary>Zapewnia semantykę tylko do przodu kursora, aby wyliczyć wszystkich kolejek publicznych w sieci, które spełniają określone kryteria.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> zapewniający dynamiczną listę kolejek publicznych komunikatów w sieci, który spełnia ograniczenia określone przez <paramref name="criteria" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> zwraca listę wszystkich kolejek publicznych w sieci, które spełniają kryteria zdefiniowane w kryteriach aplikacji. Można określić, że odpowiednie kryteria, aby uwzględnić, na przykład kolejki czas tworzenia i modyfikacji, nazwę komputera, etykiety, kategorii lub dowolnej ich kombinacji.  
  
 Ponieważ kursor jest skojarzony z dynamiczną listę, wyliczenia odzwierciedla wszelkie zmiany wprowadzone do kolejki, która występuje po przekroczeniu bieżącej pozycji kursora. Zmiany do kolejek znajdujących się przed bieżącą pozycją kursora nie są uwzględniane. Na przykład moduł wyliczający mogą automatycznie uzyskiwać dostęp kolejki dołączany poza pozycja kursora, ale nie w jednym wstawiany przed tej pozycji. Jednak można zresetować wyliczenia, a tym samym przenieść kursor powrót do początku listy, przez wywołanie metody <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> dla <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Nie ma zdefiniowanej kolejności kolejek w sieci. Moduł wyliczający nie uporządkować je, na przykład według komputera, etykiety, stan publicznych lub prywatnych lub innych kryteriów dostępny.  
  
 Chcąc statycznej migawki kolejek na sieć zamiast połączenia dynamicznego do nich, określ kryteria dla <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> lub zadzwoń <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Każda z tych dwóch metod zwraca tablicę <xref:System.Messaging.MessageQueue> obiektów, które reprezentują kolejki w momencie wywołania tej metody. Wywoływanie <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, lub <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> zapewnia te same wyniki co wywołanie metody <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> przy użyciu kryteriów filtrowania <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, i <xref:System.Messaging.MessageQueue.MachineName%2A>, odpowiednio.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośrednią nazwą formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu iteruje kolejki komunikatów i wyświetla ścieżkę każdej kolejki, który został utworzony w ciągu ostatniego dnia i znajdujące się na komputerze "Mój komputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, z którego mają zostać pobrane znajdują się kolejki prywatne.</param>
        <summary>Umożliwia pobranie wszystkich kolejek prywatnych na określonym komputerze.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiekty odwołujące się kolejki prywatne pobrane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> pobiera migawkę statyczne kolejek na określonym komputerze.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr jest <see langword="null" /> ani być pustym ciągiem ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umożliwia pobranie wszystkich kolejek publicznych w sieci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia pobranie wszystkich kolejek publicznych w sieci.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiekty odwołujące się do pobrane kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, jeśli chcesz, aby uzyskać pełną listę wszystkich kolejek publicznych w sieci. Jeśli chcesz ograniczyć listę według określonych kryteriów, takich jak <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, lub godzina ostatniej modyfikacji użyć innego przeciążenia tej metody. (Można również użyć <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, lub <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> pobiera migawkę statyczne kolejek. Do interakcji z dynamiczną listę kolejek, należy użyć <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośrednią nazwą formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Element <see cref="T:System.Messaging.MessageQueueCriteria" /> zawierający kryteria używane do filtrowania kolejek.</param>
        <summary>Umożliwia pobranie wszystkich kolejek publicznych w sieci, które spełniają określone kryteria.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiekty odwołujące się do pobrane kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz filtrować wszystkich kolejek publicznych w sieci przez etykietę, kategorii lub nazwą komputera, <xref:System.Messaging.MessageQueue> klasa zawiera konkretnych metod, które zapewniają funkcjonalność (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, i <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>odpowiednio). To przeciążenie umożliwia pobranie listy wszystkich kolejek publicznych w sieci, które spełniają więcej niż jedno z tych kryteriów (na przykład, jeśli chcesz określić etykietę i kategorii). Można również filtrować według kryteriów komunikat inny niż <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, i <xref:System.Messaging.MessageQueue.MachineName%2A>. Na przykład użyć tego przeciążenia, aby filtrować według czasu ostatniej modyfikacji kolejki. Po prostu Utwórz nowe wystąpienie klasy <xref:System.Messaging.MessageQueueCriteria> klasy, ustaw odpowiednie właściwości w wystąpieniu, a następnie przekaż wystąpienie jako `criteria` parametru.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> pobiera migawkę statyczne kolejek. Do interakcji z dynamiczną listę kolejek, należy użyć <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośrednią nazwą formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">A <see cref="T:System.Guid" /> która grupuje zestaw kolejki do pobrania.</param>
        <summary>Umożliwia pobranie wszystkich kolejek publicznych w sieci, które należą do określonej kategorii.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiekty odwołujące się do pobrane kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia filtrowanie kolejek publicznych według kategorii. <xref:System.Messaging.MessageQueue.Category%2A> Właściwości zapewnia dostęp do usługi kolejkowania komunikatów typu właściwość ID (czyli odczytu/zapisu) określonej kolejki. Chociaż można używać <xref:System.Guid.NewGuid%2A> można utworzyć wartości kategorii, która jest unikatowa dla wszystkich <xref:System.Guid> wartości nie jest konieczne. Wartość kategorii musi się różnić tylko z innych kategoriach, a nie od wszystkich pozostałych <xref:System.Guid> wartości. Na przykład możesz przypisać {00000000-0000-0000-0000-000000000001} jako <xref:System.Messaging.MessageQueue.Category%2A> dla jednego zestawu, kolejek i {00000000-0000-0000-0000-000000000002} jako <xref:System.Messaging.MessageQueue.Category%2A> dla innego zestawu.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> pobiera migawkę statyczne kolejek. Do interakcji z dynamiczną listę kolejek, należy użyć <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Można określić kategorię jako część <xref:System.Messaging.MessageQueueCriteria> przekazać do metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośrednią nazwą formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Etykieta, który grupuje zestaw kolejki do pobrania.</param>
        <summary>Umożliwia pobranie wszystkich kolejek publicznych w sieci, które mają określoną etykietą.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiekty odwołujące się do pobrane kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia filtrowanie kolejek publicznych przez etykietę.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> pobiera migawkę statyczne kolejek. Do interakcji z dynamiczną listę kolejek, należy użyć <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Etykiety można określić jako część <xref:System.Messaging.MessageQueueCriteria> przekazać do metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośrednią nazwą formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> Parametr <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nazwa komputera, który zawiera zestaw kolejek publicznych, które mają zostać pobrane.</param>
        <summary>Umożliwia pobranie wszystkich kolejek publicznych, które znajdują się na określonym komputerze.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiekty odwołujące się do kolejek publicznych, na komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia filtrowanie kolejek publicznych w przeliczeniu na komputer.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> pobiera migawkę statyczne kolejek. Do interakcji z dynamiczną listę kolejek, należy użyć <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Należy określić nazwę komputera, jako część <xref:System.Messaging.MessageQueueCriteria> przekazać do metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośrednią nazwą formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr ma błędną składnię.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kontekst zabezpieczeń, które MSMQ kojarzy z bieżącym użytkownikiem (tożsamość wątku) w czasie tego wywołania.</summary>
        <returns>A <see cref="T:System.Messaging.SecurityContext" /> obiekt, który zawiera kontekstu zabezpieczeń.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator usługi kolejkowania komunikatów z kolejki.</summary>
        <value>A <see cref="P:System.Messaging.MessageQueue.Id" /> reprezentujący identyfikator wiadomości wygenerowanymi przez aplikację usługi kolejkowania komunikatów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy w usługi kolejkowania komunikatów <xref:System.Messaging.MessageQueue.Id%2A> właściwości podczas tworzenia kolejki. Ta właściwość jest dostępna tylko dla kolejek publicznych.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.Id%2A> właściwości.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy ograniczenie rozmiaru, nie istnieje dla kolejki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski jest często używany podczas ustawiania <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> lub <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.InfiniteQueueSize> elementu członkowskiego.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy limit czasu nie istnieje dla metod, które wgląd ani odbierać wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> obsługuje dwa typy odebrania komunikatu: synchroniczne i asynchroniczne. Synchroniczne metody <xref:System.Messaging.MessageQueue.Peek%2A> i <xref:System.Messaging.MessageQueue.Receive%2A>, spowodować, że wątek procesu oczekiwania przez określony okres czasu dla nowych komunikatów w kolejce. Jeśli jest określony przedział czasu <xref:System.Messaging.MessageQueue.InfiniteTimeout>, wątek procesu pozostanie zablokowany do czasu udostępnienia nowego komunikatu. Z drugiej strony <xref:System.Messaging.MessageQueue.BeginPeek%2A> i <xref:System.Messaging.MessageQueue.BeginReceive%2A> (metod asynchronicznych), Zezwalaj, aby kontynuować w oddzielnym wątku, dopóki umieszczeniu komunikatu w kolejce zadania głównej aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.InfiniteTimeout> elementu członkowskiego.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia opis kolejki.</summary>
        <value>Etykieta dla kolejki komunikatów. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maksymalna długość etykiety kolejki komunikatów to 124 znaki.  
  
 <xref:System.Messaging.MessageQueue.Label%2A> Właściwości nie musi być unikatowa wśród wszystkich kolejek. Jednak jeśli wielu kolejek współużytkować ten sam <xref:System.Messaging.MessageQueue.Label%2A>, nie można użyć <xref:System.Messaging.MessageQueue.Send%28System.Object%29> metodę, aby emitować wiadomość do wszystkich z nich. Jeśli używasz składnia etykiety <xref:System.Messaging.MessageQueue.Path%2A> właściwości podczas wysyłania komunikatu wystąpił wyjątek zostanie zgłoszony, jeśli <xref:System.Messaging.MessageQueue.Label%2A> nie jest unikatowa.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.Label%2A> właściwości.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Etykieta została ustawiona na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podczas ostatniego właściwości kolejki zostały zmodyfikowane.</summary>
        <value>A <see cref="T:System.DateTime" /> oznacza ostatniej modyfikacji właściwości kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas ostatniej modyfikacji obejmuje podczas tworzenia kolejki oraz wszelką <xref:System.Messaging.MessageQueue> właściwość, która modyfikuje kolejki usługi kolejkowania komunikatów, takie jak <xref:System.Messaging.MessageQueue.BasePriority%2A>. Wartość <xref:System.Messaging.MessageQueue.LastModifyTime%2A> właściwość reprezentuje czas systemowy komputera lokalnego.  
  
 Należy wywołać <xref:System.Messaging.MessageQueue.Refresh%2A> przed pobraniem <xref:System.Messaging.MessageQueue.LastModifyTime%2A> właściwości; w przeciwnym razie czas modyfikacji skojarzonych z tym <xref:System.Messaging.MessageQueue> mogą być nieaktualne.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.LastModifyTime%2A> właściwości.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komputera, na którym znajduje się kolejki usługi kolejkowania komunikatów.</summary>
        <value>Nazwa komputera, na którym znajduje się kolejka. Domyślnie usługi kolejkowania komunikatów ".", komputer lokalny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A> Jest integralnym składnikiem składni przyjazna nazwa kolejki <xref:System.Messaging.MessageQueue.Path%2A>. W poniższej tabeli przedstawiono składnię, z której należy używać kolejki o określonym typie zidentyfikować na ścieżkę kolejki przy użyciu jego przyjaznej nazwy.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejki dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejki dziennika komputera|`MachineName`\\`Journal$`|  
|Kolejka utraconych wiadomości komputera|`MachineName`\\`Deadletter$`|  
|Kolejki utraconych wiadomości transakcyjnych maszyn|`MachineName`\\`XactDeadletter$`|  
  
 Użyj "." na komputerze lokalnym, określając <xref:System.Messaging.MessageQueue.MachineName%2A>. Tylko nazwa komputera jest rozpoznawany dla tej właściwości, na przykład `Server0`. <xref:System.Messaging.MessageQueue.MachineName%2A> Właściwość nie obsługuje format adresu IP.  
  
 Jeśli zdefiniujesz <xref:System.Messaging.MessageQueue.Path%2A> pod względem <xref:System.Messaging.MessageQueue.MachineName%2A>, aplikacja zgłasza wyjątek, podczas pracy w trybie offline, ponieważ kontroler domeny jest wymagany do tłumaczenia ścieżki. W związku z tym, należy użyć <xref:System.Messaging.MessageQueue.FormatName%2A> dla <xref:System.Messaging.MessageQueue.Path%2A> składni podczas pracy w trybie offline.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, I <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości są powiązane. Zmiana <xref:System.Messaging.MessageQueue.MachineName%2A> powoduje, że właściwość <xref:System.Messaging.MessageQueue.Path%2A> właściwości do zmiany. Jest zbudowany nowy <xref:System.Messaging.MessageQueue.MachineName%2A> i <xref:System.Messaging.MessageQueue.QueueName%2A>. Zmiana <xref:System.Messaging.MessageQueue.Path%2A> (na przykład, należy użyć składni nazwy formatu) resetuje <xref:System.Messaging.MessageQueue.MachineName%2A> i <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości do odwoływania się do nowej kolejki. Jeśli <xref:System.Messaging.MessageQueue.QueueName%2A> właściwość jest pusta, <xref:System.Messaging.MessageQueue.Path%2A> jest ustawiona w kolejce dziennika komputera, należy określić.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.MachineName%2A> właściwości.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa komputera nie są prawidłowe, prawdopodobnie ponieważ składnia jest niepoprawna.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar kolejki dziennika.</summary>
        <value>Maksymalny rozmiar w kilobajtach kolejki dziennika. Wartość domyślna usługi kolejkowania komunikatów Określa, że nie istnieje limit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> zapewnia dostęp do usługi kolejkowania komunikatów dziennika limit magazynu. Jest to istotne tylko wtedy, gdy <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> jest `true`. Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym, inne <xref:System.Messaging.MessageQueue> wystąpień wpływają zmiany  
  
 Jeśli przechowujesz komunikaty w dzienniku lub kolejki utraconych wiadomości, należy okresowo czyścić kolejki, aby usunąć wiadomości, które nie są już potrzebne. Komunikaty w takiej kolejki wliczają się do limitu przydziału komunikatów na komputerze, na którym znajduje się kolejka. (Administrator ustawia limit przydziału komputera).  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> właściwości.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Rozmiar kolejki dziennika maksymalna została ustawiona na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar kolejki.</summary>
        <value>Maksymalny rozmiar w kilobajtach kolejki. Wartość domyślna usługi kolejkowania komunikatów Określa, że nie istnieje limit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> Zapewnia dostęp do usługi kolejkowania komunikatów komunikatów limit magazynu, który jest oddzielony od limit przydziału komunikatów na komputerze, który administrator definiuje. Aby uzyskać więcej informacji na temat przydział wiadomości zobacz <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym, inne <xref:System.Messaging.MessageQueue> wystąpień wpływają zmiany  
  
 Jeśli zostanie podjęta próba przekracza maksymalny rozmiar kolejki lub przydział wiadomości komputera, komunikaty mogą zostać utracone. Po osiągnięciu limitu przydziału kolejki usługi kolejkowania komunikatów powiadamia kolejkę administracyjną aplikacji wysyłającej, aby wskazać, że kolejka jest zapełniona, zwracając wiadomość negatywnego potwierdzenia. Usługa kolejkowania komunikatów w dalszym ciągu wysyłać potwierdzenia ujemna, dopóki całkowity rozmiar wiadomości w kolejce nie spadnie poniżej limitu.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> właściwości.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Maksymalny rozmiar kolejki zawiera wartość ujemną.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia filtr właściwości odbierania lub wgląd do wiadomości.</summary>
        <value>
          <see cref="T:System.Messaging.MessagePropertyFilter" /> Używane przez kolejkę do filtrowania zestaw właściwości, które odbiera lub dokonuje dla każdego komunikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten filtr jest zbiorem wartości logicznych ograniczenie właściwości komunikatu, <xref:System.Messaging.MessageQueue> otrzymuje lub dokonuje. Gdy <xref:System.Messaging.MessageQueue> otrzymuje lub dokonuje komunikat z kolejki serwera pobiera tylko te właściwości, dla którego <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> wartość `true`.  
  
 Poniżej pokazano początkowe wartości właściwości <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> właściwości. Te ustawienia są identyczne z wywoływaniem <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> na <xref:System.Messaging.MessagePropertyFilter>.  
  
|Właściwość|Wartość domyślna|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 bajty|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 bajtów|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 bajtów|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> ograniczyć właściwości wiadomości odebrane.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Filtr jest <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Pobiera lub ustawia adres multiemisji skojarzony z kolejką.</summary>
        <value>A <see cref="T:System.String" /> zawiera nieprawidłowy adres multiemisji (w formie, pokazano poniżej) lub <see langword="null" />, co oznacza, że kolejka nie jest skojarzony z adresem multiemisji.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Właściwość jest używana do kojarzenia kolejka nietransakcyjna z adresem multiemisji, które mogą być używane podczas wysyłania wiadomości. Nie można skojarzyć kolejkę transakcyjną z adresem multiemisji. Gdy aplikacja wysyłająca wysyła komunikaty do adresu multiemisji, usługi kolejkowania komunikatów wysyła kopię wiadomości do kolejki, co skojarzony z tym adresem.  
  
 Multiemisja IP adresów musi należeć do zakresu klasy D od 224.0.0.0 do 239.255.255.255, który odpowiada ustawieniu pierwsze cztery najbardziej znaczących bitów na wartość 1110. Jednak tylko określonych zakresów adresów w tym zakresie są niezastrzeżone i dostępne do wysyłania komunikatów multiemisji. Aby uzyskać najnowszą listę zastrzeżonych adresów multiemisji, zobacz [adresy multiemisji Internet Internet Assigned numer Authority (IANA)](https://go.microsoft.com/fwlink/?linkid=3859) strony sieci Web. Nie ma żadnych ograniczeń na numer portu.  
  
 Jeśli kilka komputerów źródłowych wysyłają komunikaty multiemisji i chcesz określonej kolejki do odbierania komunikatów tylko z jednego komputera źródłowego, każdy komputer źródłowy musi wysyłać komunikaty do różnych kombinacji adresu IP adres i numer portu.  
  
 Aby usunąć skojarzenie kolejki z adresem multiemisji, należy ustawić <xref:System.Messaging.MessageQueue.MulticastAddress%2A> właściwości na ciąg o zerowej długości. Nie należy ustawiać na `null`, ponieważ spowoduje to <xref:System.ArgumentNullException>.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ścieżkę kolejki. Ustawienie <see cref="P:System.Messaging.MessageQueue.Path" /> powoduje, że <see cref="T:System.Messaging.MessageQueue" /> by wskazywał nową kolejkę.</summary>
        <value>Kolejki, która odwołuje się do niej <see cref="T:System.Messaging.MessageQueue" />. Wartość domyślna jest zależna od którego <see cref="M:System.Messaging.MessageQueue.#ctor" /> Użyj konstruktora; jest ona <see langword="null" /> lub została ona określona przez Konstruktor <paramref name="path" /> parametru.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnia <xref:System.Messaging.MessageQueue.Path%2A> właściwości zależy od typu kolejki go punktów do, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejki dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejki dziennika komputera|`MachineName`\\`Journal$`|  
|Kolejka utraconych wiadomości komputera|`MachineName`\\`Deadletter$`|  
|Kolejki utraconych wiadomości transakcyjnych maszyn|`MachineName`\\`XactDeadletter$`|  
  
 Użyj "." do reprezentowania na komputerze lokalnym.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, I <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości są powiązane. Zmiana <xref:System.Messaging.MessageQueue.MachineName%2A> powoduje, że właściwość <xref:System.Messaging.MessageQueue.Path%2A> właściwości do zmiany. Jest zbudowany nowy <xref:System.Messaging.MessageQueue.MachineName%2A> i <xref:System.Messaging.MessageQueue.QueueName%2A>. Zmiana <xref:System.Messaging.MessageQueue.Path%2A> (na przykład, należy użyć składni nazwy formatu) resetuje <xref:System.Messaging.MessageQueue.MachineName%2A> i <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości do odwoływania się do nowej kolejki.  
  
 Alternatywnie, można użyć <xref:System.Messaging.MessageQueue.FormatName%2A> lub <xref:System.Messaging.MessageQueue.Label%2A> do opisania na ścieżkę kolejki, jak pokazano w poniższej tabeli.  
  
|Tematy pomocy|Składnia|Przykład|  
|---------------|------------|-------------|  
|Nazwa formatu|`FormatName:` [ *nazwę formatu* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Etykieta|`Label:` [ *etykiety* ]|`Label:` TheLabel|  
  
 Jeśli używasz składnia etykiety <xref:System.Messaging.MessageQueue.Path%2A> właściwości podczas wysyłania komunikatu wystąpił wyjątek zostanie zgłoszony, jeśli <xref:System.Messaging.MessageQueue.Label%2A> nie jest unikatowa.  
  
 Aby pracować w trybie offline, należy użyć Składnia nazwy formatu, zamiast składni przyjazną nazwę w pierwszej tabeli. W przeciwnym razie jest zgłaszany wyjątek, ponieważ nie jest można rozpoznać ścieżki do nazwy formatu podstawowego kontrolera domeny (na którym usługa Active Directory).  
  
 Ustawianie nowej ścieżki zamyka kolejki komunikatów i zwalnia wszystkie dojścia.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
> [!NOTE]
>  W trybie grupy roboczej można używać tylko kolejki prywatne. Określ ścieżkę przy użyciu składni kolejki prywatnej `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowy <xref:System.Messaging.MessageQueue> obiektów przy użyciu różnych typów Składnia nazwy ścieżki. W każdym przypadku wysyła komunikat do kolejki, których ścieżka jest zdefiniowana w konstruktorze.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka jest nieprawidłowa, prawdopodobnie ponieważ składnia jest nieprawidłowa.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <summary>Zwraca kopię pierwszego komunikatu w kolejce bez usuwania tego komunikatu z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca bez usuwania (dokonuje) to odwołanie do pierwszej wiadomości w kolejce <see cref="T:System.Messaging.MessageQueue" />. <see cref="M:System.Messaging.MessageQueue.Peek" /> Metodą jest synchroniczne, więc blokują bieżący wątek, aż komunikat o stanie się dostępny.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Reprezentująca pierwszy komunikat w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, wgląd w kolejce lub poczekaj, aż komunikat istnieje w tej kolejce.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Metody odczytuje, ale nie usuwa pierwszą wiadomość z kolejki. W związku z tym, wielokrotne wywołania <xref:System.Messaging.MessageQueue.Peek%2A> zwracać ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metody, z drugiej strony, odczytuje i usuwa pierwszą wiadomość z kolejki. Wielokrotne wywołania <xref:System.Messaging.MessageQueue.Receive%2A>, zwracają więc różne komunikaty.  
  
 Usługa kolejkowania komunikatów porządkuje wiadomości w kolejce według priorytetu i przybycia czasu. Nowsze wiadomości jest umieszczany przed stary tylko wtedy, gdy jest wyższy priorytet.  
  
 Użyj <xref:System.Messaging.MessageQueue.Peek%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Ponieważ tego przeciążenia nie określa limit czasu, aplikacja może czekać w nieskończoność. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez zbędnego oczekiwania, użycie asynchronicznego <xref:System.Messaging.MessageQueue.BeginPeek%2A> metody. Alternatywnie, można określić limit czasu oczekiwania na przychodzące w kolejce za pomocą przeciążenia wiadomości <xref:System.Messaging.MessageQueue.Peek%2A> , który określa limit czasu.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 W poniższych przykładach używane <xref:System.Messaging.MessageQueue.Peek%2A> metody w kolejce.  
  
 W pierwszym przykładzie aplikacja czeka, aż komunikat o stanie się dostępny w kolejce. Należy zwrócić uwagę, pierwszego przykładu nie dostępu do wiadomości, przychodzący; jedynie wstrzymuje przetwarzanie, dopóki nie nadejścia wiadomości. Jeśli komunikat jest już istnieje w kolejce, zwróci natychmiast.  
  
 W drugim przykładzie wiadomość, która zawiera zdefiniowanych przez aplikację `Order` klasy jest wysyłany do kolejki, a następnie podejrzeć z kolejki.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> oznacza maksymalny czas oczekiwania w kolejce zawiera komunikat.</param>
        <summary>Zwraca bez usuwania (dokonuje) to odwołanie do pierwszej wiadomości w kolejce <see cref="T:System.Messaging.MessageQueue" />. <see cref="M:System.Messaging.MessageQueue.Peek" /> Metodą jest synchroniczne, więc blokują bieżący wątek, dopóki komunikat o stanie się dostępny lub występuje w określonym limicie czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Reprezentująca pierwszy komunikat w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia wgląd w kolejce lub oczekiwania określony okres czasu, aż komunikat istnieje w kolejce. Metoda zwraca natychmiast, jeśli komunikat jest już w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Metody odczytuje, ale nie usuwa pierwszą wiadomość z kolejki. W związku z tym, wielokrotne wywołania <xref:System.Messaging.MessageQueue.Peek%2A> zwracać ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metody, z drugiej strony, odczytuje i usuwa pierwszą wiadomość z kolejki. Wielokrotne wywołania <xref:System.Messaging.MessageQueue.Receive%2A>, zwracają więc różne komunikaty.  
  
 Usługa kolejkowania komunikatów porządkuje wiadomości w kolejce według priorytetu i przybycia czasu. Nowsze wiadomości jest umieszczany przed stary tylko wtedy, gdy jest wyższy priorytet.  
  
 Użyj <xref:System.Messaging.MessageQueue.Peek%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Wątek zostanie zablokowana do danego okresu czasu lub nieokreślony Jeśli wskazana <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez zbędnego oczekiwania, użycie asynchronicznego <xref:System.Messaging.MessageQueue.BeginPeek%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Messaging.MessageQueue.Peek%2A> metody z upływu limitu czasu równą zero, aby sprawdzić, czy kolejka jest pusta.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> oznacza maksymalny czas oczekiwania w kolejce zawiera komunikat.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określonej pozycji w kolejce komunikatów.</param>
        <param name="action">Jedną z <see cref="T:System.Messaging.PeekAction" /> wartości. Wskazuje, czy wglądu do bieżącej wiadomości w kolejce lub następny komunikat.</param>
        <summary>Zwraca bez usuwania (dokonuje), bieżący lub obok komunikatu w kolejce przy użyciu określonego kursora. <see cref="M:System.Messaging.MessageQueue.Peek" /> Metodą jest synchroniczne, więc blokują bieżący wątek, dopóki komunikat o stanie się dostępny lub występuje w określonym limicie czasu.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> reprezentujący wiadomości w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia wgląd w kolejce lub oczekiwania określony okres czasu, aż komunikat istnieje w kolejce. Metoda zwraca natychmiast, jeśli komunikat jest już w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Metody odczytuje, ale nie usuwa komunikat z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metody, z drugiej strony, odczytuje i usuwa komunikat z kolejki.  
  
 Użyj <xref:System.Messaging.MessageQueue.Peek%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Wątek jest blokowany do danego okresu czasu lub nieokreślony Jeśli wskazana <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez zbędnego oczekiwania, użycie asynchronicznego <xref:System.Messaging.MessageQueue.BeginPeek%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość inną niż <see langword="PeekAction.Current" /> lub <see langword="PeekAction.Next" /> określono <paramref name="action" /> parametru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy. Prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dokonuje komunikat, który jest zgodny z identyfikatorem korelacji danego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomości do wglądu.</param>
        <summary>Dokonuje komunikat, który jest zgodny z identyfikatorem korelacji danego i natychmiast zgłasza wyjątek, jeśli żaden komunikat z identyfikatorem korelacji określonego znajduje się w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza w kolejce odwołuje się <xref:System.Messaging.MessageQueue> wiadomości którego <xref:System.Messaging.Message.CorrelationId%2A> jest zgodny z określonym `correlationId` parametru. Jeśli żaden komunikat nie zostanie znaleziony, który odpowiada `correlationID` parametru, zgłaszany jest wyjątek.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązanie komunikat wysłany do kolejki, aby skojarzone wiadomości odpowiedzi, raport lub potwierdzenia.  
  
 Dwie inne metody umożliwiają podglądu komunikatów w kolejce. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła i odbiera komunikat, który zawiera zamówienia z kolejki. Go zażąda potwierdzenia dodatnie, gdy oryginalna wiadomość osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="correlationId" /> nie został odnaleziony.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomości do wglądu.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <summary>Dokonuje komunikat, który jest zgodny z identyfikatorem korelacji danego i czeka, aż komunikat z identyfikatorem korelacji określony jest dostępna w kolejce lub wygaśnięciu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza w kolejce odwołuje się <xref:System.Messaging.MessageQueue> wiadomości którego <xref:System.Messaging.Message.CorrelationId%2A> jest zgodny z określonym `correlationId` parametru. Jeśli żaden komunikat nie zostanie znaleziony, który odpowiada `correlationID` parametru, a nie nowy komunikat dociera w kolejce przed upływem określonego przez `timeout` parametru, zgłaszany jest wyjątek.  
  
 `timeout` Parametr określa łączny czas dla tej metody działania. Przeciwnie określa czas oczekiwania na nowe wiadomości w kolejce. Każdorazowo nadejdzie nowa wiadomość, ta metoda sprawdza, czy <xref:System.Messaging.Message.CorrelationId%2A> nowego komunikatu, aby sprawdzić, czy odpowiada `correlationId` parametru. W przeciwnym razie ta metoda uruchamia przed upłynięciem limitu czasu za pośrednictwem i czeka na innej nowej wiadomości na dostarczenie. W związku z tym, jeśli nowe wiadomości w dalszym ciągu pojawić się przed upływem limitu czasu, istnieje możliwość dla tej metody kontynuować do momentu przed upłynięciem limitu czasu wygaśnięcia bez żadnych nowych wiadomości przychodzących lub do momentu nadejścia wiadomości, których uruchomiona przez czas nieokreślony, <xref:System.Messaging.Message.CorrelationId%2A> Dopasowuje `correlationId` parametru.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązanie komunikat wysłany do kolejki, aby skojarzone wiadomości odpowiedzi, raport lub potwierdzenia.  
  
 Dwie inne metody umożliwiają podglądu komunikatów w kolejce. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="correlationId" /> nie istnieje w kolejce i nie pojawić się przed wygaśnięciem limitu czasu.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość nie pojawić się przed wygaśnięciem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kopię obiektu komunikat, który ma identyfikator wiadomości określony bez usuwania tego komunikatu z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Wiadomości do wglądu.</param>
        <summary>Dokonuje komunikat, którego identyfikator wiadomości pasuje <paramref name="id" /> parametru.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> do odczytu bez usuwania z kolejki, komunikat, który ma identyfikator komunikatu znane. Identyfikator wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, więc będzie co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru. To przeciążenie zgłasza wyjątek, jeśli kolejka nie zawiera obecnie wiadomości.  
  
 Dwie dodatkowe metody umożliwiają podglądu komunikatów w kolejce: <xref:System.Messaging.MessageQueue.Peek%2A> i <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zwraca pierwszy komunikat w kolejce; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> zwraca potwierdzenia, raportu lub komunikat odpowiedzi generowane aplikację, który został utworzony w wyniku wiadomości wysłanych do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak komunikatu o określonej <paramref name="id" /> istnieje.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Wiadomości do wglądu.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <summary>Dokonuje komunikat, którego identyfikator wiadomości pasuje <paramref name="id" /> parametru. Czeka, aż pojawi się komunikat w kolejce lub przekroczenia limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> do odczytu bez usuwania z kolejki, komunikat, który ma identyfikator komunikatu znane. Identyfikator wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, więc będzie co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru. To przeciążenie zgłasza wyjątek, jeśli kolejka nie zawiera obecnie wiadomości, a nowa wiadomość dotrze zanim upłynie limit czasu.  
  
 `timeout` Parametr określa łączny czas dla tej metody działania. Przeciwnie określa czas oczekiwania na nowe wiadomości w kolejce. Każdorazowo nadejdzie nowa wiadomość, ta metoda sprawdza, czy <xref:System.Messaging.Message.Id%2A> nowego komunikatu, aby sprawdzić, czy odpowiada `id` parametru. W przeciwnym razie ta metoda uruchamia przed upłynięciem limitu czasu za pośrednictwem i czeka na innej nowej wiadomości na dostarczenie. W związku z tym, jeśli nowe wiadomości w dalszym ciągu pojawić się przed upływem limitu czasu, istnieje możliwość dla tej metody kontynuować do momentu przed upłynięciem limitu czasu wygaśnięcia bez żadnych nowych wiadomości przychodzących lub do momentu nadejścia wiadomości, których uruchomiona przez czas nieokreślony, <xref:System.Messaging.Message.Id%2A> Dopasowuje `id` parametru.  
  
 Dwie dodatkowe metody umożliwiają podglądu komunikatów w kolejce: <xref:System.Messaging.MessageQueue.Peek%2A> i <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zwraca pierwszy komunikat w kolejce; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> zwraca potwierdzenia, raportu lub komunikat odpowiedzi generowane aplikację, który został utworzony w wyniku wiadomości wysłanych do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="id" /> nie istnieje w kolejce i nie pojawić się przed okres określony przez <paramref name="timeout" /> parametru wygasł.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Dokonuje wglądu szczegółowy komunikat o błędzie z kolejki. Identyfikator wyszukiwania lub położenia na wierzch lub na końcu kolejki można określić komunikat.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> Wiadomości do wglądu.</param>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Dokonuje wglądu do wiadomości, który jest zgodny z identyfikatorem danego wyszukiwania z nietransakcyjnej kolejki.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.LookupId" /> dopasowania właściwości <paramref name="lookupId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odczytywać komunikaty z identyfikatorem znane wyszukiwania bez usuwania go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie znajduje się w kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość wiadomości jest unikatowa w kolejce zawierającej komunikat zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `lookupId` parametru.  
  
 Aby odczytywać komunikaty przy użyciu określonemu identyfikatorowi przeszukiwania i usuń go z kolejki, użyj <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="lookupId" /> nie został odnaleziony.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">Jedną z <see cref="T:System.Messaging.MessageLookupAction" /> wartości, określający, jak komunikat został odczytany w kolejce. Określ jedną z następujących czynności: 
 <see langword="MessageLookupAction.Current" />: Dokonuje wglądu do wiadomości, określonej przez <c>Lookupld</c>.  
  
 <see langword="MessageLookupAction.Next" />: Dokonuje wglądu do wiadomości następującej wiadomość określoną przez <c>Lookupld</c>.  
  
 <see langword="MessageLookupAction.Previous" />: Dokonuje wglądu do wiadomości poprzedzającej wiadomość określoną przez <c>Lookupld</c>.  
  
 <see langword="MessageLookupAction.First" />: Dokonuje wglądu do pierwszej wiadomości w kolejce. <c>Lookupld</c> parametru musi być równa 0.  
  
 <see langword="MessageLookupAction.Last" />: Dokonuje wglądu do ostatniej wiadomości w kolejce. <c>Lookupld</c> parametru musi być równa 0.</param>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> Wiadomości, aby obejrzeć lub 0. 0 jest używany podczas uzyskiwania dostępu do pierwszej lub ostatniej wiadomości w kolejce.</param>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Dokonuje wglądu szczegółowy komunikat o błędzie z kolejki. Identyfikator wyszukiwania lub położenia na wierzch lub na końcu kolejki można określić komunikat.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Określony przez <paramref name="action" /> i <paramref name="lookupId" /> parametry przekazywane w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odczytywać komunikaty z identyfikatorem znane wyszukiwania bez usuwania go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie znajduje się w kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość wiadomości jest unikatowa w kolejce zawierającej komunikat zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `lookupId` parametru.  
  
 Aby odczytywać komunikaty z określonym identyfikatorem i usuń go z kolejki, użyj <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="lookupId" /> nie został odnaleziony.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageLookupAction" /> elementów członkowskich.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy komunikat jest odczytywany bez usuwania z kolejki. Jest to wynik operacji asynchronicznej <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest używana podczas przetwarzania asynchronicznego podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, gdy komunikat jest dostępna w kolejce.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> Służy do wykonania operacji zainicjowanych przez wywołanie <xref:System.Messaging.MessageQueue.BeginPeek%2A> i wgląd do wiadomości gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest wywoływane.  
  
 Po utworzeniu <xref:System.Messaging.PeekCompletedEventHandler> delegata, możesz zidentyfikować metody, która będzie obsługiwać zdarzenia. Aby skojarzyć zdarzenia z programu obsługi zdarzeń, należy dodać wystąpienie delegata zdarzenia. Program obsługi zdarzeń jest wywoływany przy każdym wystąpieniu zdarzenia, o ile nie usunięto delegata. Aby uzyskać więcej informacji na temat delegatów obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyPeekCompleted`, dołącza go do <xref:System.Messaging.MessageQueue.PeekCompleted> delegata obsługi zdarzeń i wywołania <xref:System.Messaging.MessageQueue.BeginPeek%2A> można zainicjować operacji asynchronicznych wglądu w kolejce, która znajduje się w ścieżce ". \myQueue". Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane, w przykładzie dokonuje wiadomości i zapisuje jego treść na ekranie. Przykład następnie wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> ponownie, aby zainicjować nową operację asynchroniczną podglądu  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie komunikaty, które są zawarte w kolejce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czyszczenie kolejki powoduje, że można ustawić flagi modyfikacji kolejki, który ma wpływ na usługi kolejkowania komunikatów <xref:System.Messaging.MessageQueue.LastModifyTime%2A> właściwości. Wiadomości, które są usuwane z kolejki są tracone; nie są wysyłane do kolejki utraconych wiadomości lub kolejki dziennika.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przyjazna nazwa, która identyfikuje kolejki.</summary>
        <value>Nazwę, która identyfikuje kolejki przywoływane przez to <see cref="T:System.Messaging.MessageQueue" />. Wartość nie może być <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można połączyć <xref:System.Messaging.MessageQueue.QueueName%2A> z <xref:System.Messaging.MessageQueue.MachineName%2A> utworzyć przyjazną <xref:System.Messaging.MessageQueue.Path%2A> nazwę kolejki. Składnia odmianą przyjazną nazwę <xref:System.Messaging.MessageQueue.Path%2A> właściwości zależy od typu kolejki, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejka publiczna|`MachineName`\\`QueueName`|  
|Kolejka prywatna|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejki dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Użyj "." do reprezentowania na komputerze lokalnym.  
  
 Zmiana <xref:System.Messaging.MessageQueue.QueueName%2A> właściwość ma wpływ na <xref:System.Messaging.MessageQueue.Path%2A> właściwości. Jeśli ustawisz <xref:System.Messaging.MessageQueue.QueueName%2A> bez ustawienia <xref:System.Messaging.MessageQueue.MachineName%2A> właściwości <xref:System.Messaging.MessageQueue.Path%2A> staje się właściwość.\\ `QueueName`. W przeciwnym razie <xref:System.Messaging.MessageQueue.Path%2A> staje się `MachineName` \\ `QueueName`.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa kolejki jest <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt macierzysty używany do odczytywania komunikatów z kolejki komunikatów.</summary>
        <value>Dojście do obiektu kolejki natywnych, używanego programu peeking oraz odbieranie komunikatów z kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A> Zapewnia natywne Windows uchwyt do obiektu kolejki komunikatów, który służy do peeking oraz odbieranie komunikatów z kolejki. W przypadku zmiany ścieżki kolejki uchwytu zamknięcia i ponownego otworzenia z nową wartością.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <summary>Odbiera pierwszy komunikat w kolejce usuwając ją z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odbiera pierwszy komunikat dostępnymi w kolejce odwołuje się <see cref="T:System.Messaging.MessageQueue" />. To wywołanie jest synchroniczne i blokuje bieżący wątek wykonywania, aż komunikat jest dostępna.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia odbiera wiadomości z kolejki lub poczekaj, aż znajdują się komunikaty w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając go z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwrócą komunikaty, które należy wykonać w kolejce lub nowych, komunikaty o wyższym priorytecie.  
  
 Do odczytywania do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Ponieważ to przeciążenia <xref:System.Messaging.MessageQueue.Receive%2A> metody określa nieskończony limit czasu, aplikacja może czekać w nieskończoność. Jeśli przetwarzanie aplikacji należy kontynuować bez oczekiwania na komunikat, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu otrzymuje komunikat z kolejki i wyświetla informacje o tej wiadomości do ekranu.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera pierwszy komunikat dostępnymi w kolejce transakcji odwołuje się <see cref="T:System.Messaging.MessageQueue" />. To wywołanie jest synchroniczne i blokuje bieżący wątek wykonywania, aż komunikat jest dostępna.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia celu odebranie komunikatu z kolejki transakcyjne przy użyciu tego kontekstu transakcji wewnętrznej zdefiniowany przez `transaction` parametr lub zaczekaj, aż znajdują się komunikaty w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając go z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróci wiadomości, które należy wykonać w kolejce.  
  
 Ponieważ ta metoda jest wywoływana na kolejkę transakcyjną, zostaną zwrócone odebranego komunikatu do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Do odczytywania do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nie byłaby nic nie można wycofać przez wywołanie <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Ponieważ to przeciążenia <xref:System.Messaging.MessageQueue.Receive%2A> metody określa nieskończony limit czasu, aplikacja może czekać w nieskończoność. Jeśli przetwarzanie aplikacji należy kontynuować bez oczekiwania na komunikat, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy kod łączy się kolejkę transakcyjną na komputerze lokalnym i wysyła komunikat do kolejki. Odbiera komunikat, który zawiera zamówienia. Jeśli wykryje nieważną kolejka nietransakcyjna, spowoduje zgłoszenie i wyjątków, jak i wycofywania transakcji.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.  
  
—lub— 
Kolejka jest nietransakcyjnej.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera pierwszy komunikat dostępnymi w kolejce odwołuje się <see cref="T:System.Messaging.MessageQueue" />. To wywołanie jest synchroniczne i blokuje bieżący wątek wykonywania, aż komunikat jest dostępna.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia odebrania komunikatu z kolejki za pomocą kontekstu transakcji, zdefiniowane przez `transactionType` parametr lub zaczekaj, aż znajdują się komunikaty w kolejce.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który chcesz użyć do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrznego. Można określić `None` Aby komunikat o błędzie z kolejką transakcyjną poza kontekstem transakcji.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając go z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróci wiadomości, które należy wykonać w kolejce.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjne, odebranego komunikatu będzie zwracany do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Do odczytywania do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nie byłaby nic nie można wycofać przez wywołanie <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Ponieważ to przeciążenia <xref:System.Messaging.MessageQueue.Receive%2A> metody określa nieskończony limit czasu, aplikacja może czekać w nieskończoność. Jeśli przetwarzanie aplikacji należy kontynuować bez oczekiwania na komunikat, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <summary>Odbiera pierwszy komunikat dostępnymi w kolejce odwołuje się <see cref="T:System.Messaging.MessageQueue" /> i czeka, aż komunikat jest dostępna w kolejce lub limit czasu upłynie.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia komunikat o błędzie i zwraca w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając go z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwrócą komunikaty, które należy wykonać w kolejce lub nowych, komunikaty o wyższym priorytecie.  
  
 Do odczytywania do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Wątek zostanie zablokowane w danym okresie czasu lub nieokreślony Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametru. Jeśli przetwarzanie aplikacji należy kontynuować bez oczekiwania na komunikat, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu otrzymuje komunikat z kolejki i wyświetla informacje o tej wiadomości do ekranu. Przykład wstrzymuje wykonywanie funkcji o maksymalnie pięć sekund podczas oczekiwania na komunikat w kolejce.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość dotrze do kolejki przed wygaśnięciem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określonej pozycji w kolejce komunikatów.</param>
        <summary>Odbiera bieżącego komunikatu w kolejce przy użyciu określonego kursora. Jeśli żaden komunikat nie jest dostępny, ta metoda czeka, aż komunikat jest dostępna lub limit czasu upłynie.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość dotrze do kolejki przed wygaśnięciem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów 
To przeciążenie umożliwia komunikat o błędzie i zwraca w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera pierwszy komunikat dostępnymi w kolejce transakcji odwołuje się <see cref="T:System.Messaging.MessageQueue" /> i czeka, aż komunikat jest dostępna w kolejce lub limit czasu upłynie.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia celu odebranie komunikatu z kolejki transakcyjne przy użyciu tego kontekstu transakcji wewnętrznej zdefiniowany przez `transaction` parametrów i zwrotu, które w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając go z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróci wiadomości, które należy wykonać w kolejce.  
  
 Ponieważ ta metoda jest wywoływana na kolejkę transakcyjną, zostaną zwrócone odebranego komunikatu do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Do odczytywania do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nie byłaby nic nie można wycofać przez wywołanie <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Wątek zostanie zablokowane w danym okresie czasu lub nieokreślony Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametru. Jeśli przetwarzanie aplikacji należy kontynuować bez oczekiwania na komunikat, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej metody.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość dotrze do kolejki przed wygaśnięciem limitu czasu.  
  
—lub— 
Kolejka jest nietransakcyjnej.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera pierwszy komunikat dostępnymi w kolejce odwołuje się <see cref="T:System.Messaging.MessageQueue" />. To wywołanie jest synchroniczne i czeka, aż komunikat jest dostępna w kolejce lub limit czasu upłynie.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia odebrania komunikatu z kolejki za pomocą kontekstu transakcji, zdefiniowane przez `transactionType` parametrów i zwrotu, które w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który chcesz użyć do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrznego. Można określić `None` Aby komunikat o błędzie z kolejką transakcyjną poza kontekstem transakcji.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając go z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróci wiadomości, które należy wykonać w kolejce.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjne, odebranego komunikatu będzie zwracany do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Do odczytywania do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nie byłaby nic nie można wycofać przez wywołanie <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Wątek zostanie zablokowane w danym okresie czasu lub nieokreślony Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametru. Jeśli przetwarzanie aplikacji należy kontynuować bez oczekiwania na komunikat, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tej metody.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość dotrze do kolejki przed wygaśnięciem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określonej pozycji w kolejce komunikatów.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera bieżącego komunikatu w kolejce przy użyciu określonego kursora. Jeśli żaden komunikat nie jest dostępny, ta metoda czeka, aż komunikat jest dostępna lub limit czasu upłynie.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się wiadomości w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia celu odebranie komunikatu z kolejki transakcyjne przy użyciu tego kontekstu transakcji wewnętrznej zdefiniowany przez `transaction` parametrów i zwrotu, które w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając go z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwraca wiadomości, które należy wykonać w kolejce.  
  
 Ponieważ ta metoda jest wywoływana na kolejkę transakcyjną, odebranego komunikatu jest zwracany do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Do odczytywania komunikatów w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nic nie można wycofać przez wywołanie <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Wątek jest blokowany w danym okresie czasu lub nieokreślony Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametru. Jeśli przetwarzanie aplikacji należy kontynuować bez oczekiwania na komunikat, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="transaction" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy. Prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość dotrze do kolejki przed wygaśnięciem limitu czasu.  
  
—lub— 
Kolejka jest nietransakcyjnej.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określonej pozycji w kolejce komunikatów.</param>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości, które opisuje typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera bieżącego komunikatu w kolejce przy użyciu określonego kursora. Jeśli żaden komunikat nie jest dostępny, ta metoda czeka, aż komunikat jest dostępna lub limit czasu upłynie.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się wiadomości w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia odebrania komunikatu z kolejki za pomocą kontekstu transakcji, zdefiniowane przez `transactionType` parametrów i zwrotu, które w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który chcesz użyć do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrznego. Można określić `None` Aby komunikat o błędzie z kolejką transakcyjną poza kontekstem transakcji.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając go z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwraca wiadomości, które należy wykonać w kolejce.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjne, odebranego komunikatu jest zwracany do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Do odczytywania komunikatów w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nic nie można wycofać przez wywołanie <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest dopuszczalny dla bieżącego wątku być blokowane podczas oczekiwania na komunikat w kolejce. Wątek jest blokowany w danym okresie czasu lub nieokreślony Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametru. Jeśli przetwarzanie aplikacji należy kontynuować bez oczekiwania na komunikat, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy. Prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wiadomość dotrze do kolejki przed wygaśnięciem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomości do odbierania.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego (z kolejka nietransakcyjna) i natychmiast zgłasza wyjątek, jeśli żaden komunikat z identyfikatorem korelacji określonego znajduje się w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje w kolejka nietransakcyjna odwołuje się <xref:System.Messaging.MessageQueue> wiadomości którego <xref:System.Messaging.Message.CorrelationId%2A> jest zgodny z określonym `correlationId` parametru. Jeśli żaden komunikat nie zostanie znaleziony, który odpowiada `correlationID` parametru, zgłaszany jest wyjątek. W przeciwnym razie komunikat jest usuwane z kolejki i zwrócone do aplikacji.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązanie komunikat wysłany do kolejki, aby skojarzone wiadomości odpowiedzi, raport lub potwierdzenia.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda pobiera komunikat, określając jego unikatowy identyfikator.  
  
 Do odczytywania komunikatów z identyfikatorem korelacji określonego bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła i odbiera komunikat, który zawiera zamówienia z kolejki. Go zażąda potwierdzenia dodatnie, gdy oryginalna wiadomość osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="correlationId" /> nie został odnaleziony.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomości do odbierania.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego (z kolejką transakcyjną) i natychmiast zgłasza wyjątek, jeśli żaden komunikat z identyfikatorem korelacji określonego znajduje się w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje w Kolejka transakcyjna odwołuje się <xref:System.Messaging.MessageQueue> wiadomości którego <xref:System.Messaging.Message.CorrelationId%2A> jest zgodny z określonym `correlationId` parametru. Jeśli żaden komunikat nie zostanie znaleziony, który odpowiada `correlationID` parametru, zgłaszany jest wyjątek. W przeciwnym razie komunikat jest usuwane z kolejki i zwrócone do aplikacji przy użyciu tego kontekstu transakcji wewnętrznej zdefiniowany przez `transaction` parametru.  
  
 Ponieważ ta metoda jest wywoływana na kolejkę transakcyjną, zostaną zwrócone odebranego komunikatu do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązanie komunikat wysłany do kolejki, aby skojarzone wiadomości odpowiedzi, raport lub potwierdzenia.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 Do odczytywania komunikatów z identyfikatorem korelacji określonego bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, będzie istnieć żadne do wdrożenia w przypadku transakcji zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="transaction" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="correlationId" /> nie został odnaleziony.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka jest nietransakcyjnej.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomości do odbierania.</param>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego i natychmiast zgłasza wyjątek, jeśli żaden komunikat z identyfikatorem korelacji określonego znajduje się w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza w kolejce odwołuje się <xref:System.Messaging.MessageQueue> wiadomości którego <xref:System.Messaging.Message.CorrelationId%2A> jest zgodny z określonym `correlationId` parametru. Jeśli żaden komunikat nie zostanie znaleziony, który odpowiada `correlationID` parametru, zgłaszany jest wyjątek. W przeciwnym razie usuniętych z kolejki i zwrócony do aplikacji przy użyciu kontekstu transakcji, zdefiniowane przez komunikat `transactionType` parametru.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który chcesz użyć do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrznego. Można określić `None` Aby komunikat o błędzie z kolejką transakcyjną poza kontekstem transakcji.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjne, odebranego komunikatu będzie zwracany do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązanie komunikat wysłany do kolejki, aby skojarzone wiadomości odpowiedzi, raport lub potwierdzenia.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 Do odczytywania komunikatów z identyfikatorem korelacji określonego bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, będzie istnieć żadne do wdrożenia w przypadku transakcji zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="correlationId" /> nie został odnaleziony.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomości do odbierania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego (z kolejka nietransakcyjna) i czeka, aż komunikat z identyfikatorem korelacji określony jest dostępna w kolejce lub wygaśnięciu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje w kolejka nietransakcyjna odwołuje się <xref:System.Messaging.MessageQueue> wiadomości którego <xref:System.Messaging.Message.CorrelationId%2A> jest zgodny z określonym `correlationId` parametru. Ta metoda zwraca niezwłocznie, jeśli komunikat z identyfikatorem korelacji określony przez `correlationId` parametr znajduje się w kolejce. W przeciwnym razie metoda czeka danego okresu czasu Nowa wiadomość zostanie dostarczona. Jeśli nowy komunikat nie zostanie dostarczona, przed upływem limitu czasu, jest zgłaszany wyjątek.  
  
 `timeout` Parametr określa łączny czas dla tej metody działania. Przeciwnie określa czas oczekiwania na nowe wiadomości w kolejce. Każdorazowo nadejdzie nowa wiadomość, ta metoda sprawdza, czy <xref:System.Messaging.Message.CorrelationId%2A> nowego komunikatu, aby sprawdzić, czy odpowiada `correlationId` parametru. W przeciwnym razie ta metoda uruchamia przed upłynięciem limitu czasu za pośrednictwem i czeka na innej nowej wiadomości na dostarczenie. W związku z tym, jeśli nowe wiadomości w dalszym ciągu pojawić się przed upływem limitu czasu, istnieje możliwość dla tej metody kontynuować do momentu przed upłynięciem limitu czasu wygaśnięcia bez żadnych nowych wiadomości przychodzących lub do momentu nadejścia wiadomości, których uruchomiona przez czas nieokreślony, <xref:System.Messaging.Message.CorrelationId%2A> Dopasowuje `correlationId` parametru.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązanie komunikat wysłany do kolejki, aby skojarzone wiadomości odpowiedzi, raport lub potwierdzenia.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 Do odczytywania komunikatów z identyfikatorem korelacji określonego bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat o określonej <paramref name="correlationId" /> nie istnieje w kolejce i nie pojawić się przed wygaśnięciem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomości do odbierania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego (z kolejką transakcyjną) i czeka, aż komunikat z identyfikatorem korelacji określony jest dostępna w kolejce lub wygaśnięciu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje w Kolejka transakcyjna odwołuje się <xref:System.Messaging.MessageQueue> wiadomości którego <xref:System.Messaging.Message.CorrelationId%2A> jest zgodny z określonym `correlationId` parametru. Ta metoda zwraca niezwłocznie, jeśli komunikat z identyfikatorem korelacji określony przez `correlationId` parametr znajduje się w kolejce przy użyciu tego kontekstu transakcji wewnętrznej zdefiniowany przez `transaction` parametru. W przeciwnym razie metoda czeka danego okresu czasu Nowa wiadomość zostanie dostarczona. Jeśli nowy komunikat nie zostanie dostarczona, przed upływem limitu czasu, jest zgłaszany wyjątek.  
  
 `timeout` Parametr określa łączny czas dla tej metody działania. Przeciwnie określa czas oczekiwania na nowe wiadomości w kolejce. Każdorazowo nadejdzie nowa wiadomość, ta metoda sprawdza, czy <xref:System.Messaging.Message.CorrelationId%2A> nowego komunikatu, aby sprawdzić, czy odpowiada `correlationId` parametru. W przeciwnym razie ta metoda uruchamia przed upłynięciem limitu czasu za pośrednictwem i czeka na innej nowej wiadomości na dostarczenie. W związku z tym, jeśli nowe wiadomości w dalszym ciągu pojawić się przed upływem limitu czasu, istnieje możliwość dla tej metody kontynuować do momentu przed upłynięciem limitu czasu wygaśnięcia bez żadnych nowych wiadomości przychodzących lub do momentu nadejścia wiadomości, których uruchomiona przez czas nieokreślony, <xref:System.Messaging.Message.CorrelationId%2A> Dopasowuje `correlationId` parametru.  
  
 Ponieważ ta metoda jest wywoływana na kolejkę transakcyjną, zostaną zwrócone odebranego komunikatu do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązanie komunikat wysłany do kolejki, aby skojarzone wiadomości odpowiedzi, raport lub potwierdzenia.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 Do odczytywania komunikatów z identyfikatorem korelacji określonego bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, będzie istnieć żadne do wdrożenia w przypadku transakcji zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="transaction" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat o określonej <paramref name="correlationId" /> nie istnieje w kolejce i nie pojawić się przed wygaśnięciem limitu czasu.  
  
—lub— 
Kolejka jest nietransakcyjnej.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Wiadomości do odbierania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego i czeka, aż komunikat z identyfikatorem korelacji określony jest dostępna w kolejce lub wygaśnięciu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza w kolejce odwołuje się <xref:System.Messaging.MessageQueue> wiadomości którego <xref:System.Messaging.Message.CorrelationId%2A> jest zgodny z określonym `correlationId` parametru. Ta metoda zwraca niezwłocznie, jeśli komunikat z identyfikatorem korelacji określony przez `correlationId` parametr znajduje się w kolejce przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametru. W przeciwnym razie metoda czeka danego okresu czasu Nowa wiadomość zostanie dostarczona. Jeśli nowy komunikat nie zostanie dostarczona, przed upływem limitu czasu, jest zgłaszany wyjątek.  
  
 `timeout` Parametr określa łączny czas dla tej metody działania. Przeciwnie określa czas oczekiwania na nowe wiadomości w kolejce. Każdorazowo nadejdzie nowa wiadomość, ta metoda sprawdza, czy <xref:System.Messaging.Message.CorrelationId%2A> nowego komunikatu, aby sprawdzić, czy odpowiada `correlationId` parametru. W przeciwnym razie ta metoda uruchamia przed upłynięciem limitu czasu za pośrednictwem i czeka na innej nowej wiadomości na dostarczenie. W związku z tym, jeśli nowe wiadomości w dalszym ciągu pojawić się przed upływem limitu czasu, istnieje możliwość dla tej metody kontynuować do momentu przed upłynięciem limitu czasu wygaśnięcia bez żadnych nowych wiadomości przychodzących lub do momentu nadejścia wiadomości, których uruchomiona przez czas nieokreślony, <xref:System.Messaging.Message.CorrelationId%2A> Dopasowuje `correlationId` parametru. Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który chcesz użyć do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrznego. Można określić `None` Aby komunikat o błędzie z kolejką transakcyjną poza kontekstem transakcji.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjne, odebranego komunikatu będzie zwracany do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązanie komunikat wysłany do kolejki, aby skojarzone wiadomości odpowiedzi, raport lub potwierdzenia.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 Do odczytywania komunikatów z identyfikatorem korelacji określonego bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, będzie istnieć żadne do wdrożenia w przypadku transakcji zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="correlationId" /> nie został odnaleziony.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat o określonej <paramref name="correlationId" /> nie istnieje w kolejce i nie pojawić się przed wygaśnięciem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem, usunięcie go z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Wiadomości do odbierania.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem z nietransakcyjnej kolejki i natychmiast zgłasza wyjątek, jeśli żaden komunikat o podanym identyfikatorze znajduje się w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odczytywać komunikaty przy użyciu znanego identyfikatora i usunąć go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie znajduje się w kolejce.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwość wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub komunikat odpowiedzi generowane aplikację, który został utworzony w wyniku wiadomości wysłanych do kolejki.  
  
 Do odczytywania komunikatów z określonym identyfikatorem bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="id" /> nie został odnaleziony.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Wiadomości do odbierania.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem (z kolejką transakcyjną) i natychmiast zgłasza wyjątek, jeśli żaden komunikat o podanym identyfikatorze znajduje się w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odczytywać komunikaty przy użyciu znanego identyfikatora i usunąć go z kolejki przy użyciu tego kontekstu transakcji wewnętrznej zdefiniowany przez `transaction` parametru. Ta metoda wyrzuca natychmiast wyjątek, jeśli komunikat nie znajduje się w kolejce  
  
 <xref:System.Messaging.Message.Id%2A> Właściwość wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru.  
  
 Ponieważ ta metoda jest wywoływana na kolejkę transakcyjną, zostaną zwrócone odebranego komunikatu do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub komunikat odpowiedzi generowane aplikację, który został utworzony w wyniku wiadomości wysłanych do kolejki.  
  
 Do odczytywania komunikatów z określonym identyfikatorem bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, będzie istnieć żadne do wdrożenia w przypadku transakcji zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="transaction" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="id" /> nie został odnaleziony.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka jest nietransakcyjnej.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Wiadomości do odbierania.</param>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem i natychmiast zgłasza wyjątek, jeśli żaden komunikat o podanym identyfikatorze znajduje się w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odczytywać komunikaty przy użyciu znanego identyfikatora i usunąć go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie znajduje się w kolejce. W przeciwnym razie usuniętych z kolejki i zwrócony do aplikacji przy użyciu kontekstu transakcji, zdefiniowane przez komunikat `transactionType` parametru.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który chcesz użyć do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrznego. Można określić `None` Aby komunikat o błędzie z kolejką transakcyjną poza kontekstem transakcji.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwość wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru. Jeśli komunikat o podanym identyfikatorze jest w kolejce, innym niż ten, który został skojarzony z tym <xref:System.Messaging.MessageQueue> wypadku komunikat nie zostanie znaleziony.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjne, odebranego komunikatu będzie zwracany do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub komunikat odpowiedzi generowane aplikację, który został utworzony w wyniku wiadomości wysłanych do kolejki.  
  
 Do odczytywania komunikatów z określonym identyfikatorem bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, będzie istnieć żadne do wdrożenia w przypadku transakcji zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="id" /> nie został odnaleziony.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Wiadomości do odbierania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem (z kolejka nietransakcyjna) i czeka, aż komunikat o podanym identyfikatorze jest dostępna w kolejce lub wygaśnięciu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odczytywać komunikaty przy użyciu znanego identyfikatora i usunąć go z kolejki. Ta metoda zwraca niezwłocznie, jeśli komunikat z identyfikatorem określony przez `id` parametr znajduje się w kolejce. W przeciwnym razie metoda czeka danego okresu czasu Nowa wiadomość zostanie dostarczona. Jeśli nowy komunikat nie zostanie dostarczona, przed upływem limitu czasu, jest zgłaszany wyjątek.  
  
 `timeout` Parametr określa łączny czas dla tej metody działania. Przeciwnie określa czas oczekiwania na nowe wiadomości w kolejce. Każdorazowo nadejdzie nowa wiadomość, ta metoda sprawdza, czy <xref:System.Messaging.Message.Id%2A> nowego komunikatu, aby sprawdzić, czy odpowiada `id` parametru. W przeciwnym razie ta metoda uruchamia przed upłynięciem limitu czasu za pośrednictwem i czeka na innej nowej wiadomości na dostarczenie. W związku z tym, jeśli nowe wiadomości w dalszym ciągu pojawić się przed upływem limitu czasu, istnieje możliwość dla tej metody kontynuować do momentu przed upłynięciem limitu czasu wygaśnięcia bez żadnych nowych wiadomości przychodzących lub do momentu nadejścia wiadomości, których uruchomiona przez czas nieokreślony, <xref:System.Messaging.Message.Id%2A> Dopasowuje `id` parametru.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwość wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru.  
  
 Użyj tego przeciążenia <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> gdy jest dopuszczalny dla bieżącego wątku do zablokowania tak długo, jak nowe wiadomości w dalszym ciągu pojawić się w kolejce przed upływem limitu czasu określonego przez `timeout` parametru. Wątek zostaną zablokowane dla co najmniej danym okresie czasu lub nieokreślony Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametr, lub jeśli nowe wiadomości w dalszym ciągu pojawić się w kolejce przed upływem limitu czasu określonego przez `timeout` parametr.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub komunikat odpowiedzi generowane aplikację, który został utworzony w wyniku wiadomości wysłanych do kolejki.  
  
 Do odczytywania komunikatów z określonym identyfikatorem bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat o określonej <paramref name="id" /> dotrze do kolejki przed wygaśnięciem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Wiadomości do odbierania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem (z kolejką transakcyjną) i czeka, aż komunikat o podanym identyfikatorze jest dostępna w kolejce lub wygaśnięciu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odczytywać komunikaty przy użyciu znanego identyfikatora i usunąć go z kolejki przy użyciu tego kontekstu transakcji wewnętrznej zdefiniowany przez `transaction` parametru. Ta metoda zwraca niezwłocznie, jeśli komunikat z identyfikatorem określony przez `id` parametr znajduje się w kolejce. W przeciwnym razie metoda czeka danego okresu czasu Nowa wiadomość zostanie dostarczona. Jeśli nowy komunikat nie zostanie dostarczona, przed upływem limitu czasu, jest zgłaszany wyjątek.  
  
 `timeout` Parametr określa łączny czas dla tej metody działania. Przeciwnie określa czas oczekiwania na nowe wiadomości w kolejce. Każdorazowo nadejdzie nowa wiadomość, ta metoda sprawdza, czy <xref:System.Messaging.Message.Id%2A> nowego komunikatu, aby sprawdzić, czy odpowiada `id` parametru. W przeciwnym razie ta metoda uruchamia przed upłynięciem limitu czasu za pośrednictwem i czeka na innej nowej wiadomości na dostarczenie. W związku z tym, jeśli nowe wiadomości w dalszym ciągu pojawić się przed upływem limitu czasu, istnieje możliwość dla tej metody kontynuować do momentu przed upłynięciem limitu czasu wygaśnięcia bez żadnych nowych wiadomości przychodzących lub do momentu nadejścia wiadomości, których uruchomiona przez czas nieokreślony, <xref:System.Messaging.Message.Id%2A> Dopasowuje `id` parametru.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwość wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru.  
  
 Użyj tego przeciążenia <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> gdy jest dopuszczalny dla bieżącego wątku do zablokowania tak długo, jak nowe wiadomości w dalszym ciągu pojawić się w kolejce przed upływem limitu czasu określonego przez `timeout` parametru. Wątek zostaną zablokowane dla co najmniej danym okresie czasu lub nieokreślony Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametr, lub jeśli nowe wiadomości w dalszym ciągu pojawić się w kolejce przed upływem limitu czasu określonego przez `timeout` parametr.  
  
 Ponieważ ta metoda jest wywoływana na kolejkę transakcyjną, zostaną zwrócone odebranego komunikatu do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub komunikat odpowiedzi generowane aplikację, który został utworzony w wyniku wiadomości wysłanych do kolejki.  
  
 Do odczytywania komunikatów z określonym identyfikatorem bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, będzie istnieć żadne do wdrożenia w przypadku transakcji zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="transaction" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat o określonej <paramref name="id" /> dotrze do kolejki przed wygaśnięciem limitu czasu.  
  
—lub— 
Kolejka jest nietransakcyjnej.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Wiadomości do odbierania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, dopóki nowa wiadomość jest dostępna w celu przeprowadzenia inspekcji.</param>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem i czeka, aż komunikat o podanym identyfikatorze jest dostępna w kolejce lub wygaśnięciu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odczytywać komunikaty przy użyciu znanego identyfikatora i usunąć go z kolejki. Ta metoda zwraca niezwłocznie, jeśli komunikat z identyfikatorem określony przez `id` parametr znajduje się w kolejce przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametru. W przeciwnym razie metoda czeka danego okresu czasu Nowa wiadomość zostanie dostarczona. Jeśli nowy komunikat nie zostanie dostarczona, przed upływem limitu czasu, jest zgłaszany wyjątek.  
  
 `timeout` Parametr określa łączny czas dla tej metody działania. Przeciwnie określa czas oczekiwania na nowe wiadomości w kolejce. Każdorazowo nadejdzie nowa wiadomość, ta metoda sprawdza, czy <xref:System.Messaging.Message.Id%2A> nowego komunikatu, aby sprawdzić, czy odpowiada `id` parametru. W przeciwnym razie ta metoda uruchamia przed upłynięciem limitu czasu za pośrednictwem i czeka na innej nowej wiadomości na dostarczenie. W związku z tym, jeśli nowe wiadomości w dalszym ciągu pojawić się przed upływem limitu czasu, istnieje możliwość dla tej metody kontynuować do momentu przed upłynięciem limitu czasu wygaśnięcia bez żadnych nowych wiadomości przychodzących lub do momentu nadejścia wiadomości, których uruchomiona przez czas nieokreślony, <xref:System.Messaging.Message.Id%2A> Dopasowuje `id` parametru.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który chcesz użyć do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrznego. Można określić `None` Aby komunikat o błędzie z kolejką transakcyjną poza kontekstem transakcji.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwość wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru. Jeśli komunikat o podanym identyfikatorze jest w kolejce, innym niż ten, który został skojarzony z tym <xref:System.Messaging.MessageQueue> wypadku komunikat nie zostanie znaleziony.  
  
 Użyj tego przeciążenia <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> gdy jest dopuszczalny dla bieżącego wątku do zablokowania tak długo, jak nowe wiadomości w dalszym ciągu pojawić się w kolejce przed upływem limitu czasu określonego przez `timeout` parametru. Wątek zostaną zablokowane dla co najmniej danym okresie czasu lub nieokreślony Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametr, lub jeśli nowe wiadomości w dalszym ciągu pojawić się w kolejce przed upływem limitu czasu określonego przez `timeout` parametr.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjne, odebranego komunikatu będzie zwracany do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Dwie inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszy komunikat w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub komunikat odpowiedzi generowane aplikację, który został utworzony w wyniku wiadomości wysłanych do kolejki.  
  
 Do odczytywania komunikatów z określonym identyfikatorem bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszy komunikat w kolejce, dzięki czemu kolejne wywołania do metody zwracają ten sam komunikat, chyba że komunikat o wyższym priorytecie dociera do kolejki. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, będzie istnieć żadne do wdrożenia w przypadku transakcji zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat o określonej <paramref name="id" /> dotrze do kolejki przed wygaśnięciem limitu czasu.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Odbiera szczegółowy komunikat o błędzie z kolejki. Identyfikator wyszukiwania lub położenia na wierzch lub na końcu kolejki można określić komunikat.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> Wiadomości do odbierania.</param>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Odbiera komunikat, który jest zgodny z identyfikatorem danego wyszukiwania z nietransakcyjnej kolejki.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.LookupId" /> dopasowania właściwości <paramref name="lookupId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj komunikat o identyfikatorze znane wyszukiwania i usunąć go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie znajduje się w kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość wiadomości jest unikatowa w kolejce zawierającej komunikat zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `lookupId` parametru.  
  
 Do odczytywania komunikatów z określonemu identyfikatorowi przeszukiwania, bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="lookupId" /> nie został odnaleziony.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">Jedną z <see cref="T:System.Messaging.MessageLookupAction" /> wartości, określający, jak komunikat został odczytany w kolejce. Określ jedną z następujących czynności: 
 <see langword="MessageLookupAction.Current" />: Odbiera komunikat określony przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Next" />: Otrzymuje wiadomość następującą wiadomość określoną przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Previous" />: Otrzymuje wiadomość poprzedzającą wiadomość określoną przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.First" />: Odbiera pierwszy komunikat w kolejce i usuwa go z kolejki. <c>Lookupld</c> parametru musi być równa 0.  
  
 <see langword="MessageLookupAction.Last" />: Odbiera ostatniego komunikatu w kolejce i usuwa go z kolejki. <c>Lookupld</c> parametru musi być równa 0.</param>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> Do odbierania wiadomości lub 0. 0 jest używany podczas uzyskiwania dostępu do pierwszej lub ostatniej wiadomości w kolejce.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Odbiera szczegółowy komunikat o błędzie z kolejką transakcyjną. Identyfikator wyszukiwania lub położenia na wierzch lub na końcu kolejki można określić komunikat.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Określony przez <paramref name="lookupId" /> i <paramref name="action" /> parametry przekazywane w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj komunikat o identyfikatorze znane wyszukiwania i usunąć go z kolejki przy użyciu kontekstu transakcji, zdefiniowane przez `transaction` parametru. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie znajduje się w kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość wiadomości jest unikatowa w kolejce zawierającej komunikat zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `lookupId` parametru.  
  
 Ponieważ ta metoda jest wywoływana na kolejkę transakcyjną, zostaną zwrócone odebranego komunikatu do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 Do odczytywania komunikatów z określonym identyfikatorem bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metody. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> nie usuwa komunikaty z kolejki, będzie istnieć żadne do wdrożenia w przypadku transakcji zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="lookupId" /> nie został odnaleziony.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.  
  
—lub— 
Kolejka jest nietransakcyjnej.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageLookupAction" /> elementów członkowskich.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">Jedną z <see cref="T:System.Messaging.MessageLookupAction" /> wartości, określający, jak komunikat został odczytany w kolejce. Określ jedną z następujących czynności: 
 <see langword="MessageLookupAction.Current" />: Odbiera komunikat określony przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Next" />: Otrzymuje wiadomość następującą wiadomość określoną przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Previous" />: Otrzymuje wiadomość poprzedzającą wiadomość określoną przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.First" />: Odbiera pierwszy komunikat w kolejce i usuwa go z kolejki. <c>Lookupld</c> parametru musi być równa 0.  
  
 <see langword="MessageLookupAction.Last" />: Odbiera ostatniego komunikatu w kolejce i usuwa go z kolejki. <c>Lookupld</c> parametru musi być równa 0.</param>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> Do odbierania wiadomości lub 0. 0 jest używany podczas uzyskiwania dostępu do pierwszej lub ostatniej wiadomości w kolejce.</param>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Odbiera szczegółowy komunikat o błędzie z kolejki w kontekście określonej transakcji. Identyfikator wyszukiwania lub położenia na wierzch lub na końcu kolejki można określić komunikat.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Określony przez <paramref name="action" /> i <paramref name="lookupId" /> parametry przekazywane w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj komunikat o identyfikatorze znane wyszukiwania i usunąć go z kolejki przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametru. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie znajduje się w kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość wiadomości jest unikatowa w kolejce zawierającej komunikat zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `lookupId` parametru.  
  
 Do odczytywania komunikatów z określonym identyfikatorem bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metody. Brak kontekstu transakcji skojarzony z komunikatem zwracany przez wywołanie <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> nie usuwa komunikaty z kolejki, będzie istnieć żadne do wdrożenia w przypadku transakcji zostało przerwane.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który chcesz użyć do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrznego. Można określić `None` Aby komunikat o błędzie z kolejką transakcyjną poza kontekstem transakcji.  
  
 Jeśli ta metoda jest wywoływana w celu odebrania komunikatu z kolejki transakcyjne, odebranego komunikatu będzie zwracany do kolejki, jeśli transakcja została przerwana. Komunikat nie jest trwale usunięte z kolejki, dopóki transakcja została zatwierdzona.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat o określonej <paramref name="lookupId" /> nie został odnaleziony.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageLookupAction" /> elementów członkowskich.  
  
—lub— 
<paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy komunikat został usunięty z kolejki. To zdarzenie jest wywoływane przez operację asynchroniczną <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest używana podczas przetwarzania asynchronicznego podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, gdy komunikat jest dostępna w kolejce.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> Służy do wykonania operacji zainicjowanych przez wywołanie <xref:System.Messaging.MessageQueue.BeginReceive%2A> i wgląd do wiadomości gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest wywoływane.  
  
 Po utworzeniu <xref:System.Messaging.ReceiveCompletedEventHandler> delegata, możesz zidentyfikować metody, która będzie obsługiwać zdarzenia. Aby skojarzyć zdarzenia z programu obsługi zdarzeń, należy dodać wystąpienie delegata zdarzenia. Program obsługi zdarzeń jest wywoływany przy każdym wystąpieniu zdarzenia, o ile nie usunięto delegata. Aby uzyskać więcej informacji na temat delegatów obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyReceiveCompleted`, dołącza go do <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegata obsługi zdarzeń i wywołania <xref:System.Messaging.MessageQueue.BeginReceive%2A> do zainicjowania asynchronicznego odbioru operacji w kolejce, która znajduje się w ścieżce ". \myQueue". Gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane, w przykładzie odbiera komunikat i zapisuje jego treść na ekranie. Przykład następnie wywołuje <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie, aby zainicjować nowe asynchronicznych operacji odbioru.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odświeża właściwości przedstawione przez <see cref="T:System.Messaging.MessageQueue" /> aby odzwierciedlić bieżący stan zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> Synchronizuje właściwości <xref:System.Messaging.MessageQueue> za pomocą jego skojarzonego usługi kolejkowania komunikatów zasób serwera. Jeśli dowolnej właściwości, takie jak <xref:System.Messaging.MessageQueue.Label%2A> lub <xref:System.Messaging.MessageQueue.Category%2A>, został zmieniony na serwerze, od czasu <xref:System.Messaging.MessageQueue> został utworzony, <xref:System.Messaging.MessageQueue.Refresh%2A> aktualizacje <xref:System.Messaging.MessageQueue> o nowe informacje.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje wartości domyślne systemu operacyjnego na liście uprawnień. Usuwa wszystkie uprawnienia kolejki, które mają być dołączane do domyślnej listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wywołujesz <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, zwracać listy uprawnień do jego wartości domyślnych. Ogólnie rzecz biorąc, to umożliwia przyznanie wszystkich uprawnień twórcy kolejki i wszyscy zapewnia grupy następujące uprawnienia:  
  
-   Pobierz właściwości kolejki.  
  
-   Uzyskaj uprawnienia kolejki.  
  
-   Napisz do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła obiekt do kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <summary>Wysyła obiekt do kolejki nietransakcyjnej przywoływane przez to <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można wysłać komunikatu, który zawiera `obj` parametru do kolejki, odwołuje się <xref:System.Messaging.MessageQueue>. Obiekt wysyłać do kolejki może być <xref:System.Messaging.Message> lub dowolnym obiektem zarządzanym. Jeśli wyślesz dowolnego obiektu jest inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości.  
  
 Jeśli używasz tego przeciążenia do wysyłania komunikatu do kolejki transakcyjne, wiadomość zostanie wysłana do kolejki utraconych wiadomości. Komunikat, aby być częścią transakcji, który zawiera inne komunikaty, użyć przeciążenia, które przyjmuje <xref:System.Messaging.MessageQueueTransaction> lub <xref:System.Messaging.MessageQueueTransactionType> jako parametr.  
  
 Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwości przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wartością domyślną jest element formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do każdego obiektu innego niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykiety lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości dotyczą każdy komunikat, który zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> gdy Twoja aplikacja przesyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, wartości właściwości ustawione dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy kod łączy do kolejki komunikatów i wysyła komunikat do kolejki.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 Poniższy przykładowy kod wysyła, zdefiniowany przez aplikację `Order` klasy do kolejki, a następnie otrzymuje komunikat z kolejki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Nie ustawiono właściwości.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Wysyła obiekt do kolejki transakcyjne przywoływane przez to <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można wysłać komunikatu, który zawiera `obj` parametr Kolejka transakcyjna odwołuje się <xref:System.Messaging.MessageQueue>, używanie kontekstu transakcji wewnętrznej zdefiniowany przez `transaction` parametru. Obiekt wysyłać do kolejki może być <xref:System.Messaging.Message> lub dowolnym obiektem zarządzanym. Jeśli wyślesz dowolnego obiektu jest inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości.  
  
 Jeśli używasz tego przeciążenia do wysyłania komunikatu do kolejki nietransakcyjnej może wysłać komunikatu do kolejki utraconych wiadomości bez zgłoszenia wyjątku.  
  
 Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwości przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wartością domyślną jest element formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do każdego obiektu innego niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykiety lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości dotyczą każdy komunikat, który zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> gdy Twoja aplikacja przesyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, wartości właściwości ustawione dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 <xref:System.Messaging.MessageQueueTransaction> jest wątkowości rozpoznające, więc jeśli Twoje stan apartamentu `STA`, transakcji nie można używać w wielu wątkach. Visual Basic ustawia stan wątku głównego do `STA`, więc należy najpierw zastosować <xref:System.MTAThreadAttribute> w `Main` procedurę. W przeciwnym razie wysyła wiadomości transakcyjne przy użyciu innego wątku zgłasza <xref:System.Messaging.MessageQueueException> wyjątku. Należy zastosować <xref:System.MTAThreadAttribute> przy użyciu poniższy fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła ciąg do kolejki transakcyjne i odbiera wiadomości z tej kolejki.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Nie ustawiono właściwości.  
  
—lub— 
Aplikacja usługi kolejkowania komunikatów wykazały, użyj niepoprawne transakcji.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Wysyła obiekt do kolejki przywoływane przez to <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można wysłać komunikatu, który zawiera `obj` parametru do kolejki, odwołuje się <xref:System.Messaging.MessageQueue>, przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametru. Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który ma być używany do wysyłania wiadomości. Określ `Single` Jeśli chcesz wysłać wiadomość jako jedna transakcja wewnętrznego. Można określić `None` Chcąc wysyłać wiadomości transakcyjnych nietransakcyjnej wątku.  
  
 Obiekt wysyłać do kolejki może być <xref:System.Messaging.Message> lub dowolnym obiektem zarządzanym. Jeśli wyślesz dowolnego obiektu jest inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości.  
  
 Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwości przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wartością domyślną jest element formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do każdego obiektu innego niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykiety lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości dotyczą każdy komunikat, który zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> gdy Twoja aplikacja przesyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, wartości właściwości ustawione dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Nie ustawiono właściwości.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <param name="label">Etykieta wiadomości.</param>
        <summary>Wysyła obiekt do kolejki nietransakcyjnej przywoływane przez to <see cref="T:System.Messaging.MessageQueue" /> i Określa etykietę komunikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można wysłać komunikatu, który zawiera `obj` parametru do kolejki, odwołuje się <xref:System.Messaging.MessageQueue>. W przypadku tego przeciążenia można określić etykieta ciągu, identyfikująca wiadomości. Obiekt wysyłać do kolejki może być <xref:System.Messaging.Message>, struktury, obiekt danych lub dowolnym obiektem zarządzanym. Jeśli wyślesz dowolnego obiektu jest inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości.  
  
 Etykieta wiadomości różni się od etykietę kolejki komunikatów, ale obie są zależne od aplikacji i mieć nie dziedziczą znaczenie dla usługi kolejkowania komunikatów.  
  
 Jeśli używasz tego przeciążenia do wysyłania komunikatu do kolejki transakcyjne, wiadomość zostanie wysłana do kolejki utraconych wiadomości. Komunikat, aby być częścią transakcji, który zawiera inne komunikaty, użyć przeciążenia, które przyjmuje <xref:System.Messaging.MessageQueueTransaction> lub <xref:System.Messaging.MessageQueueTransactionType> jako parametr.  
  
 <xref:System.Messaging.MessageQueue.Path%2A> Właściwości dla tego <xref:System.Messaging.MessageQueue> musi być określone wystąpienie, zanim wyślesz wiadomość. Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwości przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wartością domyślną jest element formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do każdego obiektu innego niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykiety lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości dotyczą każdy komunikat, który zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> gdy Twoja aplikacja przesyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, wartości właściwości ustawione dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Nie ustawiono właściwości.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <param name="label">Etykieta wiadomości.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Wysyła obiekt do kolejki transakcyjne przywoływane przez to <see cref="T:System.Messaging.MessageQueue" /> i Określa etykietę komunikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można wysłać komunikatu, który zawiera `obj` parametr Kolejka transakcyjna odwołuje się <xref:System.Messaging.MessageQueue>, używanie kontekstu transakcji wewnętrznej zdefiniowany przez `transaction` parametru. W przypadku tego przeciążenia można określić etykieta ciągu, identyfikująca wiadomości. Obiekt wysyłać do kolejki może być <xref:System.Messaging.Message>, struktury, obiekt danych lub dowolnym obiektem zarządzanym. Jeśli wyślesz dowolnego obiektu jest inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości.  
  
 Etykieta wiadomości różni się od etykietę kolejki komunikatów, ale obie są zależne od aplikacji i mieć nie dziedziczą znaczenie dla usługi kolejkowania komunikatów.  
  
 Jeśli używasz tego przeciążenia do wysyłania komunikatu do kolejki nietransakcyjnej może wysłać komunikatu do kolejki utraconych wiadomości bez zgłoszenia wyjątku.  
  
 Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwości przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wartością domyślną jest element formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do każdego obiektu innego niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykiety lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości dotyczą każdy komunikat, który zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> gdy Twoja aplikacja przesyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, wartości właściwości ustawione dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości  
  
 <xref:System.Messaging.MessageQueueTransaction> jest wątkowości rozpoznające, więc jeśli Twoje stan apartamentu `STA`, transakcji nie można używać w wielu wątkach. Visual Basic ustawia stan wątku głównego do `STA`, więc należy najpierw zastosować <xref:System.MTAThreadAttribute> w `Main` procedurę. W przeciwnym razie wysyła wiadomości transakcyjne przy użyciu innego wątku zgłasza <xref:System.Messaging.MessageQueueException> wyjątku. Należy zastosować <xref:System.MTAThreadAttribute> przy użyciu poniższy fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="transaction" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Nie ustawiono właściwości.  
  
—lub— 
Aplikacja usługi kolejkowania komunikatów wskazane przypadki użycia procedury transakcji niepoprawne.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <param name="label">Etykieta wiadomości.</param>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Wysyła obiekt do kolejki przywoływane przez to <see cref="T:System.Messaging.MessageQueue" /> i Określa etykietę komunikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można wysłać komunikatu, który zawiera `obj` parametru do kolejki, odwołuje się <xref:System.Messaging.MessageQueue>, przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametru. Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który ma być używany do wysyłania wiadomości. Określ `Single` Jeśli chcesz wysłać wiadomość jako jedna transakcja wewnętrznego. Można określić `None` Chcąc wysyłać wiadomości transakcyjnych nietransakcyjnej wątku.  
  
 Obiekt wysyłać do kolejki może być <xref:System.Messaging.Message> lub dowolnym obiektem zarządzanym. Jeśli wyślesz dowolnego obiektu jest inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości. W przypadku tego przeciążenia można określić etykieta ciągu, identyfikująca wiadomości.  
  
 Etykieta wiadomości różni się od etykietę kolejki komunikatów, ale obie są zależne od aplikacji i mieć nie dziedziczą znaczenie dla usługi kolejkowania komunikatów.  
  
 Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwości przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wartością domyślną jest element formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do każdego obiektu innego niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykiety lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości dotyczą każdy komunikat, który zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> gdy Twoja aplikacja przesyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, wartości właściwości ustawione dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Aplikacja usługi kolejkowania komunikatów wskazane przypadki użycia procedury transakcji niepoprawne.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Nie ustawiono właściwości.  
  
—lub— 
Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje uprawnienia do bieżącego zestawu. Tej kontrolki, które ma wystarczające uprawnienia dostępu do właściwości kolejki i wiadomości w kolejce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Element <see cref="T:System.Messaging.AccessControlList" /> zawiera jeden lub więcej wpisów kontroli dostępu, określające zarządzie oraz uprawnień udzielanych.</param>
        <summary>Przypisuje uprawnienia do kolejki na podstawie zawartości listy kontroli dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby udzielić, odmówić lub odwołania praw przy użyciu zbiór wpisów kontroli dostępu pozwala określić informacje o administratora i uprawnień. To jest używany, na przykład, aby udzielić uprawnień do wielu użytkowników, w tym samym czasie.  
  
 Zarządca, należy określić podczas konstruowania `ace` parametr może być poszczególnych użytkowników, grupy użytkowników lub komputera. Jeśli zarządca odpowiedzi to osoba, użyj formatu `DOMAIN` \\ `user`. Można określić "." dla zarządcy wskazać na komputerze lokalnym.  
  
 Uprawnienia można przypisać za pomocą <xref:System.Messaging.MessageQueue.SetPermissions%2A> Dodawanie praw do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę, a grupa domeny, wszyscy mają uprawnienia get właściwości kolejki, uzyskaj uprawnienia i zapisu do kolejki. Gdy wywołujesz <xref:System.Messaging.MessageQueue.SetPermissions%2A>, informacje użytkownika i uprawnienia są dołączane do dolnej części listy.  
  
 System sprawdza każdy <xref:System.Messaging.AccessControlEntry> w sekwencji, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa dostępu <xref:System.Messaging.AccessControlEntry> wyraźnie zabrania żadnych praw żądany dostęp do jednego z zarządzie wymienione w tokenie dostępu dla wątku.  
  
-   Co najmniej dostęp dozwolone <xref:System.Messaging.AccessControlEntry> sugerowanych dla wszystkich żądanych uprawnienia są nadawane zarządzie jawnie wymieniony w tokenie dostępu dla wątku.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i ma jeszcze co najmniej jeden żądanego prawo dostępu, które nie zostały jawnie zezwolił, w którym to przypadku niejawnie odmowa dostępu.  
  
 Podczas konstruowania `dacl` Dodaj parametr <xref:System.Messaging.AccessControlEntry> wystąpień do Twojej <xref:System.Messaging.AccessControlList> kolekcji. Podczas konstruowania każdego wpisu kontroli dostępu, należy określić prawa dostępu ogólne lub standard. Prawa do kolejki może być dowolną kombinacją następujących czynności:  
  
-   Usuwanie  
  
-   Odczyt zabezpieczeń  
  
-   Zapis zabezpieczeń  
  
-   Synchronizuj  
  
-   Modyfikuj właściciela  
  
-   Odczyt  
  
-   Write  
  
-   Wykonywanie  
  
-   Wymagane  
  
-   Wszystkie  
  
-   Brak  
  
 Te uprawnienia są zestaw flag bitowych, które można połączyć za pomocą operatora bitowego OR.  
  
-   Pełna kontrola  
  
-   Usuwanie wiadomości  
  
-   Odbieranie komunikatów  
  
-   Wgląd do wiadomości  
  
-   Odbieranie wiadomości dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustaw właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejęcie na własność kolejki  
  
-   Napisz wiadomość  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">A <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> określający użytkownika, typ dostępu i typ uprawnienia.</param>
        <summary>Przypisuje uprawnienia do kolejki, w oparciu o zawartość wpisu kontroli dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia udzielanie, odmawianie i odwołania praw przy użyciu wpisu kontroli dostępu, aby określić zarządca i informacji o prawach.  
  
 Zarządca, należy określić podczas konstruowania `ace` parametr może być poszczególnych użytkowników, grupy użytkowników lub komputera. Jeśli zarządca odpowiedzi to osoba, użyj formatu `DOMAIN` \\ `user`. Można określić "." dla zarządcy wskazać na komputerze lokalnym.  
  
 Uprawnienia można przypisać za pomocą <xref:System.Messaging.MessageQueue.SetPermissions%2A> Dodawanie praw do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę, a grupa domeny, wszyscy mają uprawnienia get właściwości kolejki, uzyskaj uprawnienia i zapisu do kolejki. Gdy wywołujesz <xref:System.Messaging.MessageQueue.SetPermissions%2A>, informacje użytkownika i uprawnienia są dołączane do dolnej części listy.  
  
 System sprawdza każdy <xref:System.Messaging.AccessControlEntry> w sekwencji, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa dostępu <xref:System.Messaging.AccessControlEntry> wyraźnie zabrania żadnych praw żądany dostęp do jednego z zarządzie wymienione w tokenie dostępu dla wątku.  
  
-   Co najmniej dostęp dozwolone <xref:System.Messaging.AccessControlEntry> sugerowanych dla wszystkich żądanych uprawnienia są nadawane zarządzie jawnie wymieniony w tokenie dostępu dla wątku.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i ma jeszcze co najmniej jeden żądanego prawo dostępu, które nie zostały jawnie zezwolił, w którym to przypadku niejawnie odmowa dostępu.  
  
 Prawa do kolejki, które jest określane w `rights` parametru podczas tworzenia usługi <xref:System.Messaging.MessageQueueAccessControlEntry>, może być dowolną kombinacją następujących czynności:  
  
-   Pełna kontrola  
  
-   Usuwanie wiadomości  
  
-   Odbieranie komunikatów  
  
-   Wgląd do wiadomości  
  
-   Odbieranie wiadomości dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustaw właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejęcie na własność kolejki  
  
-   Napisz wiadomość  
  
 `rights` Parametr w Konstruktorze `ace` parametru jest flagą <xref:System.Messaging.MessageQueueAccessRights> wyliczenia. Reprezentuje zestaw flag bitowych, które można połączyć za pomocą operatora bitowego lub podczas kompilowania `rights` parametru.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Osoby, grupy lub komputera, która umożliwia pobieranie dodatkowych praw do kolejki.</param>
        <param name="rights">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> oznacza to zestaw praw do kolejki usługi kolejkowania komunikatów przypisuje <c>użytkownika</c> przekazany.</param>
        <summary>Służy do zapewnia prawa dostępu określonego komputera, grupy lub użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby udzielić praw określonego użytkownika. Użytkownik może być żadnych zarządca prawidłowe, w tym poszczególnych użytkowników, grup użytkowników lub komputer. Jeśli użytkownik to osoba, użyj formatu `DOMAIN` \\ `user` dla `user` parametru. Można określić "." dla `user` parametru, aby wskazać na komputerze lokalnym.  
  
 Uprawnienia można przypisać za pomocą <xref:System.Messaging.MessageQueue.SetPermissions%2A> Dodawanie praw do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę, a grupa domeny, wszyscy mają uprawnienia get właściwości kolejki, uzyskaj uprawnienia i zapisu do kolejki. Gdy wywołujesz <xref:System.Messaging.MessageQueue.SetPermissions%2A>, informacje użytkownika i uprawnienia są dołączane do dolnej części listy.  
  
 System sprawdza każdy <xref:System.Messaging.AccessControlEntry> w sekwencji, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa dostępu <xref:System.Messaging.AccessControlEntry> wyraźnie zabrania żadnych praw żądany dostęp do jednego z zarządzie wymienione w tokenie dostępu dla wątku.  
  
-   Co najmniej dostęp dozwolone <xref:System.Messaging.AccessControlEntry> sugerowanych dla wszystkich żądanych uprawnienia są nadawane zarządzie jawnie wymieniony w tokenie dostępu dla wątku.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i ma jeszcze co najmniej jeden żądanego prawo dostępu, które nie zostały jawnie zezwolił, w którym to przypadku niejawnie odmowa dostępu.  
  
 Prawa do kolejki, określone w `rights` parametru może być dowolną kombinacją z następujących czynności:  
  
-   Pełna kontrola  
  
-   Usuwanie wiadomości  
  
-   Odbieranie komunikatów  
  
-   Wgląd do wiadomości  
  
-   Odbieranie wiadomości dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustaw właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejęcie na własność kolejki  
  
-   Napisz wiadomość  
  
 <xref:System.Messaging.MessageQueueAccessRights> Wyliczenie reprezentuje zestaw flag bitowych, które można połączyć za pomocą operatora bitowego lub tworzyć `rights` parametru.  
  
 Z tego przeciążenia można tylko udzielić uprawnień; Nie można odwołać lub je zablokować. Aby jawnie udzielać, należy użyć innego przeciążenia <xref:System.Messaging.AccessControlEntryType> innych niż `Allow`.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="user" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Osoby, grupy lub komputera, która umożliwia pobieranie dodatkowych praw do kolejki.</param>
        <param name="rights">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> oznacza to zestaw praw do kolejki usługi kolejkowania komunikatów przypisuje <c>użytkownika</c> przekazany.</param>
        <param name="entryType">A <see cref="T:System.Messaging.AccessControlEntryType" /> określająca, czy należy udzielić, odmówić lub odwołać uprawnienia określone przez <c>praw</c> parametru.</param>
        <summary>Zapewnia komputera, grupy lub użytkownika prawa dostępu określonego typu kontroli dostępu określonego (Zezwalaj, Odmów, odwołać lub ustaw).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby udzielić, odmówić lub odwołać prawa określony dla poszczególnych użytkowników. Użytkownik może być żadnych zarządca prawidłowe, w tym poszczególnych użytkowników, grup użytkowników lub komputer. Jeśli użytkownik to osoba, użyj formatu `DOMAIN` \\ `user` dla `user` parametru. Można określić "." dla `user` parametru, aby wskazać na komputerze lokalnym.  
  
 Uprawnienia można przypisać za pomocą <xref:System.Messaging.MessageQueue.SetPermissions%2A> Dodawanie praw do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę, a grupa domeny, wszyscy mają uprawnienia get właściwości kolejki, uzyskaj uprawnienia i zapisu do kolejki. Gdy wywołujesz <xref:System.Messaging.MessageQueue.SetPermissions%2A>, informacje użytkownika i uprawnienia są dołączane do dolnej części listy.  
  
 System sprawdza każdy <xref:System.Messaging.AccessControlEntry> w sekwencji, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa dostępu <xref:System.Messaging.AccessControlEntry> wyraźnie zabrania żadnych praw żądany dostęp do jednego z zarządzie wymienione w tokenie dostępu dla wątku.  
  
-   Co najmniej dostęp dozwolone <xref:System.Messaging.AccessControlEntry> sugerowanych dla wszystkich żądanych uprawnienia są nadawane zarządzie jawnie wymieniony w tokenie dostępu dla wątku.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i ma jeszcze co najmniej jeden żądanego prawo dostępu, które nie zostały jawnie zezwolił, w którym to przypadku niejawnie odmowa dostępu.  
  
 Prawa do kolejki, określone w `rights` parametru może być dowolną kombinacją z następujących czynności:  
  
-   Pełna kontrola  
  
-   Usuwanie wiadomości  
  
-   Odbieranie komunikatów  
  
-   Wgląd do wiadomości  
  
-   Odbieranie wiadomości dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustaw właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejęcie na własność kolejki  
  
-   Napisz wiadomość  
  
 <xref:System.Messaging.MessageQueueAccessRights> Wyliczenie reprezentuje zestaw flag bitowych, które można połączyć za pomocą operatora bitowego lub tworzyć `rights` parametru.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który kieruje wynikające z wywołania programu obsługi zdarzeń <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> lub <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> zdarzeń.</summary>
        <value>A <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, który reprezentuje obiekt, który kieruje wynikające z wywołania programu obsługi zdarzeń <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> lub <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> zdarzeń. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Messaging.MessageQueue.ReceiveCompleted> lub <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń powstały na skutek <xref:System.Messaging.MessageQueue.BeginReceive%2A> lub <xref:System.Messaging.MessageQueue.BeginPeek%2A> żądania, odpowiednio do określonego wątku. Zazwyczaj <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> zostaje ustawiona po jego składników powiązane jest umieszczony wewnątrz formantu lub formularza, ponieważ te składniki są powiązane z określonym wątku.  
  
 Zazwyczaj obiekt synchronizacji kieruje wywołanie metody do jednego wątku.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kolejka akceptuje tylko transakcje.</summary>
        <value>
          <see langword="true" /> Jeśli kolejka akceptuje tylko komunikaty wysyłane w ramach transakcji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiadomości transakcyjne odnosi się do sprzęganie kilka pokrewne wiadomości w pojedynczą transakcję. Wysyłanie komunikatów, zgodnie z częścią transakcji gwarantuje, że komunikaty są dostarczane w kolejności, dostarczane tylko raz, a następnie pomyślnie pobrane z kolejki docelowej.  
  
 Jeśli kolejka jest transakcyjna, akceptuje tylko wiadomości, które są wysyłane w ramach transakcji. Jednak wiadomość nietransakcyjna mogą być wysyłane lub odbierane z kolejki transakcji lokalnej bez jawnie za pomocą transakcyjnych <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, i <xref:System.Messaging.MessageQueueTransaction.Abort%2A> składni. Jeśli wiadomość nietransakcyjna zostanie wysłany do kolejki transakcyjnej, ten składnik tworzy transakcji pojedynczej wiadomości, z wyjątkiem w przypadku odwołania do kolejki na komputerze zdalnym przy użyciu z bezpośrednią nazwą formatu. W takiej sytuacji jeśli nie określisz kontekstu transakcji podczas wysyłania komunikatu, jeden nie jest tworzony automatycznie i będzie można wysłać wiadomości do kolejki utraconych wiadomości.  
  
 Jeśli wyślesz wiadomość nietransakcyjna do kolejki transakcji nie można wycofać komunikat w przypadku wyjątku.  
  
 <xref:System.Messaging.MessageQueueTransaction> jest wątkowości rozpoznające, więc jeśli Twoje stan apartamentu `STA`, transakcji nie można używać w wielu wątkach. Visual Basic ustawia stan wątku głównego do `STA`, więc należy najpierw zastosować <xref:System.MTAThreadAttribute> w `Main` procedurę. W przeciwnym razie wysyła wiadomości transakcyjne przy użyciu innego wątku zgłasza <xref:System.Messaging.MessageQueueException> wyjątku. Należy zastosować <xref:System.MTAThreadAttribute> przy użyciu poniższy fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.Transactional%2A> właściwości.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy Odebrane komunikaty są kopiowane do kolejki dziennika.</summary>
        <value>
          <see langword="true" /> Jeśli odebrane komunikaty z kolejki są kopiowane do kolejki dziennika; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja usługi kolejkowania komunikatów, tworzy nową kolejkę aplikacji, automatycznie tworzy kolejkę dziennika skojarzonych w tej samej lokalizacji. Kolejki dziennika jest używane do śledzenia komunikatów usuniętych z kolejki. Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym, inne <xref:System.Messaging.MessageQueue> wystąpienia ma wpływ zmiany.  
  
 Kolejki dziennika nie śledzi komunikatów usuwanych z kolejki, ponieważ wygasła ważność zegara ich czas do odbioru, ani nie jest śledzenia komunikatów, które są usuwane z kolejki, przy użyciu usługi katalogowej Usługi kolejkowania komunikatów (Store informacji lub usługi Active Directory).  
  
 Aplikacje nie mogą wysyłać komunikaty do kolejki dziennika; są one ograniczone tylko do odczytu dostęp do tych kolejkach. Ponadto usługi kolejkowania komunikatów nigdy nie powoduje usunięcie wiadomości z kolejki dziennika. Aplikacji przy użyciu kolejki należy usunąć te komunikaty według ich odbierania lub czyszczenie kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> właściwości.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt macierzysty używany do wysyłania komunikatów do kolejki komunikatów.</summary>
        <value>Dojście do obiektu kolejki natywnych, używanej do wysyłania komunikatów do kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A> Zapewnia natywne uchwyt Windows, aby obiekt kolejki komunikatów, który służy do wysyłania komunikatów do kolejki. W przypadku zmiany ścieżki kolejki uchwytu zamknięcia i ponownego otworzenia z nową wartością.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośrednią nazwą formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośrednią nazwą formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka komunikatów nie jest dostępny do zapisu.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>
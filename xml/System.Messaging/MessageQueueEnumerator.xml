<Type Name="MessageQueueEnumerator" FullName="System.Messaging.MessageQueueEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2dd645dcfd97fa2036ad0395acbbbf3e86c2865e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30558520" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueueEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueueEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueueEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueueEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueueEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zawiera tylko do przodu kursora do sortowania wiadomości z kolejki wiadomości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.MessageQueueEnumerator> dynamiczne interakcji z kolejki w sieci. Dostępne za pośrednictwem metody <xref:System.Messaging.MessageQueue> klasy mogą zwracać <xref:System.Messaging.MessageQueueEnumerator> zawierającego listę dynamicznej kolejki lub tablica zawierająca migawki kolekcji kolejki w czasie określonym metoda została wywołana.  
  
 Nie ma zdefiniowanej kolejności kolejek w sieci. Nie są one uporządkowane, na przykład przez komputer, etykiety, stan publicznych lub prywatnych lub innych kryteriów dostępne dla użytkownika. A <xref:System.Messaging.MessageQueueEnumerator> jest kursor, zainicjować nagłówek listy dynamicznych. Kursor można przenieść do pierwszej kolejki wyliczenia, wywołując <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A>. Po zainicjowaniu modułu wyliczającego można użyć <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> do krok do przodu w pozostałych kolejek.  
  
 Nie jest możliwe krok wstecz z <xref:System.Messaging.MessageQueueEnumerator>. Kursor umożliwia tylko ruch do przodu przez wyliczenie kolejki. Jednak możesz wywołać <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> zresetować wyliczenia i umieść kursor na początku listy ponownie. Ponieważ moduł wyliczający jest dynamiczny, kolejki, która jest dołączana poza bieżącej pozycji kursora są dostępne przez moduł wyliczający. Kolejki, która dodaje się przed bieżącej pozycji kursora nie można uzyskać dostęp bez pierwsze wywołanie resetowania.  
  
   
  
## Examples  
 Poniższy przykład kodu iteruje kolejek wiadomości w sieci i sprawdza, czy ścieżka do każdej kolejki. Na koniec Wyświetla liczbę kolejek publicznych w sieci.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby skojarzone z modułu wyliczającego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny ma zachowywać otwarte dojście <xref:System.Messaging.MessageQueueEnumerator.LocatorHandle%2A>, aby moduł wyliczający kolejki przez cały okres istnienia kursora. Po zakończeniu pracy z modułu wyliczającego, wywołaj <xref:System.Messaging.MessageQueueEnumerator.Close%2A> aby zwolnić zasoby skojarzone z dojścia.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueueEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ Current { System::Messaging::MessageQueue ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see cref="T:System.Messaging.MessageQueue" /> wyliczenia.</summary>
        <value>Kolejka, w którym aktualnie znajduje się kursor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu modułu wyliczającego nie wskazuje on na niczego, więc <xref:System.Messaging.MessageQueueEnumerator.Current%2A> nie jest prawidłowy i zgłosi wyjątek, jeśli jest on dostępny. Należy wywołać <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> aby umieść kursor w pierwszym kolejką w wyliczeniu.  
  
 Wiele wywołań <xref:System.Messaging.MessageQueueEnumerator.Current%2A> nie pośredniczące wywołania <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> , którą będzie zwracać taki sam <xref:System.Messaging.MessageQueue> obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Należy wywołać <see cref="P:System.Messaging.MessageQueueEnumerator.Current" /> przed pierwszym wywołaniu <see cref="M:System.Messaging.MessageQueueEnumerator.MoveNext" />. Kursor znajduje się przed pierwszym kolejką w wyliczeniu.  
  
 —lub—  
  
 Należy wywołać <see cref="P:System.Messaging.MessageQueueEnumerator.Current" /> po wywołaniu <see cref="M:System.Messaging.MessageQueueEnumerator.MoveNext" /> zwrócił wartość false, (wskazujący, gdy kursor znajduje się za ostatnią kolejką w wyliczeniu).</exception>
        <altmember cref="M:System.Messaging.MessageQueueEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageQueueEnumerator.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Messaging.MessageQueueEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Messaging.MessageQueueEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Messaging.MessageQueueEnumerator.Dispose%2A> umożliwia zasoby używane przez <xref:System.Messaging.MessageQueueEnumerator> odbiorczego do innych celów. Aby uzyskać więcej informacji na temat <xref:System.Messaging.MessageQueueEnumerator.Dispose%2A>, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Messaging.MessageQueueEnumerator" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.Messaging.MessageQueueEnumerator.Dispose%2A> — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Messaging.MessageQueueEnumerator> odwołania. Ta metoda wywołuje `Dispose` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" />, nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose" />, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see langword="Finalize" />, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [przesłaniania metody Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageQueueEnumerator ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocatorHandle">
      <MemberSignature Language="C#" Value="public IntPtr LocatorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int LocatorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueEnumerator.LocatorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocatorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr LocatorHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera usługę kolejkowania komunikatów uchwyt macierzysty używany do lokalizowania kolejek w sieci.</summary>
        <value>Uchwyt macierzysty do bieżącego kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie są już potrzebne to <xref:System.Messaging.MessageQueueEnumerator> wystąpienia, należy wywołać <xref:System.Messaging.MessageQueueEnumerator.Close%2A> zwolnienia ta dojścia do zasobu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Dojście nie istnieje.</exception>
        <exception cref="T:System.Security.SecurityException">Kod wywołujący nie ma uprawnień do przeglądania.</exception>
        <altmember cref="P:System.Messaging.MessageQueueEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przechodzi do następnego kolejki wyliczenia, moduł wyliczający, jeśli jest obecnie dostępny.</summary>
        <returns>
          <see langword="true" /> Jeśli moduł wyliczający został pomyślnie poprawionym do kolejki dalej; <see langword="false" /> Jeśli moduł wyliczający osiągnął koniec wyliczenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> Zwraca `false` natychmiast, jeśli istnieją kolejek skojarzonych z wyliczenia.  
  
 <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> Zwraca `true` dopóki osiągnie koniec kolekcji. Następnie zwróci `false` dla każdego kolejne wywołania. Jednak po <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> zwrócił `false`, podczas uzyskiwania dostępu do <xref:System.Messaging.MessageQueueEnumerator.Current%2A> właściwość spowoduje zgłoszenie wyjątku.  
  
 Po utworzeniu, moduł wyliczający jest koncepcyjnie ustawiony przed pierwszym <xref:System.Messaging.MessageQueue> wyliczenia i w pierwszym wywołaniu <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> przełącza pierwszej kolejki wyliczenia do widoku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Kod wywołujący nie ma uprawnień do przeglądania.</exception>
        <altmember cref="P:System.Messaging.MessageQueueEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageQueueEnumerator.Reset" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje kursora, więc wskazuje na początku wyliczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający przenosi kierunku tylko do przodu. Ta metoda umożliwia powrót do początku wyliczenie kolejek.  
  
 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> kursor zostanie umieszczony w kolejce pierwszy na liście. Nie należy wywołać <xref:System.Messaging.MessageQueueEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> Aby przesunąć kursor do przodu do pierwszego kolejką w wyliczeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueueEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageQueueEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see cref="T:System.Messaging.MessageQueue" /> wyliczenia.</summary>
        <value>Kolejka, w którym aktualnie znajduje się kursor.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
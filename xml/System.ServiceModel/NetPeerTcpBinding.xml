<Type Name="NetPeerTcpBinding" FullName="System.ServiceModel.NetPeerTcpBinding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9e15330aa2f91247bb1f42841dc255122e08206b" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55407174" /></Metadata><TypeSignature Language="C#" Value="public class NetPeerTcpBinding : System.ServiceModel.Channels.Binding, System.ServiceModel.Channels.IBindingRuntimePreferences" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetPeerTcpBinding extends System.ServiceModel.Channels.Binding implements class System.ServiceModel.Channels.IBindingRuntimePreferences" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.NetPeerTcpBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class NetPeerTcpBinding&#xA;Inherits Binding&#xA;Implements IBindingRuntimePreferences" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetPeerTcpBinding : System::ServiceModel::Channels::Binding, System::ServiceModel::Channels::IBindingRuntimePreferences" />
  <TypeSignature Language="F#" Value="type NetPeerTcpBinding = class&#xA;    inherit Binding&#xA;    interface IBindingRuntimePreferences" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.Binding</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IBindingRuntimePreferences</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Obsolete("PeerChannel feature is obsolete and will be removed in the future.", false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia bezpiecznego powiązania dla aplikacji sieciowych peer-to-peer.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.NetPeerTcpBinding> Powiązania zapewnia obsługę tworzenia aplikacji, które używają infrastruktury sieci peer-to-peer TCP na poziomie sieci równorzędnych.  
  
 Każdy <xref:System.ServiceModel.PeerNode> wystąpienie może obsługiwać wiele kanałów równorzędnych zdefiniowane przy użyciu tego typu powiązania. Fabryki kanałów utworzone przy użyciu skonfigurowanego wystąpienia tego typu może służyć do generowania kanałów równorzędnych. Fabryka kanałów równorzędnych może tworzyć kanały elementów równorzędnych, które są tylko szyfrowanie (implementuje <xref:System.ServiceModel.Channels.IInputChannel>) należy korzystać tylko z danych wyjściowych (implementuje <xref:System.ServiceModel.Channels.IOutputChannel>) i dwukierunkowe (implementuje <xref:System.ServiceModel.Channels.IDuplexChannel>).  
  
 Jest to jedna standardowa powiązania dostarczane przez Windows Communication Framework (WCF). Mogą być używane w kodu imperatywnego albo określony w odpowiedni plik konfiguracyjny XML dla aplikacji. Zalecana procedura jest do definiowania powiązań przy użyciu wartości konfiguracji i nie należy używać podejście oparte na kodzie, z wyjątkiem w niektórych zaawansowanych scenariuszach gdzie należy skonfigurować wartości konfiguracji, jak usługa jest zainicjowana.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.NetPeerTcpBinding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetPeerTcpBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetPeerTcpBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetPeerTcpBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie domyślnego <see cref="T:System.ServiceModel.NetPeerTcpBinding" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetPeerTcpBinding (string configurationName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string configurationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetPeerTcpBinding.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (configurationName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetPeerTcpBinding(System::String ^ configurationName);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.NetPeerTcpBinding : string -&gt; System.ServiceModel.NetPeerTcpBinding" Usage="new System.ServiceModel.NetPeerTcpBinding configurationName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="configurationName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configurationName">Wartość <see langword="configurationName" /> atrybut, który identyfikuje element powiązania, których ustawienia są stosowane do inicjalizacji powiązania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.NetPeerTcpBinding" /> klasy o nazwie określonej konfiguracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.ServiceModel.NetPeerTcpBinding> o podanej nazwie. Jeśli konfiguracja dla tej nazwy już istnieje, używane są ustawienia w pliku konfiguracji, który zawiera tę nazwę. Jeśli nazwa już istnieje, domyślne ustawienia konfiguracji są używane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Konfiguracja jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateBindingElements">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElementCollection CreateBindingElements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElementCollection CreateBindingElements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetPeerTcpBinding.CreateBindingElements" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateBindingElements () As BindingElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElementCollection ^ CreateBindingElements();" />
      <MemberSignature Language="F#" Value="override this.CreateBindingElements : unit -&gt; System.ServiceModel.Channels.BindingElementCollection" Usage="netPeerTcpBinding.CreateBindingElements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElementCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kolekcję elementów wiązania dla wiązania.</summary>
        <returns><see cref="T:System.Collections.Generic.ICollection`1" /> Typu <see cref="T:System.ServiceModel.Channels.BindingElement" /> który tworzy powiązanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnvelopeVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EnvelopeVersion EnvelopeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EnvelopeVersion EnvelopeVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.EnvelopeVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnvelopeVersion As EnvelopeVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EnvelopeVersion ^ EnvelopeVersion { System::ServiceModel::EnvelopeVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnvelopeVersion : System.ServiceModel.EnvelopeVersion" Usage="System.ServiceModel.NetPeerTcpBinding.EnvelopeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EnvelopeVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję protokołu SOAP używaną dla tego wiązania.</summary>
        <value><see cref="T:System.ServiceModel.EnvelopeVersion" /> który określa wersję SOAP do użycia z tym powiązaniem.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPnrpAvailable">
      <MemberSignature Language="C#" Value="public static bool IsPnrpAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsPnrpAvailable" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.IsPnrpAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsPnrpAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsPnrpAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPnrpAvailable : bool" Usage="System.ServiceModel.NetPeerTcpBinding.IsPnrpAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy usługa PNRP jest zainstalowany i dostępny na komputerze.</summary>
        <value><see langword="true" /> Jeśli zainstalowano i skonfigurowano; PNRP w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ListenIPAddress">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress ListenIPAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPAddress ListenIPAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.ListenIPAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property ListenIPAddress As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPAddress ^ ListenIPAddress { System::Net::IPAddress ^ get(); void set(System::Net::IPAddress ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ListenIPAddress : System.Net.IPAddress with get, set" Usage="System.ServiceModel.NetPeerTcpBinding.ListenIPAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.PeerTransportListenAddressConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia adres IP używany w celu nasłuchiwania, węzeł lokalnego elementu równorzędnego.</summary>
        <value>A <see cref="T:System.String" /> wartość, która zawiera sformułowany adres IPv4 lub IPv6, na którym nasłuchuje węzła lokalnego elementu równorzędnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość nie jest ustawiona lub jest ustawiona na `null` lub <xref:System.String.Empty>, skojarzonego <xref:System.ServiceModel.PeerNode> nasłuchuje na wszystkie adresy globalne (IPv4 i IPv6) skonfigurowany na komputerze lokalnym.  
  
 Jeśli określono adres IP emisji pojedynczej prawidłowy dla tej właściwości, a następnie skojarzone <xref:System.ServiceModel.PeerNode> obiektu nasłuchuje na ten adres. Adresy IPv4 oraz IPv6 symboli wieloznacznych nie są uważane za prawidłowe.  
  
 Jeśli innej niż`null` ciąg adresu IP jest określona dla tej właściwości w połączeniu z <xref:System.ServiceModel.Channels.PnrpPeerResolverBindingElement>, adres IP musi być skojarzony z interfejsu fizycznego, a nie jednego wirtualnego.  
  
 ListenIPAddress należy określić dla sieci ad hoc, aby zarejestrować z mechanizmem rozpoznawania elementów równorzędnych (PNRP). Jeśli ta właściwość jest określona w połączeniu z <xref:System.ServiceModel.Configuration.PnrpPeerResolverElement> (mechanizmem rozpoznawania elementów równorzędnych), a następnie adres IP musi należeć do fizycznego interfejsu sieciowego, a nie wirtualny jednym (na przykład interfejs tunelowania). Jest to spowodowane PNRP tylko publikuje w ramach chmury PNRP odpowiadający interfejsy fizyczne. Przez ustawienie tej właściwości na wartość null, wszystkie adresy globalne są publikowane w chmurze globalnej PNRP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podany adres jest nieprawidłowy lub niepoprawnie uformowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferPoolSize">
      <MemberSignature Language="C#" Value="public long MaxBufferPoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxBufferPoolSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.MaxBufferPoolSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferPoolSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxBufferPoolSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferPoolSize : int64 with get, set" Usage="System.ServiceModel.NetPeerTcpBinding.MaxBufferPoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(524288)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar w bajtach w puli pamięci używanej dla elementów równorzędnych protokołu TCP buforu.</summary>
        <value>A <see cref="T:System.Int32" /> wartość, która określa maksymalną liczbę bajtów, które są używane do zbuforowania komunikaty przychodzące w pamięci. Wartość domyślna to 65 536 bajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.ServiceModel.NetPeerTcpBinding.MaxBufferPoolSize%2A> nie może być mniejsza niż <xref:System.ServiceModel.NetPeerTcpBinding.MaxReceivedMessageSize%2A> której domyślna wartość to 65 536 bajtów (64 KB).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxReceivedMessageSize">
      <MemberSignature Language="C#" Value="public long MaxReceivedMessageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxReceivedMessageSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.MaxReceivedMessageSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxReceivedMessageSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxReceivedMessageSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxReceivedMessageSize : int64 with get, set" Usage="System.ServiceModel.NetPeerTcpBinding.MaxReceivedMessageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar w bajtach, TCP komunikaty obsługiwane przez kanałów równorzędnych utworzone przez to wiązanie.</summary>
        <value><see cref="T:System.Int32" /> Maksymalny rozmiar w bajtach wysyłanych za pośrednictwem kanałów równorzędnych utworzone przez to powiązanie wiadomości TCP, która zawiera. Wartość domyślna to 65 536 (64 KB).</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.Port" />
      <MemberSignature Language="VB.NET" Value="Public Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Port : int with get, set" Usage="System.ServiceModel.NetPeerTcpBinding.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia port sieciowy, w którym można powiązać.</summary>
        <value>A <see cref="T:System.Int32" /> wartość, która reprezentuje port sieci, w którym to wystąpienie obiektu binding będzie przetwarzać komunikatów TCP specyficzne dla elementów równorzędnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość portu jest nieprawidłowy, <xref:System.ArgumentException> jest wywoływane. Wartość domyślna tej właściwości to 0, co oznacza, że port odbiornika jest wybierane losowo spośród wszystkich niezastrzeżone portów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReaderQuotas">
      <MemberSignature Language="C#" Value="public System.Xml.XmlDictionaryReaderQuotas ReaderQuotas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDictionaryReaderQuotas ReaderQuotas" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.ReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public Property ReaderQuotas As XmlDictionaryReaderQuotas" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlDictionaryReaderQuotas ^ ReaderQuotas { System::Xml::XmlDictionaryReaderQuotas ^ get(); void set(System::Xml::XmlDictionaryReaderQuotas ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReaderQuotas : System.Xml.XmlDictionaryReaderQuotas with get, set" Usage="System.ServiceModel.NetPeerTcpBinding.ReaderQuotas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDictionaryReaderQuotas</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Xml.XmlDictionaryReaderQuotas" /> skojarzony z tym powiązaniem.</summary>
        <value><see cref="T:System.Xml.XmlDictionaryReaderQuotas" /> Skojarzony z tym powiązaniem.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Aplikacja próbowała ustawić tę właściwość na wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resolver">
      <MemberSignature Language="C#" Value="public System.ServiceModel.PeerResolvers.PeerResolverSettings Resolver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.PeerResolvers.PeerResolverSettings Resolver" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.Resolver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Resolver As PeerResolverSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::PeerResolvers::PeerResolverSettings ^ Resolver { System::ServiceModel::PeerResolvers::PeerResolverSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Resolver : System.ServiceModel.PeerResolvers.PeerResolverSettings" Usage="System.ServiceModel.NetPeerTcpBinding.Resolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.PeerResolvers.PeerResolverSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.ServiceModel.PeerResolver" /> używane przez to wystąpienie obiektu binding do rozpoznania ID siatki równorzędnej adresy IP punktów końcowych węzłów w obrębie siatki elementów równorzędnych.</summary>
        <value>A <see cref="T:System.ServiceModel.PeerResolver" /> używany do rozpoznania ID siatki równorzędnej zestaw <see cref="T:System.ServiceModel.PeerNodeAddress" /> wystąpień reprezentujących kilka węzłów uczestniczących w siatce.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public override string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.ServiceModel.NetPeerTcpBinding.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera schemat identyfikatora URI używane dla protokołu transport skojarzony z tym powiązaniem.</summary>
        <value>Element <see cref="T:System.String" /> , który określa schemat identyfikatora URI protokołu transportowego określone, używane dla tego powiązania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość musi być "net.p2p".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Security">
      <MemberSignature Language="C#" Value="public System.ServiceModel.PeerSecuritySettings Security { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.PeerSecuritySettings Security" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.Security" />
      <MemberSignature Language="VB.NET" Value="Public Property Security As PeerSecuritySettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::PeerSecuritySettings ^ Security { System::ServiceModel::PeerSecuritySettings ^ get(); void set(System::ServiceModel::PeerSecuritySettings ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Security : System.ServiceModel.PeerSecuritySettings with get, set" Usage="System.ServiceModel.NetPeerTcpBinding.Security" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.PeerSecuritySettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zabezpieczeń można ustawić za pośrednictwem kanałów równorzędnych utworzone przez to wiązanie.</summary>
        <value><see cref="T:System.ServiceModel.PeerSecuritySettings" /> Wartość wyliczenia, która wskazuje zabezpieczeń można ustawić za pośrednictwem kanałów równorzędnych utworzone przez to wiązanie. Zabezpieczeń może być albo lub transportu specyficzne dla wiadomości.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReaderQuotas">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReaderQuotas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReaderQuotas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetPeerTcpBinding.ShouldSerializeReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReaderQuotas () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReaderQuotas();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReaderQuotas : unit -&gt; bool" Usage="netPeerTcpBinding.ShouldSerializeReaderQuotas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość określającą, czy powinien zostać Zserializowany czytnika danych przydziału dla wiązania.</summary>
        <returns>Zwraca <see cref="T:System.Boolean" /> określający <see langword="true" /> Jeśli czytnik danych przydziału powinien zostać Zserializowany, i <see langword="false" /> Jeśli nie powinien podlegać serializacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSecurity">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetPeerTcpBinding.ShouldSerializeSecurity" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeSecurity () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeSecurity();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeSecurity : unit -&gt; bool" Usage="netPeerTcpBinding.ShouldSerializeSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość określającą, czy powinien zostać Zserializowany informacji o zabezpieczeniach dla wiązania.</summary>
        <returns>Zwraca <see cref="T:System.Boolean" /> , który określa <see langword="true" /> Jeśli powinien zostać Zserializowany informacji o zabezpieczeniach dla powiązania, a <see langword="false" /> Jeśli nie powinien podlegać serializacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously">
      <MemberSignature Language="C#" Value="bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetPeerTcpBinding.System#ServiceModel#Channels#IBindingRuntimePreferences#ReceiveSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ReceiveSynchronously As Boolean Implements IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ServiceModel::Channels::IBindingRuntimePreferences::ReceiveSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądania przychodzące za pośrednictwem kanałów równorzędnych utworzone przez to powiązanie są obsługiwane synchronicznie lub asynchronicznie.</summary>
        <value><see langword="true" /> Jeśli żądania przychodzące są obsługiwane synchronicznie; <see langword="false" /> jeśli są obsługiwane asynchronicznie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
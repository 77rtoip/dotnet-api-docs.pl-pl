<Type Name="ServiceContractAttribute" FullName="System.ServiceModel.ServiceContractAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6427e46c656f7c0cd43299d6736d3ceaa6f1257d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69101223" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type ServiceContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
    <AssemblyVersion>4.5.0.3</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-uwp-10.0;dotnet-plat-ext-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, AllowMultiple=false, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wskazuje, że interfejs lub Klasa definiuje kontrakt usługi w aplikacji Windows Communication Foundation (WCF).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceContractAttribute> Użyj atrybutu dla interfejsu (lub klasy), aby zdefiniować kontrakt usługi. Następnie użyj <xref:System.ServiceModel.OperationContractAttribute> atrybutu dla jednej lub więcej metod klasy (lub interfejsu), aby zdefiniować operacje usługi kontraktu. Gdy kontrakt usługi jest zaimplementowany i połączony z powiązaniami [](~/docs/framework/wcf/bindings.md) i <xref:System.ServiceModel.EndpointAddress> obiektem, kontrakt usługi jest udostępniany do użycia przez klientów. Aby zapoznać się z omówieniem procesu przy użyciu prostych przykładów, zobacz [samouczek wprowadzenie](~/docs/framework/wcf/getting-started-tutorial.md). Aby uzyskać więcej informacji na temat tworzenia umów dotyczących usług, zobacz [projektowanie i implementowanie usług](~/docs/framework/wcf/designing-and-implementing-services.md).  
  
 Informacje wyrażone przez <xref:System.ServiceModel.ServiceContractAttribute> program i jego interfejs są luźno powiązane z elementem Web Services Description Language (WSDL) `<portType>` . Kontrakt usługi jest używany po stronie usługi, aby określić, co punkt końcowy usługi ujawnia dla obiektów wywołujących. Jest on również używany po stronie klienta, aby określić kontrakt punktu końcowego, z którym komunikuje się klient, a w przypadku umów dupleksowych określić kontrakt wywołania zwrotnego (przy użyciu <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> właściwości), które klient musi zaimplementować, aby Weź udział w konwersacji dwukierunkowej.  
  
> [!NOTE]
>  Interfejs lub Klasa, która jest <xref:System.ServiceModel.ServiceContractAttribute> oznaczona <xref:System.ServiceModel.OperationContractAttribute> atrybutem, musi również mieć co najmniej jedną metodę oznaczoną przy użyciu atrybutu w celu udostępnienia dowolnej funkcjonalności. Zapoznaj się z sekcją przykładów, aby zapoznać się z przykładem kodu najprostszym do definiowania i implementowania usługi.  
  
 Użyj właściwości <xref:System.ServiceModel.ServiceContractAttribute> , aby zmodyfikować kontrakt usługi.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.ConfigurationName%2A> Właściwość określa nazwę elementu usługi w pliku konfiguracji, który ma być używany.  
  
-   Właściwości <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> `<portType>` i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> kontrolują nazwę i przestrzeń nazw kontraktu w elemencie WSDL.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> Właściwość określa, czy kontrakt wymaga powiązania, które obsługuje sesje.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> Właściwość określa umowę zwrotną w konwersacji dwukierunkowej.  
  
-   Właściwości <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> i <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> wskazują, czy wszystkie komunikaty obsługujące kontrakt mają wartość jawną, a jeśli tak, to jaki jest poziom.  
  
 Usługi implementują kontrakty usługi, które reprezentują wymianę danych obsługiwaną przez typ usługi. Klasa usługi może zaimplementować kontrakt usługi (przez zaimplementowanie interfejsu oznaczonego przy <xref:System.ServiceModel.ServiceContractAttribute> użyciu metod <xref:System.ServiceModel.OperationContractAttribute>oznaczonych jako) lub <xref:System.ServiceModel.ServiceContractAttribute> można go oznaczyć <xref:System.ServiceModel.OperationContractAttribute> przy użyciu i zastosować atrybut do własnych metod. (Jeśli klasa implementuje interfejs oznaczony przy użyciu <xref:System.ServiceModel.ServiceContractAttribute>, nie może być oznaczony za pomocą <xref:System.ServiceModel.ServiceContractAttribute>.) Metody typów usług oznaczone za pomocą <xref:System.ServiceModel.OperationContractAttribute> są traktowane jako część domyślnego kontraktu usługi określonego przez sam typ usługi. Aby uzyskać szczegółowe informacje o operacjach <xref:System.ServiceModel.OperationContractAttribute>usługi, zobacz.  
  
 Domyślnie <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> właściwości i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> są nazwą typu `http://tempuri.org`kontraktu i, odpowiednio, i <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> is <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>. Zalecane jest, aby kontrakty usług jawnie ustawiać swoje nazwy, przestrzenie nazw i poziomy ochrony przy użyciu tych właściwości. W ten sposób wykonywane są dwa cele. Najpierw kompiluje kontrakt, który nie jest bezpośrednio połączony z informacjami o zarządzanym typie, umożliwiając refaktoryzację kodu zarządzanego i przestrzenie nazw bez przerywania kontraktu, ponieważ jest on wyrażony w języku WSDL. Po drugie, jawne wymaganie pewnego poziomu ochrony w ramach umowy umożliwia środowisko uruchomieniowe Weryfikowanie, czy konfiguracja powiązania obsługuje ten poziom zabezpieczeń, zapobiegając niewłaściwej konfiguracji przed ujawnieniem poufnych informacji. Aby uzyskać więcej informacji na temat poziomów ochrony, zobacz [Opis poziomu ochrony](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Aby uwidocznić usługę do użytku przez aplikacje klienckie, Utwórz aplikację hosta, aby zarejestrować punkt końcowy usługi przy użyciu Windows Communication Foundation (WCF). Usługi WCF można hostować przy użyciu usług aktywacji systemu Windows (WAS), w aplikacjach konsolowych, aplikacjach usług systemu Windows, aplikacji ASP.NET, aplikacji Windows Forms lub dowolnego innego rodzaju domeny aplikacji.  
  
 Hosting w programie był bardzo podobny do tworzenia aplikacji ASP.NET. Aby uzyskać szczegółowe informacje [, zobacz How to: Hostowanie usługi WCF w usługach](~/docs/framework/wcf/feature-details/how-to-host-a-wcf-service-in-iis.md)IIS.  
  
 Klienci używają interfejsu kontraktu usługi (interfejsu oznaczonego za pomocą <xref:System.ServiceModel.ServiceContractAttribute>) do tworzenia kanału do usługi lub używają obiektów klienta (które łączą typ informacji o interfejsie kontraktu usługi <xref:System.ServiceModel.ClientBase%601> z klasą) do Komunikuj się z usługą. Aby uzyskać szczegółowe informacje na temat kanałów klienta usługi, <xref:System.ServiceModel.ChannelFactory%601> Zobacz temat [Omówienie klasy i klienta WCF](~/docs/framework/wcf/wcf-client-overview.md).  
  
 Użycie klasy lub interfejsu do dziedziczenia z innej <xref:System.ServiceModel.ServiceContractAttribute> klasy lub interfejsu rozszerza kontrakt nadrzędny. <xref:System.ServiceModel.ServiceContractAttribute> `IChildContract` Na przykład, jeśli interfejs jest <xref:System.ServiceModel.ServiceContractAttribute> oznaczony i Dziedziczony z innego interfejsu `IChildContract` kontraktu usługi, `IParentContract`kontrakt usługi zawiera metody obu `IParentContract` i `IChildContract`. Rozszerzanie kontraktów (zarówno w przypadku klas, jak i interfejsów) jest bardzo podobne do rozszerzania zarządzanych klas i interfejsów.  
  
 Najbardziej elastycznym podejściem do tworzenia usług jest najpierw zdefiniowanie interfejsów kontraktu usługi, a następnie zaimplementowanie interfejsu przez klasę usługi. (Jest to również najprostszy sposób kompilowania usług, jeśli trzeba zaimplementować kontrakty usługi, które zostały zdefiniowane przez inne osoby). Tworzenie usług bezpośrednio poprzez oznaczenie klasy za pomocą <xref:System.ServiceModel.ServiceContractAttribute> i jej metod w <xref:System.ServiceModel.OperationContractAttribute> programie działa, gdy usługa ujawnia tylko jeden kontrakt (ale ten kontrakt może być narażony przez więcej niż jeden punkt końcowy).  
  
 <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> Użyj właściwości, aby wskazać inny kontrakt usługi, który, w połączeniu z oryginalnym kontraktem usługi, zdefiniuj wymianę komunikatów, która może przepływać na dwa sposoby niezależnie. Aby uzyskać szczegółowe informacje <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>, zobacz.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.ServiceModel.ServiceContractAttribute> jak zastosować do interfejsu w celu zdefiniowania kontraktu usługi przy użyciu jednej metody usługi, wskazanej <xref:System.ServiceModel.OperationContractAttribute>przez. W takim przypadku poziom ochrony wymagany przez powiązania dla wszystkich komunikatów to <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.  
  
 Przykład kodu implementuje ten kontrakt w `SampleService` klasie.  
  
 [!code-csharp[ServiceContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/services.cs#1)]
 [!code-vb[ServiceContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/services.vb#1)]  
  
 Poniższy przykład kodu przedstawia prosty plik konfiguracji dla poprzedniej usługi, który tworzy jeden punkt końcowy.  
  
 [!code-xml[ServiceContractAttribute#2](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/hostapplication.exe.config#2)]   
  
 Poniższy przykład kodu pokazuje prostego klienta, który wywołuje poprzedni `SampleService`.  
  
 [!code-csharp[ServiceContractAttribute#3](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/client.cs#3)]
 [!code-vb[ServiceContractAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationContractAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/036fae20-7c55-4002-b71d-ac4466e167a3">Definiowanie kontraktów usługi</related>
    <related type="Article" href="https://msdn.microsoft.com/library/192be927-6be2-4fda-98f0-e513c4881acc">Hosting usługi</related>
    <related type="Article" href="https://msdn.microsoft.com/library/7cf21bfe-23bd-46aa-8033-609f851dbf76">Przegląd tworzenia usługi</related>
    <related type="Article" href="https://msdn.microsoft.com/library/28dfff47-d95b-4cc2-9d5c-b3b9ba71fd50">Kompilowanie klienta</related>
    <related type="Article" href="https://msdn.microsoft.com/library/d780af9f-73c5-42db-9e52-077a5e4de7fe">Omówienie tworzenia serwera proxy</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceContractAttribute" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor tworzy wystąpienie atrybutu bez wymagań dotyczących sesji, bez kontraktu wywołania zwrotnego i nazwy domyślnej i przestrzeni nazw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallbackContract">
      <MemberSignature Language="C#" Value="public Type CallbackContract { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type CallbackContract" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberSignature Language="VB.NET" Value="Public Property CallbackContract As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ CallbackContract { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CallbackContract : Type with get, set" Usage="System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ kontraktu wywołania zwrotnego, gdy kontrakt jest kontraktem dwukierunkowym.</summary>
        <value>A <see cref="T:System.Type" /> który wskazuje kontrakt wywołania zwrotnego. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określ interfejs we <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> właściwości, która reprezentuje wymagany przeciwieństwo kontraktu w przypadku wymiany komunikatów dwukierunkowych (lub dupleksu). Umożliwia aplikacjom klienckim nasłuchiwanie wywołań operacji przychodzących, które aplikacja usługi po stronie serwera może wysyłać niezależnie od aktywności klienta. Kontrakty wywołania zwrotnego, które mają jednokierunkową operację reprezentują wywołania z usługi, którą może obsłużyć klient.  
  
> [!NOTE]
>  Ten <xref:System.ServiceModel.ServiceContractAttribute> atrybut jest ignorowany w kontraktach wywołania zwrotnego. Aby skonfigurować zachowanie w czasie wykonywania obiektów wywołania zwrotnego <xref:System.ServiceModel.CallbackBehaviorAttribute?displayProperty=nameWithType>, użyj.  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia usługę, która określa kontrakt wywołania zwrotnego, który wskazuje, że usługa typu `IDuplexHello` musi mieć korespondent, który implementuje usługę typu. `IHelloCallbackContract` Ponadto `IHelloCallbackContract` implementuje jednokierunkową metodę wywołania zwrotnego, umożliwiając usłudze wywoływanie klienta bez oczekiwania na odpowiedź na obsługę rozproszonego klienta opartego na zdarzeniach.  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę używaną do lokalizowania usługi w pliku konfiguracyjnym aplikacji.</summary>
        <value>Nazwa używana do lokalizowania elementu usługi w pliku konfiguracyjnym aplikacji. Wartość domyślna to nazwa klasy implementacji usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustawić wartość, za pomocą której system konfiguracji lokalizuje wartość kontraktu w pliku konfiguracji, zobacz <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość jest równa null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest ciągiem pustym.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy element członkowski ma przypisany poziom ochrony.</summary>
        <value><see langword="true" />Jeśli właściwość nie <see cref="F:System.Net.Security.ProtectionLevel.None" />jest; w przeciwnym razie <see langword="false" />,. <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> wskazuje, czy wartość poziomu ochrony inną niż `false` została ustawiona dla kontraktu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę <see langword="&lt;portType&gt;" /> elementu w Web Services Description Language (WSDL).</summary>
        <value>Wartość domyślna to nazwa klasy lub interfejsu, do którego <see cref="T:System.ServiceModel.ServiceContractAttribute" /> jest stosowana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> Użyj `<portType>` i właściwości, aby kontrolować nazwę i przestrzeń nazw elementu w języku WSDL. <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak użyć <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> właściwości i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> , <xref:System.ServiceModel.ServiceContractAttribute> aby ustawić odpowiednie wartości w języku WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 Poniższy przykład kodu pokazuje klienta Windows Communication Foundation (WCF) dla poprzedniej usługi, która zaimportowali WSDL przy użyciu [Narzędzia do obsługi metadanych ServiceModel (Svcutil. exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Klient używa `HelloWorldProxy` klienta zamiast `SampleServiceProxy` klienta (podobnie jak <xref:System.ServiceModel.ServiceContractAttribute>w przypadku przykładu w sekcji przykład).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość jest równa null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest ciągiem pustym.</exception>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przestrzeń nazw <see langword="&lt;portType&gt;" /> elementu w Web Services Description Language (WSDL).</summary>
        <value>Przestrzeń nazw <see langword="&lt;portType&gt;" /> WSDL elementu. Wartość domyślna to <c>"http://tempuri.org"</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak użyć <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> właściwości i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> , <xref:System.ServiceModel.ServiceContractAttribute> aby ustawić odpowiednie wartości w języku WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 Poniższy przykład kodu pokazuje klienta Windows Communication Foundation (WCF) dla poprzedniej usługi, która zaimportowali WSDL przy użyciu [Narzędzia do obsługi metadanych ServiceModel (Svcutil. exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Klient używa `HelloWorldClient` klienta zamiast `SampleServiceClient` klienta (podobnie jak <xref:System.ServiceModel.ServiceContractAttribute>w przypadku przykładu w sekcji przykład).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy powiązanie dla kontraktu musi obsługiwać wartość <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" /> właściwości.</summary>
        <value>Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości. Wartość domyślna to <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> Użyj właściwości, aby określić stopień, w jakim powiązanie kontraktu wymaga szyfrowania, podpisów cyfrowych lub obu dla punktów końcowych, które uwidaczniają kontrakt. Ustawiona w tym miejscu wartość jest wartością domyślną dla wszystkich komunikatów operacji, w tym błędów.  
  
 Należy pamiętać, że zachowanie ochrony w czasie wykonywania jest kombinacją wartości poziomu ochrony ustawionych dla następujących właściwości. Te właściwości mają hierarchiczną strukturę. Ustawienie skrajnej wartości określa ustawienie domyślne dla wszystkich zakresów węższych, chyba że zostanie jawnie ustawiona inna wartość dla węższego zakresu. W takim przypadku wartość zewnętrzna pozostaje wartością domyślną dla wszystkich zakresów węższych, z wyjątkiem tego, które zostały określone.  
  
 Na przykład jeśli <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> jest ustawiona na <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> , a żadne inne węższe zakresy nie mają ustawień poziomu ochrony, wszystkie komunikaty w kontrakcie operacji są szyfrowane i podpisane. Jeśli jednak jedna z tych operacji ma <xref:System.ServiceModel.OperationContractAttribute> <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>ustawioną wartość, wówczas komunikaty dla tej operacji są podpisane, ale wszystkie inne komunikaty w kontrakcie są szyfrowane i podpisane.  
  
 Aby uzyskać szczegółowe informacje o poziomach ochrony i ich założeniach i zakresach, zobacz [Opis poziomu ochrony](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Zakresy, w których są ustawiane te wartości:  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> Właściwość w<xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> Właściwość w<xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Jeśli w umowie nie określono żadnego poziomu ochrony, a powiązanie bazowe obsługuje zabezpieczenia (na poziomie transportu lub wiadomości), obowiązuje poziom ochrony dla całego kontraktu <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Jeśli powiązanie nie obsługuje zabezpieczeń (np <xref:System.ServiceModel.BasicHttpBinding>.), <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> obowiązuje <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> dla całego kontraktu. Wynika to z tego, że w zależności od powiązania punktu końcowego klienci mogą wymagać innej ochrony komunikatów lub zabezpieczeń na poziomie transportu nawet wtedy, <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>gdy kontrakt określi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jedną z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.SessionMode SessionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.SessionMode SessionMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SessionMode As SessionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::SessionMode SessionMode { System::ServiceModel::SessionMode get(); void set(System::ServiceModel::SessionMode value); };" />
      <MemberSignature Language="F#" Value="member this.SessionMode : System.ServiceModel.SessionMode with get, set" Usage="System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.SessionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, czy sesje są dozwolone, niedozwolone czy wymagane.</summary>
        <value><see cref="T:System.ServiceModel.SessionMode" /> Wskazuje, czy sesje są dozwolone, niedozwolone czy wymagane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> Użyj właściwości, aby wymagać powiązań, które obsługują sesje między punktami końcowymi. Sesja jest sposobem skorelowania zestawu komunikatów wymienianych między dwa lub więcej punktów końcowych. Jeśli usługa obsługuje sesje kanałów, można użyć <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> właściwości, aby określić relację między wystąpieniami wdrożenia kontraktu usługi i sesją kanału. Jeśli powiązanie nie obsługuje sesji, zgłaszany jest wyjątek.  
  
 Na przykład, <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> Jeśli właściwość jest ustawiona na <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType> , a <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> właściwość jest ustawiona na <xref:System.ServiceModel.InstanceContextMode.PerSession>, klienci mogą używać tego samego połączenia do wykonywania powtarzających się wywołań do tego samego obiektu usługi.  
  
 Aby uzyskać więcej informacji o sesjach i wystąpieniach usługi, zobacz [Korzystanie z sesji](~/docs/framework/wcf/using-sessions.md) i [sesji, Tworzenie wystąpień i współbieżność](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
> [!NOTE]
>  Kanał obsługujący sesje obsługuje domyślne skojarzenie wystąpienia usługi z określoną sesją. Jednak inne implementacje sesji obsługują różne funkcje oprócz kontroli nad tworzeniem wystąpień opartych na sesji. Usługa WCF udostępnia cztery typy sesji, których można użyć w celu zapewnienia działania aplikacji w ramach sesji; Każdy typ sesji zapewnia dodatkowe zachowanie specyficzne dla typu sesji.  
  
1.  <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> Obsługuje sesje zabezpieczeń, w których oba punkty końcowe komunikacji zgadzają się z szyfrowaniem i/lub procesem podpisu cyfrowego; wszystkie komunikaty są skorelowane z tą konkretną bezpieczną konwersacją. Aby uzyskać więcej informacji, zobacz [Zabezpieczanie usług](~/docs/framework/wcf/securing-services.md). Na przykład <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType>, który zawiera obsługę zarówno dla sesji zabezpieczeń, jak i sesji niezawodnych, domyślnie używa tylko bezpiecznej sesji, która szyfruje i cyfrowo podpisuje wiadomości.  
  
2.  <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> Obsługuje sesje udostępniane przez połączenia TCP/IP, aby upewnić się, że wszystkie komunikaty są skorelowane przez sesję połączenia na poziomie gniazda.  
  
3.  <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType>, Który implementuje specyfikację WS-ReliableMessaging, zapewnia obsługę niezawodnych sesji, w których komunikaty są dostarczane w kolejności i dokładnie raz, co pozwala na zapewnienie pewności nawet w przypadku przesyłania komunikatów między wieloma węzłami podczas konwersacji. Aby uzyskać więcej informacji, zobacz [niezawodne sesje](~/docs/framework/wcf/feature-details/reliable-sessions.md).  
  
4.  <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> Udostępnia sesje usługi MSMQ datagram. Aby uzyskać więcej informacji, zobacz [kolejki w programie WCF](~/docs/framework/wcf/feature-details/queues-in-wcf.md).  
  
 Należy pamiętać, że <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> ustawienie właściwości nie określa typu sesji wymaganej przez kontrakt, tylko wtedy, gdy jest to wymagane.  
  
   
  
## Examples  
 Następujący kontrakt usługi wymaga, aby skonfigurowane powiązania używały sesji podczas korzystania z `SampleDuplexHello` implementacji usług.  
  
 [!code-csharp[SCA.Session#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.session/cs/services.cs#1)]
 [!code-vb[SCA.Session#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.session/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jedną z <see cref="T:System.ServiceModel.SessionMode" /> wartości.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

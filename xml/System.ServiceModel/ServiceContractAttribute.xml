<Type Name="ServiceContractAttribute" FullName="System.ServiceModel.ServiceContractAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="836bff17abd0c652796f07aa5bc5019db2387652" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36610027" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ServiceContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type ServiceContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wskazuje, że interfejs lub klasa definiuje kontrakt usługi w aplikacji Windows Communication Foundation (WCF).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute> atrybutu w interfejsie (lub klasy) do definiowanie kontraktu usługi. Następnie użyj <xref:System.ServiceModel.OperationContractAttribute> atrybutu na co najmniej jedna z metod klasy (lub interface), aby zdefiniować kontrakt operacji usługi. Gdy kontrakt usługi jest zaimplementowana i połączeniu z [powiązania](~/docs/framework/wcf/bindings.md) i <xref:System.ServiceModel.EndpointAddress> obiekt kontraktu usługi jest udostępniana do użytku przez klientów. Omówienie procesu przy użyciu proste przykłady, zobacz [Wprowadzenie — samouczek](~/docs/framework/wcf/getting-started-tutorial.md). Aby uzyskać więcej informacji o tworzeniu kontraktów usług, zobacz [projektowanie i Implementowanie usług](~/docs/framework/wcf/designing-and-implementing-services.md).  
  
 Informacje wyrażonych przez <xref:System.ServiceModel.ServiceContractAttribute> i jego interfejs jest luźno powiązane do usługi sieci Web Services Description Language (WSDL) `<portType>` elementu. Kontrakt usługi jest używany po stronie usługi do określenia punktu końcowego usługi przedstawia wywołań. Również jest używany do określenia kontraktu punktu końcowego, z którym komunikuje się klient, a w przypadku kontrakty dwukierunkowe, aby określić kontrakt wywołania zwrotnego po stronie klienta (za pomocą <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> właściwości), który klient musi implementować w celu uczestniczyć w komunikacji dupleksowej.  
  
> [!NOTE]
>  Interfejs lub klasa, która zostanie nadany <xref:System.ServiceModel.ServiceContractAttribute> również musi mieć co najmniej jednej metody oznaczonej jako <xref:System.ServiceModel.OperationContractAttribute> atrybutu udostępniać wszystkie funkcje. W sekcji przykłady stosowania najprostszym dwa atrybuty do definiowania i zaimplementować usługi przykładowego kodu.  
  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute> właściwości, aby zmodyfikować kontraktu usługi.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.ConfigurationName%2A> Właściwość określa nazwę elementu usługi w pliku konfiguracji do użycia.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> właściwości formantu, nazwę i przestrzeń nazw kontraktu w formacie WSDL `<portType>` elementu.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> Właściwość określa, czy kontrakt wymaga powiązania, które obsługuje sesji.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> Właściwość określa kontrakt zwrotny dwukierunkowej komunikacji (dupleks).  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> i <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> właściwości wskazują, czy wszystkie komunikaty obsługa kontrakt mieć jawną <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> wartości, a jeśli tak, jakie tego poziomu.  
  
 Usługi Implementowanie kontraktów usług, które reprezentują wymiany danych, która obsługuje typ usługi. Klasa usługi można zaimplementować kontrakt usługi (zaimplementowanie interfejsu oznaczony atrybutem <xref:System.ServiceModel.ServiceContractAttribute> mający metody oznaczonej jako <xref:System.ServiceModel.OperationContractAttribute>) lub może być oznaczony przez <xref:System.ServiceModel.ServiceContractAttribute> i zastosować <xref:System.ServiceModel.OperationContractAttribute> atrybutu do jego własnej metody. (Jeśli klasa implementuje interfejs oznaczony atrybutem <xref:System.ServiceModel.ServiceContractAttribute>, nie może być się zaznaczony z <xref:System.ServiceModel.ServiceContractAttribute>.) Metody na typach usługi, które są oznaczone ikoną z <xref:System.ServiceModel.OperationContractAttribute> są traktowane jako część kontrakt usługi domyślne określona przez samego typu usługi. Aby uzyskać szczegółowe informacje o operacjach usługi, zobacz <xref:System.ServiceModel.OperationContractAttribute>.  
  
 Domyślnie <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> właściwości są nazwa typu kontraktu i `http://tempuri.org`odpowiednio i <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> jest <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>. Zaleca się, że kontraktów usług jawnie ustawione ich nazw, obszary nazw i poziomów ochrony za pomocą tych właściwości. W ten sposób umożliwia zrealizowanie dwóch celów. Najpierw tworzy on kontraktu, który nie jest podłączony bezpośrednio do informacji typ zarządzany, dzięki któremu można Refaktoryzuj z kodu zarządzanego i przestrzenie nazw bez przerywania kontraktu, ponieważ jest wyrażona w języku WSDL. Po drugie jawnie wymagające pewnego poziomu ochrony na kontrakt umożliwia środowiska wykonawczego sprawdzić, czy konfiguracja powiązań obsługuje tego poziomu zabezpieczeń, co uniemożliwia niewłaściwej konfiguracji z udostępnianie poufnych informacji. Aby uzyskać więcej informacji na temat poziomów ochrony, zobacz [poziom ochrony opis](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Aby aktywować usługi do użycia przez aplikacje klienckie, Utwórz aplikację hosta można zarejestrować punktu końcowego usługi z usługi Windows Communication Foundation (WCF). Można obsługiwać usług WCF za pomocą usług aktywacji systemu Windows (WAS) w aplikacji konsoli, aplikacje usług systemu Windows, aplikacje ASP.NET, aplikacji formularzy systemu Windows lub dowolny inny rodzaj domeny aplikacji.  
  
 Hosting w usługi WAS jest bardzo podobny do tworzenia aplikacji ASP.NET. Aby uzyskać więcej informacji, zobacz [porady: hostowanie usługi WCF w programie IIS](~/docs/framework/wcf/feature-details/how-to-host-a-wcf-service-in-iis.md).  
  
 Klienci użyć interfejsu kontraktu usługi (interfejs z oznaczeniem <xref:System.ServiceModel.ServiceContractAttribute>) do utworzenia kanału do usługi lub korzystają z obiektów klientów (czyli informacji o typie interfejsu kontraktu usługi z <xref:System.ServiceModel.ClientBase%601> klasy) do komunikować się z usługą. Aby uzyskać szczegółowe informacje w kanałach klienta do usługi, zobacz <xref:System.ServiceModel.ChannelFactory%601> klasy i [Przegląd klienta programu WCF](~/docs/framework/wcf/wcf-client-overview.md).  
  
 Przy użyciu <xref:System.ServiceModel.ServiceContractAttribute> klasy lub interfejsu, aby dziedziczyć z innego <xref:System.ServiceModel.ServiceContractAttribute> klasy lub interfejsu rozszerza kontrakt nadrzędny. Na przykład jeśli `IChildContract` interfejs jest oznaczony atrybutem <xref:System.ServiceModel.ServiceContractAttribute> i dziedziczone z innego interfejsu kontraktu usługi, `IParentContract`, `IChildContract` kontraktu usługi zawiera metody obu `IParentContract` i `IChildContract`. Rozszerzanie umów, (zarówno na klasy i interfejsy) jest bardzo podobny do rozszerzania zarządzanej klasy i interfejsy.  
  
 Najbardziej elastyczne podejście do tworzenia usług jest najpierw zdefiniować interfejsy kontraktu usługi, a następnie klasy usługa implementuje ten interfejs. (To jest również Najprostszym sposobem, aby utworzyć usługi, jeśli musi implementować kontraktów usług, które zostały zdefiniowane przez innych użytkowników). Tworzenie usług bezpośrednio przez oznaczenie klasy z <xref:System.ServiceModel.ServiceContractAttribute> i jego metody o <xref:System.ServiceModel.OperationContractAttribute> działa, gdy usługa przedstawia tylko jeden kontrakt (ale umowy można uwidocznić przez więcej niż jeden punkt końcowy).  
  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> właściwości, aby wskazać inny kontrakt usługi powiązanej, gdy wraz z oryginalnym kontraktu usługi, zdefiniuj wymiany wiadomości, który można niezależnie przepływu na dwa sposoby. Aby uzyskać więcej informacji, zobacz <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób stosowania <xref:System.ServiceModel.ServiceContractAttribute> do interfejsu definiowanie kontraktu usługi z metodą jedną usługę wskazywanym przez <xref:System.ServiceModel.OperationContractAttribute>. W takim przypadku wymaganych powiązań dla wszystkich wiadomości poziom ochrony jest <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.  
  
 Przykładowy kod następnie wykonuje umowy na `SampleService` klasy.  
  
 [!code-csharp[ServiceContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/services.cs#1)]
 [!code-vb[ServiceContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/services.vb#1)]  
  
 Poniższy przykładowy kod przedstawia plik prostą konfigurację dla poprzedniego usługa, która tworzy jeden punkt końcowy.  
  
 [!code-xml[ServiceContractAttribute#2](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/hostapplication.exe.config#2)]   
  
 Poniższy przykład kodu pokazuje proste klienta, który wywołuje poprzedniego `SampleService`.  
  
 [!code-csharp[ServiceContractAttribute#3](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/client.cs#3)]
 [!code-vb[ServiceContractAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationContractAttribute" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceContractAttribute" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor tworzy wystąpienie atrybutu z żadnych wymagań sesji, nie kontrakt wywołania zwrotnego domyślnej nazwy i przestrzeni nazw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallbackContract">
      <MemberSignature Language="C#" Value="public Type CallbackContract { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type CallbackContract" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberSignature Language="VB.NET" Value="Public Property CallbackContract As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ CallbackContract { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CallbackContract : Type with get, set" Usage="System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ kontraktu wywołania zwrotnego w przypadku kontraktu dupleksowego.</summary>
        <value>A <see cref="T:System.Type" /> wskazuje, że kontrakt wywołania zwrotnego. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określ interfejs w <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> właściwość, która reprezentuje wymagane przeciwnej kontraktu w wymianie wiadomości dwukierunkowe (lub dupleks). Dzięki temu aplikacje klienckie do nasłuchiwania wywołania operacji przychodzących, które aplikacji usługi po stronie serwera może wysyłać niezależnie od aktywności klienta. Kontraktach wywołania zwrotnego, które mają operacji jednokierunkowych reprezentowania połączenia z usługą, która może obsłużyć klienta.  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceContractAttribute> Atrybut jest ignorowany w kontraktach wywołania zwrotnego. Aby skonfigurować zachowania w czasie wykonywania wywołania zwrotnego obiektów, użyj <xref:System.ServiceModel.CallbackBehaviorAttribute?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje to usługa, która określa kontrakt wywołania zwrotnego, który wskazuje, że usługi typu `IDuplexHello` musi mieć korespondenta, który implementuje usługę typu `IHelloCallbackContract`. Ponadto `IHelloCallbackContract` implementuje Metoda wywołania zwrotnego jednokierunkowe, włączanie usługi do wywołania klienta bez oczekiwania na odpowiedź do obsługi klienta rozproszonych, sterowanego zdarzeniami.  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę używaną do lokalizowania usługi w pliku konfiguracyjnym aplikacji.</summary>
        <value>Nazwa używana do lokalizowania elementu usługi w pliku konfiguracyjnym aplikacji. Wartość domyślna to nazwa klasy implementacji usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustawić wartość, według której system konfiguracji lokalizuje wartość kontraktu w pliku konfiguracji, zobacz <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest ciągiem pustym.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy element członkowski ma przypisano poziomu ochrony.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" /> właściwość nie jest <see cref="F:System.Net.Security.ProtectionLevel.None" />; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> Właściwość wskazuje, czy ochrony na poziomie wartości innych niż `false` został ustawiony dla kontraktu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę <see langword="&lt;portType&gt;" /> elementu w sieci Web Services Description Language (WSDL).</summary>
        <value>Wartością domyślną jest nazwa klasy lub interfejsu, do którego <see cref="T:System.ServiceModel.ServiceContractAttribute" /> została zastosowana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> właściwości, aby kontrolować nazwę i przestrzeń nazw `<portType>` elementu w języku WSDL.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> właściwości <xref:System.ServiceModel.ServiceContractAttribute> można ustawić odpowiednie wartości w języku WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 Poniższy przykład kodu pokazuje klienta Windows Communication Foundation (WCF) dla usługi poprzedniego tego importowanych WSDL za pomocą [narzędzie narzędzia metadanych elementu ServiceModel (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Ten klient używa `HelloWorldProxy` klienta, a nie `SampleServiceProxy` klienta (tak jak w przypadku próbki w sekcji przykład <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest ciągiem pustym.</exception>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar nazw <see langword="&lt;portType&gt;" /> elementu w sieci Web Services Description Language (WSDL).</summary>
        <value>Przestrzeń nazw WSDL <see langword="&lt;portType&gt;" /> elementu. Wartość domyślna to "http://tempuri.org".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> właściwości <xref:System.ServiceModel.ServiceContractAttribute> można ustawić odpowiednie wartości w języku WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 Poniższy przykład kodu pokazuje klienta Windows Communication Foundation (WCF) dla usługi poprzedniego tego importowanych WSDL za pomocą [narzędzie narzędzia metadanych elementu ServiceModel (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Ten klient używa `HelloWorldClient` klienta, a nie `SampleServiceClient` klienta (tak jak w przypadku próbki w sekcji przykład <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy powiązania dla kontraktu musi obsługiwać wartość <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" /> właściwości.</summary>
        <value>Jeden z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości. Wartość domyślna to <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> właściwości w celu określenia stopnia, do których powiązanie kontrakt wymaga szyfrowania i/lub podpisów cyfrowych dla punktów końcowych, które udostępniają kontraktu. Wartość ustawiona w tym polu jest wartością domyślną dla wszystkich wiadomości operacji, łącznie z błędów.  
  
 Należy pamiętać, że zachowania ochrony w czasie wykonywania jest kombinacja wartości poziomu ochrony na następujących właściwości. Te właściwości mają strukturę hierarchiczną. Ustawienie wartości peryferyjnych ustanawia ustawieniem domyślnym dla wszystkich zakresów mniejszą niż, chyba że jawnie ustawiono inną wartość mniejszą niż zakres. W takim przypadku wartość zewnętrzne pozostaje domyślnego dla wszystkich mniejszą niż zakresów z wyjątkiem obsługującej ustawione.  
  
 Na przykład jeśli <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> ustawiono <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> i nie mniejszą niż zakresy mają ustawienia poziomu ochrony, wszystkie wiadomości w kontrakt operacji są zaszyfrowana i podpisana. Jeśli jednak jeden z tych działań ma <xref:System.ServiceModel.OperationContractAttribute> ustawioną <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, następnie komunikatów dla tej operacji jest zarejestrowany, ale wszystkie inne komunikaty w kontrakcie są zaszyfrowana i podpisana.  
  
 Aby uzyskać więcej informacji dotyczących poziomów ochrony i założenia i zakresy, zobacz [poziom ochrony opis](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Zakresy, w których te wartości są ustawiane są:  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> Właściwość <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> Właściwość <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Gdy nie poziomu ochrony, nie jawnie określone w umowie a podstawowej powiązanie obsługuje zabezpieczeń, (zarówno na poziomie transportu lub komunikat), poziom skutecznej ochrony dla całej umowy jest <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Jeśli powiązanie nie obsługuje zabezpieczeń (takich jak <xref:System.ServiceModel.BasicHttpBinding>), obowiązującą <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> jest <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> dla całej umowy. Wynik jest, w zależności od powiązanie punktu końcowego, klienci mogą wymagają różnych ochrony zabezpieczeń na poziomie komunikatu i transportu, nawet wtedy, gdy kontrakt Określa <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.SessionMode SessionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.SessionMode SessionMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SessionMode As SessionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::SessionMode SessionMode { System::ServiceModel::SessionMode get(); void set(System::ServiceModel::SessionMode value); };" />
      <MemberSignature Language="F#" Value="member this.SessionMode : System.ServiceModel.SessionMode with get, set" Usage="System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.SessionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, czy sesje są dozwolone, nie dozwolona lub wymagana.</summary>
        <value>A <see cref="T:System.ServiceModel.SessionMode" /> wskazuje, czy sesji dozwolone, nie są dozwolone lub wymagane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> właściwości, aby wymagać powiązania, które obsługują sesje między punktami końcowymi. Sesja jest sposób korelacji zestaw wiadomości wymieniane między co najmniej dwa punkty końcowe. Jeśli usługa obsługuje kanału sesji, można użyć <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> właściwości w celu określenia relacji między wystąpienia implementacji kontraktu usługi i kanału sesji. Jeśli powiązanie nie obsługuje sesji, zwracany jest wyjątek.  
  
 Na przykład jeśli <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> właściwość jest ustawiona na <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType> i <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> właściwość jest ustawiona na <xref:System.ServiceModel.InstanceContextMode.PerSession>, klienci mogą używać tego samego połączenia do powtarzające łączenia się z tym samym obiektem usługi.  
  
 Aby uzyskać więcej informacji o sesji i wystąpienie usługi, zobacz [sesji przy użyciu](~/docs/framework/wcf/using-sessions.md) i [sesji, Instancing i współbieżność](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
> [!NOTE]
>  Kanału, który obsługuje sesji obsługuje domyślne skojarzenie wystąpienia usługi z określoną sesją. Jednak implementacje innej sesji obsługują różne funkcje oprócz kontroli wystąpień na podstawie sesji. Usługi WCF udostępnia cztery typy sesji, które można użyć, aby zapewnić zachowanie zamykania aplikacji; Każdy typ sesji zapewnia dodatkowe zachowanie specyficzne dla typu sesji, który jest.  
  
1.  <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> Obsługuje sesji zabezpieczeń, w których oba końce elementu komunikacji przyjmują szyfrowania i/lub proces podpisu cyfrowego; wszystkie komunikaty są powiązane z tym określonej bezpiecznej konwersacji. Aby uzyskać więcej informacji, zobacz [zabezpieczania usług](~/docs/framework/wcf/securing-services.md). Na przykład <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType>, który zawiera obsługę zarówno sesji zabezpieczeń i niezawodne sesje domyślnie używa tylko bezpiecznej sesji, który szyfruje i podpisaniu wiadomości.  
  
2.  <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> Obsługuje sesji udostępnianych przez połączenia protokołu TCP/IP, aby upewnić się, że wszystkie komunikaty są skorelowane w sesji połączenia na poziomie gniazda.  
  
3.  <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType>, Który implementuje specyfikacji WS-ReliableMessaging zapewnia obsługę niezawodne sesje, w których wiadomości są dostarczane w kolejności i dokładnie raz, włączanie zaufania, nawet wtedy, gdy wiadomości przesyłane na wielu węzłach podczas konwersacji. Aby uzyskać więcej informacji, zobacz [sesji niezawodnej](~/docs/framework/wcf/feature-details/reliable-sessions.md).  
  
4.  <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> Obsługuje sesje datagramu MSMQ. Aby uzyskać więcej informacji, zobacz [kolejki programu WCF](~/docs/framework/wcf/feature-details/queues-in-wcf.md).  
  
 Należy pamiętać, że ustawienie <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> właściwość nie określa typ sesji kontrakt wymaga, tylko że wymaga jednego.  
  
   
  
## Examples  
 Następujące kontraktu usługi wymaga, aby skonfigurowanego powiązania używać sesji podczas interakcji z `SampleDuplexHello` implementacji usługi.  
  
 [!code-csharp[SCA.Session#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.session/cs/services.cs#1)]
 [!code-vb[SCA.Session#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.session/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.ServiceModel.SessionMode" /> wartości.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
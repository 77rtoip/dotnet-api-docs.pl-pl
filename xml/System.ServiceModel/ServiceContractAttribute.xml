<Type Name="ServiceContractAttribute" FullName="System.ServiceModel.ServiceContractAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="aa5c44abf8964e705f5a899718153f6034bdc3df" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52909754" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ServiceContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type ServiceContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, AllowMultiple=false, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wskazuje, że interfejs lub klasa definiuje kontrakt usługi w aplikacji Windows Communication Foundation (WCF).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute> atrybut interfejsu (lub klasy) definiowanie kontraktu usługi. Następnie użyj <xref:System.ServiceModel.OperationContractAttribute> atrybutu w co najmniej jedna z metod klasy (lub interfejs), aby zdefiniować kontrakt operacji usługi. Podczas wdrożenia i w połączeniu z kontraktu usługi [powiązania](~/docs/framework/wcf/bindings.md) i <xref:System.ServiceModel.EndpointAddress> obiektu kontraktu usługi jest udostępniane do użycia przez klientów. Aby uzyskać omówienie proces, korzystając z prostymi przykładami, zobacz [Samouczek wprowadzający](~/docs/framework/wcf/getting-started-tutorial.md). Aby uzyskać więcej informacji na temat tworzenia kontraktów usług, zobacz [projektowanie i Implementowanie usług](~/docs/framework/wcf/designing-and-implementing-services.md).  
  
 Informacje wyrażona <xref:System.ServiceModel.ServiceContractAttribute> i jego interfejs jest luźno powiązana do usługi sieci Web Services Description Language (WSDL) `<portType>` elementu. Kontrakt usługi jest używany po stronie usługi do określenia punktu końcowego usługi udostępnia dotyczące obiektów wywołujących. Również jest używany do określenia kontraktu punktu końcowego, z którym komunikuje się klient, a w przypadku kontrakty dwukierunkowe, aby określić kontrakt wywołania zwrotnego po stronie klienta (przy użyciu <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> właściwości), klient musi implementować do udział w konwersacji dwukierunkowego.  
  
> [!NOTE]
>  Interfejs lub klasa, która zostanie nadany <xref:System.ServiceModel.ServiceContractAttribute> również musi mieć co najmniej jedną metodę oznaczone <xref:System.ServiceModel.OperationContractAttribute> atrybutu, aby udostępnić wszystkie funkcje. Zobacz przykłady części dla przykładu kodu, najprostsze użycie dwa atrybuty, definiować i wdrażać usługi.  
  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute> właściwości modyfikujące kontraktu usługi.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.ConfigurationName%2A> Właściwość określa nazwę elementu usługi w pliku konfiguracji do użycia.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> właściwości formantu, nazwę i przestrzeń nazw kontraktu w formacie WSDL `<portType>` elementu.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> Właściwość określa, czy kontrakt wymaga powiązanie, które obsługuje sesji.  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> Właściwość określa zwracany kontraktu dwukierunkowego konwersacji (dupleks).  
  
-   <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> i <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> właściwości wskazują, czy wszystkie komunikaty, które obsługuje kontrakt mają jawne <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> wartości, a jeśli tak, co ten poziom jest.  
  
 Usługi Implementowanie kontraktów usług, które reprezentują wymiany danych, która obsługuje typ usługi. Klasa usługi można zaimplementować kontrakt usługi (implementując interfejs oznaczone <xref:System.ServiceModel.ServiceContractAttribute> zawierający metody oznaczone <xref:System.ServiceModel.OperationContractAttribute>) lub może być oznaczona przy użyciu <xref:System.ServiceModel.ServiceContractAttribute> i zastosować <xref:System.ServiceModel.OperationContractAttribute> atrybutu do jego własnej metody. (Jeśli klasa implementuje interfejs oznaczone <xref:System.ServiceModel.ServiceContractAttribute>, go nie mogą być sam oznaczone atrybutem <xref:System.ServiceModel.ServiceContractAttribute>.) Metody dla typów usług, które są oznaczone <xref:System.ServiceModel.OperationContractAttribute> są traktowane jako część domyślnego kontraktu usługi, określona przez samego typu usługi. Aby uzyskać szczegółowe informacje o operacjach usługi, zobacz <xref:System.ServiceModel.OperationContractAttribute>.  
  
 Domyślnie <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> właściwości to nazwa typu kontraktu i `http://tempuri.org`odpowiednio i <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> jest <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>. Zaleca się, że kontraktów usług jawnie ustawić ich nazwy, przestrzenie nazw i poziomów ochrony przy użyciu tych właściwości. Ten sposób umożliwia zrealizowanie dwóch celów. Najpierw tworzy kontraktu, który nie jest podłączony bezpośrednio do informacji typu zarządzanego, umożliwiając Refaktoryzuj kod zarządzany i przestrzenie nazw bez przerywania kontrakt, ponieważ jest wyrażona w języku WSDL. Po drugie jawnie wymaga pewnego poziomu ochrony na sam kontrakt umożliwia środowiska uruchomieniowego sprawdzić, czy konfiguracja powiązań obsługuje tego poziomu zabezpieczeń, zapobiegając niewłaściwej konfiguracji z ujawnienia poufnych informacji. Aby uzyskać więcej informacji na temat poziomów ochrony, zobacz [zrozumieć poziom ochrony](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Aby udostępnić usługę do używania przez aplikacje klienckie, Utwórz aplikację hosta można zarejestrować punktu końcowego usługi za pomocą programu Windows Communication Foundation (WCF). Umożliwia hostowanie usługi WCF, za pomocą usług aktywacji Windows (WAS) w aplikacji konsoli, aplikacji usług Windows, aplikacji programu ASP.NET, aplikacjach Windows Forms lub dowolny inny rodzaj domeny aplikacji.  
  
 Hosting w WAS jest bardzo podobny do tworzenia aplikacji ASP.NET. Aby uzyskać więcej informacji, zobacz [instrukcje: hostowanie usługi WCF w programie IIS](~/docs/framework/wcf/feature-details/how-to-host-a-wcf-service-in-iis.md).  
  
 Klienci albo przy użyciu interfejsu kontraktu usługi (interfejs z oznaczeniem <xref:System.ServiceModel.ServiceContractAttribute>) do utworzenia kanału do usługi lub używają obiektów klientów (czyli informacji o typie interfejsu kontraktu usługi o <xref:System.ServiceModel.ClientBase%601> klasy) do komunikować się z Twoją usługą. Szczegółowe informacje na temat kanały klientów do usług, <xref:System.ServiceModel.ChannelFactory%601> klasy i [Przegląd klienta programu WCF](~/docs/framework/wcf/wcf-client-overview.md).  
  
 Za pomocą <xref:System.ServiceModel.ServiceContractAttribute> klasę lub interfejs dziedziczyć z innej <xref:System.ServiceModel.ServiceContractAttribute> klasę lub interfejs rozszerza kontrakt nadrzędny. Na przykład jeśli `IChildContract` interfejs z oznaczeniem <xref:System.ServiceModel.ServiceContractAttribute> i dziedziczonej z innego interfejsu kontraktu usługi `IParentContract`, `IChildContract` kontraktu usługi zawiera metody obu `IParentContract` i `IChildContract`. Rozszerzanie umowy (ani klas lub interfejsów) jest bardzo podobne do rozszerzania zarządzanych klas i interfejsy.  
  
 Najbardziej elastycznym podejściem do tworzenia usług jest najpierw zdefiniować interfejsy kontraktu usługi, a następnie klasie usługi implementują ten interfejs. (To jest również Najprostszym sposobem, aby tworzyć usługi, jeśli musisz zaimplementować kontraktów usług, które zostały zdefiniowane przez inne osoby). Tworzenie usług bezpośrednio, oznaczając klasy z <xref:System.ServiceModel.ServiceContractAttribute> i jego metod z <xref:System.ServiceModel.OperationContractAttribute> działa w przypadku, gdy usługa udostępnia tylko jednego kontraktu (ale kontrakt ten może być udostępnianych przez więcej niż jeden punkt końcowy).  
  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> właściwości, aby wskazać inną kontraktu usługi, który podczas wiązania wraz z oryginalnym kontraktu usługi definiuje wymianę komunikatów, który może przepływać na dwa sposoby niezależnie. Aby uzyskać więcej informacji, zobacz <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób stosowania <xref:System.ServiceModel.ServiceContractAttribute> interfejsu do definiowanie kontraktu usługi przy użyciu metody w jednej usłudze, wskazywanym przez <xref:System.ServiceModel.OperationContractAttribute>. W tym przypadku jest poziom ochrony wymaganych powiązań dla wszystkich komunikatów <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.  
  
 Następnie przykładowy kod implementuje ten kontrakt na `SampleService` klasy.  
  
 [!code-csharp[ServiceContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/services.cs#1)]
 [!code-vb[ServiceContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/services.vb#1)]  
  
 Poniższy przykład kodu pokazuje plik prostej konfiguracji dla poprzedniego usługa, która tworzy jeden punkt końcowy.  
  
 [!code-xml[ServiceContractAttribute#2](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/hostapplication.exe.config#2)]   
  
 Poniższy przykład kodu pokazuje prosty klienta, który wywołuje poprzednim `SampleService`.  
  
 [!code-csharp[ServiceContractAttribute#3](~/samples/snippets/csharp/VS_Snippets_CFX/servicecontractattribute/cs/client.cs#3)]
 [!code-vb[ServiceContractAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/servicecontractattribute/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationContractAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/036fae20-7c55-4002-b71d-ac4466e167a3">Definiowanie kontraktów usług</related>
    <related type="Article" href="https://msdn.microsoft.com/library/192be927-6be2-4fda-98f0-e513c4881acc">Hosting usługi</related>
    <related type="Article" href="https://msdn.microsoft.com/library/7cf21bfe-23bd-46aa-8033-609f851dbf76">Omówienie tworzenia usługi</related>
    <related type="Article" href="https://msdn.microsoft.com/library/28dfff47-d95b-4cc2-9d5c-b3b9ba71fd50">Tworzenie klienta</related>
    <related type="Article" href="https://msdn.microsoft.com/library/d780af9f-73c5-42db-9e52-077a5e4de7fe">Omówienie tworzenia serwera proxy</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceContractAttribute" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor tworzy wystąpienie atrybutu żadnych wymagań sesji nie kontrakt wywołania zwrotnego oraz domyślną nazwę i przestrzeń nazw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallbackContract">
      <MemberSignature Language="C#" Value="public Type CallbackContract { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type CallbackContract" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberSignature Language="VB.NET" Value="Public Property CallbackContract As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ CallbackContract { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CallbackContract : Type with get, set" Usage="System.ServiceModel.ServiceContractAttribute.CallbackContract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ kontrakt wywołania zwrotnego, gdy kontrakt jest kontraktu dwukierunkowego.</summary>
        <value>A <see cref="T:System.Type" /> oznacza kontrakt wywołania zwrotnego. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określ interfejs w <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> właściwość, która reprezentuje wymagane przeciwne umowy w wymianie wiadomości dwukierunkowe (lub dupleks). Dzięki temu aplikacje klienckie do nasłuchiwania pod kątem wywołania operacji dla ruchu przychodzącego, które aplikacja usługi po stronie serwera może wysyłać niezależnie od aktywności klienta. Kontrakty wywołania zwrotnego, które mają operacji jednokierunkowych reprezentują wywołania między usługami, która może obsłużyć klienta.  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceContractAttribute> Atrybut jest ignorowany w kontrakty wywołania zwrotnego. Aby skonfigurować zachowanie środowiska uruchomieniowego obiektów wywołania zwrotnego, użyj <xref:System.ServiceModel.CallbackBehaviorAttribute?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje to usługa, która określa kontrakt wywołania zwrotnego, co oznacza, że usługi typu `IDuplexHello` musi mieć korespondenta, który implementuje usługi typu `IHelloCallbackContract`. Ponadto `IHelloCallbackContract` implementuje metodę wywołania zwrotnego jednokierunkowe włączania usługi do wywołania klienta bez oczekiwania na odpowiedź zapewnić obsługę klienta dystrybuowana, oparte na zdarzeniach.  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę używaną do lokalizowania usługi w pliku konfiguracji aplikacji.</summary>
        <value>Nazwa używana do lokalizowania element usługi w pliku konfiguracji aplikacji. Wartość domyślna to nazwa klasy implementacji usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustawić wartość, według której system konfiguracji lokalizuje wartość umowy w pliku konfiguracji, zobacz <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest ciągiem pustym.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.ServiceContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy element członkowski ma przypisany poziom ochrony.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" /> właściwość nie jest <see cref="F:System.Net.Security.ProtectionLevel.None" />; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceContractAttribute.HasProtectionLevel%2A> Właściwość wskazuje, czy ochrony na poziomie wartości innych niż `false` została ustawiona dla kontraktu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę <see langword="&lt;portType&gt;" /> elementu w sieci Web Services Description Language (WSDL).</summary>
        <value>Wartością domyślną jest nazwa klasy lub interfejsu, do którego <see cref="T:System.ServiceModel.ServiceContractAttribute" /> jest stosowany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> właściwości w celu kontrolowania, nazwa i nazw `<portType>` elementu w języku WSDL.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> właściwości <xref:System.ServiceModel.ServiceContractAttribute> można ustawić odpowiednie wartości w języku WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 Poniższy przykład kodu pokazuje klienta programu Windows Communication Foundation (WCF) dla usługi w poprzednim, zaimportowane WSDL przy użyciu [narzędzia narzędzie metadanych elementu ServiceModel (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Ten klient używa `HelloWorldProxy` klienta zamiast `SampleServiceProxy` klienta (tak jak w przypadku z przykładem w sekcji przykład <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest ciągiem pustym.</exception>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar nazw <see langword="&lt;portType&gt;" /> elementu w sieci Web Services Description Language (WSDL).</summary>
        <value>Przestrzeń nazw WSDL <see langword="&lt;portType&gt;" /> elementu. Wartość domyślna to " http://tempuri.org ".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> i <xref:System.ServiceModel.ServiceContractAttribute.Namespace%2A> właściwości <xref:System.ServiceModel.ServiceContractAttribute> można ustawić odpowiednie wartości w języku WSDL.  
  
 [!code-csharp[SCA.Names#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/services.cs#1)]
 [!code-vb[SCA.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/services.vb#1)]  
  
 Poniższy przykład kodu pokazuje klienta programu Windows Communication Foundation (WCF) dla usługi w poprzednim, zaimportowane WSDL przy użyciu [narzędzia narzędzie metadanych elementu ServiceModel (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). Ten klient używa `HelloWorldClient` klienta zamiast `SampleServiceClient` klienta (tak jak w przypadku z przykładem w sekcji przykład <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 [!code-csharp[SCA.Names#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.names/cs/client.cs#3)]
 [!code-vb[SCA.Names#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.names/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.ServiceContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy powiązania dla kontraktu musi obsługiwać wartość <see cref="P:System.ServiceModel.ServiceContractAttribute.ProtectionLevel" /> właściwości.</summary>
        <value>Jedną z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości. Wartość domyślna to <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> właściwość, aby określić stopień, do których powiązanie kontrakt wymaga szyfrowania i/lub podpisów cyfrowych dla punktów końcowych, które uwidaczniają umowy. Wartość ustawiona w tym miejscu jest wartością domyślną dla wszystkich komunikatów operacji, w tym błędów.  
  
 Należy pamiętać, że zachowania w zakresie ochrony w czasie wykonywania jest kombinacją wartości poziomu ochrony, ustaw następujące właściwości. Te właściwości mają hierarchiczną strukturę. Ustawienie wartości peryferyjnych ustanawia ustawienie domyślne dla wszystkich zakresów mniejszą niż, chyba że jawnie ustawiono inną wartość dla węższy zakres. W tym przypadku zewnętrzny wartość pozostaje domyślnego dla wszystkich mniejszą niż zakresów, z wyjątkiem ustawione to inaczej.  
  
 Na przykład jeśli <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> ustawiono <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> i inne zakresy mniejszą niż ma ustawienia poziomu ochrony, wszystkie komunikaty w kontrakt operacji czy zaszyfrowana i podpisana. Jeśli jednak ma jedną z tych operacji <xref:System.ServiceModel.OperationContractAttribute> równa <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, następnie komunikatów dla tej operacji są podpisane, ale wszystkie inne komunikaty w kontrakcie czy zaszyfrowana i podpisana.  
  
 Aby uzyskać szczegółowe informacje dotyczące poziomów ochrony i ich wartości domyślne i zakresów, zobacz [zrozumieć poziom ochrony](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Zakresy, w których te wartości są ustawiane są następujące:  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> Właściwość <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> Właściwość <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Jeśli występuje żaden poziom ochrony jawnie określone w umowie bazowego powiązanie obsługuje zabezpieczenia, (zarówno na poziomie transportu lub wiadomości), poziom skuteczną ochronę całej umowy jest <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Jeśli wiązanie nie obsługuje zabezpieczeń (takich jak <xref:System.ServiceModel.BasicHttpBinding>), obowiązującą <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> jest <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> dla całej umowy. Wynik jest, że zależą od powiązania punktu końcowego, klienci mogą wymagają różnych ochrony zabezpieczeń na poziomie komunikatu lub transportu, nawet wtedy, gdy kontrakt Określa <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.SessionMode SessionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.SessionMode SessionMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SessionMode As SessionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::SessionMode SessionMode { System::ServiceModel::SessionMode get(); void set(System::ServiceModel::SessionMode value); };" />
      <MemberSignature Language="F#" Value="member this.SessionMode : System.ServiceModel.SessionMode with get, set" Usage="System.ServiceModel.ServiceContractAttribute.SessionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.SessionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informację, czy sesje są dozwolone, niedozwolone lub wymagane.</summary>
        <value>A <see cref="T:System.ServiceModel.SessionMode" /> wskazuje, czy sesje są dozwolone, niedozwolone lub wymagane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> właściwości, aby wymagać powiązania, które obsługują sesje między punktami końcowymi. Sesja jest sposób korelacji zestaw komunikatów wymienianych między dwa lub więcej punktów końcowych. Jeśli usługa obsługuje sesje kanału, można użyć <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> właściwości w celu określenia relacji między wystąpienia implementacji kontraktu usługi i sesji kanału. Jeśli powiązanie nie obsługuje sesji, zwracany jest wyjątek.  
  
 Na przykład jeśli <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> właściwość jest ustawiona na <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType> i <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> właściwość jest ustawiona na <xref:System.ServiceModel.InstanceContextMode.PerSession>, klienci mogą używać tego samego połączenia do łączenia powtarzające się tego samego obiektu usługi.  
  
 Aby uzyskać więcej informacji o sesjach i wystąpień usługi, zobacz [przy użyciu sesji](~/docs/framework/wcf/using-sessions.md) i [sesji, Instancing i współbieżności](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
> [!NOTE]
>  Kanał, który obsługuje sesji obsługuje domyślne skojarzenie wystąpienia usługi w określonej sesji. Jednak implementacje innej sesji obsługują różne funkcje oprócz sterowania wystąpień oparte na sesji. Usługi WCF oferuje cztery typy sesje, które można użyć, aby zapewnić zachowanie sesji aplikacji; Każdy typ sesji udostępnia dodatkowe zachowania specyficzne dla typu sesji, który jest.  
  
1.  <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> Obsługuje sesji bezpieczeństwa, w których obu końcach komunikacji uzgodnionych szyfrowania i/lub podpis cyfrowy procesu; wszystkie komunikaty są powiązane z tym określonej bezpiecznej konwersacji. Aby uzyskać więcej informacji, zobacz [zabezpieczania usług](~/docs/framework/wcf/securing-services.md). Na przykład <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType>, który zawiera obsługę obie sesje zabezpieczeń i sesje niezawodnej domyślnie używa tylko bezpiecznej sesji, który szyfruje i podpisuje cyfrowo wiadomości.  
  
2.  <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> Obsługuje sesji udostępnianych przez połączeń TCP/IP, aby upewnić się, że wszystkie komunikaty są powiązane przez sesję połączenia na poziomie gniazd.  
  
3.  <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType>, Który implementuje specyfikację WS-ReliableMessaging zapewnia obsługę dotyczące sesji niezawodnych, w których dostarczania wiadomości w kolejności i dokładnie raz, włączanie zaufania, nawet wtedy, gdy komunikaty przesyłane między wieloma węzłami podczas konwersacji. Aby uzyskać więcej informacji, zobacz [sesje niezawodnej](~/docs/framework/wcf/feature-details/reliable-sessions.md).  
  
4.  <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> Udostępnia usługi MSMQ datagram sesji. Aby uzyskać więcej informacji, zobacz [kolejki programu WCF](~/docs/framework/wcf/feature-details/queues-in-wcf.md).  
  
 Należy pamiętać, że ustawienie <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> właściwość nie określa typ sesji wymaga umowy, tylko jeden wymagane przez dział it.  
  
   
  
## Examples  
 Następujące kontraktu usługi wymaga, aby skonfigurowanego powiązania pomocą sesji podczas interakcji z `SampleDuplexHello` implementacji usługi.  
  
 [!code-csharp[SCA.Session#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.session/cs/services.cs#1)]
 [!code-vb[SCA.Session#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.session/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.ServiceModel.SessionMode" /> wartości.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
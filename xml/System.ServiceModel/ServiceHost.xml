<Type Name="ServiceHost" FullName="System.ServiceModel.ServiceHost">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b9bd9e574a16f37d9722705874671597e3cb60aa" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36410444" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceHost : System.ServiceModel.ServiceHostBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceHost extends System.ServiceModel.ServiceHostBase" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceHost" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceHost&#xA;Inherits ServiceHostBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceHost : System::ServiceModel::ServiceHostBase" />
  <TypeSignature Language="F#" Value="type ServiceHost = class&#xA;    inherit ServiceHostBase" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.ServiceHostBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia hosta usługi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementuje hosta używany przez model usługi Windows Communication Foundation (WCF), modelu programowania.  
  
 Użyj <xref:System.ServiceModel.ServiceHost> klasy do konfiguracji i ekspozycji usługi do użycia przez aplikacje klienckie, gdy nie używasz usług Internet Information Services (IIS) lub usługi aktywacji systemu Windows (WAS) do udostępnienia usługi. Zarówno usług IIS i WAS współdziałają z <xref:System.ServiceModel.ServiceHost> obiektu w Twoim imieniu.  
  
 Do udostępnienia usługi do użycia przez obiekty wywołujące, WCF wymaga opisu usługi pełną (reprezentowane przez <xref:System.ServiceModel.Description.ServiceDescription> klasy). <xref:System.ServiceModel.ServiceHost> Tworzy klasy <xref:System.ServiceModel.Description.ServiceDescription> z informacje dotyczące typu i konfiguracji usługi, a następnie używa opis, aby utworzyć <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> obiektów dla każdego punktu końcowego w opisie.  
  
 Użyj <xref:System.ServiceModel.ServiceHost> obiekt, aby załadować usługi, skonfiguruj punkty końcowe, Zastosuj ustawienia zabezpieczeń i uruchomić odbiorników do obsługi żądań przychodzących.  
  
   
  
## Examples  
 [!code-csharp[S_SelfHost#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#1)]
 [!code-vb[S_SelfHost#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_selfhost/vb/wholeenchilada.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceHost" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ServiceHost ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ServiceHost();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceHost" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieją dwa konstruktory użyty do utworzenia wystąpienia <xref:System.ServiceModel.ServiceHost> klasy. Użyj <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Type%2CSystem.Uri%5B%5D%29> konstruktora, który przyjmuje jako parametr wejściowy, w większości przypadków typu usługi. Host umożliwia to tworzenie nowych usług zgodnie z potrzebami. Użyj <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29> Konstruktor zamiast niego tylko wtedy, gdy chcesz używać określonego pojedyncze wystąpienie usługi host usługi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceHost (object singletonInstance, params Uri[] baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object singletonInstance, class System.Uri[] baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.#ctor(System.Object,System.Uri[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (singletonInstance As Object, ParamArray baseAddresses As Uri())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceHost(System::Object ^ singletonInstance, ... cli::array &lt;Uri ^&gt; ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.ServiceHost : obj * Uri[] -&gt; System.ServiceModel.ServiceHost" Usage="new System.ServiceModel.ServiceHost (singletonInstance, baseAddresses)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="singletonInstance" Type="System.Object" />
        <Parameter Name="baseAddresses" Type="System.Uri[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="singletonInstance">Wystąpienie usługi hostowanej.</param>
        <param name="baseAddresses">
          <see cref="T:System.Array" /> Typu <see cref="T:System.Uri" /> zawierający adres podstawowy usługi hostowanej.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceHost" /> klasy z wystąpienia usługi i jego adres podstawowy określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora jako alternatywę do wdrażania niestandardowego <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType> gdy chcesz podać wystąpienie określonego obiektu do użytku przez usługi singleton. Można użyć tego przeciążenia z typem implementacji usługi jest trudne do skonstruowania (na przykład, jeśli nie implementuje domyślnego konstruktora publicznego, który nie ma parametrów).  
  
 Należy pamiętać, że jeśli obiekt został dostarczony do tego przeciążenia, niektóre funkcje związane z do systemu Windows Communication Foundation (WCF) wystąpień zachowanie działają inaczej. Na przykład wywołanie elementu <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> nie obowiązują, gdy wystąpienie dobrze znanego obiektu jest realizowane przy użyciu tego przeciążenia konstruktora. Podobnie inny mechanizm wersji wystąpienia jest ignorowana. <xref:System.ServiceModel.ServiceHost> Zawsze zachowuje się tak, jakby <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> ma ustawioną wartość właściwości <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType> dla wszystkich operacji.  
  
   
  
## Examples  
 [!code-csharp[S_UEServiceHost2#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost2/cs/service.cs#1)]
 [!code-vb[S_UEServiceHost2#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost2/vb/service.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="singletonInstance" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceHost (Type serviceType, params Uri[] baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type serviceType, class System.Uri[] baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.#ctor(System.Type,System.Uri[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serviceType As Type, ParamArray baseAddresses As Uri())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceHost(Type ^ serviceType, ... cli::array &lt;Uri ^&gt; ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.ServiceHost : Type * Uri[] -&gt; System.ServiceModel.ServiceHost" Usage="new System.ServiceModel.ServiceHost (serviceType, baseAddresses)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
        <Parameter Name="baseAddresses" Type="System.Uri[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="serviceType">Typ usługi hostowanej.</param>
        <param name="baseAddresses">Tablica typu <see cref="T:System.Uri" /> zawierający adres podstawowy usługi hostowanej.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceHost" /> klasy z typem usługi i jego adres podstawowy określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, gdy typ usługi, możesz utworzyć nowe wystąpienia klasy ją w razie potrzeby, nawet jeśli wymagane jest pojedyncze wystąpienie. Użyj <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29> Konstruktor zamiast niego tylko wtedy, gdy chcesz używać określonego pojedyncze wystąpienie usługi host usługi.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono metodę zastosowania <xref:System.ServiceModel.ServiceHost> klasy do obsługi usługi Windows Communication Foundation:  
  
 [!code-csharp[S_UEServiceHost#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#1)]
 [!code-vb[S_UEServiceHost#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serviceType" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddServiceEndpoint">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje punkt końcowy usługi do usługi hostowanej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, string address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, string address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, System::String ^ address);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * string -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="implementedContract">
          <see cref="T:System.Type" /> Kontraktu punktu końcowego dodane.</param>
        <param name="binding">
          <see cref="T:System.ServiceModel.Channels.Binding" /> Dodać punktu końcowego.</param>
        <param name="address">Adres punktu końcowego dodane.</param>
        <summary>Dodaje punkt końcowy usługi do usługi hostowanej z określonego kontrakt, powiązanie i adres punktu końcowego.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> Dodane do usługi hostowanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UEServiceHost#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#3)]
 [!code-vb[S_UEServiceHost#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="implementedContract" /> lub <paramref name="binding" /> lub <paramref name="address" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, Uri ^ address);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract">
          <see cref="T:System.Type" /> Kontraktu punktu końcowego dodane.</param>
        <param name="binding">
          <see cref="T:System.ServiceModel.Channels.Binding" /> Dodać punktu końcowego.</param>
        <param name="address">
          <see cref="T:System.Uri" /> Zawierający adres punktu końcowego dodane.</param>
        <summary>Dodaje punkt końcowy usługi do usługi hostowanej z określonym kontraktu, powiązania i identyfikator URI zawierający adres punktu końcowego.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> Dodane do usługi hostowanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UEServiceHost#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#4)]
 [!code-vb[S_UEServiceHost#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="implementedContract" /> lub <paramref name="binding" /> lub <paramref name="address" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, string address, Uri listenUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, string address, class System.Uri listenUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.String,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, System::String ^ address, Uri ^ listenUri);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * string * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address, listenUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.String" />
        <Parameter Name="listenUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract">
          <see cref="T:System.Type" /> Kontraktu punktu końcowego dodane.</param>
        <param name="binding">
          <see cref="T:System.ServiceModel.Channels.Binding" /> Dodać punktu końcowego.</param>
        <param name="address">Adres punktu końcowego usługi.</param>
        <param name="listenUri">
          <see cref="T:System.Uri" /> Na można nasłuchiwać punktów końcowych usługi.</param>
        <summary>Dodaje punkt końcowy usługi do usługi hostowanej z określonego kontrakt, powiązanie adresu punktu końcowego i identyfikatora URI, na którym nasłuchuje usługa.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> Dodane do usługi hostowanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej wersji metody, jeśli masz wiele punktów końcowych, które należy do nasłuchiwania na tym samym określony identyfikator URI.  
  
   
  
## Examples  
 [!code-csharp[S_UEServiceHost#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#5)]
 [!code-vb[S_UEServiceHost#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="implementedContract" /> lub <paramref name="binding" /> lub <paramref name="address" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, Uri address, Uri listenUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, class System.Uri address, class System.Uri listenUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.Uri,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, Uri ^ address, Uri ^ listenUri);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * Uri * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address, listenUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="listenUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract">
          <see cref="T:System.Type" /> Kontraktu punktu końcowego dodane.</param>
        <param name="binding">
          <see cref="T:System.ServiceModel.Channels.Binding" /> Dodać punktu końcowego.</param>
        <param name="address">
          <see cref="T:System.Uri" /> Zawierający adres punktu końcowego dodane.</param>
        <param name="listenUri">
          <see cref="T:System.Uri" /> Na można nasłuchiwać punktów końcowych usługi.</param>
        <summary>Dodaje punkt końcowy usługi do usługi hostowanej z określonego kontrakt, powiązanie, identyfikator URI zawierający adres punktu końcowego i identyfikatora URI, na którym nasłuchuje usługa.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> Dodane do usługi hostowanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej wersji metody, jeśli masz wiele punktów końcowych, które należy do nasłuchiwania na tym samym określony identyfikator URI.  
  
   
  
## Examples  
 [!code-csharp[S_UEServiceHost#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#6)]
 [!code-vb[S_UEServiceHost#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="implementedContract" /> lub <paramref name="binding" /> lub <paramref name="address" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zainicjowano umów lub nie można odnaleźć kluczy kontraktu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyConfiguration">
      <MemberSignature Language="C#" Value="protected override void ApplyConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ApplyConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.ApplyConfiguration" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ApplyConfiguration ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ApplyConfiguration();" />
      <MemberSignature Language="F#" Value="override this.ApplyConfiguration : unit -&gt; unit" Usage="serviceHost.ApplyConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ładuje opisu usługi z pliku konfiguracji i stosuje je do środowiska wykonawczego tworzona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDescription">
      <MemberSignature Language="C#" Value="protected override System.ServiceModel.Description.ServiceDescription CreateDescription (out System.Collections.Generic.IDictionary&lt;string,System.ServiceModel.Description.ContractDescription&gt; implementedContracts);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.ServiceModel.Description.ServiceDescription CreateDescription([out] class System.Collections.Generic.IDictionary`2&lt;string, class System.ServiceModel.Description.ContractDescription&gt;&amp; implementedContracts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.CreateDescription(System.Collections.Generic.IDictionary{System.String,System.ServiceModel.Description.ContractDescription}@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateDescription (ByRef implementedContracts As IDictionary(Of String, ContractDescription)) As ServiceDescription" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::ServiceModel::Description::ServiceDescription ^ CreateDescription([Runtime::InteropServices::Out] System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Description::ContractDescription ^&gt; ^ % implementedContracts);" />
      <MemberSignature Language="F#" Value="override this.CreateDescription :  -&gt; System.ServiceModel.Description.ServiceDescription" Usage="serviceHost.CreateDescription implementedContracts" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceDescription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContracts" Type="System.Collections.Generic.IDictionary&lt;System.String,System.ServiceModel.Description.ContractDescription&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="implementedContracts">
          <see cref="T:System.Collections.Generic.IDictionary`2" /> z parami kluczy typu (<see cref="T:System.String" />, <see cref="T:System.ServiceModel.Description.ContractDescription" />) zawierający keyed umów usługi hostowanej, które zostały wdrożone.</param>
        <summary>Tworzy opis usługi hostowanej.</summary>
        <returns>A <see cref="T:System.ServiceModel.Description.ServiceDescription" /> usługi hostowanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana do konstruowania opisy umowy z dostosowanych modele programowania. Zastąp metodę odpowiedniej klasy podstawowej <xref:System.ServiceModel.ServiceHostBase.CreateDescription%28System.Collections.Generic.IDictionary%7BSystem.String%2CSystem.ServiceModel.Description.ContractDescription%7D%40%29>, aby zaimplementować dostosowane modelu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ usługi hostowanej jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="InitializeDescription">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje opis usługi hostowanej na podstawie jego typ lub wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wymóg adres podstawowy może być przekazywany jako część <xref:System.ServiceModel.ServiceHost.%23ctor%2A>. Klasy, które dziedziczą z <xref:System.ServiceModel.ServiceHost> można wywołać <xref:System.ServiceModel.ServiceHost.%23ctor%2A> , a następnie można wywołać jeden z <xref:System.ServiceModel.ServiceHost.InitializeDescription%2A> Jeśli adres podstawowy nie jest dostępny. Jest to implementowania usługi modelu narzędzie do obsługi metadanych (Svcutil.exe).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitializeDescription">
      <MemberSignature Language="C#" Value="protected void InitializeDescription (object singletonInstance, System.ServiceModel.UriSchemeKeyedCollection baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeDescription(object singletonInstance, class System.ServiceModel.UriSchemeKeyedCollection baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.InitializeDescription(System.Object,System.ServiceModel.UriSchemeKeyedCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeDescription (singletonInstance As Object, baseAddresses As UriSchemeKeyedCollection)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeDescription(System::Object ^ singletonInstance, System::ServiceModel::UriSchemeKeyedCollection ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="override this.InitializeDescription : obj * System.ServiceModel.UriSchemeKeyedCollection -&gt; unit" Usage="serviceHost.InitializeDescription (singletonInstance, baseAddresses)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="singletonInstance" Type="System.Object" />
        <Parameter Name="baseAddresses" Type="System.ServiceModel.UriSchemeKeyedCollection" />
      </Parameters>
      <Docs>
        <param name="singletonInstance">Wystąpienie usługi hostowanej.</param>
        <param name="baseAddresses">
          <see cref="T:System.ServiceModel.UriSchemeKeyedCollection" /> Zawierający adres podstawowy usługi hostowanej.</param>
        <summary>Inicjuje opis usługi hostowanej na podstawie jego wystąpieniu i określonej podstawowej adresów.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="singletonInstance" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeDescription">
      <MemberSignature Language="C#" Value="protected void InitializeDescription (Type serviceType, System.ServiceModel.UriSchemeKeyedCollection baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeDescription(class System.Type serviceType, class System.ServiceModel.UriSchemeKeyedCollection baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.InitializeDescription(System.Type,System.ServiceModel.UriSchemeKeyedCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeDescription (serviceType As Type, baseAddresses As UriSchemeKeyedCollection)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeDescription(Type ^ serviceType, System::ServiceModel::UriSchemeKeyedCollection ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="override this.InitializeDescription : Type * System.ServiceModel.UriSchemeKeyedCollection -&gt; unit" Usage="serviceHost.InitializeDescription (serviceType, baseAddresses)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
        <Parameter Name="baseAddresses" Type="System.ServiceModel.UriSchemeKeyedCollection" />
      </Parameters>
      <Docs>
        <param name="serviceType">
          <see cref="T:System.Type" /> Usługi hostowanej.</param>
        <param name="baseAddresses">
          <see cref="T:System.ServiceModel.UriSchemeKeyedCollection" /> Zawierający adres podstawowy usługi hostowanej.</param>
        <summary>Inicjuje opis usługi hostowanej na podstawie jego typu i określonej podstawowej adresów.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serviceType" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected override void OnClosed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClosed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.OnClosed" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnClosed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnClosed();" />
      <MemberSignature Language="F#" Value="override this.OnClosed : unit -&gt; unit" Usage="serviceHost.OnClosed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa jednorazowe usług, które są obsługiwane, gdy host usługi jest zamknięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku przesłaniania <xref:System.ServiceModel.ServiceHost.OnClosed%2A> metody muszą zapewnić podstawowym. Wywoływana jest metoda OnClosed, nawet jeśli wystąpi wyjątek. Poniższy kod ilustruje sposób to zrobić.  
  
```  
protected override void OnClosed()  
{  
    try  
    {  
        if (FaultFlagService.faultFlag == ThrowDuring.OnClosed)  
        {  
            FaultFlagService.faultFlag = ThrowDuring.Never;  
            throw new ServiceActivationException("Faulting the service because FaultFlagService.faultFlag = ThrowDuring.OnClosed");  
        }  
    }  
    finally  
    {  
        base.OnClosed();  
    }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SingletonInstance">
      <MemberSignature Language="C#" Value="public object SingletonInstance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SingletonInstance" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHost.SingletonInstance" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SingletonInstance As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SingletonInstance { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SingletonInstance : obj" Usage="System.ServiceModel.ServiceHost.SingletonInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pojedyncze wystąpienie usługi hostowanej.</summary>
        <value>Obiekt usługi hostowanej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29> konstruktora w celu zainicjowania pojedyncze wystąpienie usługi, która ma być obsługiwana, gdy użytkownik chce sterować tym wystąpieniem usługi, która jest używana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
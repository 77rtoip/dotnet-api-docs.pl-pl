<Type Name="ServiceHost" FullName="System.ServiceModel.ServiceHost">
  <Metadata><Meta Name="ms.openlocfilehash" Value="771d20933f9fd55d02eda9304f1084e40ceb8f11" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69147239" /></Metadata><TypeSignature Language="C#" Value="public class ServiceHost : System.ServiceModel.ServiceHostBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceHost extends System.ServiceModel.ServiceHostBase" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceHost" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceHost&#xA;Inherits ServiceHostBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceHost : System::ServiceModel::ServiceHostBase" />
  <TypeSignature Language="F#" Value="type ServiceHost = class&#xA;    inherit ServiceHostBase" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.ServiceHostBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia hosta dla usług.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementuje hosta używanego przez model programowania modelu usług Windows Communication Foundation (WCF).  
  
 <xref:System.ServiceModel.ServiceHost> Użyj klasy, aby skonfigurować i uwidocznić usługę do użycia przez aplikacje klienckie, gdy nie korzystasz z usługi Internet Information Services (IIS) lub usług aktywacji systemu Windows (was), aby uwidocznić usługę. Zarówno usługi IIS, jak i działały z <xref:System.ServiceModel.ServiceHost> obiektem w Twoim imieniu.  
  
 Aby uwidocznić usługę do użycia przez wywołujących, WCF wymaga kompletnego opisu usługi (reprezentowanego przez <xref:System.ServiceModel.Description.ServiceDescription> klasę). Klasa tworzy z informacji o typie i konfiguracji usługi, a następnie używa tego opisu do tworzenia <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> obiektów dla każdego punktu końcowego w opisie. <xref:System.ServiceModel.Description.ServiceDescription> <xref:System.ServiceModel.ServiceHost>  
  
 <xref:System.ServiceModel.ServiceHost> Użyj obiektu do załadowania usługi, konfigurowania punktów końcowych, stosowania ustawień zabezpieczeń i uruchamiania odbiorników do obsługi żądań przychodzących.  
  
   
  
## Examples  
 [!code-csharp[S_SelfHost#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#1)]
 [!code-vb[S_SelfHost#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_selfhost/vb/wholeenchilada.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceHost" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ServiceHost ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ServiceHost();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceHost" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieją dwa konstruktory służące do tworzenia wystąpienia <xref:System.ServiceModel.ServiceHost> klasy. <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Type%2CSystem.Uri%5B%5D%29> Użyj konstruktora, który przyjmuje typ usługi jako parametr wejściowy, w większości czasu. Za pomocą tego hosta można utworzyć nowe usługi zgodnie z wymaganiami. <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29> Użyj konstruktora zamiast tego, tylko wtedy, gdy chcesz, aby Host usługi używał określonego pojedynczego wystąpienia usługi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceHost (object singletonInstance, params Uri[] baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object singletonInstance, class System.Uri[] baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.#ctor(System.Object,System.Uri[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (singletonInstance As Object, ParamArray baseAddresses As Uri())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceHost(System::Object ^ singletonInstance, ... cli::array &lt;Uri ^&gt; ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.ServiceHost : obj * Uri[] -&gt; System.ServiceModel.ServiceHost" Usage="new System.ServiceModel.ServiceHost (singletonInstance, baseAddresses)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="singletonInstance" Type="System.Object" />
        <Parameter Name="baseAddresses" Type="System.Uri[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="singletonInstance">Wystąpienie usługi hostowanej.</param>
        <param name="baseAddresses"><see cref="T:System.Array" /> Typ<see cref="T:System.Uri" /> zawierający adresy podstawowe dla usługi hostowanej.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ServiceModel.ServiceHost" /> klasy z wystąpieniem usługi i określonym adresem podstawowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora jako alternatywy dla implementacji niestandardowej <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType> , jeśli chcesz podać konkretne wystąpienie obiektu do użytku przez pojedynczą usługę. Może być konieczne użycie tego przeciążenia, gdy typ implementacji usługi jest trudny do skonstruowania (na przykład jeśli nie implementuje domyślnego konstruktora publicznego, który nie ma parametrów).  
  
 Należy pamiętać, że po przeniesieniu obiektu do tego przeciążenia niektóre funkcje związane z zachowaniem wystąpień Windows Communication Foundation (WCF) działają inaczej. Na przykład wywoływanie <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> nie ma wpływu, gdy jest dostarczane dobrze znane wystąpienie obiektu za pomocą tego przeciążenia konstruktora. Podobnie wszystkie inne mechanizmy zwalniania wystąpień są ignorowane. Zawsze zachowuje się tak, <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> jakby właściwość została ustawiona na <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType> dla wszystkich operacji. <xref:System.ServiceModel.ServiceHost>  
  
   
  
## Examples  
 [!code-csharp[S_UEServiceHost2#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost2/cs/service.cs#1)]
 [!code-vb[S_UEServiceHost2#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost2/vb/service.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="singletonInstance" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceHost (Type serviceType, params Uri[] baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type serviceType, class System.Uri[] baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.#ctor(System.Type,System.Uri[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serviceType As Type, ParamArray baseAddresses As Uri())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceHost(Type ^ serviceType, ... cli::array &lt;Uri ^&gt; ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.ServiceHost : Type * Uri[] -&gt; System.ServiceModel.ServiceHost" Usage="new System.ServiceModel.ServiceHost (serviceType, baseAddresses)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
        <Parameter Name="baseAddresses" Type="System.Uri[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="serviceType">Typ usługi hostowanej.</param>
        <param name="baseAddresses">Tablica typu <see cref="T:System.Uri" /> , która zawiera adresy podstawowe dla usługi hostowanej.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ServiceModel.ServiceHost" /> klasy z typem usługi i jego określonymi adresami podstawowymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, gdy dysponujesz typem usługi i możesz w razie potrzeby utworzyć nowe wystąpienia, nawet jeśli potrzebujesz pojedynczego wystąpienia. <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29> Użyj konstruktora zamiast tego, tylko wtedy, gdy chcesz, aby Host usługi używał określonego pojedynczego wystąpienia usługi.  
  
   
  
## Examples  
 Ten przykład ilustruje sposób użycia <xref:System.ServiceModel.ServiceHost> klasy do hostowania usługi Windows Communication Foundation:  
  
 [!code-csharp[S_UEServiceHost#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#1)]
 [!code-vb[S_UEServiceHost#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serviceType" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddServiceEndpoint">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje punkt końcowy usługi do usługi hostowanej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, string address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, string address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, System::String ^ address);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * string -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="implementedContract"><see cref="T:System.Type" /> Kontrakt dla dodanego punktu końcowego.</param>
        <param name="binding"><see cref="T:System.ServiceModel.Channels.Binding" /> Dla punktu końcowego został dodany.</param>
        <param name="address">Adres punktu końcowego został dodany.</param>
        <summary>Dodaje punkt końcowy usługi do usługi hostowanej przy użyciu określonego kontraktu, powiązania i adresu punktu końcowego.</summary>
        <returns><see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> Dodano do usługi hostowanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UEServiceHost#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#3)]
 [!code-vb[S_UEServiceHost#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" />or <paramref name="binding" /> lub <paramref name="address" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, Uri ^ address);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract"><see cref="T:System.Type" /> Kontrakt dla dodanego punktu końcowego.</param>
        <param name="binding"><see cref="T:System.ServiceModel.Channels.Binding" /> Dla punktu końcowego został dodany.</param>
        <param name="address">Zawiera adres dla punktu końcowego, któryzostałdodany.<see cref="T:System.Uri" /></param>
        <summary>Dodaje punkt końcowy usługi do usługi hostowanej z określonym kontraktem, powiązaniem i identyfikatorem URI, który zawiera adres punktu końcowego.</summary>
        <returns><see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> Dodano do usługi hostowanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UEServiceHost#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#4)]
 [!code-vb[S_UEServiceHost#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" />or <paramref name="binding" /> lub <paramref name="address" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, string address, Uri listenUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, string address, class System.Uri listenUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.String,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, System::String ^ address, Uri ^ listenUri);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * string * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address, listenUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.String" />
        <Parameter Name="listenUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract"><see cref="T:System.Type" /> Kontrakt dla dodanego punktu końcowego.</param>
        <param name="binding"><see cref="T:System.ServiceModel.Channels.Binding" /> Dla punktu końcowego został dodany.</param>
        <param name="address">Adres punktu końcowego usługi.</param>
        <param name="listenUri"><see cref="T:System.Uri" /> Na którym można nasłuchiwać punkty końcowe usługi.</param>
        <summary>Dodaje punkt końcowy usługi do usługi hostowanej z określonym kontraktem, powiązaniem, adresem punktu końcowego i identyfikatorem URI, w którym usługa nasłuchuje.</summary>
        <returns><see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> Dodano do usługi hostowanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej wersji metody, jeśli masz wiele punktów końcowych, które muszą nasłuchiwać tego samego, określonego identyfikatora URI.  
  
   
  
## Examples  
 [!code-csharp[S_UEServiceHost#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#5)]
 [!code-vb[S_UEServiceHost#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" />or <paramref name="binding" /> lub <paramref name="address" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (Type implementedContract, System.ServiceModel.Channels.Binding binding, Uri address, Uri listenUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(class System.Type implementedContract, class System.ServiceModel.Channels.Binding binding, class System.Uri address, class System.Uri listenUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.AddServiceEndpoint(System.Type,System.ServiceModel.Channels.Binding,System.Uri,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(Type ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, Uri ^ address, Uri ^ listenUri);" />
      <MemberSignature Language="F#" Value="override this.AddServiceEndpoint : Type * System.ServiceModel.Channels.Binding * Uri * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHost.AddServiceEndpoint (implementedContract, binding, address, listenUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.Type" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="listenUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract"><see cref="T:System.Type" /> Kontrakt dla dodanego punktu końcowego.</param>
        <param name="binding"><see cref="T:System.ServiceModel.Channels.Binding" /> Dla punktu końcowego został dodany.</param>
        <param name="address">Zawiera adres dla punktu końcowego, któryzostałdodany.<see cref="T:System.Uri" /></param>
        <param name="listenUri"><see cref="T:System.Uri" /> Na którym można nasłuchiwać punkty końcowe usługi.</param>
        <summary>Dodaje punkt końcowy usługi do usługi hostowanej z określonym kontraktem, powiązaniem, identyfikatorem URI zawierającym adres punktu końcowego oraz identyfikatorem URI, w którym usługa nasłuchuje.</summary>
        <returns><see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> Dodano do usługi hostowanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej wersji metody, jeśli masz wiele punktów końcowych, które muszą nasłuchiwać tego samego, określonego identyfikatora URI.  
  
   
  
## Examples  
 [!code-csharp[S_UEServiceHost#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ueservicehost/cs/service.cs#6)]
 [!code-vb[S_UEServiceHost#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ueservicehost/vb/service.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" />or <paramref name="binding" /> lub <paramref name="address" /> is .<see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie zainicjowano kontraktów lub nie można znaleźć kluczy kontraktu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyConfiguration">
      <MemberSignature Language="C#" Value="protected override void ApplyConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ApplyConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.ApplyConfiguration" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ApplyConfiguration ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ApplyConfiguration();" />
      <MemberSignature Language="F#" Value="override this.ApplyConfiguration : unit -&gt; unit" Usage="serviceHost.ApplyConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ładuje Opis usługi z pliku konfiguracji i stosuje go do konstruowanego środowiska uruchomieniowego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDescription">
      <MemberSignature Language="C#" Value="protected override System.ServiceModel.Description.ServiceDescription CreateDescription (out System.Collections.Generic.IDictionary&lt;string,System.ServiceModel.Description.ContractDescription&gt; implementedContracts);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.ServiceModel.Description.ServiceDescription CreateDescription([out] class System.Collections.Generic.IDictionary`2&lt;string, class System.ServiceModel.Description.ContractDescription&gt;&amp; implementedContracts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.CreateDescription(System.Collections.Generic.IDictionary{System.String,System.ServiceModel.Description.ContractDescription}@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateDescription (ByRef implementedContracts As IDictionary(Of String, ContractDescription)) As ServiceDescription" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::ServiceModel::Description::ServiceDescription ^ CreateDescription([Runtime::InteropServices::Out] System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Description::ContractDescription ^&gt; ^ % implementedContracts);" />
      <MemberSignature Language="F#" Value="override this.CreateDescription :  -&gt; System.ServiceModel.Description.ServiceDescription" Usage="serviceHost.CreateDescription implementedContracts" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceDescription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContracts" Type="System.Collections.Generic.IDictionary&lt;System.String,System.ServiceModel.Description.ContractDescription&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="implementedContracts">Pary kluczy typu (<see cref="T:System.String" />, <see cref="T:System.ServiceModel.Description.ContractDescription" />), które zawierają przedstawione kontrakty usługi hostowanej, która została zaimplementowana. <see cref="T:System.Collections.Generic.IDictionary`2" /></param>
        <summary>Tworzy opis hostowanej usługi.</summary>
        <returns>A <see cref="T:System.ServiceModel.Description.ServiceDescription" /> usługi hostowanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia opisów kontraktu z niestandardowych modeli programowania. Zastąp odpowiednią metodę <xref:System.ServiceModel.ServiceHostBase.CreateDescription%28System.Collections.Generic.IDictionary%7BSystem.String%2CSystem.ServiceModel.Description.ContractDescription%7D%40%29>klasy bazowej,, aby zaimplementować dostosowany model.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ hostowanej usługi to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="InitializeDescription">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje Opis usługi hostowanej na podstawie jej typu lub wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wymagania dotyczące przekazywania adresów bazowych w ramach programu <xref:System.ServiceModel.ServiceHost.%23ctor%2A>. Klasy dziedziczące z <xref:System.ServiceModel.ServiceHost> mogą wywołać metodę <xref:System.ServiceModel.ServiceHost.%23ctor%2A> , a następnie może wywoływać jeden <xref:System.ServiceModel.ServiceHost.InitializeDescription%2A> z, gdy dostępny jest adres podstawowy. Jest to sposób implementacji narzędzia Narzędzia metadanych modelu usług (Svcutil. exe).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitializeDescription">
      <MemberSignature Language="C#" Value="protected void InitializeDescription (object singletonInstance, System.ServiceModel.UriSchemeKeyedCollection baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeDescription(object singletonInstance, class System.ServiceModel.UriSchemeKeyedCollection baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.InitializeDescription(System.Object,System.ServiceModel.UriSchemeKeyedCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeDescription (singletonInstance As Object, baseAddresses As UriSchemeKeyedCollection)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeDescription(System::Object ^ singletonInstance, System::ServiceModel::UriSchemeKeyedCollection ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="override this.InitializeDescription : obj * System.ServiceModel.UriSchemeKeyedCollection -&gt; unit" Usage="serviceHost.InitializeDescription (singletonInstance, baseAddresses)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="singletonInstance" Type="System.Object" />
        <Parameter Name="baseAddresses" Type="System.ServiceModel.UriSchemeKeyedCollection" />
      </Parameters>
      <Docs>
        <param name="singletonInstance">Wystąpienie usługi hostowanej.</param>
        <param name="baseAddresses"><see cref="T:System.ServiceModel.UriSchemeKeyedCollection" /> Zawiera adresy podstawowe dla usługi hostowanej.</param>
        <summary>Inicjuje Opis usługi hostowanej na podstawie jej wystąpienia i określonych adresów podstawowych.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="singletonInstance" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeDescription">
      <MemberSignature Language="C#" Value="protected void InitializeDescription (Type serviceType, System.ServiceModel.UriSchemeKeyedCollection baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeDescription(class System.Type serviceType, class System.ServiceModel.UriSchemeKeyedCollection baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.InitializeDescription(System.Type,System.ServiceModel.UriSchemeKeyedCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeDescription (serviceType As Type, baseAddresses As UriSchemeKeyedCollection)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeDescription(Type ^ serviceType, System::ServiceModel::UriSchemeKeyedCollection ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="override this.InitializeDescription : Type * System.ServiceModel.UriSchemeKeyedCollection -&gt; unit" Usage="serviceHost.InitializeDescription (serviceType, baseAddresses)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
        <Parameter Name="baseAddresses" Type="System.ServiceModel.UriSchemeKeyedCollection" />
      </Parameters>
      <Docs>
        <param name="serviceType"><see cref="T:System.Type" /> Hostowana usługa.</param>
        <param name="baseAddresses"><see cref="T:System.ServiceModel.UriSchemeKeyedCollection" /> Zawiera adresy podstawowe dla usługi hostowanej.</param>
        <summary>Inicjuje Opis usługi hostowanej na podstawie typu i określonych adresów podstawowych.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serviceType" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected override void OnClosed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClosed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHost.OnClosed" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnClosed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnClosed();" />
      <MemberSignature Language="F#" Value="override this.OnClosed : unit -&gt; unit" Usage="serviceHost.OnClosed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa usługi jednorazowe, które są hostowane po zamknięciu hosta usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas zastępowania <xref:System.ServiceModel.ServiceHost.OnClosed%2A> metody należy zapewnić bazę. Metoda OnClosed jest wywoływana, nawet jeśli wystąpi wyjątek. Poniższy kod ilustruje, jak to zrobić.  
  
```  
protected override void OnClosed()  
{  
    try  
    {  
        if (FaultFlagService.faultFlag == ThrowDuring.OnClosed)  
        {  
            FaultFlagService.faultFlag = ThrowDuring.Never;  
            throw new ServiceActivationException("Faulting the service because FaultFlagService.faultFlag = ThrowDuring.OnClosed");  
        }  
    }  
    finally  
    {  
        base.OnClosed();  
    }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SingletonInstance">
      <MemberSignature Language="C#" Value="public object SingletonInstance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SingletonInstance" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHost.SingletonInstance" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SingletonInstance As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SingletonInstance { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SingletonInstance : obj" Usage="System.ServiceModel.ServiceHost.SingletonInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pojedyncze wystąpienie usługi hostowanej.</summary>
        <value>Obiekt usługi hostowanej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29> Użyj konstruktora, aby zainicjować pojedyncze wystąpienie usługi do hostowania, gdy chcesz kontrolować wystąpienie usługi, która jest używana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

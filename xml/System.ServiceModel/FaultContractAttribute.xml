<Type Name="FaultContractAttribute" FullName="System.ServiceModel.FaultContractAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="89bc38b0d324c5acef904d36980d3cbed4c16a1d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36610855" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FaultContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FaultContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.FaultContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FaultContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FaultContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type FaultContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Określa jeden lub więcej błędów protokołu SOAP, które są zwracane, gdy operacja usługi wystąpią błędy przetwarzania.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznacz operację, podając <xref:System.ServiceModel.FaultContractAttribute> atrybutu, aby zadeklarować jedną lub więcej wyjątek warunków, które są dodawane do opisu usługi sieci Web Service Description Language (WSDL) operacji usługi jako jawne SOAP fault wiadomości zwrócony przez operację.  
  
 We wszystkich aplikacjach zarządzanych błędy przetwarzania są reprezentowane przez <xref:System.Exception> obiektów. W aplikacjach opartego na protokole SOAP, takich jak aplikacje systemu Windows Communication Foundation (WCF) metody usługi komunikują się za pomocą protokołu SOAP komunikatów "fault" informacje o błędzie przetwarzania. Ponieważ aplikacje WCF w obu typów systemów błąd, należy przekonwertować wszelkie informacje o zarządzanym wyjątku wysłania do klienta z wyjątków w błędach SOAP. Można użyć domyślnego zachowania wyjątek usługi lub jawnie kontrolowanie, czy--i jak--wyjątki są mapowane na komunikaty o błędach. Omówienie wyjątków i błędów protokołu SOAP w aplikacjach WCF, zobacz [określanie i obsługa błędów w kontraktach i usługach](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).  
  
 Zalecane jest, aby używać operacji usługi <xref:System.ServiceModel.FaultContractAttribute> formalnie określić wszystkie błędach SOAP, które klient może oczekiwać w trakcie normalnego przebiegu operacji. Zalecane jest również, że tylko te informacje, których klient musi wiedzieć, jest zwracany w błędu protokołu SOAP, aby zminimalizować ujawnienie informacji.  
  
-   <xref:System.ServiceModel.FaultContractAttribute.Action%2A> Właściwość kontroluje akcji komunikat o błędzie.  
  
-   <xref:System.ServiceModel.FaultContractAttribute.DetailType%2A> Właściwość pobiera typ obiektu szczegóły zserializowane w komunikat o błędzie.  
  
-   <xref:System.ServiceModel.FaultContractAttribute.Name%2A> i <xref:System.ServiceModel.FaultContractAttribute.Namespace%2A> właściwości formantu nazwę i przestrzeń nazw, odpowiednio z komunikat o błędzie.  
  
-   <xref:System.ServiceModel.FaultContractAttribute.HasProtectionLevel%2A> Wskazuje, czy określony poziom ochrony jest komunikat o błędzie i <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> właściwość określa, że poziom ochrony.  
  
> [!CAUTION]
>  Jeśli komunikat o błędzie zawiera informacje poufne lub może prowadzić do problemów z zabezpieczeniami, zdecydowanie zalecane jest <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> można ustawić właściwości.  
  
-   Jeśli ustawisz <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> jawnie na jeden <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType> lub <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>, należy użyć powiązania z zabezpieczeniami włączyć za pomocą <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> właściwości powiązania ani wyjątek jest zgłaszany.  
  
-   Po wybraniu powiązania, które zapewnia bezpieczeństwo i nie należy ustawiać <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> właściwość dowolnym kontrakt wszystkich aplikacji, danych zostanie zaszyfrowana i podpisana.  
  
-   Jeśli wybierzesz powiązania, które nie ma włączoną obsługą zabezpieczeń (na przykład <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> zabezpieczeń domyślnie wyłączone) i <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> nie jest jawnie ustawiona, a następnie żadne dane aplikacji ma podlegać ochronie.  
  
 W różnych scenariuszach ustawienie <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> do <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> błędu wiadomości jest wystarczająca. Aby uzyskać więcej informacji, zobacz [poziom ochrony opis](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Aby zwrócić określonego błędu z operacji oznaczonej jako <xref:System.ServiceModel.FaultContractAttribute>, throw <xref:System.ServiceModel.FaultException%601> (gdzie parametr typu jest informacje o błędzie do serializacji) po wystąpieniu wyjątku zarządzanego podczas operacji. Aplikacje klienta WCF powierzchni błędu protokołu SOAP jako ten sam typ jak został zgłoszony w implementacji klienta — to znaczy jako <xref:System.ServiceModel.FaultException%601> (gdzie typeparameter jest informacje o błędzie do serializacji). <xref:System.ServiceModel.FaultContractAttribute> Mogą być używane tylko w celu określenia SOAP błędów dla operacji usługi dwukierunkowe i operacji asynchronicznej pary; operacji jednokierunkowych nie obsługują błędach SOAP i dlatego nie obsługują <xref:System.ServiceModel.FaultContractAttribute>.  
  
> [!NOTE]
>  Dowolny typ możliwy do serializacji służy do przekazywania informacji o błędzie. Tylko ograniczenie w tej wersji programu WCF jest czy typy określone w <xref:System.ServiceModel.FaultContractAttribute> muszą umożliwiać serializację za pomocą <xref:System.Runtime.Serialization.DataContractSerializer?displayProperty=nameWithType>. Do obsługi serializacji <xref:System.Runtime.Serialization.DataContractSerializer> udostępnia, zobacz [serializator kontraktu danych](~/docs/framework/wcf/feature-details/data-contract-serializer.md).  
  
 Na przykład, aby określić, że klientów można spodziewać się SOAP usterki, które zawiera <xref:System.Int32>, umieść ten parametr typu w <xref:System.ServiceModel.FaultContractAttribute> na metodę usługi.  
  
> [!NOTE]
>  W poniższych przykładach kodu nie należy ustawiać <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A>, <xref:System.ServiceModel.FaultContractAttribute.Name%2A>, lub <xref:System.ServiceModel.FaultContractAttribute.Namespace%2A> właściwości.  
  
 [!code-csharp[C_FCA#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_fca/cs/fcademo.cs#1)]
 [!code-vb[C_FCA#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_fca/vb/fcademo.vb#1)]  
  
 Następnie, w metodę usługi, throw nowy <xref:System.ServiceModel.FaultException%601> gdzie parametr typu jest typ, który zawiera informacje o błędzie (w przypadku powyższych <xref:System.Int32>). Na przykład:  
  
 [!code-csharp[C_FCA#2](~/samples/snippets/csharp/VS_Snippets_CFX/c_fca/cs/fcademo.cs#2)]
 [!code-vb[C_FCA#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_fca/vb/fcademo.vb#2)]  
  
 Powyższy przykład jest bardzo proste; prawie wszystkie informacje mogą zostać przekazane za pomocą <xref:System.Int32?displayProperty=nameWithType> kod, więc ten typ szczegółów nie jest najbardziej przydatna. Zazwyczaj aplikacji WCF Określ błędach SOAP z typami szczegółów specyficzne dla wymagań informacji błąd klienta. Na przykład bardziej szczegółowy zobacz sekcję przykład.  
  
> [!NOTE]
>  Jeśli określisz <xref:System.ServiceModel.FaultException%601> gdzie parametr typu jest <xref:System.String?displayProperty=nameWithType>, wartość ciągu jest przypisany do właściwości szczegółu w aplikacji klienckiej; klienci nie mogą pobrać ten ciąg przez wywołanie metody <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> metody. Wartości ciągu zwracany, gdy aplikacja klient wywołuje <xref:System.Exception.ToString%2A?displayProperty=nameWithType>, throw <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> wyjątek w operacji i przekazać ciąg konstruktora.  
  
 Aby jawnie wpływają na zachowanie aplikacji, gdy wyjątek lub <xref:System.ServiceModel.FaultException%601> jest zgłoszony, wdrożenie <xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType> interfejs w <xref:System.ServiceModel.Description.IServiceBehavior?displayProperty=nameWithType>, <xref:System.ServiceModel.Description.IContractBehavior?displayProperty=nameWithType> lub <xref:System.ServiceModel.Description.IEndpointBehavior?displayProperty=nameWithType> i przypisz go do <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A?displayProperty=nameWithType> właściwości. <xref:System.ServiceModel.Dispatcher.IErrorHandler> Umożliwia użytkownikom jawnie kontrolowania błędu protokołu SOAP, który jest generowany i czy do wysłania do klienta.  
  
 W celu ułatwienia debugowania, ustaw <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> do `true` w kodzie, lub można użyć <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> w pliku konfiguracyjnym aplikacji. Po włączeniu usługa automatycznie zwraca informacje o wyjątku do obiektu wywołującego. Te błędy są wyświetlane do klienta jako <xref:System.ServiceModel.FaultException> wyjątków.  
  
> [!IMPORTANT]
>  Ponieważ zarządzane wyjątki może ujawnić informacje o wewnętrznych aplikacji, ustawianie <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> lub <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> do `true` może zezwolić klientom uzyskanie informacji o wyjątkach operacji wewnętrzny usługi, w tym osobiście WCF do zidentyfikowania lub inne poufne informacje.  
>   
>  W związku z tym ustawienie <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> lub <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> do `true` jest zalecane tylko w sposób tymczasowo debugowania aplikacji usługi. Ponadto WSDL dla metody, która zwraca nieobsługiwanych wyjątków w ten sposób zarządzanych nie zawiera kontraktu dla <xref:System.ServiceModel.FaultException%601> typu <xref:System.String>. Klienci muszą oczekują możliwości nieznany błąd protokołu SOAP (zwracanych do klientów WCF jako <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> obiektów) można uzyskać informacji o debugowaniu poprawnie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.ServiceModel.FaultContractAttribute> Aby określić, że `SampleMethod` operacji może zwrócić błąd SOAP z typem szczegółów `GreetingFault`.  
  
 [!code-csharp[FaultContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#1)]
 [!code-vb[FaultContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#1)]  
  
 W poniższym przykładzie pokazano, że klienci WCF z `ISampleService` wystąpić tego błędu protokołu SOAP jako <xref:System.ServiceModel.FaultException%601> typu `GreetingFault`.  
  
 [!code-csharp[FaultContractAttribute#3](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
 [!code-vb[FaultContractAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FaultContractAttribute (Type detailType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type detailType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.FaultContractAttribute.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (detailType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FaultContractAttribute(Type ^ detailType);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.FaultContractAttribute : Type -&gt; System.ServiceModel.FaultContractAttribute" Usage="new System.ServiceModel.FaultContractAttribute detailType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="detailType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="detailType">Typ możliwy do serializacji, który zawiera informacje o błędzie do obiektu wywołującego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.FaultContractAttribute" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor jest zazwyczaj wykonywane przez stosowanie atrybut do metody usługi i określanie typu jako argumentu w atrybucie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.ServiceModel.FaultContractAttribute> Aby określić, że `SampleMethod` operacji może zwrócić błąd SOAP z typem szczegółów `GreetingFault`.  
  
 [!code-csharp[FaultContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#1)]
 [!code-vb[FaultContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="detailType" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Action">
      <MemberSignature Language="C#" Value="public string Action { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Action" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.Action" />
      <MemberSignature Language="VB.NET" Value="Public Property Action As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Action { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Action : string with get, set" Usage="System.ServiceModel.FaultContractAttribute.Action" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia akcję komunikat o błędzie SOAP, który jest określony jako część kontrakt operacji.</summary>
        <value>Wartość akcji dla komunikatu błędu SOAP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj, aby kontrolować działań komunikatu błędu SOAP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetailType">
      <MemberSignature Language="C#" Value="public Type DetailType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DetailType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.DetailType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DetailType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ DetailType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DetailType : Type" Usage="System.ServiceModel.FaultContractAttribute.DetailType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ możliwy do serializacji obiektu, który zawiera informacje o błędzie.</summary>
        <value>Typ, który reprezentuje klasę błąd serializacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.ServiceModel.FaultContractAttribute> Aby określić, że `SampleMethod` operacji może zwrócić błąd SOAP z typem szczegółów `GreetingFault`.  
  
 [!code-csharp[FaultContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#1)]
 [!code-vb[FaultContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.FaultContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy komunikat o błędzie protokołu SOAP ma przypisano poziomu ochrony.</summary>
        <value>
          <see langword="true" /> Jeśli komunikat o błędzie ma poziom ochrony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.FaultContractAttribute.HasProtectionLevel%2A> właściwości w celu określenia, czy komunikat o błędzie SOAP musi być zaszyfrowany, podpisany, lub obie. Zobacz <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> właściwości, aby uzyskać szczegółowe informacje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.FaultContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komunikat o błędzie w sieci Web Services Description Language (WSDL).</summary>
        <value>Nazwa komunikat błędu. Wartością domyślną jest nazwa typu używany jako szczegół błędu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.FaultContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar nazw błędu protokołu SOAP.</summary>
        <value>Przestrzeń nazw błędu protokołu SOAP.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.FaultContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa poziom ochrony wymaga błędu protokołu SOAP z powiązania.</summary>
        <value>Jeden z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości. Wartość domyślna to <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.Description.FaultDescription.ProtectionLevel%2A?displayProperty=nameWithType> właściwość, aby określić stopień, w której powiązania musi szyfrowania, zaloguj się i/lub podczas wysyłania błędu protokołu SOAP. Zdecydowanie zaleca się błędu operacji jawnie zdecydować wymagania poziomu ochrony zabezpieczeń kontraktu. Domyślny poziom ochrony jest <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>, co oznacza, że komunikat o błędzie SOAP są definiowane nie wymaga szyfrowania lub podpis cyfrowy (chociaż wiązania może zapewniają tę obsługę, jeśli jest skonfigurowany w tym celu). Jeśli komunikat o błędzie zawiera informacje poufne lub może prowadzić do problemów z zabezpieczeniami, zdecydowanie zalecane jest <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> właściwości można ustawić <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Aby uzyskać więcej informacji na temat problemów z zabezpieczeniami, zobacz [poziom ochrony opis](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Zachowania ochrony w czasie wykonywania jest kombinacją właściwości poziomu ochrony, które mają strukturę hierarchiczną. Ustawienie wartości peryferyjnych ustanawia ustawieniem domyślnym dla wszystkich zakresów mniejszą niż, chyba że jawnie ustawiono inną wartość mniejszą niż zakres. W takim przypadku wartość zewnętrzne pozostaje domyślnego dla wszystkich mniejszą niż zakresów z wyjątkiem obsługującej ustawione.  
  
 Na przykład jeśli <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> ustawiono <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> i nie mniejszą niż zakresy mają ustawienia poziomu ochrony, wszystkie wiadomości w kontrakt operacji są zaszyfrowana i podpisana, w tym komunikatów "fault". Jeśli jednak jeden z tych działań ma <xref:System.ServiceModel.OperationContractAttribute> ustawioną <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, następnie komunikatów dla tej operacji jest zarejestrowany, ale wszystkie inne komunikaty w kontrakcie są zaszyfrowana i podpisana, w tym komunikatów "fault".  
  
 Zakresy, w których te wartości są ustawiane są:  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> Właściwość <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> Właściwość <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Gdy nie poziomu ochrony, nie jawnie określone w umowie a podstawowej powiązanie obsługuje zabezpieczeń, (zarówno na poziomie transportu lub komunikat), poziom skutecznej ochrony dla całej umowy jest <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Jeśli powiązanie nie obsługuje zabezpieczeń (takich jak <xref:System.ServiceModel.BasicHttpBinding>), obowiązującą <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> jest <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> dla całej umowy. Wynik jest, w zależności od powiązanie punktu końcowego, klienci mogą wymagają różnych ochrony zabezpieczeń na poziomie komunikatu i transportu, nawet wtedy, gdy kontrakt Określa <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
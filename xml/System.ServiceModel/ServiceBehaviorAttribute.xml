<Type Name="ServiceBehaviorAttribute" FullName="System.ServiceModel.ServiceBehaviorAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1b89a648a4ad568eab392ff9b9e8c24917e01881" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69101277" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceBehaviorAttribute : Attribute, System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceBehaviorAttribute extends System.Attribute implements class System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceBehaviorAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceBehaviorAttribute&#xA;Inherits Attribute&#xA;Implements IServiceBehavior" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBehaviorAttribute sealed : Attribute, System::ServiceModel::Description::IServiceBehavior" />
  <TypeSignature Language="F#" Value="type ServiceBehaviorAttribute = class&#xA;    inherit Attribute&#xA;    interface IServiceBehavior" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IServiceBehavior</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Określa wewnętrzny sposób wykonywania implementacji kontraktu usługi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceBehaviorAttribute> Zastosuj atrybut do implementacji usługi, aby określić zachowanie wykonywania w całej usłudze. (Aby określić zachowanie wykonywania na poziomie metody, użyj <xref:System.ServiceModel.OperationBehaviorAttribute> atrybutu). Ten atrybut może być stosowany tylko do implementacji usługi. Aby zapoznać się z [przykładami pracy, zobacz Usługa: Przykłady](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90))zachowań.  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute>Właściwości to funkcja modelu programowania w Windows Communication Foundation (WCF), która umożliwia korzystanie z typowych funkcji, które w przeciwnym wypadku deweloperzy muszą zaimplementować. Aby uzyskać więcej informacji na temat tych i innych zachowań, zobacz [Określanie zachowania usługi w czasie wykonywania](~/docs/framework/wcf/specifying-service-run-time-behavior.md). Aby uzyskać więcej informacji na temat podstawowych właściwości środowiska uruchomieniowego, które są określone przez niektóre z następujących właściwości, zobacz Rozszerzanie elementu [ServiceHost i warstwy modelu usług](~/docs/framework/wcf/extending/extending-servicehost-and-the-service-model-layer.md).  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> Właściwość określa typ filtru używanego przez system dyspozytora do lokalizowania punktu końcowego, który obsługuje żądania.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> Właściwość automatycznie zamyka sesję, gdy kanał zostanie zamknięty i usługa zakończyła przetwarzanie pozostałych komunikatów.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> Właściwość steruje wewnętrznym modelem wątkowości, co umożliwia obsługę współużytkowanych lub wielowątkowych usług.  
  
-   Właściwość służy do deklarowania nazwy do użycia `name` w atrybucie `<service>` elementu w pliku konfiguracji. <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A>  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> Właściwość włącza czas wykonywania ignorowanie dodatkowych informacji serializacji, które nie są wymagane do przetworzenia komunikatu.  
  
-   Właściwość <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> określa, czy Nieobsłużone wyjątki w usłudze są zwracane jako błędy SOAP. Jest to tylko do celów debugowania.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> Właściwość określa, czy i kiedy usługi i ich obiekty usługi mają być odtwarzane podczas wymiany z klientem.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> Właściwość do ograniczenia liczby elementów w grafie obiektu, które są serializowane.  
  
-   Właściwości <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> i<xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> kontrolują nazwę i przestrzeń nazw dla wyrażenia WSDL elementu usługi.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> Właściwość określa, czy obiekt usługi jest odtwarzany po zakończeniu transakcji.  
  
-   Właściwość <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> określa, czy oczekujące transakcje są uzupełniane po zamknięciu sesji.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> Właściwość określa poziom izolacji transakcji obsługiwany przez umowę.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> Właściwość określa czas, w którym transakcja musi zostać zakończona lub przerwana.  
  
-   Właściwość <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> wskazuje, czy należy automatycznie synchronizować wywołania metod przychodzących z wątkiem interfejsu użytkownika.  
  
-   Właściwość informuje system, czy powinien potwierdzić, że nagłówki protokołu SOAP oznaczone jako `MustUnderstand` mają, w rzeczywistości, zostały zrozumiałe. <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A>  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> Właściwość można również ustawić przy użyciu pliku konfiguracji aplikacji. Aby uzyskać szczegółowe informacje <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A>, zobacz.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości. `BehaviorService` Klasa<xref:System.ServiceModel.ServiceBehaviorAttribute> używa atrybutu, aby wskazać, że:  
  
-   Obiekt usługi jest odtwarzany po zakończeniu transakcji.  
  
-   Dla każdej sesji istnieje jeden obiekt usługi.  
  
-   Usługa jest jednowątkowa i nie obsługuje wywołań współużytkowanych.  
  
 Ponadto na poziomie <xref:System.ServiceModel.OperationBehaviorAttribute> operacji wartości wskazują `TxWork` , że metoda automatycznie zarejestrowana w przetwarzanych transakcjach lub tworzy nową transakcję do wykonania pracy, i że transakcja jest zatwierdzana automatycznie, jeśli nieobsłużone wyjątek nie wystąpił.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Powiązanie bazowe musi obsługiwać przepływające transakcje, aby można było prawidłowo wykonać następujący przykład kodu. Aby obsługiwać przepływy transakcji przy użyciu <xref:System.ServiceModel.WSHttpBinding>, na przykład, <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> ustaw właściwość na `true` wartość w kodzie lub w pliku konfiguracyjnym aplikacji. Poniższy przykład kodu pokazuje plik konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationBehaviorAttribute" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)">Usługa: Przykład zachowań</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBehaviorAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBehaviorAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceBehaviorAttribute" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości domyślne dla <xref:System.ServiceModel.ServiceBehaviorAttribute> :  
  
-   Ustawienie jest ustawione na <xref:System.ServiceModel.AddressFilterMode.Exact>. <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A>  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> Właściwość jest`true`.  
  
-   Ustawienie jest ustawione na <xref:System.ServiceModel.ConcurrencyMode.Single>. <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> Właściwość jest kwalifikowana nazwa typu w przestrzeni nazw bez informacji o zestawie.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> Właściwość jest`false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> Właściwość ma wartość 64 KB.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> Właściwość jest nazwą typu usługi, bez przestrzeni nazw lub informacji o zestawie.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> Właściwość jest`"http://tempuri.org"`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> Właściwość jest`true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A>jest `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A>jest `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> Właściwość jest`false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> Właściwość jest<xref:System.Transactions.IsolationLevel.Unspecified>.  
  
-   Właściwość jest ustawiona na <xref:System.TimeSpan.Zero>. <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A>  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> Właściwość jest`true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFilterMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AddressFilterMode AddressFilterMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AddressFilterMode AddressFilterMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AddressFilterMode As AddressFilterMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AddressFilterMode AddressFilterMode { System::ServiceModel::AddressFilterMode get(); void set(System::ServiceModel::AddressFilterMode value); };" />
      <MemberSignature Language="F#" Value="member this.AddressFilterMode : System.ServiceModel.AddressFilterMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AddressFilterMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ServiceModel.AddressFilterMode" /> , który jest używany przez dyspozytora do kierowania komunikatów przychodzących do poprawnego punktu końcowego.</summary>
        <value><see cref="T:System.ServiceModel.AddressFilterMode" /> Obiekt, który jest używany przez dyspozytora do kierowania komunikatów przychodzących do poprawnego punktu końcowego.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jedną z <see cref="T:System.ServiceModel.AddressFilterMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomaticSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticSessionShutdown : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy należy automatycznie zamykać sesję, gdy klient zamknie sesję wyjściową.</summary>
        <value><see langword="true" />Jeśli usługa automatycznie zamknie sesję, gdy klient zamknie sesję wyjściową; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie, gdy klient zamyka sesję wyjściową, a usługa zakończyła przetwarzanie pozostałych komunikatów, serwer zamknie sesję. Ustawienie <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A>uniemożliwiaserwerowi Automatycznezamknięciesesjiiwłączenieniestandardowejkontroliokresówistnieniasesji.`false`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czy usługa obsługuje jeden wątek, wiele wątków lub wywołania współużytkowane.</summary>
        <value>Jedna z <see cref="T:System.ServiceModel.ConcurrencyMode" /> wartości; wartość domyślna to <see cref="F:System.ServiceModel.ConcurrencyMode.Single" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość wskazuje, czy wystąpienie usługi może obsłużyć jeden wątek lub wiele wątków wykonywanych współbieżnie, a jeśli jest to współużytkowania wątkowości, czy jest obsługiwana.  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> Właściwość współdziała z innymi ustawieniami. Na przykład, <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> Jeśli wartość jest ustawiona na <xref:System.ServiceModel.InstanceContextMode.Single> wynik, usługa może przetwarzać tylko jeden komunikat w danym momencie, <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> chyba że zostanie <xref:System.ServiceModel.ConcurrencyMode.Multiple>również ustawiona wartość. Ta właściwość tworzy również zachowanie w połączeniu z <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> właściwością. Aby uzyskać szczegółowe informacje, zobacz [sesje, Tworzenie wystąpień i współbieżność](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Ustawienie określające <xref:System.ServiceModel.ConcurrencyMode> , że system ma ograniczać wystąpienia usługi do jednego wątku wykonywania w danym momencie, co uwalnia użytkownika od rozwiązywania problemów z wątkami. <xref:System.ServiceModel.ConcurrencyMode.Single> Wartość <xref:System.ServiceModel.ConcurrencyMode.Multiple> oznacza, że obiekty usługi mogą być wykonywane przez wiele wątków w dowolnym czasie. W takim przypadku należy zapewnić bezpieczeństwo wątków.  
  
 <xref:System.ServiceModel.ConcurrencyMode.Reentrant>ogranicza również dostęp do pojedynczego wątku naraz; podczas przetwarzania operacji nie można wprowadzić tej operacji. Jeśli podczas operacji wywołanie do innej usługi opuszcza, bieżący komunikat utraci blokadę operacji, która jest bezpłatna do przetwarzania innych komunikatów. Gdy usługa wywołała zwroty, blokada zostaje ponownie ustanowiona, a oryginalny komunikat może kontynuować przetwarzanie do jego wniosku lub do czasu, aż zostanie wykonane inne wywołanie operacji.  
  
> [!IMPORTANT]
>  Mimo że <xref:System.ServiceModel.ConcurrencyMode.Single> program ogranicza wystąpienia usługi do jednego wątku wykonywania w danym momencie, należy również ustawić wartość <xref:System.ServiceModel.Description.ServiceThrottlingBehavior.MaxConcurrentCalls%2A> 1, aby zagwarantować Brak komunikatów poza kolejnością.  
>   
>  Ponadto użytkownik jest odpowiedzialny za pozostawienie stanu obiektu spójnego przed objaśnieniami i należy potwierdzić, że dane operacji — lokalne są prawidłowe po wywołaniach. Należy zauważyć, że wystąpienie usługi jest odblokowane tylko przez wywołanie innej usługi za pośrednictwem kanału WCF. W takim przypadku wywołana usługa może ponownie wprowadzić pierwszą usługę za pośrednictwem wywołania zwrotnego. Jeśli pierwsza usługa nie jest współużytkowana, sekwencja wywołań skutkuje zakleszczeniem. Aby uzyskać szczegółowe informacje <xref:System.ServiceModel.ConcurrencyMode>, zobacz.  
  
 Podczas dowolnego wywołania wychodzącego z operacji przetwarzania dane, które nie są lokalne dla operacji, można modyfikować. (Dane stanu lokalnego są uznawane za prawidłowe, gdy oryginalny komunikat zostanie wznowiony.) W związku z tym przed wywołaniem wychodzącym musisz upewnić się, że dane nielokalne są prawidłowe dla innych wywołań przychodzących i ponownie Weryfikuj dane nielokalne po powrocie wywołania wychodzącego.  
  
 Poniższy pseudo kodu ilustruje wymagany wzorzec dla pomyślnej obsługi współużytkowanej.  
  
```csharp  
public void MyMethod()  
{  
  this.SomeNonLocalDataState;  
  // Here you need to clean nonlocal state for other users  
  OutboundProxy proxy = new OutboundProxy();  
  int returnValue = proxy.CallOutOfOperation();  
  // Ensure that this.SomeNonLocalDataState is valid for continued use.  
  this.ModifyNonLocalState;  
  return returnValue;  
}  
  
```  
  
 Używanie wzorca wywołań asynchronicznych begin/end dla wywołania wychodzącego, <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> <xref:System.ServiceModel.ConcurrencyMode.Reentrant> gdy wyzwala wyjątek. Asynchroniczne wywołania wychodzące wymagają operacji <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> <xref:System.ServiceModel.ConcurrencyMode.Multiple>, w tym przypadku należy obsługiwać problemy z synchronizacją.  
  
 Ogólnie rzecz biorąc, jeśli komunikat dociera do wystąpienia, które narusza jego tryb współbieżności, komunikat czeka do momentu udostępnienia wystąpienia lub do czasu przełączenia.  
  
 Ponadto, jeśli <xref:System.ServiceModel.ConcurrencyMode> jest ustawiona na <xref:System.ServiceModel.ConcurrencyMode.Single> , a wywołanie współużytkowane jest blokowane podczas oczekiwania na zwolnienie wystąpienia, system wykryje zakleszczenie i zgłosi wyjątek.  
  
> [!NOTE]
>  Występuje <xref:System.InvalidOperationException> w czasie wykonywania, `true` Jeśli <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> właściwość jest ustawiona na <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 Należy pamiętać, że należy jawnie <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> ustawić `false` na, jeśli istnieje operacja z <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> ustawioną wartością true i ustawioną <xref:System.ServiceModel.ConcurrencyMode.Reentrant> <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> jako. W przeciwnym razie jest zgłaszany wyjątek sprawdzania poprawności, ponieważ <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> wartość `true`domyślna to.  
  
 Istnieje interakcja z <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> i innych właściwości, które mogą zmienić zachowanie w czasie wykonywania. Pełny opis tych interakcji można znaleźć w temacie [sesje, Tworzenie wystąpień i współbieżność](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje różne między poleceniami <xref:System.ServiceModel.ConcurrencyMode.Single>, <xref:System.ServiceModel.ConcurrencyMode.Reentrant>i <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Ten przykład nie kompiluje się bez prawdziwej implementacji, ale pokazuje rodzaj gwarancji, że Windows Communication Foundation (WCF) i co to znaczy, co oznacza kod operacji.  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jedną z <see cref="T:System.ServiceModel.ConcurrencyMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość używaną do lokalizowania elementu usługi w pliku konfiguracyjnym aplikacji.</summary>
        <value>Wartość, która ma zostać zlokalizowana w pliku konfiguracji. Wartość domyślna to w pełni kwalifikowana nazwa typu bez informacji o zestawie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość umożliwia określenie określonej usługi w pliku konfiguracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość jest równa null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest ciągiem pustym.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest zapewniona zamówiona wysyłka usługi.</summary>
        <value><see langword="true" />Jeśli jest zapewniona zamówiona wysyłka usługi; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public object GetWellKnownSingleton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetWellKnownSingleton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.GetWellKnownSingleton" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWellKnownSingleton () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetWellKnownSingleton();" />
      <MemberSignature Language="F#" Value="member this.GetWellKnownSingleton : unit -&gt; obj" Usage="serviceBehaviorAttribute.GetWellKnownSingleton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt, który implementuje usługę i jest używany jako pojedyncze wystąpienie usługi lub <see langword="null" /> Jeśli nie istnieje pojedyncze wystąpienie.</summary>
        <returns>Implementacja usługi. Wartość domyślna to <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `null` Wartość nie jest wartością określającą wystąpienie usługi, do której będą wysyłane wszystkie komunikaty kierowane do usługi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy nieznane dane serializacji mają być wysyłane do sieci.</summary>
        <value><see langword="true" />Jeśli nieznane dane serializacji nigdy nie są wysyłane; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ implementuje <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejs, przechowuje wszelkie dodatkowe dane, które nie są dostępne w sieci podczas deserializacji do tego typu. Na przykład `Person` , jeśli typ ma składowe `FirstName` i `LastName`, a element o nazwie `PhoneNumber` znajduje się w, jest przechowywany. Gdy później zostanie serializowany typ, `PhoneNumber` zostanie on ponownie wyemitowany. Problem polega na tym, że schemat `Person` wyeksportowany przez tę usługę ma `FirstName` tylko i `LastName`, więc Windows Communication Foundation (WCF) generuje schemat — nieprawidłowe wystąpienie. Jeśli ścisła zgodność schematu jest ważna, można ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> `true` , aby ponownie wyemitować zachowanie.  
  
 Bez względu na ustawienie Funkcja WCF zawsze przetwarza znane dane (zarówno w programie, jak i out) i nie generuje wyjątków w przypadku, gdy dodatkowe dane są dostępne. <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> Możesz również ustawić tę właściwość przy użyciu [ &lt;elementu DataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) w pliku konfiguracyjnym aplikacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> i implementacji programu. <xref:System.Runtime.Serialization.IExtensibleDataObject> W tym przykładzie z <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> ustawieniem na `false`, dodatkowe dane, których dotyczy klient, są z powrotem przeprzywracane do klienta.  
  
 [!code-csharp[DCAContainerNoValidation#1](~/samples/snippets/csharp/VS_Snippets_CFX/dcacontainernovalidation/cs/services.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, że ogólne Nieobsłużone wyjątki wykonywania mają być konwertowane na <see cref="T:System.ServiceModel.FaultException`1" /> typ <see cref="T:System.ServiceModel.ExceptionDetail" /> i wysyłane jako komunikat o błędzie. Ustaw tę wartość <see langword="true" /> na tylko podczas programowania, aby rozwiązywać problemy z usługą.</summary>
        <value><see langword="true" />Jeśli Nieobsłużone wyjątki mają być zwracane jako błędy protokołu SOAP; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A>, aby umożliwić przepływ informacji o wyjątku do klientów na potrzeby debugowania. `true` Ta właściwość wymaga powiązania, które obsługuje komunikaty Request-Response lub Duplex.  
  
 W przypadku wszystkich aplikacji zarządzanych błędy przetwarzania są reprezentowane przez <xref:System.Exception> obiekty. W aplikacjach opartych na protokole SOAP, takich jak aplikacje WCF, metody implementujące operacje usługi komunikują informacje o błędach przy użyciu komunikatów błędów protokołu SOAP. Ponieważ aplikacje WCF są wykonywane w obu typach systemów błędów, wszelkie zarządzane informacje o wyjątkach, które muszą być wysłane do klienta, muszą być konwertowane z wyjątków na błędy protokołu SOAP. Aby uzyskać więcej informacji, zobacz [określanie i obsługa błędów w kontraktach i usługach](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).  
  
 Podczas opracowywania można chcieć, aby usługa mogła również wysyłać inne wyjątki z powrotem do klienta, aby pomóc w debugowaniu. Jest to funkcja tylko programistyczna i nie powinna być stosowana w wdrożonych usługach.  
  
 Aby ułatwić debugowanie, należy ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> na `true` wartość w kodzie lub przy użyciu pliku konfiguracyjnego aplikacji.  
  
 Po włączeniu usługa automatycznie zwraca bezpieczniejsze informacje o wyjątku do obiektu wywołującego. Te błędy pojawiają się na kliencie jako <xref:System.ServiceModel.FaultException%601> obiekty typu. <xref:System.ServiceModel.ExceptionDetail>  
  
> [!IMPORTANT]
>  Ustawienie <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A>umożliwiające klientom uzyskanie informacji o wyjątkach metody usługi wewnętrznej; jest to zalecane tylko jako sposób tymczasowego debugowania aplikacji usługi. `true` Ponadto WSDL dla metody, która zwraca Nieobsłużone wyjątki zarządzane w ten sposób, nie zawiera kontraktu dla <xref:System.ServiceModel.FaultException%601> typu. <xref:System.ServiceModel.ExceptionDetail> Klienci muszą oczekiwać, że nieznany błąd protokołu SOAP będzie mógł prawidłowo uzyskać informacje o debugowaniu.  
  
 Ustawienie tej właściwości na `true` można także wykonać przy użyciu pliku konfiguracji aplikacji [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicedebug.md) i elementu serviceDebug, jak pokazano w poniższym przykładzie kodu.  
  
 [!code-xml[OperationBehaviorAttribute1#10](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#10)]   
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości. `BehaviorService` Klasa<xref:System.ServiceModel.ServiceBehaviorAttribute> używa atrybutu, aby wskazać, że:  
  
-   Metody implementacji są wywoływane w wątku interfejsu użytkownika.  
  
-   Dla każdej sesji istnieje jeden obiekt usługi.  
  
-   Usługa jest jednowątkowa i nie obsługuje wywołań współużytkowanych.  
  
 Ponadto na poziomie <xref:System.ServiceModel.OperationBehaviorAttribute> operacji wartości wskazują `TxWork` , że metoda automatycznie zarejestrowana w przetwarzanych transakcjach lub tworzy nową transakcję do wykonania pracy, i że transakcja jest zatwierdzana automatycznie, jeśli nieobsłużone wyjątek nie wystąpił.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Powiązanie bazowe musi obsługiwać przepływające transakcje, aby można było prawidłowo wykonać następujący przykład kodu. Aby obsługiwać przepływy transakcji przy użyciu <xref:System.ServiceModel.WSHttpBinding>, na przykład, <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> ustaw właściwość na `true` wartość w kodzie lub w pliku konfiguracyjnym aplikacji. Poniższy przykład kodu pokazuje plik konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContextMode InstanceContextMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.InstanceContextMode InstanceContextMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextMode As InstanceContextMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContextMode InstanceContextMode { System::ServiceModel::InstanceContextMode get(); void set(System::ServiceModel::InstanceContextMode value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextMode : System.ServiceModel.InstanceContextMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContextMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, kiedy są tworzone nowe obiekty usługi.</summary>
        <value>Jedna z <see cref="T:System.ServiceModel.InstanceContextMode" /> wartości; wartość domyślna to <see cref="F:System.ServiceModel.InstanceContextMode.PerSession" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości <xref:System.ServiceModel.InstanceContextMode> , aby określić, kiedy mają być tworzone nowe obiekty usługi. Ponieważ obiekt usługi nie jest bezpośrednio połączony z kanałem komunikacji, okres istnienia obiektów usługi jest niezależny od okresu istnienia kanału między klientem a aplikacją usługi. Wartość domyślna, powoduje <xref:System.ServiceModel.InstanceContextMode.PerSession>, że aplikacja usługi tworzy nowy obiekt usługi w przypadku ustanowienia nowej sesji komunikacji między klientem a aplikacją usługi. Kolejne wywołania w tej samej sesji są obsługiwane przez ten sam obiekt.  
  
 <xref:System.ServiceModel.InstanceContextMode.PerSession>wskazuje, że każdy obiekt usługi obsługuje żądania z jednego kanału klienta.  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> Właściwość współdziała z innymi ustawieniami. Na przykład, <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> Jeśli wartość jest ustawiona na <xref:System.ServiceModel.InstanceContextMode.Single> wynik, usługa może przetwarzać tylko jeden komunikat w danym momencie, <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> chyba że zostanie <xref:System.ServiceModel.ConcurrencyMode.Multiple>również ustawiona wartość. Ta właściwość tworzy również zachowanie w połączeniu z <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> właściwością. Aby uzyskać szczegółowe informacje, zobacz [sesje, Tworzenie wystąpień i współbieżność](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 W przypadku działania pojedynczego okresu istnienia (na przykład jeśli aplikacja hosta wywołuje <xref:System.ServiceModel.ServiceHost.%23ctor%2A> konstruktora i przekazuje obiekt, który ma być używany jako usługa), Klasa usługi musi mieć <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> `Single`ustawioną wartość lub wyjątek jest zgłaszany w czasie wykonywania.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości. `BehaviorService` Klasa<xref:System.ServiceModel.ServiceBehaviorAttribute> używa atrybutu, aby wskazać, że:  
  
-   Metody implementacji są wywoływane w wątku interfejsu użytkownika.  
  
-   Dla każdej sesji istnieje jeden obiekt usługi.  
  
-   Usługa jest jednowątkowa i nie obsługuje wywołań współużytkowanych.  
  
 Ponadto na poziomie <xref:System.ServiceModel.OperationBehaviorAttribute> operacji wartości wskazują `TxWork` , że metoda automatycznie zarejestrowana w przetwarzanych transakcjach lub tworzy nową transakcję do wykonania pracy, i że transakcja jest zatwierdzana automatycznie, jeśli nieobsłużone wyjątek nie wystąpił.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Powiązanie bazowe musi obsługiwać przepływające transakcje, aby można było prawidłowo wykonać następujący przykład kodu. Aby obsługiwać przepływy transakcji przy użyciu <xref:System.ServiceModel.WSHttpBinding>, na przykład, <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> ustaw właściwość na `true` wartość w kodzie lub w pliku konfiguracyjnym aplikacji. Poniższy przykład kodu pokazuje plik konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jedną z <see cref="T:System.ServiceModel.InstanceContextMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę elementów dozwoloną w serializowanym obiekcie.</summary>
        <value>Maksymalna liczba elementów dozwolona w obiekcie. Wartość domyślna to 65536 bajtów (64 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> Użyj właściwości ustaw limit liczby elementów w grafie obiektów, które są serializowane. Możesz również ustawić tę właściwość przy użyciu [ &lt;elementu DataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) w pliku konfiguracyjnym aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość atrybutu Name w elemencie usługi w Web Services Description Language (WSDL).</summary>
        <value>Wartość atrybutu Name w <see langword="&lt;wsdl:service&gt;" /> elemencie po wyeksportowaniu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość docelowej przestrzeni nazw dla usługi w Web Services Description Language (WSDL).</summary>
        <value>Wartość <see langword="targetNamespace" /> atrybutu <see langword="&lt;wsdl:service&gt;" /> dla elementu, który zawiera element. <see langword="&lt;wsdl:definitions&gt;" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy obiekt usługi jest wydawany po zakończeniu bieżącej transakcji.</summary>
        <value><see langword="true" />Jeśli obiekt usługi ma zostać opublikowany; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że należy jawnie <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> ustawić `false` na, jeśli istnieje operacja z <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> ustawioną wartością true i ustawioną <xref:System.ServiceModel.ConcurrencyMode.Reentrant> <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> jako. W przeciwnym razie jest zgłaszany wyjątek sprawdzania poprawności, ponieważ <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> wartość `true`domyślna to.  
  
 Ponadto ważne jest, aby pamiętać, że jeśli usługa zostanie utworzona przez przekazanie obiektu usługi do <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> konstruktora, wartość tej właściwości jest traktowana tak, jakby była. `false`  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia poziom izolacji transakcji na <xref:System.Transactions.IsolationLevel.ReadCommitted>, wyłącza obsługę współbieżnych transakcji, wymaga transakcji przepływowej z wywołania operacji i zatwierdza transakcję w usłudze automatycznie, jeśli nie jest obsługiwany Wystąpił wyjątek.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 Powiązanie bazowe musi obsługiwać przepływające transakcje, aby można było prawidłowo wykonać następujący przykład kodu. Aby obsługiwać przepływy transakcji przy użyciu <xref:System.ServiceModel.WSHttpBinding>, na przykład, <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> ustaw właściwość na `true` wartość w kodzie lub w pliku konfiguracyjnym aplikacji. Poniższy przykład kodu pokazuje plik konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public void SetWellKnownSingleton (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetWellKnownSingleton(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetWellKnownSingleton (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetWellKnownSingleton(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetWellKnownSingleton : obj -&gt; unit" Usage="serviceBehaviorAttribute.SetWellKnownSingleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Pojedyncze wystąpienie usługi.</param>
        <summary>Określa obiekt, który implementuje usługę i który jest używany jako pojedyncze wystąpienie usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zapewnia to wystąpienie usługi, do którego zostaną wysłane wszystkie komunikaty kierowane do usługi.  
  
 Jeśli <xref:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton%2A> jest ustawiona na`null` wartość niebędącą wartością, <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> należy określić <xref:System.ServiceModel.InstanceContextMode.Single> wartość lub <xref:System.InvalidOperationException> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ustawiona wartość to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeConfigurationName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeConfigurationName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeConfigurationName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeConfigurationName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeConfigurationName();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeConfigurationName : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeConfigurationName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> właściwość została zmieniona z wartości domyślnej i powinna być serializowana.</summary>
        <returns><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReleaseServiceInstanceOnTransactionComplete () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReleaseServiceInstanceOnTransactionComplete : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> właściwość została zmieniona z wartości domyślnej i powinna być serializowana.</summary>
        <returns><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionAutoCompleteOnSessionClose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionAutoCompleteOnSessionClose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionAutoCompleteOnSessionClose () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionAutoCompleteOnSessionClose();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionAutoCompleteOnSessionClose : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> właściwość została zmieniona z wartości domyślnej i powinna być serializowana.</summary>
        <returns><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionIsolationLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionIsolationLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionIsolationLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionIsolationLevel();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionIsolationLevel : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> właściwość została zmieniona z wartości domyślnej i powinna być serializowana.</summary>
        <returns><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionTimeout">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionTimeout () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionTimeout();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionTimeout : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> właściwość została zmieniona z wartości domyślnej i powinna być serializowana.</summary>
        <returns><see langword="true" />Jeśli wartość <see langword="false" />właściwości powinna być serializowana; w przeciwnym razie,. <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.AddBindingParameters">
      <MemberSignature Language="C#" Value="void IServiceBehavior.AddBindingParameters (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase, class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase, System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ endpoints, System::ServiceModel::Channels::BindingParameterCollection ^ parameters) = System::ServiceModel::Description::IServiceBehavior::AddBindingParameters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
        <Parameter Name="endpoints" Type="System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <param name="description">Opis usługi.</param>
        <param name="serviceHostBase">Host usługi.</param>
        <param name="endpoints">Punkty końcowe usługi.</param>
        <param name="parameters">Obiekty danych, które są konieczne przez powiązania do obsługi zachowania.</param>
        <summary>Przekazuje niestandardowe obiekty danych do powiązań, które obsługują właściwości zachowania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior">
      <MemberSignature Language="C#" Value="void IServiceBehavior.ApplyDispatchBehavior (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::ApplyDispatchBehavior;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Opis usługi.</param>
        <param name="serviceHostBase">Host usługi.</param>
        <summary>Dostosowuje czas wykonywania usługi do obsługi właściwości zachowania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.Validate">
      <MemberSignature Language="C#" Value="void IServiceBehavior.Validate (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.Validate(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.Validate(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::Validate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Opis usługi.</param>
        <param name="serviceHostBase">Host usługi.</param>
        <summary>Potwierdza, że opis usługi i Host usługi mogą obsługiwać zachowanie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy oczekujące transakcje są kończone, gdy bieżąca sesja zostanie zamknięta bez błędu.</summary>
        <value><see langword="true" />Jeśli oczekujące transakcje mają zostać ukończone, gdy bieżąca sesja zostanie zamknięta bez błędu; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa poziom izolacji transakcji dla nowych transakcji utworzonych wewnątrz usługi i przychodzących transakcji przepływających z klienta.</summary>
        <value><see cref="T:System.Transactions.IsolationLevel" /> Wartość określająca poziom izolacji transakcji. Wartość domyślna to <see cref="F:System.Transactions.IsolationLevel.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom izolacji, w którym działa transakcja określa sposób traktowania danych podczas wprowadzania zmian w innych transakcjach i czas, w którym transakcja musi zawierać blokady, aby chronić je przed tymi zmianami. Na przykład wartość <xref:System.Transactions.IsolationLevel.Unspecified>domyślna,, określa, że nie mogą wystąpić żadne aktualizacje ani Wstawianie, dopóki transakcja nie zostanie ukończona.  
  
 Ta właściwość może również służyć do ograniczania poziomu izolacji transakcji przychodzących przepływających z klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia poziom izolacji transakcji na <xref:System.Transactions.IsolationLevel.ReadCommitted>, nie obsługuje współbieżnych transakcji, wymaga transakcji przepływu z wywołania metody i automatycznie zatwierdza transakcję, jeśli nie wystąpił nieobsługiwany wyjątek.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 Powiązanie bazowe musi obsługiwać przepływające transakcje, aby można było prawidłowo wykonać następujący przykład kodu. Aby obsługiwać przepływy transakcji przy użyciu <xref:System.ServiceModel.WSHttpBinding>, na przykład, <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> ustaw właściwość na `true` wartość w kodzie lub w pliku konfiguracyjnym aplikacji. Poniższy przykład kodu pokazuje plik konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jedną z <see cref="T:System.Transactions.IsolationLevel" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public string TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionTimeout { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia okres, w którym transakcja musi zostać ukończona.</summary>
        <value><see cref="T:System.TimeSpan" /> Obiekt, który reprezentuje czas, w którym transakcje muszą zostać zakończone lub być automatycznie przerywane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość ustawia <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout%2A?displayProperty=nameWithType> właściwość. Tę właściwość można również ustawić przy użyciu [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicetimeouts.md) elementu servicetimeouts w pliku konfiguracyjnym aplikacji.  
  
   
  
## Examples  
 Następujący plik konfiguracji określa przedział czasu transakcji równy trzy minuty.  
  
 [!code-csharp[SBA.TransactionTimeout#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactiontimeout/cs/services.cs#2)]
 [!code-vb[SBA.TransactionTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactiontimeout/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość jest równa null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza <see cref="F:System.TimeSpan.Zero" /> lub <see cref="F:System.TimeSpan.MaxValue" />równa.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSynchronizationContext">
      <MemberSignature Language="C#" Value="public bool UseSynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSynchronizationContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSynchronizationContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSynchronizationContext : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy należy używać bieżącego kontekstu synchronizacji do wybierania wątku wykonania.</summary>
        <value><see langword="true" />Jeśli wszystkie wywołania usługi muszą działać w wątku określonym przez <see cref="T:System.Threading.SynchronizationContext" />; w przeciwnym razie,. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej właściwości, aby zapewnić koligację wątku interfejsu użytkownika wymaganą przez niektóre aplikacje. Na przykład aplikacja Windows Forms może być zarejestrowana jako pojedynczy obiekt usługi. W takim przypadku wszystkie wywołania do usługi muszą zostać uruchomione w wątku Windows Forms. Domyślny przypadek, w którym <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> jest ustawiona na `true`, synchronizuje wszystkie wywołania do usługi w celu uruchomienia na wątku przechwytywanym z <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy system lub aplikacja wymuszają przetwarzanie nagłówka SOAP <see langword="MustUnderstand" /> .</summary>
        <value><see langword="true" />Jeśli system ma wykonać przetwarzanie nagłówka <see langword="MustUnderstand" /> SOAP; w przeciwnym razie <see langword="false" />wskazuje, że aplikacja wykonuje to przetwarzanie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> Użyj właściwości, aby wyłączyć wymuszane walidację nagłówków wiadomości. W normalnym wykonywaniu nagłówki komunikatów są porównywane <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> z właściwością, aby potwierdzić, że przychodzące nagłówki są jawnie obsługiwane przez usługę. Ustaw tę wartość `false` na, aby wyłączyć sprawdzanie. Po ustawieniu na `false`, aplikacja musi sprawdzić nagłówki oznaczone jako MustUnderstand = "true" i zwrócić błąd, jeśli co najmniej jeden z nich nie został rozpoznany. Jest to przydatne, gdy aplikacja powinna akceptować wszystkie przychodzące komunikaty protokołu SOAP (na przykład podczas korzystania z komunikatów z wpisanymi lub nieokreślonymi typami) i wykonywać niestandardowe przetwarzanie nagłówków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="ServiceBehaviorAttribute" FullName="System.ServiceModel.ServiceBehaviorAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="17070c85f228ee7676168b3d7c5aa05d14bfc1c8" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36610053" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ServiceBehaviorAttribute : Attribute, System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceBehaviorAttribute extends System.Attribute implements class System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceBehaviorAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceBehaviorAttribute&#xA;Inherits Attribute&#xA;Implements IServiceBehavior" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBehaviorAttribute sealed : Attribute, System::ServiceModel::Description::IServiceBehavior" />
  <TypeSignature Language="F#" Value="type ServiceBehaviorAttribute = class&#xA;    inherit Attribute&#xA;    interface IServiceBehavior" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IServiceBehavior</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Określa sposób wykonywania wewnętrznej implementacji kontraktu usługi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastosuj <xref:System.ServiceModel.ServiceBehaviorAttribute> atrybutu implementacji usługi, aby określić sposób wykonywania całej usługi. (Aby określić sposób wykonywania na poziomie metody, należy użyć <xref:System.ServiceModel.OperationBehaviorAttribute> atrybutu.) Ten atrybut można stosować tylko do implementacji usługi. Przykłady pracy można znaleźć [przykłady zachowania usługi](http://msdn.microsoft.com/library/4e3c6513-a7ff-4b35-8dcf-b5506c6f39a7).  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości są Windows Communication Foundation (WCF) programowania modelu funkcja, która umożliwia typowe funkcje, które w przeciwnym razie programiści muszą implementować. Aby uzyskać więcej informacji na temat tych i innych zachowań, zobacz [Określanie zachowania środowiska uruchomieniowego usługi](~/docs/framework/wcf/specifying-service-run-time-behavior.md). Aby uzyskać więcej informacji o właściwościach podstawowego środowiska wykonawczego niektórych do następującego zestawu właściwości, zobacz [rozszerzanie elementu ServiceHost i warstwy modelu usług](~/docs/framework/wcf/extending/extending-servicehost-and-the-service-model-layer.md).  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> Właściwość określa typ filtru, który używa systemu dyspozytora można zlokalizować punktu końcowego, który obsługuje żądania.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> Właściwości automatycznie zamknięciu sesji, gdy zamknięcie kanału i usługa zakończył przetwarzanie wszelkie pozostałe wiadomości.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> Właściwość kontroluje wewnętrzny model wątkowy Włączanie obsługi usługi współużytkowane lub wielowątkowych.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> Właściwość służy do deklarowania Nazwa do użycia w `name` atrybut `<service>` w pliku konfiguracji.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> Właściwość umożliwia czasie wykonywania zignorować serializacji dodatkowe informacje, które nie jest wymagana do przetwarzania komunikatu.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> Właściwość określa, czy jako błędach SOAP zwracanych nieobsługiwanych wyjątków w usłudze. To jest tylko do celów debugowania.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> Właściwość określa, czy i kiedy usług i ich obiektami usługi są będzie wykonywane podczas wymiany z klientem.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> Właściwości do ograniczania liczby elementów na wykresie obiektu, które są serializowane.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> i <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> właściwości formantu, nazwę i przestrzeń nazw dla wyrażenia WSDL elementu usługi.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> Właściwość określa, czy obiekt usługi jest ponownie przetwarzany po zakończeniu transakcji.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> Właściwość określa, czy transakcje oczekujące są wykonywane po zamknięciu sesji.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> Właściwość określa poziom izolacji transakcji obsługującego kontrakt.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> Właściwość określa okres czasu, w ramach którego transakcja musi zostać zakończona, lub ją przerwie.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> Właściwość wskazuje, czy automatyczną synchronizację wywołania metody przychodzące z wątku interfejsu użytkownika.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> Właściwości informuje system czy go należy się upewnić, że nagłówki SOAP oznaczona jako `MustUnderstand` w rzeczywistości rozumiem.  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> Właściwości można również ustawić przy użyciu pliku konfiguracji aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości. `BehaviorService` Klasy używa <xref:System.ServiceModel.ServiceBehaviorAttribute> atrybutu, aby wskazać, że:  
  
-   Obiekt usługi jest ponownie przetworzony po zakończeniu transakcji.  
  
-   Dla każdej sesji jest jeden obiekt usługi.  
  
-   Usługa jest jednowątkowy i nie obsługuje wywołania współużytkowane.  
  
 Ponadto na poziomie operacji <xref:System.ServiceModel.OperationBehaviorAttribute> wartości wskazują, że `TxWork` metody automatycznie rejestruje przesłanej transakcji lub tworzy nową transakcję jej oraz że transakcja została przekazana automatycznie Jeśli nieobsługiwany wyjątek nie występuje.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Podstawowe powiązanie musi obsługiwać przesłanej transakcji dla Poniższy przykładowy kod do wykonania poprawnie. Do obsługi przesłanej transakcji za pomocą <xref:System.ServiceModel.WSHttpBinding>, na przykład ustawić <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> właściwości `true` w kodzie, lub w pliku konfiguracyjnym aplikacji. Poniższy przykładowy kod przedstawia plik konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationBehaviorAttribute" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBehaviorAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBehaviorAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceBehaviorAttribute" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości domyślne <xref:System.ServiceModel.ServiceBehaviorAttribute> są:  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> Ma ustawioną wartość <xref:System.ServiceModel.AddressFilterMode.Exact>.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> Jest właściwość `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> Ma ustawioną wartość <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> Właściwości jest nazwa kwalifikowana przestrzeni nazw typu bez informacji o zestawie.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> Jest właściwość `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> Właściwość jest ustawiona na 64 KB.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> Właściwości jest nazwa typu usługi bez informacji o przestrzeni nazw lub zestawu.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> Jest właściwość "http://tempuri.org".  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> Jest właściwość `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> jest `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> jest `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> Jest właściwość `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> Jest właściwość <xref:System.Transactions.IsolationLevel.Unspecified>.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> Właściwość jest ustawiona na <xref:System.TimeSpan.Zero>.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> Jest właściwość `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFilterMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AddressFilterMode AddressFilterMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AddressFilterMode AddressFilterMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AddressFilterMode As AddressFilterMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AddressFilterMode AddressFilterMode { System::ServiceModel::AddressFilterMode get(); void set(System::ServiceModel::AddressFilterMode value); };" />
      <MemberSignature Language="F#" Value="member this.AddressFilterMode : System.ServiceModel.AddressFilterMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AddressFilterMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ServiceModel.AddressFilterMode" /> używany przez Dyspozytor do kierowania wiadomości przychodzących do właściwego punktu końcowego.</summary>
        <value>
          <see cref="T:System.ServiceModel.AddressFilterMode" /> Obiekt, który jest używany przez Dyspozytor do kierowania wiadomości przychodzących do właściwego punktu końcowego.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.ServiceModel.AddressFilterMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomaticSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticSessionShutdown : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy automatycznie zamykać sesję przy zamykaniu przez klienta sesji wyjściowej.</summary>
        <value>
          <see langword="true" /> Jeśli usługi automatycznie zamykać sesję, jeśli klient zamyka sesji wyjściowej; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie przy zamykaniu przez klienta sesji wyjściowej i usługa zakończył przetwarzanie wszelkie pozostałe komunikatów serwera zamknięciu sesji. Ustawienie <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> do `false` zapobiega automatycznego zamykania sesji serwera i umożliwia niestandardowego formantu okresy istnienia sesji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, czy usługa obsługuje jeden wątek, wiele wątków lub wywołania współużytkowane.</summary>
        <value>Jeden z <see cref="T:System.ServiceModel.ConcurrencyMode" /> wartości; wartość domyślna jest <see cref="F:System.ServiceModel.ConcurrencyMode.Single" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość wskazuje, czy wystąpienie usługi może obsługiwać jeden wątek lub wiele wątków, które są wykonywane jednocześnie, a jeśli jednowątkowe, czy ponowne wejście jest obsługiwane.  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> Właściwość współdziała z kilkoma innymi ustawieniami. Na przykład jeśli <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> ma wartość <xref:System.ServiceModel.InstanceContextMode.Single> wynik jest, że usługa może przetwarzać tylko jeden komunikat w czasie chyba, że można również ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> do wartości <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Ta właściwość tworzy również zachowanie w połączeniu z <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> właściwości. Aby uzyskać więcej informacji, zobacz [sesji, Instancing i współbieżność](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Ustawienie <xref:System.ServiceModel.ConcurrencyMode> do <xref:System.ServiceModel.ConcurrencyMode.Single> instruuje system do ograniczenia wystąpień usługi do jednego wątku do wykonania w czasie, dzięki czemu możesz o problemy wielowątkowości. Wartość <xref:System.ServiceModel.ConcurrencyMode.Multiple> oznacza, że usługi obiekty mogą być wykonywane przez wiele wątków w dowolnym momencie. W takim przypadku musi zapewnić bezpieczeństwo wątków.  
  
 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> również ogranicza dostęp do pojedynczego wątku jednocześnie. podczas przetwarzania operacji komunikat nie można wprowadzić wykonać operację. Jeśli podczas operacji pozostawia wywołania do innej usługi, bieżący komunikat traci blokady operacja, która może przetwarzać inne komunikaty. Gdy usługa wyróżnienia zwraca, ustanowieniu blokady i oryginalnej wiadomości, można kontynuować przetwarzania do jego zakończenia lub dopóki nie wystąpi innym wywołaniu poza operacji.  
  
> [!IMPORTANT]
>  Mimo że <xref:System.ServiceModel.ConcurrencyMode.Single> ogranicza wystąpień usługi na jeden wątek na raz, należy także ustawić <xref:System.ServiceModel.Description.ServiceThrottlingBehavior.MaxConcurrentCalls%2A> 1, aby zagwarantować żadnych komunikatów poza kolejnością.  
>   
>  Ponadto odpowiedzialność za pozostawić spójne przed objaśnienia Nazwa stanu obiektu i musisz potwierdzić, że dane lokalne operacji jest ważne po objaśnienia. Należy pamiętać, że wystąpienie usługi jest odblokowana tylko wywołując innej usługi za pośrednictwem kanału WCF. W takim przypadku usługa o nazwie można ponownie pierwszej usługi za pośrednictwem wywołania zwrotnego. Jeśli pierwsza usługa nie jest współużytkowane, sekwencję wywołań powoduje zakleszczenie. Aby uzyskać więcej informacji, zobacz <xref:System.ServiceModel.ConcurrencyMode>.  
  
 Wszelkie głosu wychodzące z operacji przetwarzania danych nie jest lokalny dla operacji może być modyfikowany. (Dane o stanie lokalnego gwarantuje to prawidłowe podczas przetwarzania wznawia oryginalnej wiadomości.) W związku z tym przed połączenia wychodzącego należy zapewnić, że danych innego niż lokalne jest nieprawidłowa dla innych połączeń przychodzących i ponownie sprawdź poprawność danych innego niż lokalne, po powrocie wywołań wychodzących.  
  
 Poniższy pseudo-kod przedstawia wymaganym wzorcem obsługi współużytkowane powiodło się.  
  
```csharp  
public void MyMethod()  
{  
  this.SomeNonLocalDataState;  
  // Here you need to clean nonlocal state for other users  
  OutboundProxy proxy = new OutboundProxy();  
  int returnValue = proxy.CallOutOfOperation();  
  // Ensure that this.SomeNonLocalDataState is valid for continued use.  
  this.ModifyNonLocalState;  
  return returnValue;  
}  
  
```  
  
 Za pomocą wzorca wywołania asynchronicznego Begin/End dla ruchu wychodzącego wywołania, gdy <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> jest <xref:System.ServiceModel.ConcurrencyMode.Reentrant> wyzwala Wystąpił wyjątek. Asynchroniczne wywołania wychodzącego wymagają operacji, w którym <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> jest <xref:System.ServiceModel.ConcurrencyMode.Multiple>, w którym to przypadku należy samodzielnie problemów z synchronizacją.  
  
 Ogólnie rzecz biorąc Jeśli komunikat dla wystąpienia, który narusza jego tryb współbieżności, komunikat czeka dopóki wystąpienie będzie niedostępny lub dopóki nie upłynie limit czasu.  
  
 Ponadto jeśli <xref:System.ServiceModel.ConcurrencyMode> ustawiono <xref:System.ServiceModel.ConcurrencyMode.Single> i jest współużytkowane wywołanie jest blokowane podczas oczekiwania na wystąpienie ma zostać zwolniony, system wykryje zakleszczenie i zgłasza wyjątek.  
  
> [!NOTE]
>  A <xref:System.InvalidOperationException> jest zgłaszany w czasie wykonywania, jeśli <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> jest `true` podczas <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> właściwość jest ustawiona na <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 Należy pamiętać, że musisz jawnie ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> do `false` w przypadku operacji z <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> ustawioną wartość true, <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> do <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. W przeciwnym razie jest zwracany wyjątek sprawdzania poprawności, ponieważ domyślna wartość <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> jest `true`.  
  
 Brak interakcji z <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> i inne właściwości, które można zmienić zachowania w czasie wykonywania. Aby uzyskać pełny opis tych interakcji, zobacz [sesji, Instancing i współbieżność](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje różnic między przy użyciu <xref:System.ServiceModel.ConcurrencyMode.Single>, <xref:System.ServiceModel.ConcurrencyMode.Reentrant>, i <xref:System.ServiceModel.ConcurrencyMode.Multiple>. W tym przykładzie nie kompiluje się bez rzeczywistego wykonania za nią, ale pokazują rodzaj wątkowość gwarantuje, że ułatwia Windows Communication Foundation (WCF) i który znaczenia dla kodu operacji.  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.ServiceModel.ConcurrencyMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość używaną do lokalizowania elementu usługi w pliku konfiguracyjnym aplikacji.</summary>
        <value>Wartość do zlokalizowania w pliku konfiguracji. Wartość domyślna to w pełni kwalifikowana nazwa typu bez informacji o zestawie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość umożliwia określenie określonej usługi w pliku konfiguracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest ciągiem pustym.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest zapewniona uporządkowane wysyłania usługi.</summary>
        <value>
          <see langword="True" /> Jeśli usługa uporządkowane wysyłania zapewniony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public object GetWellKnownSingleton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetWellKnownSingleton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.GetWellKnownSingleton" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWellKnownSingleton () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetWellKnownSingleton();" />
      <MemberSignature Language="F#" Value="member this.GetWellKnownSingleton : unit -&gt; obj" Usage="serviceBehaviorAttribute.GetWellKnownSingleton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt, który implementuje usługę i który jest używany jako pojedyncze wystąpienie usługi lub <see langword="null" /> przypadku nie pojedyncze wystąpienie.</summary>
        <returns>Implementacja usługi. Wartość domyślna to <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niż`null` wartość zawiera wystąpienie usługi, do którego będą wysyłane wszystkie komunikaty kierowane do usługi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która określa, czy nieznane dane serializacji serializacji.</summary>
        <value>
          <see langword="true" /> Jeśli nigdy nie są wysyłane nieznane dane serializacji; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ implementuje <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejsu, przechowuje dodatkowe dane go nie ma informacji dotyczących dostarczanego przez sieć podczas deserializacji do tego typu. Na przykład, jeśli typem `Person` ma członków `FirstName` i `LastName`, i wywołuje element `PhoneNumber` pochodzi, są przechowywane. Podczas serializowania później typu `PhoneNumber` będzie obliczanie ponownie. Problem jest schemat `Person` wyeksportowane przez usługę tylko ma `FirstName` i `LastName`, więc Windows Communication Foundation (WCF) generuje wystąpienia nieprawidłowy schemat! Jeśli zgodność schematu strict odgrywa ważną rolę, możesz ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> do `true` Aby wyłączyć to zachowanie ponownie emisji.  
  
 Niezależnie od <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> ustawienie, WCF zawsze przetwarza dane znane, (zarówno in oraz out) i nie zgłaszają wyjątki, gdy ma dodatkowe dane. Możesz także ustawić dla tej właściwości przy użyciu [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) elementu w pliku konfiguracyjnym aplikacji.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono użycie <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> oraz implementację <xref:System.Runtime.Serialization.IExtensibleDataObject>. W tym przykładzie z <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> ustawioną `false`, dodatkowe dane, które klient zna jest zwrotnego do klienta.  
  
 [!code-csharp[DCAContainerNoValidation#1](~/samples/snippets/csharp/VS_Snippets_CFX/dcacontainernovalidation/cs/services.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy Wyjątki ogólne nieobsłużonego do przekonwertowania na <see cref="T:System.ServiceModel.FaultException`1" /> typu <see cref="T:System.ServiceModel.ExceptionDetail" /> i wysłany jako komunikat o błędzie. Ustaw tę wartość na <see langword="true" /> tylko podczas programowania rozwiązywania problemów z usługą.</summary>
        <value>
          <see langword="true" /> Jeśli nieobsługiwanych wyjątków, które mają zostać zwrócone jako błędach SOAP; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> do `true` wyjątek informacji mogą przepływać do klientów na potrzeby debugowania. Ta właściwość wymaga powiązania, które obsługuje zarówno żądanie odpowiedź lub dupleks wiadomości.  
  
 We wszystkich aplikacjach zarządzanych błędy przetwarzania są reprezentowane przez <xref:System.Exception> obiektów. W aplikacjach opartego na protokole SOAP, takich jak aplikacje WCF metody, które implementują operacji usługi komunikują się za pomocą protokołu SOAP komunikatów "fault" informacje o błędzie. Ponieważ aplikacje WCF w obu typów systemów błąd, należy przekonwertować wszystkie informacje o zarządzanym wyjątku, który musi być wysyłana do klienta z wyjątków w błędach SOAP. Aby uzyskać więcej informacji, zobacz [określanie i obsługa błędów w kontraktach i usługach](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).  
  
 Podczas tworzenia można również wysłać do klienta, aby pomóc w debugowaniu pozostałe wyjątki usługa. To jest tylko do rozwoju funkcją i nie powinny być stosowane w wdrożonych usług.  
  
 Aby ułatwić projektowanie debugowania, ustaw <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> do `true` w kodu lub przy użyciu pliku konfiguracji aplikacji.  
  
 Po włączeniu usługa automatycznie zwraca bezpieczniejsze informacji o wyjątkach do obiektu wywołującego. Te błędy są wyświetlane do klienta jako <xref:System.ServiceModel.FaultException%601> obiektów typu <xref:System.ServiceModel.ExceptionDetail>.  
  
> [!IMPORTANT]
>  Ustawienie <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> do `true` umożliwia klientom, aby uzyskać informacje o wewnętrznych Usługa metody wyjątków; jest zalecane tylko sposób tymczasowo debugowania aplikacji usługi. Ponadto WSDL dla metody, która zwraca nieobsługiwanych wyjątków w ten sposób zarządzanych nie zawiera kontraktu dla <xref:System.ServiceModel.FaultException%601> typu <xref:System.ServiceModel.ExceptionDetail>. Klienci muszą oczekują możliwości nieznany błąd protokołu SOAP, aby uzyskać informacje o debugowaniu poprawnie.  
  
 Ustawienie tej właściwości na `true` można również wykonać przy użyciu pliku konfiguracji aplikacji i [ &lt;serviceDebug&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicedebug.md) element, jak przedstawiono na poniższym przykładzie kodu.  
  
 [!code-xml[OperationBehaviorAttribute1#10](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#10)]   
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości. `BehaviorService` Klasy używa <xref:System.ServiceModel.ServiceBehaviorAttribute> atrybutu, aby wskazać, że:  
  
-   Implementacja metody są wywoływane w wątku interfejsu użytkownika.  
  
-   Dla każdej sesji jest jeden obiekt usługi.  
  
-   Usługa jest jednowątkowy i nie obsługuje wywołania współużytkowane.  
  
 Ponadto na poziomie operacji <xref:System.ServiceModel.OperationBehaviorAttribute> wartości wskazują, że `TxWork` metody automatycznie rejestruje przesłanej transakcji lub tworzy nową transakcję jej oraz że transakcja została przekazana automatycznie Jeśli nieobsługiwany wyjątek nie występuje.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Podstawowe powiązanie musi obsługiwać przesłanej transakcji dla Poniższy przykładowy kod do wykonania poprawnie. Do obsługi przesłanej transakcji za pomocą <xref:System.ServiceModel.WSHttpBinding>, na przykład ustawić <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> właściwości `true` w kodzie, lub w pliku konfiguracyjnym aplikacji. Poniższy przykładowy kod przedstawia plik konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContextMode InstanceContextMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.InstanceContextMode InstanceContextMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextMode As InstanceContextMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContextMode InstanceContextMode { System::ServiceModel::InstanceContextMode get(); void set(System::ServiceModel::InstanceContextMode value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextMode : System.ServiceModel.InstanceContextMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContextMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która wskazuje, kiedy są tworzone nowe obiekty usługi.</summary>
        <value>Jeden z <see cref="T:System.ServiceModel.InstanceContextMode" /> wartości; wartością domyślną jest <see cref="F:System.ServiceModel.InstanceContextMode.PerSession" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.InstanceContextMode> właściwości w celu określenia, kiedy są tworzone nowe obiekty usługi. Ponieważ obiekt usługi nie jest bezpośrednio połączony do kanału komunikacji, okres istnienia obiektów usługi jest niezależna od ważności kanał między klientem usług i aplikacji. Wartość domyślna to <xref:System.ServiceModel.InstanceContextMode.PerSession>, powoduje, że aplikacja usługi można utworzyć nowego obiektu usługi, po nawiązaniu nowej sesji komunikacji między klientem usług i aplikacji. Kolejne wywołania w tej samej sesji są obsługiwane przez tego samego obiektu.  
  
 <xref:System.ServiceModel.InstanceContextMode.PerSession> Wskazuje, że każdy obiekt usługi obsługuje żądania z kanału jednego klienta.  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> Właściwość współdziała z kilkoma innymi ustawieniami. Na przykład jeśli <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> ma wartość <xref:System.ServiceModel.InstanceContextMode.Single> wynik jest, że usługa może przetwarzać tylko jeden komunikat w czasie chyba, że można również ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> do wartości <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Ta właściwość tworzy również zachowanie w połączeniu z <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> właściwości. Aby uzyskać więcej informacji, zobacz [sesji, Instancing i współbieżność](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Pojedyncze okres istnienia zachowania (na przykład, jeśli aplikacja hosta wywołuje <xref:System.ServiceModel.ServiceHost.%23ctor%2A> Konstruktor i przekazuje obiekt ma być używana jako usługa), klasy usługi należy ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> do `Single`, lub wyjątek w czasie wykonywania.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości. `BehaviorService` Klasy używa <xref:System.ServiceModel.ServiceBehaviorAttribute> atrybutu, aby wskazać, że:  
  
-   Implementacja metody są wywoływane w wątku interfejsu użytkownika.  
  
-   Dla każdej sesji jest jeden obiekt usługi.  
  
-   Usługa jest jednowątkowy i nie obsługuje wywołania współużytkowane.  
  
 Ponadto na poziomie operacji <xref:System.ServiceModel.OperationBehaviorAttribute> wartości wskazują, że `TxWork` metody automatycznie rejestruje przesłanej transakcji lub tworzy nową transakcję jej oraz że transakcja została przekazana automatycznie Jeśli nieobsługiwany wyjątek nie występuje.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Podstawowe powiązanie musi obsługiwać przesłanej transakcji dla Poniższy przykładowy kod do wykonania poprawnie. Do obsługi przesłanej transakcji za pomocą <xref:System.ServiceModel.WSHttpBinding>, na przykład ustawić <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> właściwości `true` w kodzie, lub w pliku konfiguracyjnym aplikacji. Poniższy przykładowy kod przedstawia plik konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.ServiceModel.InstanceContextMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę elementów dozwoloną w obiekcie szeregowanym.</summary>
        <value>Maksymalną liczbę elementów dozwoloną w obiekcie. Wartość domyślna to 65536 bajtów (64KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> właściwość ustawić limit liczby elementów na wykresie obiektu, które są serializowane. Możesz także ustawić dla tej właściwości przy użyciu [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) elementu w pliku konfiguracyjnym aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość atrybutu nazwy w elemencie usługi w sieci Web Services Description Language (WSDL).</summary>
        <value>Wartość atrybutu nazwy w <see langword="&lt;wsdl:service&gt;" /> element podczas eksportowania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość docelowa przestrzeń nazw dla usługi w sieci Web Services Description Language (WSDL).</summary>
        <value>Wartość <see langword="targetNamespace" /> atrybutu dla <see langword="&lt;wsdl:definitions&gt;" /> element, który zawiera <see langword="&lt;wsdl:service&gt;" /> elementu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy obiekt usługi jest zwolnione po zakończeniu bieżącej transakcji.</summary>
        <value>
          <see langword="true" /> Jeśli usługa jest zwalniane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że musisz jawnie ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> do `false` w przypadku operacji z <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> ustawioną wartość true, <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> do <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. W przeciwnym razie jest zwracany wyjątek sprawdzania poprawności, ponieważ domyślna wartość <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> jest `true`.  
  
 Ponadto należy koniecznie należy pamiętać, że usługa jest tworzony przez przekazanie obiektu usługi, aby <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> konstruktora, wartość tej właściwości jest traktowana tak, jakby była `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu określa poziom izolacji transakcji <xref:System.Transactions.IsolationLevel.ReadCommitted>, wyłącza obsługę równoczesnych transakcji wymaga przesłanej transakcji z wywołania operacji i automatycznie zatwierdza transakcji usługi, jeśli nie nieobsługiwany Wystąpił wyjątek.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 Podstawowe powiązanie musi obsługiwać przesłanej transakcji dla Poniższy przykładowy kod do wykonania poprawnie. Do obsługi przesłanej transakcji za pomocą <xref:System.ServiceModel.WSHttpBinding>, na przykład ustawić <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> właściwości `true` w kodzie, lub w pliku konfiguracyjnym aplikacji. Poniższy przykładowy kod przedstawia plik konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public void SetWellKnownSingleton (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetWellKnownSingleton(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetWellKnownSingleton (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetWellKnownSingleton(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetWellKnownSingleton : obj -&gt; unit" Usage="serviceBehaviorAttribute.SetWellKnownSingleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Pojedyncze wystąpienie usługi.</param>
        <summary>Określa obiekt, który implementuje usługę i który jest używany jako pojedyncze wystąpienie usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zapewnia to wystąpienie usługi, do którego będą wysyłane wszystkie komunikaty kierowane do usługi.  
  
 Jeśli <xref:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton%2A> ustawiono niż`null` wartości, a następnie <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> musi mieć ustawioną <xref:System.ServiceModel.InstanceContextMode.Single> lub <xref:System.InvalidOperationException> jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Podana wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeConfigurationName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeConfigurationName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeConfigurationName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeConfigurationName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeConfigurationName();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeConfigurationName : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeConfigurationName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> właściwości została zmieniona z jej wartości domyślnej i powinny być serializowane.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> wartość właściwości powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReleaseServiceInstanceOnTransactionComplete () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReleaseServiceInstanceOnTransactionComplete : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> właściwości została zmieniona z jej wartości domyślnej i powinny być serializowane.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> wartość właściwości powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionAutoCompleteOnSessionClose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionAutoCompleteOnSessionClose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionAutoCompleteOnSessionClose () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionAutoCompleteOnSessionClose();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionAutoCompleteOnSessionClose : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> właściwości została zmieniona z jej wartości domyślnej i powinny być serializowane.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> wartość właściwości powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionIsolationLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionIsolationLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionIsolationLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionIsolationLevel();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionIsolationLevel : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> właściwości została zmieniona z jej wartości domyślnej i powinny być serializowane.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> wartość właściwości powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionTimeout">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionTimeout () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionTimeout();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionTimeout : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> właściwości została zmieniona z jej wartości domyślnej i powinny być serializowane.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> wartość właściwości powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.AddBindingParameters">
      <MemberSignature Language="C#" Value="void IServiceBehavior.AddBindingParameters (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase, class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase, System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ endpoints, System::ServiceModel::Channels::BindingParameterCollection ^ parameters) = System::ServiceModel::Description::IServiceBehavior::AddBindingParameters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
        <Parameter Name="endpoints" Type="System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <param name="description">Opis usługi.</param>
        <param name="serviceHostBase">Host usługi.</param>
        <param name="endpoints">Punkty końcowe usługi.</param>
        <param name="parameters">Obiekty danych potrzebne do obsługi zachowanie wiązania.</param>
        <summary>Przekazuje dane niestandardowe obiekty do powiązania, które obsługują właściwości zachowania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior">
      <MemberSignature Language="C#" Value="void IServiceBehavior.ApplyDispatchBehavior (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::ApplyDispatchBehavior;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Opis usługi.</param>
        <param name="serviceHostBase">Host usługi.</param>
        <summary>Dostosowuje wykonawczego do obsługi właściwości zachowania usługi.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.Validate">
      <MemberSignature Language="C#" Value="void IServiceBehavior.Validate (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.Validate(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.Validate(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::Validate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Opis usługi.</param>
        <param name="serviceHostBase">Host usługi.</param>
        <summary>Potwierdza, że opisu usługi i hosta usługi mogą obsłużyć zachowanie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy transakcje oczekujące są kończone podczas zamykania bieżącej sesji bez błędów.</summary>
        <value>
          <see langword="true" /> Jeśli transakcje oczekujące są wypełniane podczas zamykania bieżącej sesji bez błędów; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa poziom izolacji transakcji dla nowych transakcji tworzone wewnątrz usługi, a przepływ przychodzący transakcji od klienta.</summary>
        <value>A <see cref="T:System.Transactions.IsolationLevel" /> wartość, która określa poziom izolacji transakcji. Wartość domyślna to <see cref="F:System.Transactions.IsolationLevel.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom izolacji, w którym sekwencji transakcji określa, jak dane są używane podczas wprowadzania zmian w innych transakcjach i jak długo transakcji musi posiadać blokad w celu ochrony przed tych zmian. Na przykład, wartość domyślna to <xref:System.Transactions.IsolationLevel.Unspecified>, określa, że nie aktualizowania lub wstawianie mogą występować do czasu ukończenia transakcji.  
  
 Tej właściwości można również ograniczyć izolację przepływ poziom przychodzących transakcji od klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu określa poziom izolacji transakcji <xref:System.Transactions.IsolationLevel.ReadCommitted>, nie obsługuje równoczesnych transakcji wymaga przesłanej transakcji w wywołaniu metody i automatycznie zatwierdza transakcji, jeśli nie nieobsługiwanego wyjątku.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 Podstawowe powiązanie musi obsługiwać przesłanej transakcji dla Poniższy przykładowy kod do wykonania poprawnie. Do obsługi przesłanej transakcji za pomocą <xref:System.ServiceModel.WSHttpBinding>, na przykład ustawić <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> właściwości `true` w kodzie, lub w pliku konfiguracyjnym aplikacji. Poniższy przykładowy kod przedstawia plik konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.Transactions.IsolationLevel" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public string TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionTimeout { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia okres, w ramach którego transakcja musi zostać zakończona.</summary>
        <value>A <see cref="T:System.TimeSpan" /> obiekt, który reprezentuje czas, w ramach którego transakcje muszą się ukończyć lub automatycznie przerwana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość ustawia <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout%2A?displayProperty=nameWithType> właściwości. Możesz także ustawić dla tej właściwości przy użyciu [ &lt;serviceTimeouts&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicetimeouts.md) elementu w pliku konfiguracyjnym aplikacji.  
  
   
  
## Examples  
 Następujący plik konfiguracyjny określa limit czasu transakcji trzy minuty.  
  
 [!code-csharp[SBA.TransactionTimeout#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactiontimeout/cs/services.cs#2)]
 [!code-vb[SBA.TransactionTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactiontimeout/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSynchronizationContext">
      <MemberSignature Language="C#" Value="public bool UseSynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSynchronizationContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSynchronizationContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSynchronizationContext : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy ma być używany bieżący kontekst synchronizacji do wyboru wątku do wykonania.</summary>
        <value>
          <see langword="true" /> wszystkie wywołania usługi należy uruchomić w wątku, określony przez <see cref="T:System.Threading.SynchronizationContext" />; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do zapewnienia koligacji wątku interfejsu użytkownika, że niektóre aplikacje wymagają. Na przykład aplikacji formularzy systemu Windows mogą być rejestrowane jako pojedynczego obiektu usługi. W takim przypadku wszystkie wywołania do usługi, należy uruchomić w wątku formularzy systemu Windows. W przypadku domyślny, w którym <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> ustawiono `true`, synchronizuje wszystkie wywołania do usługi do uruchamiania w wątku przechwytywane z <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy system lub aplikacja wymusza SOAP <see langword="MustUnderstand" /> przetwarzanie nagłówka.</summary>
        <value>
          <see langword="true" /> Jeśli system jest wykonanie nagłówka SOAP <see langword="MustUnderstand" /> przetwarzania; w przeciwnym razie <see langword="false" />, co oznacza, że aplikacja jest wykonywane to przetwarzanie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> właściwości, aby wyłączyć wymuszone weryfikacji nadchodzących nagłówki komunikatów. Podczas wykonywania normalnych, nagłówki komunikatów są porównywane <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> właściwości, aby upewnić się, że nagłówki nadchodzących jawnie są obsługiwane przez usługę. Ustaw tę wartość na `false` wyłączenie tego sprawdzenia. Jeśli wartość `false`, aplikacja musi sprawdzać dla nagłówków oznaczony atrybutem MustUnderstand = "true" i zwraca błąd, jeśli co najmniej jeden z nich są niezrozumiałe. Jest to przydatne, gdy aplikacja ma akceptować przychodzących wiadomości SOAP (na przykład, gdy wpisany przy użyciu lub bez typu wiadomości) i przetwarzania niestandardowego nagłówka.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
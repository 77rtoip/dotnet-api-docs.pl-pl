<Type Name="ServiceBehaviorAttribute" FullName="System.ServiceModel.ServiceBehaviorAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="50331392363256e74f896d27155738cc69fd5c32" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53294801" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceBehaviorAttribute : Attribute, System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceBehaviorAttribute extends System.Attribute implements class System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceBehaviorAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceBehaviorAttribute&#xA;Inherits Attribute&#xA;Implements IServiceBehavior" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBehaviorAttribute sealed : Attribute, System::ServiceModel::Description::IServiceBehavior" />
  <TypeSignature Language="F#" Value="type ServiceBehaviorAttribute = class&#xA;    inherit Attribute&#xA;    interface IServiceBehavior" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IServiceBehavior</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Określa zachowanie wykonywania wewnętrznej implementacji kontraktu usługi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastosuj <xref:System.ServiceModel.ServiceBehaviorAttribute> atrybut do implementacji usługi, aby określić sposób wykonywania obejmujących całą usługę. (Aby określić sposób wykonywania na poziomie metody, należy użyć <xref:System.ServiceModel.OperationBehaviorAttribute> atrybutu.) Ten atrybut może być stosowane tylko do implementacji usługi. Przykłady pracy, zobacz [usługi: Przykłady zachowania](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)).  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości są Windows Communication Foundation (WCF) programowania modelu funkcja, która umożliwia typowe funkcje, które deweloperzy, w przeciwnym razie musiał zostać zaimplementowany. Aby uzyskać więcej informacji na temat tych i innych zachowań, zobacz [Określanie zachowania środowiska uruchomieniowego usługi](~/docs/framework/wcf/specifying-service-run-time-behavior.md). Aby uzyskać więcej informacji na temat podstawowej właściwości środowisko uruchomieniowe niektórych do następującego zestawu właściwości, zobacz [rozszerzanie elementu ServiceHost i warstwy modelu usług](~/docs/framework/wcf/extending/extending-servicehost-and-the-service-model-layer.md).  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> Właściwość określa typ filtr, który system dyspozytora używa do zlokalizowania punktu końcowego, który obsługuje żądania.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> Właściwość automatycznie zamyka sesji, gdy kanał jest zamknięte, a usługa zakończył przetwarzanie wszelkie pozostałe komunikaty.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> Właściwość kontroluje wewnętrznego modelu wątkowości, umożliwiające obsługę usług reentrant lub wielowątkowych.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> Właściwości służy do deklarowania nazwę do użycia w `name` atrybutu `<service>` elementu w pliku konfiguracji.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> Właściwość umożliwia w czasie wykonywania zignorować informacje dodatkowe serializacji, który nie jest wymagane do przetwarzania wiadomości.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> Właściwość określa, czy nieobsługiwanych wyjątków w usłudze są zwracane jako błędach SOAP. Dotyczy to tylko do celów debugowania.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> Właściwość określa, czy i kiedy usług i ich obiektami usługi są będzie wykonywane podczas wymiany przy użyciu klienta.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> Właściwości, aby ograniczyć liczbę elementów w grafu obiektów, które są serializowane.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> i <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> właściwości formantu, nazwę i przestrzeń nazw dla wyrażenia WSDL element usługi.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> Właściwość określa, czy obiekt usługi zostanie odtworzony po zakończeniu transakcji.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> Właściwość określa, czy zaległe transakcje odbywa się po zamknięciu sesji.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> Właściwość określa poziom izolacji transakcji, który obsługuje kontrakt.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> Właściwości określa okres czasu, w którym należy wykonać transakcji lub ją przerwie.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> Właściwość wskazuje, czy automatyczną synchronizację wywołania metody dla ruchu przychodzącego z wątku interfejsu użytkownika.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> Właściwość informuje system, czy go należy się upewnić, że nagłówków protokołu SOAP oznaczone jako `MustUnderstand` w rzeczywistości zrozumiałe.  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> Właściwości można również ustawić za pomocą pliku konfiguracji aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości. `BehaviorService` Klasy używa <xref:System.ServiceModel.ServiceBehaviorAttribute> atrybutu, aby wskazać, że:  
  
-   Obiekt usługi zostanie odtworzony po zakończeniu transakcji.  
  
-   Dla każdej sesji jest jeden obiekt usługi.  
  
-   Usługa jest jednowątkowym i nie obsługuje wywołania współużytkowane.  
  
 Ponadto na poziomie operacji <xref:System.ServiceModel.OperationBehaviorAttribute> wartości wskazują, że `TxWork` metody automatycznie rejestruje przesłanej transakcji lub tworzy nową transakcję, które wykonają tę pracę, a transakcja została zatwierdzona automatycznie Jeśli nieobsługiwany wyjątek nie występuje.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Podstawowe powiązania musi obsługiwać przesłanej transakcji w następującym przykładzie kodu do wykonania prawidłowo. Do obsługi transakcji przesłanej za pomocą <xref:System.ServiceModel.WSHttpBinding>, na przykład ustawić <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> właściwości `true` w kodzie lub w pliku konfiguracji aplikacji. Poniższy przykład kodu pokazuje plik konfiguracyjny dla poprzedniego przykładu.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationBehaviorAttribute" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)">Usługa: Przykład zachowania</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBehaviorAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBehaviorAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceBehaviorAttribute" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości domyślne <xref:System.ServiceModel.ServiceBehaviorAttribute> są:  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> Ustawiono <xref:System.ServiceModel.AddressFilterMode.Exact>.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> Właściwość `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> Ustawiono <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> Właściwość jest nazwą kwalifikowaną przestrzenią nazw, typu bez informacji o zestawie.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> Właściwość `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> Właściwość jest ustawiona na 64 KB.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> Właściwość jest nazwą typu usługi bez informacji o przestrzeni nazw lub zestawu.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> Właściwość "http://tempuri.org".  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> Właściwość `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> jest `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> jest `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> Właściwość `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> Właściwość <xref:System.Transactions.IsolationLevel.Unspecified>.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> Właściwość jest ustawiona na <xref:System.TimeSpan.Zero>.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> Właściwość `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFilterMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AddressFilterMode AddressFilterMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AddressFilterMode AddressFilterMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AddressFilterMode As AddressFilterMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AddressFilterMode AddressFilterMode { System::ServiceModel::AddressFilterMode get(); void set(System::ServiceModel::AddressFilterMode value); };" />
      <MemberSignature Language="F#" Value="member this.AddressFilterMode : System.ServiceModel.AddressFilterMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AddressFilterMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ServiceModel.AddressFilterMode" /> używanego przez Dyspozytor do rozsyłania wiadomości przychodzących do właściwego punktu końcowego.</summary>
        <value><see cref="T:System.ServiceModel.AddressFilterMode" /> Obiekt, który jest używany przez Dyspozytor do rozsyłania wiadomości przychodzących do właściwego punktu końcowego.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.ServiceModel.AddressFilterMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomaticSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticSessionShutdown : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy należy automatycznie Zamknij sesję, gdy klient zamyka sesję danych wyjściowych.</summary>
        <value><see langword="true" /> Jeśli usługi automatycznie Zamknij sesję, gdy klient zamyka sesję danych wyjściowych. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie gdy klient zamyka sesję w danych wyjściowych usługi zostało zakończone, wszelkie pozostałe komunikaty przetwarzania serwera zamyka sesję. Ustawienie <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> do `false` zapobiega automatycznego zamykania sesji serwera i umożliwia kontrolka niestandardowa okresy istnienia sesji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informację, czy usługa obsługuje jeden wątek, wiele wątków lub wywołania współużytkowane.</summary>
        <value>Jedną z <see cref="T:System.ServiceModel.ConcurrencyMode" /> wartości; wartość domyślna to <see cref="F:System.ServiceModel.ConcurrencyMode.Single" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość wskazuje, czy wystąpienie usługi może obsługiwać jeden wątek lub wielu wątków, które są wykonywane jednocześnie, a jeśli jednowątkowe, czy współużytkowania wątkowości jest obsługiwane.  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> Właściwość wchodzi w interakcję z kilkoma innymi ustawieniami. Na przykład jeśli <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> wartość jest równa <xref:System.ServiceModel.InstanceContextMode.Single> wynik jest, że usługa może przetwarzać tylko jeden komunikat w czasie, chyba że jednocześnie ustawiono <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> wartość <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Tej właściwości powoduje również zachowanie w połączeniu z <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> właściwości. Aby uzyskać więcej informacji, zobacz [sesji, Instancing i współbieżności](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Ustawienie <xref:System.ServiceModel.ConcurrencyMode> do <xref:System.ServiceModel.ConcurrencyMode.Single> system ma ograniczenia wystąpień usługi do jeden wątek wykonywania w czasie, dzięki czemu nie musisz o problemy wielowątkowości. Wartość <xref:System.ServiceModel.ConcurrencyMode.Multiple> oznacza, że usługi obiekty mogą być wykonywane przez wiele wątków jednocześnie. W takim przypadku upewnij się, bezpieczeństwo wątkowe.  
  
 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> również ogranicza dostęp do pojedynczego wątku jednocześnie. podczas przetwarzania operacji nie inne komunikaty można wprowadzić operację. Jeśli podczas operacji wywołania do innej usługi, bieżący komunikat traci blokadę operacji, która może przetwarzać inne komunikaty. Gdy usługa wyróżnienia zwraca, ustanowieniu blokady i przetwarzanie jego zawarcia lub dopóki nie wystąpi inne wywołanie poza operacja może zostać wznowione oryginalnej wiadomości.  
  
> [!IMPORTANT]
>  Mimo że <xref:System.ServiceModel.ConcurrencyMode.Single> ogranicza wystąpień usługi na jeden wątek jednocześnie, należy także ustawić <xref:System.ServiceModel.Description.ServiceThrottlingBehavior.MaxConcurrentCalls%2A> 1, aby zagwarantować żadnych komunikatów poza kolejnością.  
>   
>  Ponadto jest Twoim obowiązkiem opuszczenia Twojej stan obiektu spójne przed objaśnienia i musisz potwierdzić, czy dane lokalne operacja jest prawidłowa, po objaśnienia. Należy pamiętać, że wystąpienie usługi jest odblokowana tylko przez za pośrednictwem kanału WCF podczas wywoływania innej usługi. W tym przypadku usługa o nazwie wprowadzić ponownie pierwszej usługi za pośrednictwem wywołania zwrotnego. Jeśli pierwsza usługa nie jest współużytkowane, sekwencja wywołań powoduje zakleszczenia. Aby uzyskać więcej informacji, zobacz <xref:System.ServiceModel.ConcurrencyMode>.  
  
 Podczas każde wychodzące wywołanie operacji przetwarzania można zmodyfikować dane nie lokalne, aby wykonać operację. (Dane o stanie lokalnego jest gwarantowane, jest nieprawidłowy, gdy oryginalnego komunikatu wznawia przetwarzania). W wyniku przed wychodzące wywołanie upewnij się, że danych-local nadaje się do innych wywołań przychodzących i przechowywać dane inną niż lokalna, po powrocie wychodzące wywołanie.  
  
 Poniższy pseudo-kod ilustruje wymaganym wzorcem pomyślne współużytkowane pomocy technicznej.  
  
```csharp  
public void MyMethod()  
{  
  this.SomeNonLocalDataState;  
  // Here you need to clean nonlocal state for other users  
  OutboundProxy proxy = new OutboundProxy();  
  int returnValue = proxy.CallOutOfOperation();  
  // Ensure that this.SomeNonLocalDataState is valid for continued use.  
  this.ModifyNonLocalState;  
  return returnValue;  
}  
  
```  
  
 Za pomocą wzorcu początku/końca wywołania asynchronicznego dla ruchu wychodzącego wywołania, gdy <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> jest <xref:System.ServiceModel.ConcurrencyMode.Reentrant> powoduje wyjątek. Wywołania asynchroniczne wychodzącego wymagają operacją, w którym <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> jest <xref:System.ServiceModel.ConcurrencyMode.Multiple>, w którym to przypadku musi obsługiwać problemów z synchronizacją.  
  
 Ogólnie rzecz biorąc Jeśli wiadomość zostanie odebrana wystąpienia naruszającą jej tryb współbieżności, komunikat czeka do momentu wystąpienia lub dopóki nie upłynie limit czasu.  
  
 Ponadto jeśli <xref:System.ServiceModel.ConcurrencyMode> ustawiono <xref:System.ServiceModel.ConcurrencyMode.Single> i współużytkowane wywołanie jest blokowane podczas oczekiwania na wystąpienie, które ma zostać zwolniony, system wykryje zakleszczenie i zgłasza wyjątek.  
  
> [!NOTE]
>  A <xref:System.InvalidOperationException> jest generowany w czasie wykonywania, jeśli <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> jest `true` podczas <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> właściwość jest ustawiona na <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 Należy pamiętać, że musisz jawnie ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> do `false` w przypadku operacji z <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> równa true, ustaw <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> do <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. W przeciwnym razie jest zgłaszany wyjątek sprawdzania poprawności, ponieważ domyślna wartość <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> jest `true`.  
  
 Brak interakcji z <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> i innych właściwości, które można zmienić zachowania w czasie wykonywania. Aby uzyskać pełny opis tych interakcji, zobacz [sesji, Instancing i współbieżności](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje różne między <xref:System.ServiceModel.ConcurrencyMode.Single>, <xref:System.ServiceModel.ConcurrencyMode.Reentrant>, i <xref:System.ServiceModel.ConcurrencyMode.Multiple>. W tym przykładzie nie kompiluje się bez rzeczywistego wykonania związanych z nim, ale pokazują rodzaj wątkowości gwarantuje, że sprawia, że usługi Windows Communication Foundation (WCF) i co to oznacza dla kodu operacji.  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.ServiceModel.ConcurrencyMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość używaną do lokalizowania element usługi w pliku konfiguracji aplikacji.</summary>
        <value>Wartość do zlokalizowania w pliku konfiguracji. Wartość domyślna to w pełni kwalifikowana nazwa typu bez informacji o zestawie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość umożliwia określenie określonej usługi w pliku konfiguracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest ciągiem pustym.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest zapewniona usługi uporządkowane wysyłania.</summary>
        <value><see langword="true" /> Jeśli usługa uporządkowane wysyłania zapewniony. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public object GetWellKnownSingleton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetWellKnownSingleton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.GetWellKnownSingleton" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWellKnownSingleton () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetWellKnownSingleton();" />
      <MemberSignature Language="F#" Value="member this.GetWellKnownSingleton : unit -&gt; obj" Usage="serviceBehaviorAttribute.GetWellKnownSingleton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt, który implementuje usługę, która jest używana jako pojedyncze wystąpienie usługi lub <see langword="null" /> Jeśli żadne wystąpienie singleton.</summary>
        <returns>Implementacja usługi. Wartość domyślna to <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Innej niż`null` wartość zawiera wystąpienie usługi, do którego będą wysyłane wszystkie komunikaty, które zostały rozwiązane w usłudze.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy wysyłać dane serializacji nieznany podczas transmisji.</summary>
        <value><see langword="true" /> Jeśli nigdy nie są wysyłane dane serializacji nieznany; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ implementuje <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejsu, przechowuje dodatkowe dane nie ma informacji o dostarczanego przez sieć podczas deserializacji do tego typu. Na przykład, jeśli typ `Person` ma elementy członkowskie `FirstName` i `LastName`, oraz nazywany elementem `PhoneNumber` pochodzi, są przechowywane. Podczas dalszej serializacji typu `PhoneNumber` będzie emitowane ponownie. Problem jest schematu dla `Person` wyeksportowany przez, że usługa ma tylko `FirstName` i `LastName`, więc Windows Communication Foundation (WCF) generuje wystąpienie schemat nieprawidłowy! Jeśli ważne jest, ścisłego schematu zgodności, możesz ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> do `true` wyłączyć to zachowanie emitowanie ponownie.  
  
 Niezależnie od tego <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> ustawienie WCF zawsze przetwarza znanych danych (zarówno in i out) i nie zgłasza wyjątków, po przejściu do trybu dodatkowe dane. Można również ustawić tej właściwości przy użyciu [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) elementu w pliku konfiguracji aplikacji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje użycie <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> oraz implementację <xref:System.Runtime.Serialization.IExtensibleDataObject>. W tym przykładzie za pomocą <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> równa `false`, dodatkowe dane, które klient zna jest zwrotnego do klienta.  
  
 [!code-csharp[DCAContainerNoValidation#1](~/samples/snippets/csharp/VS_Snippets_CFX/dcacontainernovalidation/cs/services.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy można przekonwertować na wyjątki ogólne nieobsłużonego <see cref="T:System.ServiceModel.FaultException`1" /> typu <see cref="T:System.ServiceModel.ExceptionDetail" /> i wysyłane jako komunikat o błędzie. Ustaw tę opcję na <see langword="true" /> tylko podczas programowania rozwiązywać problemy z usługą.</summary>
        <value><see langword="true" /> Jeśli nieobsłużone wyjątki, które mają zostać zwrócone jako błędach SOAP; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> do `true` włączyć wyjątek informacje przesyłane do klientów na potrzeby debugowania. Ta właściwość wymaga powiązanie, które obsługuje zarówno żądanie odpowiedź lub dupleks messaging.  
  
 We wszystkich aplikacjach zarządzanych błędy przetwarzania są reprezentowane przez <xref:System.Exception> obiektów. W aplikacjach opartego na protokole SOAP, takich jak aplikacje usługi WCF metody, które implementują operacji usługi komunikują się przy użyciu protokołu SOAP wiadomości błędu informacje o błędzie. Ponieważ aplikacje usługi WCF w ramach obu rodzajów błędów systemów, informacje o zarządzanym wyjątku, który ma zostać wysłane do klienta musi zostać przekonwertowana z wyjątków w błędach SOAP. Aby uzyskać więcej informacji, zobacz [określanie i obsługa błędów w kontraktach i usługach](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).  
  
 Podczas tworzenia aplikacji może być usługi w celu również wysłania innych wyjątków do klienta, aby pomóc w debugowaniu. To jest funkcją tylko do programowania i nie powinny być stosowane w wdrożonych usług.  
  
 W celu ułatwienia tworzenia debugowania, ustaw <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> do `true` w kod lub przy użyciu pliku konfiguracji aplikacji.  
  
 Po włączeniu usługa automatycznie zwraca bezpieczniejsze informacje o wyjątku do obiektu wywołującego. Te błędy są wyświetlane do klienta jako <xref:System.ServiceModel.FaultException%601> obiektów typu <xref:System.ServiceModel.ExceptionDetail>.  
  
> [!IMPORTANT]
>  Ustawienie <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> do `true` umożliwia klientom, aby uzyskać informacje o wewnętrznej usługi wyjątki metody; jest to zalecane tylko jako sposób tymczasowo debugowania aplikacji usługi. Ponadto pliku WSDL dla zarządzanych przy użyciu metody, która zwraca nieobsługiwanych wyjątków w ten sposób nie zawiera kontrakt dla <xref:System.ServiceModel.FaultException%601> typu <xref:System.ServiceModel.ExceptionDetail>. Klienci oczekują, możliwość nieznany błąd protokołu SOAP, aby uzyskać informacje o debugowaniu prawidłowo.  
  
 Ustawienie tej właściwości na `true` można również wykonać przy użyciu pliku konfiguracji aplikacji i [ &lt;serviceDebug&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicedebug.md) elementu, co ilustruje poniższy przykład kodu.  
  
 [!code-xml[OperationBehaviorAttribute1#10](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#10)]   
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości. `BehaviorService` Klasy używa <xref:System.ServiceModel.ServiceBehaviorAttribute> atrybutu, aby wskazać, że:  
  
-   Implementacja metody są wywoływane w wątku interfejsu użytkownika.  
  
-   Dla każdej sesji jest jeden obiekt usługi.  
  
-   Usługa jest jednowątkowym i nie obsługuje wywołania współużytkowane.  
  
 Ponadto na poziomie operacji <xref:System.ServiceModel.OperationBehaviorAttribute> wartości wskazują, że `TxWork` metody automatycznie rejestruje przesłanej transakcji lub tworzy nową transakcję, które wykonają tę pracę, a transakcja została zatwierdzona automatycznie Jeśli nieobsługiwany wyjątek nie występuje.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Podstawowe powiązania musi obsługiwać przesłanej transakcji w następującym przykładzie kodu do wykonania prawidłowo. Do obsługi transakcji przesłanej za pomocą <xref:System.ServiceModel.WSHttpBinding>, na przykład ustawić <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> właściwości `true` w kodzie lub w pliku konfiguracji aplikacji. Poniższy przykład kodu pokazuje plik konfiguracyjny dla poprzedniego przykładu.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContextMode InstanceContextMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.InstanceContextMode InstanceContextMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextMode As InstanceContextMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContextMode InstanceContextMode { System::ServiceModel::InstanceContextMode get(); void set(System::ServiceModel::InstanceContextMode value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextMode : System.ServiceModel.InstanceContextMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContextMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, kiedy są tworzone nowe obiekty usługi.</summary>
        <value>Jedną z <see cref="T:System.ServiceModel.InstanceContextMode" /> wartości; wartość domyślna to <see cref="F:System.ServiceModel.InstanceContextMode.PerSession" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.InstanceContextMode> właściwości w celu określenia, kiedy są tworzone nowe obiekty usługi. Ponieważ obiekt usługi nie jest podłączony bezpośrednio do kanału komunikacji, okres istnienia obiektów usługi jest niezależna od okresu istnienia kanał między klientem i aplikacji usługi. Wartość domyślna to <xref:System.ServiceModel.InstanceContextMode.PerSession>, powoduje, że aplikacja usługi, aby utworzyć nowy obiekt usługi, po nawiązaniu nowej sesji komunikacji między klientem i aplikacji usługi. Kolejne wywołania w tej samej sesji są obsługiwane przez ten sam obiekt.  
  
 <xref:System.ServiceModel.InstanceContextMode.PerSession> Wskazuje, że każdy obiekt usługi obsługuje żądania z kanału jednego klienta.  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> Właściwość wchodzi w interakcję z kilkoma innymi ustawieniami. Na przykład jeśli <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> wartość jest równa <xref:System.ServiceModel.InstanceContextMode.Single> wynik jest, że usługa może przetwarzać tylko jeden komunikat w czasie, chyba że jednocześnie ustawiono <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> wartość <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Tej właściwości powoduje również zachowanie w połączeniu z <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> właściwości. Aby uzyskać więcej informacji, zobacz [sesji, Instancing i współbieżności](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Zachowania okresu istnienia pojedyncze (na przykład w przypadku, gdy aplikacja hosta wywołuje <xref:System.ServiceModel.ServiceHost.%23ctor%2A> Konstruktor i przekazuje obiekt ma być używany jako usługa), należy ustawić klasy usługi <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> do `Single`, lub wyjątek jest generowany w czasie wykonywania.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.ServiceModel.ServiceBehaviorAttribute> właściwości. `BehaviorService` Klasy używa <xref:System.ServiceModel.ServiceBehaviorAttribute> atrybutu, aby wskazać, że:  
  
-   Implementacja metody są wywoływane w wątku interfejsu użytkownika.  
  
-   Dla każdej sesji jest jeden obiekt usługi.  
  
-   Usługa jest jednowątkowym i nie obsługuje wywołania współużytkowane.  
  
 Ponadto na poziomie operacji <xref:System.ServiceModel.OperationBehaviorAttribute> wartości wskazują, że `TxWork` metody automatycznie rejestruje przesłanej transakcji lub tworzy nową transakcję, które wykonają tę pracę, a transakcja została zatwierdzona automatycznie Jeśli nieobsługiwany wyjątek nie występuje.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 Podstawowe powiązania musi obsługiwać przesłanej transakcji w następującym przykładzie kodu do wykonania prawidłowo. Do obsługi transakcji przesłanej za pomocą <xref:System.ServiceModel.WSHttpBinding>, na przykład ustawić <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> właściwości `true` w kodzie lub w pliku konfiguracji aplikacji. Poniższy przykład kodu pokazuje plik konfiguracyjny dla poprzedniego przykładu.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.ServiceModel.InstanceContextMode" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę elementów dozwoloną w Zserializowany obiekt.</summary>
        <value>Maksymalną liczbę elementów dozwoloną w obiekcie. Wartość domyślna to 65 536 bajtów (64KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> właściwość ustawić limit liczby elementów wykresu obiektu, które są serializowane. Można również ustawić tej właściwości przy użyciu [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) elementu w pliku konfiguracji aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość atrybutu nazwy w elemencie usługi w sieci Web Services Description Language (WSDL).</summary>
        <value>Wartość atrybutu name w <see langword="&lt;wsdl:service&gt;" /> elementu podczas eksportowania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość docelowa przestrzeń nazw dla usługi w sieci Web Services Description Language (WSDL).</summary>
        <value>Wartość <see langword="targetNamespace" /> atrybutu dla <see langword="&lt;wsdl:definitions&gt;" /> element, który zawiera <see langword="&lt;wsdl:service&gt;" /> elementu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy obiekt usługi jest wydane po zakończeniu bieżącej transakcji.</summary>
        <value><see langword="true" /> Jeśli obiekt usługi mogą być wprowadzane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że musisz jawnie ustawić <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> do `false` w przypadku operacji z <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> równa true, ustaw <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> do <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. W przeciwnym razie jest zgłaszany wyjątek sprawdzania poprawności, ponieważ domyślna wartość <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> jest `true`.  
  
 Ponadto warto należy pamiętać, że jeśli usługa została utworzona przez przekazanie obiektu usługi, aby <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> konstruktora, wartość tej właściwości jest traktowany tak, jakby była `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia poziom izolacji transakcji <xref:System.Transactions.IsolationLevel.ReadCommitted>, wyłącza obsługę jednoczesnych transakcji, wymaga transakcji z wywołania operacji i zatwierdzeń transakcji usługi automatycznie, jeśli nie, nieobsługiwany wystąpi wyjątek.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 Podstawowe powiązania musi obsługiwać przesłanej transakcji w następującym przykładzie kodu do wykonania prawidłowo. Do obsługi transakcji przesłanej za pomocą <xref:System.ServiceModel.WSHttpBinding>, na przykład ustawić <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> właściwości `true` w kodzie lub w pliku konfiguracji aplikacji. Poniższy przykład kodu pokazuje pliku konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public void SetWellKnownSingleton (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetWellKnownSingleton(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetWellKnownSingleton (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetWellKnownSingleton(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetWellKnownSingleton : obj -&gt; unit" Usage="serviceBehaviorAttribute.SetWellKnownSingleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Pojedyncze wystąpienie usługi.</param>
        <summary>Określa obiekt, który implementuje usługę, która jest używana jako pojedyncze wystąpienie usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zapewnia to wystąpienie usługi, do którego będą wysyłane wszystkie komunikaty, które zostały rozwiązane w usłudze.  
  
 Jeśli <xref:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton%2A> jest ustawiona na innej niż`null` wartości, a następnie <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> musi być równa <xref:System.ServiceModel.InstanceContextMode.Single> lub <xref:System.InvalidOperationException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Podana wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeConfigurationName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeConfigurationName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeConfigurationName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeConfigurationName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeConfigurationName();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeConfigurationName : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeConfigurationName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> właściwość został zmieniony z wartości domyślnej i powinien zostać Zserializowany.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReleaseServiceInstanceOnTransactionComplete () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReleaseServiceInstanceOnTransactionComplete : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> właściwość został zmieniony z wartości domyślnej i powinien zostać Zserializowany.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionAutoCompleteOnSessionClose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionAutoCompleteOnSessionClose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionAutoCompleteOnSessionClose () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionAutoCompleteOnSessionClose();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionAutoCompleteOnSessionClose : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> właściwość został zmieniony z wartości domyślnej i powinien zostać Zserializowany.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionIsolationLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionIsolationLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionIsolationLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionIsolationLevel();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionIsolationLevel : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> właściwość został zmieniony z wartości domyślnej i powinien zostać Zserializowany.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionTimeout">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionTimeout () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionTimeout();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionTimeout : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> właściwość został zmieniony z wartości domyślnej i powinien zostać Zserializowany.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.AddBindingParameters">
      <MemberSignature Language="C#" Value="void IServiceBehavior.AddBindingParameters (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase, class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase, System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ endpoints, System::ServiceModel::Channels::BindingParameterCollection ^ parameters) = System::ServiceModel::Description::IServiceBehavior::AddBindingParameters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
        <Parameter Name="endpoints" Type="System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <param name="description">Opis usługi.</param>
        <param name="serviceHostBase">Host usługi.</param>
        <param name="endpoints">Punkty końcowe usługi.</param>
        <param name="parameters">Obiekty danych potrzebne do obsługi zachowanie wiązania.</param>
        <summary>Przekazuje dane niestandardowe obiekty, do powiązania, które obsługują właściwości zachowania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior">
      <MemberSignature Language="C#" Value="void IServiceBehavior.ApplyDispatchBehavior (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::ApplyDispatchBehavior;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Opis usługi.</param>
        <param name="serviceHostBase">Host usługi.</param>
        <summary>Dostosowuje usługi, w czasie wykonywania, aby obsługiwać właściwości zachowania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.Validate">
      <MemberSignature Language="C#" Value="void IServiceBehavior.Validate (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.Validate(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.Validate(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::Validate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Opis usługi.</param>
        <param name="serviceHostBase">Host usługi.</param>
        <summary>Potwierdza, że opis usługi i hosta usługi mogą obsłużyć zachowanie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy oczekujące transakcje odbywa się podczas bieżącej sesji, który zostanie zamknięty bez błędów.</summary>
        <value><see langword="true" /> Jeśli oczekujące transakcje mają zostać wykonane podczas bieżącej sesji, który zostanie zamknięty bez błędów; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa poziom izolacji transakcji dla nowych transakcji utworzone w usłudze i przekazane transakcje przychodzące z klienta.</summary>
        <value>A <see cref="T:System.Transactions.IsolationLevel" /> wartość, która określa poziom izolacji transakcji. Wartość domyślna to <see cref="F:System.Transactions.IsolationLevel.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom izolacji, w którym przebiegów transakcji określa, jak dane są używane, gdy zostaną wprowadzone zmiany innych transakcji i ile transakcji musi posiadać blokad, aby zapewnić ochronę przed te zmiany. Na przykład, wartość domyślna to <xref:System.Transactions.IsolationLevel.Unspecified>, określa, że nie aktualizowania i wstawiania może wystąpić do czasu ukończenia transakcji.  
  
 Ta właściwość może również służyć do ograniczania izolację stopień przychodzące transakcje przekazane przez klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia poziom izolacji transakcji <xref:System.Transactions.IsolationLevel.ReadCommitted>, nie obsługuje równoczesnych transakcji, wymaga transakcji z wywołania metody i automatycznie zatwierdzeń transakcji, jeśli nie nieobsługiwanego wyjątku.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 Podstawowe powiązania musi obsługiwać przesłanej transakcji w następującym przykładzie kodu do wykonania prawidłowo. Do obsługi transakcji przesłanej za pomocą <xref:System.ServiceModel.WSHttpBinding>, na przykład ustawić <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> właściwości `true` w kodzie lub w pliku konfiguracji aplikacji. Poniższy przykład kodu pokazuje pliku konfiguracji dla poprzedniego przykładu.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość nie jest jednym z <see cref="T:System.Transactions.IsolationLevel" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public string TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionTimeout { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia okres, w którym należy wykonać transakcję.</summary>
        <value>Element <see cref="T:System.TimeSpan" /> obiektu, który reprezentuje czas, w ramach którego transakcje muszą się ukończyć lub automatycznie przerwana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawia tę wartość <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout%2A?displayProperty=nameWithType> właściwości. Można również ustawić tej właściwości przy użyciu [ &lt;serviceTimeouts&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicetimeouts.md) elementu w pliku konfiguracji aplikacji.  
  
   
  
## Examples  
 Następujący plik konfiguracji nie określa limit czasu transakcji trzy minuty.  
  
 [!code-csharp[SBA.TransactionTimeout#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactiontimeout/cs/services.cs#2)]
 [!code-vb[SBA.TransactionTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactiontimeout/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSynchronizationContext">
      <MemberSignature Language="C#" Value="public bool UseSynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSynchronizationContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSynchronizationContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSynchronizationContext : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy ma być umożliwia wybieranie wątkiem wykonywania w bieżącym kontekście synchronizacji.</summary>
        <value><see langword="true" /> Jeśli wszystkie wywołania do usługi, należy uruchomić na wątku określonego przez <see cref="T:System.Threading.SynchronizationContext" />; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do zapewnienia koligacji wątku interfejsu użytkownika, że niektóre aplikacje wymagają. Na przykład aplikacji Windows Forms może zostać zarejestrowana jako pojedynczego obiektu usługi. W tym przypadku wszystkie wywołania do usługi, należy uruchomić na wątku Windows Forms. Przypadek domyślny, w którym <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> ustawiono `true`, synchronizuje wszystkie wywołania Usługa do uruchamiania w wątku przechwytywane z <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy system lub aplikacja wymusza SOAP <see langword="MustUnderstand" /> przetwarzania nagłówka.</summary>
        <value><see langword="true" /> Jeśli system jest przeprowadzenie nagłówek SOAP <see langword="MustUnderstand" /> przetwarzania; w przeciwnym razie <see langword="false" />, co oznacza, że aplikacja wykonuje tego przetwarzania. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> właściwości, aby wyłączyć wymuszone sprawdzanie poprawności nadchodzących nagłówków wiadomości. Podczas wykonywania normalnych nagłówków wiadomości są porównywane <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> właściwości, aby upewnić się, że nadchodzących nagłówki są jawnie obsługiwane przez usługę. Ustaw tę opcję na `false` wyłączenie tego sprawdzenia. Po ustawieniu `false`, aplikacja musi sprawdzać, czy nagłówki oznaczone MustUnderstand = "true" i zwraca błąd, jeśli co najmniej jeden z nich była niezrozumiała. Jest to przydatne, gdy aplikacja powinna akceptować przychodzące wiadomości SOAP (na przykład, gdy przy użyciu wpisanych lub wiadomości bez typu) i wykonywania przetwarzania niestandardowego nagłówka.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
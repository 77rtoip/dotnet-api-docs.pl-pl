<Type Name="ServiceAuthorizationManager" FullName="System.ServiceModel.ServiceAuthorizationManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="507ef7fb282a367be5aaaddbe4806c43a6bf0204" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34316052" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceAuthorizationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceAuthorizationManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceAuthorizationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceAuthorizationManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceAuthorizationManager" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia dostęp autoryzacji sprawdzanie dla operacji usługi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest odpowiedzialny za obliczenia wszystkich zasad (reguł, które definiują, co użytkownik może wykonywać), porównanie zasady do roszczenia, ustawienie klienta powstałe w ten sposób <xref:System.IdentityModel.Policy.AuthorizationContext> do <xref:System.ServiceModel.ServiceSecurityContext>oraz czy zapewnienie decyzję dotyczącą autoryzacji Aby zezwolić lub odmówić dostępu dla operacji usługi danego dla obiekt wywołujący.  
  
 <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> Metoda jest wywoływana przez infrastrukturę programu Windows Communication Foundation (WCF) zawsze podejmowana jest próba uzyskania dostępu do zasobu. Metoda zwraca `true` lub `false` Aby zezwolić lub odmówić dostępu, odpowiednio.  
  
 <xref:System.ServiceModel.ServiceAuthorizationManager> Wchodzi w skład WCF*modelu tożsamości* infrastruktury. Modelu tożsamości umożliwia tworzenie zasad niestandardowych autoryzacji i schematy autoryzacji niestandardowej. Aby uzyskać więcej informacji na temat działania modelu tożsamości, zobacz [Zarządzanie oświadczeniami i autoryzacją za pomocą modelu tożsamości](~/docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md).  
  
## <a name="custom-authorization"></a>Autoryzacja niestandardowa  
 Ta klasa nie wykonuje żadnych autoryzacji i umożliwia użytkownikom dostęp do wszystkich operacji usługi. Aby zapewnić bardziej restrykcyjne autoryzacji, należy utworzyć menedżera, która sprawdza niestandardowych zasad autoryzacji niestandardowej. Aby to zrobić, dziedziczą z tej klasy i zastąpić <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> metody. Określ wystąpienie klasy pochodnej za pośrednictwem <xref:System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthorizationManager%2A> właściwości.  
  
 W <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A>, aplikacja może używać <xref:System.ServiceModel.OperationContext> obiektu do uzyskania dostępu do tożsamości wywołującego (<xref:System.ServiceModel.OperationContext.ServiceSecurityContext%2A>).  
  
 Pobierając <xref:System.ServiceModel.OperationContext.IncomingMessageHeaders%2A> właściwość, która zwraca <xref:System.ServiceModel.Channels.MessageHeaders> obiekt aplikacji można uzyskać dostęp do usługi (<xref:System.ServiceModel.Channels.MessageHeaders.To%2A>), a operacja (<xref:System.ServiceModel.Channels.MessageHeaders.Action%2A>).  
  
 Pobierając <xref:System.ServiceModel.OperationContext.RequestContext%2A> właściwość, która zwraca <xref:System.ServiceModel.Channels.RequestContext> obiekt dostęp komunikat żądania całej aplikacji (<xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A>) i w związku z tym wykonaj decyzję dotyczącą autoryzacji.  
  
 Na przykład zobacz [porady: tworzenie Menedżera autoryzacji niestandardowej dla usługi](~/docs/framework/wcf/extending/how-to-create-a-custom-authorization-manager-for-a-service.md).  
  
 Aby utworzyć zasady niestandardowe autoryzacji, należy zaimplementować <xref:System.IdentityModel.Policy.IAuthorizationPolicy> klasy.  Na przykład zobacz [porady: Tworzenie niestandardowych zasad autoryzacji](~/docs/framework/wcf/extending/how-to-create-a-custom-authorization-policy.md).  
  
 Aby utworzyć niestandardowe oświadczenia, użyj <xref:System.IdentityModel.Claims.Claim> klasy.  Na przykład zobacz [porady: tworzenie oświadczenia niestandardowego](~/docs/framework/wcf/extending/how-to-create-a-custom-claim.md). Aby porównać oświadczenia niestandardowe, należy porównać oświadczenia, jak pokazano w [porady: porównywanie oświadczeń](~/docs/framework/wcf/extending/how-to-compare-claims.md).  
  
 Aby uzyskać więcej informacji, zobacz [autoryzacji niestandardowej](~/docs/framework/wcf/extending/custom-authorization.md).  
  
 Można ustawić typu przy użyciu Menedżera autoryzacji niestandardowej [ &lt;serviceAuthorization&gt; ](~/docs/framework/configure-apps/file-schema/wcf/serviceauthorization-element.md) w pliku konfiguracji aplikacji klienta.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono klasę o nazwie `MyServiceAuthorizationManager` dziedziczący po <xref:System.ServiceModel.ServiceAuthorizationManager> i zastępuje <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> metody.  
  
 [!code-csharp[c_CustomAuthMgr#2](~/samples/snippets/csharp/VS_Snippets_CFX/c_customauthmgr/cs/c_customauthmgr.cs#2)]
 [!code-vb[c_CustomAuthMgr#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_customauthmgr/vb/c_customauthmgr.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Claims.ClaimSet" />
    <altmember cref="T:System.IdentityModel.Claims.Claim" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceAuthorizationManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceAuthorizationManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceAuthorizationManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.ServiceAuthorizationManager" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckAccess">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdzanie autoryzacji dla danej operacji kontekstu i opcjonalne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public virtual bool CheckAccess (System.ServiceModel.OperationContext operationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CheckAccess(class System.ServiceModel.OperationContext operationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceAuthorizationManager.CheckAccess(System.ServiceModel.OperationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CheckAccess(System::ServiceModel::OperationContext ^ operationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="operationContext" Type="System.ServiceModel.OperationContext" />
      </Parameters>
      <Docs>
        <param name="operationContext">
          <see cref="T:System.ServiceModel.OperationContext" />.</param>
        <summary>Sprawdzanie autoryzacji dla kontekstu danej operacji.</summary>
        <returns>
          <see langword="true" /> Jeśli dostęp; w przeciwnym razie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogólnie rzecz biorąc, powinny zastępować aplikacje <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> zamiast tej metody.  
  
 Zastąpienie <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccess%2A> Jeśli aplikacja kojarzy lub wprowadza innego zestawu zasad dla powstałe w ten sposób <xref:System.ServiceModel.ServiceSecurityContext> lub podaj modelu oceny (łańcucha) inne zasady.  
  
 Ta metoda jest odpowiedzialna za wywoływanie <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A>.  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób przesłonięcia tej metody, aby wymusić wymagania dotyczące kontroli dostępu niestandardowych.  
  
 [!code-csharp[c_Federation#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_federation/cs/source.cs#1)]
 [!code-vb[c_Federation#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_federation/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public virtual bool CheckAccess (System.ServiceModel.OperationContext operationContext, ref System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CheckAccess(class System.ServiceModel.OperationContext operationContext, class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceAuthorizationManager.CheckAccess(System.ServiceModel.OperationContext,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CheckAccess(System::ServiceModel::OperationContext ^ operationContext, System::ServiceModel::Channels::Message ^ % message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="operationContext" Type="System.ServiceModel.OperationContext" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="operationContext">
          <see cref="T:System.ServiceModel.OperationContext" />.</param>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> Badane określa autoryzację.</param>
        <summary>Sprawdza autoryzacji dla kontekstu danej operacji, gdy wymagany jest dostęp do wiadomości.</summary>
        <returns>
          <see langword="true" /> Jeśli dostęp; w przeciwnym razie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogólnie rzecz biorąc, powinny zastępować aplikacje <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> zamiast tej metody, które należy używać tylko jeśli decyzję dotyczącą autoryzacji zależy od treści wiadomości. Z powodu problemów z wydajnością Jeśli to możliwe powinien zmiany projektu aplikacji tak, aby decyzję dotyczącą autoryzacji nie wymagają dostępu do treści wiadomości.  
  
 Przesłonić tę metodę, jeśli aplikacja kojarzy lub wprowadza innego zestawu zasad dla powstałe w ten sposób <xref:System.ServiceModel.ServiceSecurityContext> i <xref:System.ServiceModel.Channels.Message> lub podaj modelu oceny (łańcucha) inne zasady.  
  
 Ta metoda jest odpowiedzialna za wywoływanie <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A>.  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób przesłonięcia tej metody, aby wymusić wymaganiom kontroli dostępu niestandardowe, które wymagają dostępu do treści wiadomości.  
  
 [!code-csharp[c_Federation#6](~/samples/snippets/csharp/VS_Snippets_CFX/c_federation/cs/source.cs#6)]
 [!code-vb[c_Federation#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_federation/vb/source.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckAccessCore">
      <MemberSignature Language="C#" Value="protected virtual bool CheckAccessCore (System.ServiceModel.OperationContext operationContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckAccessCore(class System.ServiceModel.OperationContext operationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore(System.ServiceModel.OperationContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckAccessCore(System::ServiceModel::OperationContext ^ operationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="operationContext" Type="System.ServiceModel.OperationContext" />
      </Parameters>
      <Docs>
        <param name="operationContext">
          <see cref="T:System.ServiceModel.OperationContext" /> Dla bieżącego żądania autoryzacji.</param>
        <summary>Sprawdza, czy autoryzacji dla danej operacji kontekstu oparte na ocenie zasady domyślne.</summary>
        <returns>
          <see langword="true" /> Jeśli dostęp; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.OperationContext.ServiceSecurityContext%2A> Ogólnie jest wynik oceny zasad domyślne.  
  
 Przesłonić tę metodę w celu zapewnienia podejmowania decyzji dotyczących autoryzacji niestandardowej.  
  
 Ta metoda może Umożliwia pokazanie autoryzacji, które decyzje oparte na zestawy oświadczeń, które są wywnioskować oparte na przychodzące tokeny lub dodane przy użyciu zasad autoryzacji zewnętrznych. Może również wprowadzać podejmowania decyzji dotyczących autoryzacji na podstawie właściwości wiadomości przychodzącej: na przykład nagłówek akcji.  
  
 W przypadku tej metody można użyć aplikacji `operationContext` parametr, aby uzyskać dostęp do tożsamości wywołującego (<xref:System.ServiceModel.OperationContext.ServiceSecurityContext%2A>). Zwracając <xref:System.ServiceModel.Channels.RequestContext> obiekt z <xref:System.ServiceModel.OperationContext.RequestContext%2A> właściwości komunikatu żądania cały dostęp aplikacji (<xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A>). Zwracając <xref:System.ServiceModel.Channels.MessageHeaders> obiekt z <xref:System.ServiceModel.OperationContext.IncomingMessageHeaders%2A> właściwości, aplikacja może uzyskiwać dostęp do adresu URL usługi (<xref:System.ServiceModel.Channels.MessageHeaders.To%2A>), a operacja (<xref:System.ServiceModel.Channels.MessageHeaders.Action%2A>). Dzięki tym informacjom aplikacji można odpowiednio wykonywać decyzję dotyczącą autoryzacji.  
  
 Oświadczenia wprowadzone przez użytkownika znajdują się w <xref:System.IdentityModel.Claims.ClaimSet> zwrócony przez <xref:System.IdentityModel.Policy.AuthorizationContext.ClaimSets%2A> właściwość `AuthorizationContext`. Bieżący `AuthorizationContext` zwróconego przez <xref:System.ServiceModel.OperationContext.ServiceSecurityContext%2A> właściwość <xref:System.ServiceModel.OperationContext> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia Przesłonięcie elementu <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> metody.  
  
 [!code-csharp[c_CustomAuthMgr#6](~/samples/snippets/csharp/VS_Snippets_CFX/c_customauthmgr/cs/c_customauthmgr.cs#6)]
 [!code-vb[c_CustomAuthMgr#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_customauthmgr/vb/c_customauthmgr.vb#6)]  
  
 Na przykład innego, zobacz [porady: tworzenie Menedżera autoryzacji niestandardowej dla usługi](~/docs/framework/wcf/extending/how-to-create-a-custom-authorization-manager-for-a-service.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAuthorizationPolicies">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Policy.IAuthorizationPolicy&gt; GetAuthorizationPolicies (System.ServiceModel.OperationContext operationContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.Policy.IAuthorizationPolicy&gt; GetAuthorizationPolicies(class System.ServiceModel.OperationContext operationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceAuthorizationManager.GetAuthorizationPolicies(System.ServiceModel.OperationContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::Policy::IAuthorizationPolicy ^&gt; ^ GetAuthorizationPolicies(System::ServiceModel::OperationContext ^ operationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Policy.IAuthorizationPolicy&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="operationContext" Type="System.ServiceModel.OperationContext" />
      </Parameters>
      <Docs>
        <param name="operationContext">
          <see cref="T:System.ServiceModel.OperationContext" /> Bieżącego żądania autoryzacji.</param>
        <summary>Pobiera zestaw zasad, które uczestniczą w oceny zasad.</summary>
        <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> typu <see cref="T:System.IdentityModel.Policy.IAuthorizationPolicy" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja usługi Windows Communication Foundation (WCF) udostępnia domyślny zestaw zasad autoryzacji. Obejmują one podstawowego tokenu, który zawiera poświadczenia, które osoby żądającej i wszystkie pomocnicze tokenów, tokeny transportu i zewnętrznych zasad, jeśli określony.  
  
 Można zastąpić tę implementację i podaj inny zestaw zasad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
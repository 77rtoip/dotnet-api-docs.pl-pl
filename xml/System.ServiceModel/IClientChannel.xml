<Type Name="IClientChannel" FullName="System.ServiceModel.IClientChannel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3af7d0743208b8eba14dd1a1fb7e85ac527f5d5a" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34315313" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IClientChannel : IDisposable, System.ServiceModel.IContextChannel, System.ServiceModel.IExtensibleObject&lt;System.ServiceModel.IContextChannel&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IClientChannel implements class System.IDisposable, class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject, class System.ServiceModel.IContextChannel, class System.ServiceModel.IExtensibleObject`1&lt;class System.ServiceModel.IContextChannel&gt;" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.IClientChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IClientChannel&#xA;Implements IContextChannel, IDisposable, IExtensibleObject(Of IContextChannel)" />
  <TypeSignature Language="C++ CLI" Value="public interface class IClientChannel : IDisposable, System::ServiceModel::IContextChannel, System::ServiceModel::IExtensibleObject&lt;System::ServiceModel::IContextChannel ^&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.IContextChannel</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.IExtensibleObject&lt;System.ServiceModel.IContextChannel&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Definiuje zachowanie żądania wychodzącego i używanych przez aplikacje klienckie kanałów żądanie/odpowiedź.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.IClientChannel> Interfejsu określa operacje obsługiwane przez wszystkie kanały zwrócony przez wywołanie do <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>. Użyj <xref:System.ServiceModel.IClientChannel> metody i właściwości do przeglądania i modyfikowania wychodzących kanałów określonego. [Narzędzie narzędzia metadanych elementu ServiceModel (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) eksportuje zarówno <xref:System.ServiceModel.ClientBase%601> klas i interfejsu kontraktu usługi, tworząc interfejsu kontraktu, który dziedziczy z obu kontrakt usługi docelowej i <xref:System.ServiceModel.IClientChannel>, Włączanie używanie rozszerzonych kontraktu jako proxy do usługi oraz dostęp do kanału klienta.  
  
 Aby uzyskać więcej informacji, zobacz [Architektura klienta WCF](~/docs/framework/wcf/feature-details/client-architecture.md). Przykłady jego wyglądu w plikach kodu wygenerowanego klienta można znaleźć [opis wygenerowany kod klienta](~/docs/framework/wcf/feature-details/understanding-generated-client-code.md).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AllowInitializationUI">
      <MemberSignature Language="C#" Value="public bool AllowInitializationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowInitializationUI" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.IClientChannel.AllowInitializationUI" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowInitializationUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowInitializationUI { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="M:System.ServiceModel.IClientChannel.DisplayInitializationUI" /> próby wywołania <see cref="T:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer" /> obiekty w <see cref="P:System.ServiceModel.Dispatcher.ClientRuntime.InteractiveChannelInitializers" /> właściwości lub zgłasza, jeśli w tej kolekcji nie jest pusty.</summary>
        <value>
          <see langword="true" /> Jeśli Windows Communication Foundation (WCF) może wywołać interakcyjne kanału inicjatory; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę wartość na `false` Aby zgłosić wyjątek, zamiast wyświetlania okna dialogowego inicjowania. Jest to przydatne w przypadku scenariusza warstwy środkowej, w którym chcesz zagwarantować, nawet jeśli aplikacja jest skonfigurowana do wyświetlania jednego pojawi się okno nie. Aby uzyskać więcej informacji, zobacz [dostęp do usług za pomocą klienta WCF](~/docs/framework/wcf/feature-details/accessing-services-using-a-client.md) i <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginDisplayInitializationUI">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisplayInitializationUI (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginDisplayInitializationUI(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.IClientChannel.BeginDisplayInitializationUI(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisplayInitializationUI (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisplayInitializationUI(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda, która jest wywoływana po zakończeniu tej metody.</param>
        <param name="state">Informacje o stanie kanału.</param>
        <summary>Wywołanie asynchroniczne, aby rozpocząć korzystanie z interfejsu użytkownika można uzyskać informacji o poświadczeniach.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Można użyć do wywołania po zakończeniu przetwarzania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby spowodować, że wszystkie inicjacji kanału interakcyjne (na przykład wyboru karty CardSpace) występuje. Jest to wykonywane automatycznie, gdy kanał jest używane bez jawnie podczas wywoływania <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType>, więc dla wielu aplikacji to wywołanie jest opcjonalne.  
  
 Jednak użytkownik zajmuje dużo czasu, w procesie wyboru, operację, która automatycznie wywołuje ten może upłynął limit czasu. Aby tego uniknąć, należy wywołać <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A> lub <xref:System.ServiceModel.IClientChannel.BeginDisplayInitializationUI%2A> i <xref:System.ServiceModel.IClientChannel.EndDisplayInitializationUI%2A> jawnie. Te operacje nie wygasają i pozwala na kontrolowanie dokładnie gdzie w aplikacji to okno dialogowe pojawia się.  
  
 Ta metoda wywołuje okno dialogowe tylko jeśli aplikacja jest skonfigurowana w tym celu. Gdy aplikacja nie jest skonfigurowany do używania CardSpace lub inny kanał interaktywnego inicjatora, to wywołanie zwraca bez żadnych działań.  
  
 Jawnie wywołać tę metodę należy otworzyć również jawnie kanału przed jego użyciem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidInteractiveInitialization">
      <MemberSignature Language="C#" Value="public bool DidInteractiveInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DidInteractiveInitialization" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.IClientChannel.DidInteractiveInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DidInteractiveInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DidInteractiveInitialization { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy Wykonano wywołanie do interfejsu użytkownika można uzyskać informacji o poświadczeniach.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="M:System.ServiceModel.IClientChannel.DisplayInitializationUI" /> wywołano metodę (lub <see cref="M:System.ServiceModel.IClientChannel.BeginDisplayInitializationUI(System.AsyncCallback,System.Object)" /> i <see cref="M:System.ServiceModel.IClientChannel.EndDisplayInitializationUI(System.IAsyncResult)" /> metod; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli działania są nazywane na <xref:System.ServiceModel.IClientChannel> bez wywoływania elementu <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A> i <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType>, te metody są nazywane automatycznie. Aby uzyskać więcej informacji, zobacz [dostęp do usług za pomocą klienta WCF](~/docs/framework/wcf/feature-details/accessing-services-using-a-client.md) i <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayInitializationUI">
      <MemberSignature Language="C#" Value="public void DisplayInitializationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisplayInitializationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.IClientChannel.DisplayInitializationUI" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisplayInitializationUI ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisplayInitializationUI();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołanie interfejsu użytkownika można uzyskać informacji o poświadczeniach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby spowodować, że wszystkie inicjacji kanału interakcyjne (na przykład wyboru karty CardSpace) występuje. Jest to wykonywane automatycznie, gdy kanał jest używane bez jawnie podczas wywoływania <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType>, więc dla wielu aplikacji to wywołanie jest opcjonalne.  
  
 Jednak użytkownik zajmuje dużo czasu, w procesie wyboru, operację, która automatycznie wywołuje ten może upłynął limit czasu. Aby tego uniknąć, należy wywołać <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A> lub <xref:System.ServiceModel.IClientChannel.BeginDisplayInitializationUI%2A> i <xref:System.ServiceModel.IClientChannel.EndDisplayInitializationUI%2A> jawnie. Te operacje nie wygasają i pozwala na kontrolowanie dokładnie gdzie w aplikacji to okno dialogowe pojawia się.  
  
 Ta metoda wywołuje okno dialogowe tylko jeśli aplikacja jest skonfigurowana w tym celu. Gdy aplikacja nie jest skonfigurowany do używania CardSpace lub inny kanał interaktywnego inicjatora, to wywołanie zwraca bez żadnych działań.  
  
 Jawnie wywołać tę metodę należy otworzyć również jawnie kanału przed jego użyciem.  
  
 Aby uzyskać więcej informacji, zobacz [dostęp do usług za pomocą klienta WCF](~/docs/framework/wcf/feature-details/accessing-services-using-a-client.md) i <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndDisplayInitializationUI">
      <MemberSignature Language="C#" Value="public void EndDisplayInitializationUI (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndDisplayInitializationUI(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.IClientChannel.EndDisplayInitializationUI(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisplayInitializationUI (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisplayInitializationUI(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />.</param>
        <summary>Wywoływane, gdy wywołanie <see cref="M:System.ServiceModel.IClientChannel.BeginDisplayInitializationUI(System.AsyncCallback,System.Object)" /> zostało zakończone.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnknownMessageReceived">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.ServiceModel.UnknownMessageReceivedEventArgs&gt; UnknownMessageReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.ServiceModel.UnknownMessageReceivedEventArgs&gt; UnknownMessageReceived" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.IClientChannel.UnknownMessageReceived" />
      <MemberSignature Language="VB.NET" Value="Event UnknownMessageReceived As EventHandler(Of UnknownMessageReceivedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::ServiceModel::UnknownMessageReceivedEventArgs ^&gt; ^ UnknownMessageReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.ServiceModel.UnknownMessageReceivedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To jest zdarzenie zastrzeżone.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Via">
      <MemberSignature Language="C#" Value="public Uri Via { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Via" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.IClientChannel.Via" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Via As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Via { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator URI zawierający adres transportu, do którego są wysyłane w kanale klienta.</summary>
        <value>
          <see cref="T:System.Uri" /> Zawierający adres transportu, do którego są wysyłane w kanale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.EndpointAddress> Służy jako docelowy ultimate i adresu fizycznego, jeśli <xref:System.ServiceModel.IClientChannel.Via%2A> nie jest określona. Jeśli <xref:System.ServiceModel.IClientChannel.Via%2A> zostanie określony, to rzeczywisty adres fizyczny jest wysyłany komunikat, a za pomocą którego wiadomości musi przejść do osiągnięcia miejsca docelowego. Tę wartość można ustawić z pliku konfiguracji przy użyciu <xref:System.ServiceModel.Description.ClientViaBehavior?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
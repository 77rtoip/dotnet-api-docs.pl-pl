<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a0eb37d6ae2f638490e9eacbee37ac609774ad2e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69385703" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Umożliwia ASP.NET Odczytywanie wartości HTTP wysyłanych przez klienta w trakcie żądania sieci Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody i <xref:System.Web.HttpRequest> właściwości klasy są udostępniane `Request` za pomocą <xref:System.Web.HttpApplication> <xref:System.Web.HttpContext> <xref:System.Web.UI.UserControl> właściwości klasy,, i. <xref:System.Web.UI.Page>  
  
 Aby uzyskać dostęp do danych <xref:System.Web.HttpRequest.QueryString%2A>z <xref:System.Web.HttpRequest.Form%2A>kolekcji <xref:System.Web.HttpRequest.Cookies%2A>,, <xref:System.Web.HttpRequest.ServerVariables%2A> lub, można napisać `Request["key"]`, jak pokazano w przykładzie <xref:System.Web.HttpRequest.QueryString%2A> właściwości.  
  
> [!NOTE]
>  Obsługa standardu <xref:System.Web.HttpRequest> Unicode dla elementów członkowskich klasy wymaga usług IIS w wersji 6,0 lub nowszej.  
  
   
  
## Examples  
 Poniższe przykłady uzyskują dostęp <xref:System.Web.HttpRequest> do wystąpienia dla bieżącego żądania przy <xref:System.Web.UI.Page.Request%2A> użyciu właściwości <xref:System.Web.UI.Page> klasy.  
  
 Można użyć uproszczonej składni do uzyskiwania dostępu do danych <xref:System.Web.HttpRequest.QueryString%2A>z <xref:System.Web.HttpRequest.Form%2A>kolekcji <xref:System.Web.HttpRequest.Cookies%2A>,, <xref:System.Web.HttpRequest.ServerVariables%2A> , lub. Możesz pisać `Request["key"]`.  
  
 Pierwszy przykład pokazuje, jak pobrać wartość ciągu zapytania podczas ładowania strony.  
  
```csharp  
public partial class AddToCart : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        string rawId = Request["ProductID"];  
        int productId;  
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))  
        {  
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())  
            {  
                usersShoppingCart.AddToCart(productId);  
            }  
        }  
        else  
        {  
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");  
        }  
        Response.Redirect("ShoppingCart.aspx");  
    }  
}  
```  
  
```vb  
Public Class AddToCart  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        Dim rawId = Request("ProductID")  
        Dim productId As Integer  
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then  
            Using usersShoppingCart As New ShoppingCartActions()  
                usersShoppingCart.AddToCart(productId)  
            End Using  
  
        Else  
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")  
        End If  
        Response.Redirect("ShoppingCart.aspx")  
    End Sub  
End Class  
```  
  
 W następnym przykładzie pokazano, jak sprawdzić, czy żądanie jest uwierzytelnione i pobrać nieprzetworzony adres URL.  
  
```csharp  
public partial class RestrictedPage : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        if (!Request.IsAuthenticated)  
        {  
            var rawUrl = Request.RawUrl;  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));  
        }  
    }  
}  
```  
  
```vb  
Public Class RestrictedPage  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        If Not Request.IsAuthenticated Then  
            Dim rawUrl = Request.RawUrl  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))  
        End If  
    End Sub  
End Class  
```  
  
 Projekt witryny sieci Web programu Visual Studio z kodem źródłowym jest dostępny do załączenia do tego tematu: [Pobierz](https://go.microsoft.com/fwlink/?LinkID=191455).  
  
 Ten przykład używa klasy <xref:System.IO.StreamWriter> , aby zapisać wartości kilku <xref:System.Web.HttpRequest> właściwości klasy do pliku. Dla właściwości typu String wartości są kodowane w formacie HTML, ponieważ są zapisywane w pliku. Właściwości reprezentujące kolekcję są załączone w pętli, a każda para klucz/wartość, która zawiera, jest zapisywana w pliku.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe akceptujące dane wejściowe użytkownika, które jest potencjalnym zagrożeniem bezpieczeństwa. Domyślnie strony sieci Web ASP.NET sprawdzają, czy dane wejściowe użytkownika nie obejmują elementów skryptu ani HTML. Aby uzyskać więcej informacji, zobacz [Omówienie luk](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)w zabezpieczeniach.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filename As String, url As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpRequest(System::String ^ filename, System::String ^ url, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpRequest : string * string * string -&gt; System.Web.HttpRequest" Usage="new System.Web.HttpRequest (filename, url, queryString)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku skojarzonego z żądaniem.</param>
        <param name="url">Informacje dotyczące adresu URL bieżącego żądania.</param>
        <param name="queryString">Cały ciąg zapytania wysyłany wraz z żądaniem (wszystko jest wykonywane po <c>"?"</c>).</param>
        <summary><see cref="T:System.Web.HttpRequest" /> Inicjuje obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie trzeba tworzyć własnego wystąpienia <xref:System.Web.HttpRequest> klasy. Metody i <xref:System.Web.HttpRequest> właściwości klasy są udostępniane `Request` przez właściwość <xref:System.Web.HttpApplication>klasy, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, i <xref:System.Web.UI.UserControl> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza zakończenie bazowego połączenia TCP, co powoduje niepowodzenie operacji we/wy. Ta metoda może być używana w odpowiedzi na atak złośliwego klienta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest bezpieczna wątkowo. Dowolny wątek może wywoływać go w dowolnym momencie.  
  
 Tej metody można używać tylko w trybie zintegrowanym. Jeśli wywołasz ją w trybie klasycznym, zostanie zgłoszony wyjątek. Aby określić tryb potokowy, użyj <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Web.HttpRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tablicę ciągów typów akceptowania MIME obsługiwanych przez klienta.</summary>
        <value>Tablica ciągów typów akceptowanych MIME obsługiwanych przez klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu przechwytuje wiele wartości zwracanych przez <xref:System.Web.HttpRequest.AcceptTypes%2A> właściwość do zmiennej obiektu i zapisuje liczbę i nazwę każdej wartości w osobnym wierszu wyjścia http.  
  
 [!code-csharp[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AnonymousID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AnonymousID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AnonymousID : string" Usage="System.Web.HttpRequest.AnonymousID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator anonimowy dla użytkownika, jeśli jest obecny.</summary>
        <value>Ciąg reprezentujący bieżący identyfikator użytkownika anonimowego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość przypisuje unikatowy identyfikator o długim okresie ważności do nieuwierzytelnionego użytkownika, który może służyć do śledzenia użytkownika lub przypisywania właściwości profilu do tego użytkownika bez zapisywania danych `Session` w obiekcie. <xref:System.Web.HttpRequest.AnonymousID%2A> Domyślnie <xref:System.Web.HttpRequest.AnonymousID%2A> właściwość jest śledzona przy użyciu pliku cookie, ale można ją ustawić, aby użyć identyfikatora URI, <xref:System.Web.Configuration.SessionStateSection.Cookieless%2A> gdy atrybut w sekcji Konfiguracja identyfikacji anonimowej <xref:System.Web.HttpCookieMode.UseUri>jest ustawiony na, lub <xref:System.Web.HttpCookieMode.AutoDetect> <xref:System.Web.HttpCookieMode.UseDeviceProfile> wartościami. Należy jawnie wyczyścić plik cookie, jeśli nie ma już dostępu do niego, na przykład podczas uwierzytelniania użytkownika anonimowego.  
  
 Identyfikacja anonimowa jest używana, gdy istnieje potrzeba zidentyfikowania jednostek, które nie są uwierzytelniane i gdy wymagane jest autoryzacja. Aby uzyskać więcej informacji, zobacz [anonymousIdentification element (Schemat ustawień ASP.NET)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100))  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Web.HttpRequest.AnonymousID%2A> jak używać właściwości przez <xref:System.Web.Security.AnonymousIdentificationModule.Creating> obsługę zdarzenia w pliku Global. asax. Ten przykład ma dwie części:  
  
-   Metoda w pliku Global. asax, która obsługuje <xref:System.Web.Security.AnonymousIdentificationModule.Creating> zdarzenie.  
  
-   Strona formularzy sieci Web.  
  
 Pierwsza część przykładu kodu pokazuje, jak ustawić <xref:System.Web.HttpRequest.AnonymousID%2A> Właściwość przez <xref:System.Web.Security.AnonymousIdentificationModule.Creating> obsługę zdarzenia w pliku Global. asax. Metoda o nazwie `AnonymousIdentification_Creating` <xref:System.Web.HttpRequest.AnonymousID%2A> ustawia właściwość podczas tworzenia anonimowego identyfikatora.  
  
 [!code-csharp[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]  
  
 Druga część przykładu kodu pokazuje, jak wyświetlić nowy <xref:System.Web.HttpRequest.AnonymousID%2A> , który jest tworzony `AnonymousIdentification_Creating` przez program obsługi zdarzeń w poprzednim przykładzie.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.IsAuthenticated" />
        <altmember cref="E:System.Web.Security.AnonymousIdentificationModule.Creating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100)">anonymousIdentification, element (Schemat ustawień ASP.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationPath : string" Usage="System.Web.HttpRequest.ApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę katalogu głównego aplikacji ASP.NET na serwerze.</summary>
        <value>Ścieżka wirtualna bieżącej aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do konstruowania adresu URL względem katalogu głównego aplikacji ze strony lub kontrolki użytkownika sieci Web, która nie znajduje się w katalogu głównym. Pozwala to na stron i kontrolki udostępnione, które istnieją na różnych poziomach struktury katalogów, aby używać tego samego kodu do łączenia się z zasobami w stałych lokalizacjach w aplikacji.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.IO.StreamWriter.Write%2A> metodę do kodowania HTML, a następnie zapisuje wartość <xref:System.Web.HttpRequest.ApplicationPath%2A> właściwości do pliku tekstowego. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy. Zakłada istnienie <xref:System.IO.StreamWriter> obiektu o nazwie `sw`.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 W poniższym przykładzie użyta <xref:System.Web.HttpRequest.ApplicationPath%2A> jest właściwość w celu programistycznego skonstruowania ścieżki do zasobu, który znajduje się w stałej lokalizacji w aplikacji. Strona, która odwołuje się do zasobu, nie musi znajdować się w tym samym katalogu co zasób.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]  
  
 Jeśli ten przykład zostanie uruchomiony w aplikacji sieci Web o nazwie WebSite1, `/WebSite1` będzie ona wyświetlana jako wartość <xref:System.Web.HttpRequest.ApplicationPath%2A> właściwości i `/WebSite1/images/Image1.gif` będzie wyświetlana jako pełna ścieżka obrazu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppRelativeCurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeCurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeCurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę wirtualną katalogu głównego aplikacji i ustawia ją jako względną przy użyciu notacji tyldy (\~) dla katalogu głównego aplikacji (jak w "\~/Page.aspx").</summary>
        <value>Wirtualna ścieżka katalogu głównego aplikacji dla bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej właściwości, aby podać informacje o adresie URL, które pozostaną takie same, nawet jeśli aplikacja zmieni lokalizację. Pozwala to na użycie tego samego kodu mapowania adresów URL w środowisku testowym i w końcowym środowisku wdrażania lub do użycia przez kopie aplikacji sieci Web w różnych domenach.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> właściwości, aby ustawić adres URL <xref:System.Web.UI.WebControls.Image> kontrolki na obraz w tym samym katalogu, w którym znajduje się Strona. Uruchom Tę stronę na różnych poziomach struktury katalogów, aby wyświetlić wyniki <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> wartości właściwości.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]  
  
 Poniższy przykład używa <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> właściwości, aby programowo ustawić ścieżkę do zasobu na podstawie bieżącej ścieżki strony.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinaryRead (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ BinaryRead(int count);" />
      <MemberSignature Language="F#" Value="member this.BinaryRead : int -&gt; byte[]" Usage="httpRequest.BinaryRead count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Liczba bajtów do odczytania.</param>
        <summary>Wykonuje odczyt binarny z określonej liczby bajtów z bieżącego strumienia wejściowego.</summary>
        <returns>Tablica bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta <xref:System.Web.HttpRequest.BinaryRead%2A> Metoda zapewnia zgodność z ASP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest równa 0.  
  
—lub— 
 <paramref name="count" />jest większa niż liczba dostępnych bajtów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberSignature Language="VB.NET" Value="Public Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); void set(System::Web::HttpBrowserCapabilities ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities with get, set" Usage="System.Web.HttpRequest.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o możliwościach przeglądarki żądającej klienta.</summary>
        <value><see cref="T:System.Web.HttpBrowserCapabilities" /> Obiekt zawierający listę możliwości przeglądarki klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wysyła listę możliwości przeglądarki z powrotem do klienta na stronie HTML.  
  
 [!code-csharp[Classic HttpRequest.Browser Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">Kontrolki serwera ASP.NET i możliwości przeglądarki</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificate As HttpClientCertificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpClientCertificate ^ ClientCertificate { System::Web::HttpClientCertificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificate : System.Web.HttpClientCertificate" Usage="System.Web.HttpRequest.ClientCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera certyfikat zabezpieczeń klienta bieżącego żądania.</summary>
        <value><see cref="T:System.Web.HttpClientCertificate" /> Obiekt zawierający informacje o ustawieniach certyfikatu zabezpieczeń klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wysyła Ustawienia certyfikatu klienta z powrotem do klienta na stronie HTML.  
  
 [!code-csharp[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zestaw znaków treści jednostki.</summary>
        <value><see cref="T:System.Text.Encoding" /> Obiekt reprezentujący zestaw znaków klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne kodowanie zawartości można określić w [elemencie globalizacji (Schemat ustawień ASP.NET)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) pliku konfiguracji. Jeśli kodowanie zawartości jest również określone przez klienta, domyślne ustawienia konfiguracji są zastępowane.  
  
   
  
## Examples  
 Poniższy przykład kodu przypisuje wartość reprezentującą Opis bieżącego kodowania HTTP do zmiennej ciągu.  
  
 [!code-csharp[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContentLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int" Usage="System.Web.HttpRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa długość (w bajtach) zawartości wysyłanej przez klienta.</summary>
        <value>Długość (w bajtach) zawartości wysyłanej przez klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu przypisuje wartość reprezentującą długość zawartości żądania przychodzącego do zmiennej całkowitej.  
  
 [!code-csharp[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ zawartości MIME żądania przychodzącego.</summary>
        <value>Ciąg reprezentujący typ zawartości MIME żądania przychodzącego, na przykład "text/html". Dodatkowe popularne typy MIME to "audio. wav", "Image/GIF" i "Application/PDF".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu przypisuje wartość reprezentującą typ zawartości żądania przychodzącego do zmiennej ciągu.  
  
 [!code-csharp[Classic HttpRequest.ContentType Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]  
  
 W poniższym przykładzie przedstawiono dane wyjściowe, które mogą zostać utworzone przez ten kod.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję plików cookie wysyłanych przez klienta.</summary>
        <value><see cref="T:System.Web.HttpCookieCollection" /> Obiekt reprezentujący zmienne plików cookie klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET obejmuje dwie wewnętrzne kolekcje plików cookie. Kolekcja dostępna za pomocą <xref:System.Web.HttpRequest.Cookies%2A> <xref:System.Web.HttpRequest> kolekcji zawiera pliki cookie przesłane przez klienta `Cookie` do serwera w nagłówku. Kolekcja dostępna za pomocą <xref:System.Web.HttpResponse.Cookies%2A> <xref:System.Web.HttpResponse> kolekcji zawiera nowe pliki cookie utworzone na serwerze i przesłane `Set-Cookie` do klienta w nagłówku programu.  
  
> [!NOTE]
>  Po dodaniu pliku cookie przy użyciu <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> kolekcji plik cookie jest natychmiast dostępny <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> w kolekcji, nawet jeśli odpowiedź nie została wysłana do klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu prowadzi pętlę przez wszystkie pliki cookie wysyłane przez klienta i wysyła nazwę, datę wygaśnięcia, parametr zabezpieczeń i wartości każdego pliku cookie do danych wyjściowych HTTP.  
  
 [!code-csharp[Classic HttpRequest.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę wirtualną bieżącego żądania.</summary>
        <value>Ścieżka wirtualna bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A>zwraca ścieżkę pliku do procedury obsługi aktualnie wykonywanej strony. W przypadku scenariuszy przekierowywania <xref:System.Web.HttpServerUtility.Transfer%2A> przy użyciu <xref:System.Web.HttpServerUtility.Execute%2A> <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> metod i oznacza to, że właściwość zwraca ścieżkę do strony przekierowanej do (strona podrzędna). Jednak gdy klient zostanie przekierowany do innej strony, <xref:System.Web.HttpRequest.FilePath%2A> Właściwość zwraca ścieżkę do oryginalnej strony.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpUtility.HtmlEncode%2A> metody do języka HTML — kodowanie wartości <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metody w celu zapisania zakodowanej wartości do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="M:System.Web.HttpServerUtility.Execute(System.String)" />
        <altmember cref="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePathExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePathExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePathExtension : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozszerzenie nazwy pliku, który jest określony we <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> właściwości.</summary>
        <value>Rozszerzenie nazwy pliku, który jest określony we <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> właściwości.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilePath : string" Usage="System.Web.HttpRequest.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę wirtualną bieżącego żądania.</summary>
        <value>Ścieżka wirtualna bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.FilePath%2A> Właściwość nie<xref:System.Web.HttpRequest.PathInfo%2A> zawiera przyczepy. Na przykład dla adresu URL `http://www.contoso.com/virdir/page.html/tail` <xref:System.Web.HttpRequest.FilePath%2A> wartość jest/virdir/page.html.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpUtility.HtmlEncode%2A> metody do języka HTML — kodowanie wartości <xref:System.Web.HttpRequest.FilePath%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metody w celu zapisania zakodowanej wartości do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Files As HttpFileCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpFileCollection ^ Files { System::Web::HttpFileCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Files : System.Web.HttpFileCollection" Usage="System.Web.HttpRequest.Files" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję plików przekazanych przez klienta w wieloczęściowym formacie MIME.</summary>
        <value><see cref="T:System.Web.HttpFileCollection" /> Obiekt reprezentujący kolekcję plików przekazanych przez klienta. Elementy <see cref="T:System.Web.HttpFileCollection" /> obiektu są typu <see cref="T:System.Web.HttpPostedFile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja plików jest wypełniana tylko wtedy, gdy wartość `Content-Type` żądania HTTP to "wieloczęściowa/formularz-dane".  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla nazwy wszystkich plików w <xref:System.Web.HttpRequest.Files%2A> kolekcji.  
  
 [!code-csharp[Classic HttpRequest.Files Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpRequest.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia filtr do użycia podczas odczytywania bieżącego strumienia wejściowego.</summary>
        <value><see cref="T:System.IO.Stream" /> Obiekt, który ma być używany jako filtr.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy dwie nowe klasy `QQQ1` i `QQQ2` filtruje <xref:System.Web.HttpRequest.InputStream%2A>. Umieść klasy w pliku Global. asax w katalogu aplikacji ASP.NET, tak aby wszystkie dane wejściowe dla wszystkich ASP.NETych stron sieci Web w aplikacji zostały przefiltrowane.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Filter#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Filter#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Określona <see cref="T:System.IO.Stream" /> wartość jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Form { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zmiennych formularza.</summary>
        <value><see cref="T:System.Collections.Specialized.NameValueCollection" /> Reprezentujący kolekcję zmiennych formularza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest wypełniana, gdy wartość żądania `Content-Type` http to "application/x-www-form-urlencoded" lub "wieloczęściowa/form-Data". <xref:System.Web.HttpRequest.Form%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak odczytać wartości z kolekcji formularzy ogłoszonej w przeglądarce. Każda para nazwa/wartość w kolekcji reprezentuje kontrolkę w postaci i jej wartość.  
  
 [!code-csharp[Classic HttpRequest.Form Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferedInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferedInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferedInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferedInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.IO.Stream" /> Pobiera obiekt, który może służyć do odczytywania przychodzącej treści jednostki http.</summary>
        <returns><see cref="T:System.IO.Stream" /> Obiekt, który może służyć do odczytywania przychodzącej treści jednostki http.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest identyczna <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> z, z tą różnicą, że kopiuje także bajty, które są odczytywane do magazynu wewnętrznego, który <xref:System.Web.HttpRequest.Form%2A>jest używany przez <xref:System.Web.HttpRequest.InputStream%2A> ASP.NET do wypełnienia właściwości, <xref:System.Web.HttpRequest.Files%2A>i. Ponieważ te informacje są zachowywane, kod podrzędny, taki jak ASP.NET strony formularzy sieci Web (pliki aspx), zostanie uruchomiony pomyślnie. Nie jest to przypadek z <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> metodą.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Treść jednostki żądania została już załadowana i przeanalizowana. Przykłady właściwości, które powodują załadowanie i przeanalizowanie treści jednostki, obejmują następujące elementy: 
<see cref="P:System.Web.HttpRequest.Form" /> -Właściwość.  
  
<see cref="P:System.Web.HttpRequest.Files" /> -Właściwość.  
  
<see cref="P:System.Web.HttpRequest.InputStream" /> -Właściwość.  
  
<see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" /> -Metoda.  
  
Aby uniknąć tego wyjątku, najpierw Wywołaj <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> metodę. Ten wyjątek jest również zgłaszany, jeśli klient rozłącza się podczas odczytywania treści jednostki.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBufferlessInputStream">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.Stream" /> Pobiera obiekt, który może służyć do odczytywania przychodzącej treści jednostki http.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.IO.Stream" /> Pobiera obiekt, który może służyć do odczytywania przychodzącej treści jednostki http.</summary>
        <returns><see cref="T:System.IO.Stream" /> Obiekt, który może służyć do odczytywania przychodzącej treści jednostki http.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia alternatywę dla użycia <xref:System.Web.HttpRequest.InputStream%2A> właściwości. Właściwość czeka na odebranie całego żądania przed <xref:System.IO.Stream> zwróceniem obiektu. <xref:System.Web.HttpRequest.InputStream%2A> Z kolei <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> Metoda <xref:System.IO.Stream> zwraca obiekt natychmiast. Możesz użyć metody, aby rozpocząć przetwarzanie treści jednostki przed odebraniem pełnej zawartości treści.  
  
 Treść jednostki (lub tyle, ile jest to żądanie i zostało odebrane), jest zwracana tylko wtedy, gdy używasz obiektu, który jest zwracany przez tę metodę w celu odczytu strumienia, wywołując metody, takie jak <xref:System.IO.Stream.Read%2A> Metoda. Użyj parametrów metody, <xref:System.IO.Stream.Read%2A> aby określić, jaka część treści jednostki ma zostać odczytana.  
  
 <xref:System.IO.Stream> Obiekt zwrócony przez ASP.NET z tej metody obsługuje metody odczytu synchronicznego i asynchronicznego. Obiekt implementuje obie metody <xref:System.IO.Stream.EndRead%2A>i. <xref:System.IO.Stream.BeginRead%2A> <xref:System.IO.Stream> Metody asynchroniczne umożliwiają asynchroniczne odczytywanie jednostki żądania w fragmentach, podczas gdy ASP.NET uwalnia bieżący wątek między każdą iteracją asynchronicznej pętli odczytu.  
  
 Ta metoda może być przydatna, jeśli żądanie przekazuje duży plik i chcesz rozpocząć uzyskiwanie dostępu do zawartości pliku przed zakończeniem przekazywania. Tej metody należy jednak używać tylko w scenariuszach, w których należy przejmowanie całego przetwarzania treści jednostki. Oznacza to, że nie można użyć tej metody ze strony. aspx, ponieważ przez czas uruchomienia strony. aspx, treść jednostki została już odczytana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Treść jednostki żądania została już załadowana i przeanalizowana. Przykłady właściwości, które powodują załadowanie i przeanalizowanie treści jednostki, obejmują następujące elementy: 
-   <see cref="P:System.Web.HttpRequest.Form" />  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   <see cref="P:System.Web.HttpRequest.Files" />  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />  
  
Aby uniknąć tego wyjątku, najpierw Wywołaj <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> metodę. Ten wyjątek jest również zgłaszany, jeśli klient rozłącza się podczas odczytywania treści jednostki.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream (disableMaxRequestLength As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream(bool disableMaxRequestLength);" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : bool -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream disableMaxRequestLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength"><see langword="true" />Aby wyłączyć limit długości żądania; w przeciwnym razie. <see langword="false" /></param>
        <summary>Pobiera obiekt, który może służyć do odczytywania przychodzącej treści jednostki http, opcjonalnie przez wyłączenie limitu długość żądania, który jest ustawiony <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" /> we właściwości. <see cref="T:System.IO.Stream" /></summary>
        <returns><see cref="T:System.IO.Stream" /> Obiekt, który może służyć do odczytywania przychodzącej treści jednostki http.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat tej metody, <xref:System.Web.HttpRequest.GetBufferlessInputStream> Zobacz Przeciążenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Treść jednostki żądania została już załadowana i przeanalizowana. Przykłady właściwości, które powodują załadowanie i przeanalizowanie treści jednostki, obejmują następujące elementy: 
<see cref="P:System.Web.HttpRequest.Form" /> -Właściwość.  
  
<see cref="P:System.Web.HttpRequest.Files" /> -Właściwość.  
  
<see cref="P:System.Web.HttpRequest.InputStream" /> -Właściwość.  
  
<see cref="M:System.Web.HttpRequest.GetBufferedInputStream" /> -Metoda.  
  
Aby uniknąć tego wyjątku, najpierw Wywołaj <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> metodę. Ten wyjątek jest również zgłaszany, jeśli klient rozłącza się podczas odczytywania treści jednostki.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję nagłówków HTTP.</summary>
        <value>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> z nagłówków.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę wszystkich możliwych nagłówków, zobacz [pola nagłówka żądania](https://go.microsoft.com/fwlink/?LinkId=73147) w witrynie sieci Web W3C.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla nazwy i wartości wszystkich nagłówków w żądaniu HTTP.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpChannelBinding As ChannelBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ChannelBinding ^ HttpChannelBinding { System::Security::Authentication::ExtendedProtection::ChannelBinding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpChannelBinding : System.Security.Authentication.ExtendedProtection.ChannelBinding" Usage="System.Web.HttpRequest.HttpChannelBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt bieżącego <see cref="T:System.Web.HttpWorkerRequest" />wystąpienia. <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /></summary>
        <value><see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> Obiekt bieżącego<see cref="T:System.Web.HttpWorkerRequest" /> wystąpienia.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący <see cref="T:System.Web.HttpWorkerRequest" /> obiekt <see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" /> nie jest obiektem ani obiektem. <see langword="System.Web.Hosting.IIS7WorkerRequest" /></exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Web.HttpRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metodę transferu danych http (taką jak <see langword="GET" />, <see langword="POST" />lub <see langword="HEAD" />) używaną przez klienta.</summary>
        <value>Metoda transferu danych HTTP używana przez klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpUtility.HtmlEncode%2A> metody do języka HTML — kodowanie wartości <xref:System.Web.HttpRequest.HttpMethod%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metody w celu zapisania zakodowanej wartości do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 Poniższy przykład przedstawia dane wyjściowe, które są generowane przez ten kod.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Web.HttpRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawartość przychodzącej treści jednostki HTTP.</summary>
        <value><see cref="T:System.IO.Stream" /> Obiekt reprezentujący zawartość przychodzącej treści zawartości http.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu kopiuje zawartość <xref:System.Web.HttpRequest.InputStream%2A> do ciągu.  
  
 [!code-csharp[Classic HttpRequest.InputStream Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Udostępnia otokę zarządzaną dla metody IIS, która wstawia treść jednostki żądania HTTP do pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia metody zapewniają dostęp zarządzany do metody usług IIS 7 `IHttpRequest::InsertEntityBody`. <xref:System.Web.HttpRequest.InsertEntityBody%2A> Metoda IIS wstawia treść jednostki żądania HTTP (dane, które są publikowane przez klienta) w pamięci. Jest to przydatne, ponieważ usługi IIS nie przechowują kopii jednostki żądania po jej odczytaniu. <xref:System.Web.HttpRequest.InsertEntityBody%2A> Metody tworzą kopię danych jednostki żądania HTTP i udostępniają je dla usług IIS w celu uzyskania dodatkowej obsługi niestandardowej.  
  
> [!NOTE]
>  Przeciążenia metody działają tylko w usługach IIS 7,0 lub nowszym, `IHttpRequest::InsertEntityBody` ponieważ metoda została dodana w usługach IIS 7,0. <xref:System.Web.HttpRequest.InsertEntityBody%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody();" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : unit -&gt; unit" Usage="httpRequest.InsertEntityBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia serwerowi IIS kopię treści jednostki żądania HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługi IIS nie przechowują kopii żądania po jego odczytaniu. Dlatego zaleca się, aby tylko procedura obsługi dla żądania HTTP mogła odczytać jednostkę żądania.  
  
 Przeciążenie <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> metody zapewnia usługi IIS kopię jednostki żądania, jeśli wcześniej została odczytana przez ASP.NET. To Przeciążenie metody jest przydatne w przypadkach, gdy ASP.NET odczytuje żądanie jednostki i chcesz ponownie wykorzystać istniejące dane żądania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Metoda została wywołana w programie IIS w wersji starszej niż 7,0.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">Dla działania w środowisku hostowanym. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone Wyliczenie:<see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : byte[] * int * int -&gt; unit" Usage="httpRequest.InsertEntityBody (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica zawierająca dane jednostki żądania.</param>
        <param name="offset">Pozycja od zera w <paramref name="buffer" /> lokalizacji, w której ma zostać rozpoczęte przechowywanie danych jednostki żądania.</param>
        <param name="count">Liczba bajtów do odczytu do <paramref name="buffer" /> tablicy.</param>
        <summary>Zapewnia usługi IIS kopię treści jednostki żądania HTTP i informacje o obiekcie jednostki żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługi IIS nie przechowują kopii żądania po jego odczytaniu. Dlatego zaleca się, aby tylko procedura obsługi dla żądania HTTP mogła odczytać jednostkę żądania.  
  
 Przeciążenie <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> metody jest przydatne, gdy chcesz wykonać przetwarzanie niestandardowe, takie jak wstawianie innej treści jednostki do pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Metoda została wywołana w programie IIS w wersji starszej niż 7,0.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest wartością ujemną.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w <paramref name="count" /> jest większa niż ilość dostępnego miejsca w, <paramref name="buffer" />w której znajduje <paramref name="offset" /> się wartość.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">dla działania w środowisku hostowanym. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone Wyliczenie:<see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Web.HttpRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądanie zostało uwierzytelnione.</summary>
        <value><see langword="true" />Jeśli żądanie zostało uwierzytelnione; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu używa właściwości, <xref:System.Web.HttpRequest.IsAuthenticated%2A> aby określić, czy bieżące żądanie zostało uwierzytelnione. Jeśli nie zostało ono uwierzytelnione, żądanie jest przekierowywane do innej strony, w której użytkownicy mogą wprowadzać poświadczenia do aplikacji sieci Web. Jest to typowa technika używana na stronie domyślnej aplikacji.  
  
 [!code-csharp[System.Web.HttpRequest_Sample3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Web.HttpRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądanie pochodzi z komputera lokalnego.</summary>
        <value><see langword="true" />Jeśli żądanie pochodzi z komputera lokalnego; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zwraca wartość `true` , jeśli adres IP nadawcy żądania jest 127.0.0.1 lub jeśli adres IP żądania jest taki sam jak adres IP serwera. <xref:System.Web.HttpRequest.IsLocal%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Web.HttpRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy połączenie HTTP używa protokołu Secure Sockets (czyli protokołu HTTPS).</summary>
        <value><see langword="true" />Jeśli połączenie jest połączeniem SSL; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu określa, <xref:System.Web.HttpRequest.IsSecureConnection%2A> czy właściwość jest ustawiona na false. Jeśli tak jest, <xref:System.Web.HttpResponse.SuppressContent%2A> właściwość jest ustawiona na wartość true, aby zatrzymać wysyłanie odpowiedzi.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Web.HttpRequest.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Nazwa członka kolekcji, który ma zostać pobrany.</param>
        <summary>Pobiera <see cref="P:System.Web.HttpRequest.QueryString" />określony obiekt z kolekcji, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" />, lub <see cref="P:System.Web.HttpRequest.ServerVariables" /> .</summary>
        <value><see cref="P:System.Web.HttpRequest.Form" /> <paramref name="key" /> Element członkowski kolekcji <see cref="P:System.Web.HttpRequest.Cookies" />,, lub<see cref="P:System.Web.HttpRequest.ServerVariables" /> , określony w parametrze. <see cref="P:System.Web.HttpRequest.QueryString" /> Jeśli określona <paramref name="key" /> nie zostanie znaleziona <see langword="null" /> , zwracana jest wartość.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogonUserIdentity As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::WindowsIdentity ^ LogonUserIdentity { System::Security::Principal::WindowsIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogonUserIdentity : System.Security.Principal.WindowsIdentity" Usage="System.Web.HttpRequest.LogonUserIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Security.Principal.WindowsIdentity" /> Pobiera typ bieżącego użytkownika.</summary>
        <value><see cref="T:System.Security.Principal.WindowsIdentity" /> Obiekt bieżących ustawień uwierzytelniania programu Microsoft Internet Information Services (IIS).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość uwidacznia właściwości i metody <xref:System.Security.Principal.WindowsIdentity> obiektu aktualnie połączonego użytkownika z programem Microsoft Internet Information Services (IIS). <xref:System.Web.HttpRequest.LogonUserIdentity%2A> Wystąpienie <xref:System.Security.Principal.WindowsIdentity> klasy, która jest udostępniona przez <xref:System.Web.HttpRequest.LogonUserIdentity%2A> śledzenie tokenu żądania usług IIS i zapewnia łatwy dostęp do tego tokenu dla bieżącego żądania HTTP przetwarzanego wewnątrz ASP.NET. Wystąpienie <xref:System.Security.Principal.WindowsIdentity> klasy jest tworzone automatycznie, dlatego nie musi być skonstruowane do programu w celu uzyskania dostępu do jego metod i właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak pobrać <xref:System.Web.HttpRequest.LogonUserIdentity%2A> Właściwość bieżącego użytkownika i zapisać wartości poszczególnych elementów w pliku tekstowym. Umieść ten kod na stronie ASP.NET, do której odwołuje się `ACTION` atrybut formularza.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aplikacja sieci Web działa w trybie zintegrowanym usług IIS 7, <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> a zdarzenie nie zostało jeszcze zgłoszone.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapImageCoordinates (imageFieldName As String) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ MapImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapImageCoordinates : string -&gt; int[]" Usage="httpRequest.MapImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Nazwa mapy obrazu formularza.</param>
        <summary>Mapuje parametr przychodzącego formularza pola obrazu na odpowiednie wartości współrzędnych x i współrzędnej y.</summary>
        <returns>Dwuwymiarowa tablica liczb całkowitych.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mapuje ścieżkę wirtualną w żądanym adresie URL na ścieżkę fizyczną na serwerze dla bieżącego żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpRequest.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna (bezwzględna lub względna) dla bieżącego żądania.</param>
        <summary>Mapuje określoną ścieżkę wirtualną do ścieżki fizycznej.</summary>
        <returns>Ścieżka fizyczna na serwerze określonym przez <paramref name="virtualPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A> Właściwość potencjalnie zawiera poufne informacje o środowisku hostingu. Wartość zwracana nie powinna być wyświetlana użytkownikom.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpRequest.MapPath%2A> metody do konwersji ścieżki wirtualnej do w pełni kwalifikowanej ścieżki fizycznej na serwerze. Ten przykład ma dwie części:  
  
-   Strona. aspx mapuje ścieżkę, odczytuje plik i wyświetla wyniki operacji odczytu.  
  
-   Klasa, `UpperCaseFilterStream`która zmienia wszystkie znaki przenoszone przez niego na wielkie litery.  
  
 Pierwsza część tego przykładu pokazuje, jak przekonwertować ścieżkę wirtualną na w pełni kwalifikowaną ścieżkę fizyczną przy użyciu <xref:System.Web.HttpRequest.MapPath%2A> metody. Ta ścieżka fizyczna jest następnie przenoszona <xref:System.IO.StreamReader> do obiektu, który uzyskuje zawartość pliku. <xref:System.Web.HttpResponse.Write%2A> Metoda jest następnie wywoływana w celu wyświetlenia zawartości pliku na stronie. <xref:System.Web.HttpResponse.Filter%2A> Właściwość służy do dołączania filtru do strumienia odpowiedzi, który sprawia, że tekst jest wyświetlany na całej stronie wielką literą.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 Druga część przykładu przedstawia klasę, która dziedziczy z <xref:System.IO.Stream> i konwertuje wszystkie znaki w strumieniu na wielkie litery. Umieść ten kod w `App_Code` folderze dla swojej aplikacji.  
  
 [!code-csharp[System.Web.HttpRequest_Samples2#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest_Samples2#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie <see cref="T:System.Web.HttpContext" /> zdefiniowano obiektu dla żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String, baseVirtualDir As String, allowCrossAppMapping As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath, System::String ^ baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string * string * bool -&gt; string" Usage="httpRequest.MapPath (virtualPath, baseVirtualDir, allowCrossAppMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna (bezwzględna lub względna) dla bieżącego żądania.</param>
        <param name="baseVirtualDir">Wirtualna ścieżka katalogu podstawowego używana do rozpoznawania względnego.</param>
        <param name="allowCrossAppMapping"><see langword="true" />Aby wskazać, <paramref name="virtualPath" /> że może należeć do innej aplikacji; <see langword="false" />w przeciwnym razie.</param>
        <summary>Mapuje określoną ścieżkę wirtualną do ścieżki fizycznej.</summary>
        <returns>Ścieżka fizyczna na serwerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A> Właściwość potencjalnie zawiera poufne informacje o środowisku hostingu. Wartość zwracana nie powinna być wyświetlana użytkownikom.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="allowCrossMapping" />jest <see langword="false" /> i<paramref name="virtualPath" /> należy do innej aplikacji.

—lub— 
Nie <see cref="T:System.Web.HttpContext" /> zdefiniowano obiektu dla żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapRawImageCoordinates (imageFieldName As String) As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ MapRawImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapRawImageCoordinates : string -&gt; double[]" Usage="httpRequest.MapRawImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Nazwa pola obrazu.</param>
        <summary>Mapuje parametr formularza pola obrazu przychodzącego na odpowiednie wartości współrzędnych x i y.</summary>
        <returns>Wartości współrzędnych x i y.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Params As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Params { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Params : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Params" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną kolekcję <see cref="P:System.Web.HttpRequest.QueryString" />elementów, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" />i. <see cref="P:System.Web.HttpRequest.ServerVariables" /></summary>
        <value>Element <see cref="T:System.Collections.Specialized.NameValueCollection" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pary nazwa-wartość są dodawane do kolekcji w następującej kolejności:  
  
1.  Parametry ciągu zapytania.  
  
2.  Pola formularza.  
  
3.  Cookie.  
  
4.  Zmienne serwera.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Web.HttpRequest.Params%2A> jak przepętlać przez właściwość strony i jak wyświetlać każdą parę klucz/wartość.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Params#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Params#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Path : string" Usage="System.Web.HttpRequest.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę wirtualną bieżącego żądania.</summary>
        <value>Ścieżka wirtualna bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to połączenie <xref:System.Web.HttpRequest.FilePath%2A> z i <xref:System.Web.HttpRequest.PathInfo%2A> przyczepą. <xref:System.Web.HttpRequest.Path%2A> Na przykład adres URL `http://www.contoso.com/virdir/page.html/tail` <xref:System.Web.HttpRequest.Path%2A> to/virdir/page.html/tail.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpUtility.HtmlEncode%2A> metody do języka HTML — kodowanie wartości <xref:System.Web.HttpRequest.Path%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metody w celu zapisania zakodowanej wartości do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathInfo : string" Usage="System.Web.HttpRequest.PathInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dodatkowe informacje o ścieżce dla zasobu z rozszerzeniem adresu URL.</summary>
        <value>Dodatkowe informacje o ścieżce dla zasobu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku adresu `http://www.contoso.com/virdir/page.html/tail`URL <xref:System.Web.HttpRequest.PathInfo%2A> wartość jest/tail.  
  
   
  
## Examples  
 Poniższy przykład kodu określa, <xref:System.Web.HttpRequest.PathInfo%2A> czy właściwość zawiera pusty ciąg. Jeśli tak, <xref:System.IO.StreamWriter.Write%2A> Metoda zapisuje ciąg wskazujący ten plik. Jeśli tak nie jest, <xref:System.Web.HttpUtility.HtmlEncode%2A> Metoda HTML dekoduje wartość <xref:System.Web.HttpRequest.PathInfo%2A> właściwości, a <xref:System.IO.TextWriter.WriteLine%2A> Metoda zapisuje zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest_Sample1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalApplicationPath : string" Usage="System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera fizyczną ścieżkę systemu plików w katalogu głównym aktualnie wykonywanej aplikacji serwera.</summary>
        <value>Ścieżka systemu plików katalogu głównego bieżącej aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpUtility.HtmlEncode%2A> metody do języka HTML — kodowanie wartości <xref:System.Web.HttpRequest.PhysicalApplicationPath%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metody w celu zapisania zakodowanej wartości do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalPath : string" Usage="System.Web.HttpRequest.PhysicalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera fizyczną ścieżkę systemu plików odpowiadającą żądanemu adresowi URL.</summary>
        <value>Ścieżka systemu plików dla bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W scenariuszach przekierowania <xref:System.Web.HttpServerUtility.Execute%2A> przy <xref:System.Web.HttpServerUtility.Transfer%2A>użyciu i <xref:System.Web.HttpRequest.PhysicalPath%2A> , właściwość zwraca ścieżkę do oryginalnej strony. Aby znaleźć ścieżkę fizyczną aktualnie wykonywanej strony, użyj <xref:System.Web.HttpRequest.MapPath%2A> metody z argumentem wejściowym ustawionym <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> jako właściwość.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpUtility.HtmlEncode%2A> metody do języka HTML — kodowanie wartości <xref:System.Web.HttpRequest.PhysicalPath%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metody w celu zapisania zakodowanej wartości do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.MapPath(System.String)" />
        <altmember cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zmiennych ciągu zapytania HTTP.</summary>
        <value>Zmienne ciągu zapytania wysyłane przez klienta. Klucze i wartości są zdekodowane na adres URL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu przedstawia dwa sposoby uzyskania wartości zmiennej ciągu zapytania o nazwie "FullName". W każdym przypadku, jeśli adres URL to `http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri`, zwracana wartość to "Fadi Fakhouri", `%20` ponieważ jest to adres URL-zdekodowany do znaku spacji. Jeśli adres URL nie zawiera `fullname` identyfikatora ciągu zapytania, zwrócona wartość `null`to.  
  
 Pierwszy wiersz kodu szuka klucza "FullName" tylko w ciągu zapytania; drugi wiersz szuka klucza "FullName" we wszystkich kolekcjach żądań HTTP. Aby uzyskać więcej informacji na temat drugiego wiersza, <xref:System.Web.HttpRequest.Item%2A>Zobacz.  
  
```csharp  
string fullname1 = Request.QueryString["fullname"];  
string fullname2 = Request["fullname"];  
  
```  
  
```vb  
Dim fullname1 As String = Request.QueryString("fullname")  
Dim fullname2 As String = Request("fullname")  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Web.HttpRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nieprzetworzony adres URL bieżącego żądania.</summary>
        <value>Nieprzetworzony adres URL bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprzetworzony adres URL jest definiowany jako część adresu URL po informacji o domenie. W ciągu `http://www.contoso.com/articles/recent.aspx`adresu URL nieprzetworzony adres URL to/articles/Recent.aspx. Nieprzetworzony adres URL zawiera ciąg zapytania, jeśli jest obecny.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpUtility.HtmlEncode%2A> metody do języka HTML — kodowanie wartości <xref:System.Web.HttpRequest.RawUrl%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metody w celu zapisania zakodowanej wartości do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadEntityBodyMode As ReadEntityBodyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ReadEntityBodyMode ReadEntityBodyMode { System::Web::ReadEntityBodyMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadEntityBodyMode : System.Web.ReadEntityBodyMode" Usage="System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy treść jednostki żądania została odczytana, a jeśli tak, jak została odczytana.</summary>
        <value>Wartość, która wskazuje, jak odczytano treść jednostki żądania lub nie została odczytana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do uniknięcia wyjątku, który jest zgłaszany, jeśli treść jednostki została już odczytana i podjęto próbę odczytu przy użyciu niezgodnej metody. Metody i właściwości odczytające treść jednostki obejmują następujące elementy:  
  
-   <xref:System.Web.HttpRequest.Form%2A> Właściwość.  
  
-   <xref:System.Web.HttpRequest.Files%2A> Właściwość.  
  
-   <xref:System.Web.HttpRequest.InputStream%2A> Właściwość.  
  
-   <xref:System.Web.HttpRequest.GetBufferedInputStream%2A> Metoda.  
  
-   <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> Metoda.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); void set(System::Web::Routing::RequestContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.Web.Routing.RequestContext with get, set" Usage="System.Web.HttpRequest.RequestContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.Routing.RequestContext" /> Pobiera wystąpienie bieżącego żądania.</summary>
        <value><see cref="T:System.Web.Routing.RequestContext" /> Wystąpienie bieżącego żądania. W przypadku żądań <see cref="T:System.Web.Routing.RequestContext" /> niekierowanych zwracany jest pusty obiekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia dostęp do <xref:System.Web.Routing.RouteData> obiektu dla bieżącego żądania. Aby uzyskać więcej informacji na temat routingu ASP.NET, zobacz. [ASP.NET routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Przewodnik: Używanie routingu ASP.NET w aplikacji formularzy sieci Web</related>
        <related type="Article" href="https://msdn.microsoft.com/library/dc88e6ba-470c-4b20-b644-35874cfd781d">Instrukcje: Dostęp do parametrów adresu URL na stronie trasowanej</related>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RequestType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestType : string with get, set" Usage="System.Web.HttpRequest.RequestType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia metodę transferu danych http (<see langword="GET" /> lub <see langword="POST" />) używaną przez klienta.</summary>
        <value>Ciąg reprezentujący typ wywołania HTTP Wysłany przez klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpUtility.HtmlEncode%2A> metody do języka HTML — kodowanie wartości <xref:System.Web.HttpRequest.RequestType%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metody w celu zapisania zakodowanej wartości do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveAs (filename As String, includeHeaders As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAs(System::String ^ filename, bool includeHeaders);" />
      <MemberSignature Language="F#" Value="member this.SaveAs : string * bool -&gt; unit" Usage="httpRequest.SaveAs (filename, includeHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Ścieżka dysku fizycznego.</param>
        <param name="includeHeaders">Wartość logiczna określająca, czy nagłówek HTTP ma być zapisany na dysku.</param>
        <summary>Zapisuje żądanie HTTP na dysku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zapisywanie kontekstu żądania na dysku może być przydatne w debugowaniu.  
  
   
  
## Examples  
 Poniższy przykład kodu wywołuje <xref:System.Web.HttpRequest.SaveAs%2A> metodę podczas ładowania strony. Wywołanie określa, że żądanie zostanie zapisane jako plik tekstowy w katalogu, w którym tożsamość procesu ASP.NET ma przyznane uprawnienia do zapisu oraz że wszystkie informacje nagłówka zawarte w żądaniu są zawarte w pliku.  
  
 [!code-csharp[System.Web.HttpRequest_Sample6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Właściwość obiektu ma ustawioną <see langword="true" /> wartość, <see cref="T:System.Web.Configuration.HttpRuntimeSection" /> ale <paramref name="filename" /> nie jest ścieżką bezwzględną. <see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServerVariables As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ ServerVariables { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServerVariables : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.ServerVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zmiennych serwera sieci Web.</summary>
        <value><see cref="T:System.Collections.Specialized.NameValueCollection" /> Zmienna serwera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę zmiennych serwera obsługiwanych przez usługi IIS, zobacz [zmienne serwera usług IIS](https://go.microsoft.com/fwlink/?LinkId=52471).  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla nazwy i wartości wszystkich nazwanych zmiennych serwerowych.  
  
 [!code-csharp[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimedOutToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken TimedOutToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TimedOutToken : System.Threading.CancellationToken" Usage="System.Web.HttpRequest.TimedOutToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.CancellationToken" /> Pobiera obiekt, który jest wyzwalany, gdy żądanie przekracza limit czasu.</summary>
        <value>Token anulowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Limit czasu można określić w pliku Web. config (zobacz <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=nameWithType>) lub programowo (zobacz <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>). Limit czasu jest mierzony od momentu, w którym znajduje się żądanie. Jeśli domyślny limit czasu wynoszący 110 sekund obowiązuje, token anulowania zostanie wyzwoleniem nie wcześniej niż 110 s po rozpoczęciu przetwarzania żądania. Można zmienić <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType> wartość właściwości, a dopóki ten token nie został jeszcze wykorzystany, zostanie zachowana nowa wartość limitu czasu.  
  
 Obecnie token zapewnia tylko 15 sekund, co oznacza, że jeśli wartość limitu czasu wynosi 110 sekund, token zostanie wyłączany od 110 do 125 sekund po rozpoczęciu przetwarzania żądania. Stopień szczegółowości może ulec zmianie w przyszłości.  
  
 Mimo że ta właściwość jest bezpieczna wątkowo, istnieją ograniczenia dotyczące użycia. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=nameWithType>.  
  
 Ta właściwość jest bezużyteczne, jeśli Rozpoczęto przetwarzanie żądań WebSockets.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TlsTokenBindingInfo As ITlsTokenBindingInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ITlsTokenBindingInfo ^ TlsTokenBindingInfo { System::Web::ITlsTokenBindingInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TlsTokenBindingInfo : System.Web.ITlsTokenBindingInfo" Usage="System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o powiązaniu tokenu TLS. Właściwość umożliwia aplikacjom pobieranie informacji o tokenach z przychodzących żądań HTTP w celu rozszerzonego uwierzytelniania.</summary>
        <value>Token powiązania dla bieżącego połączenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `null` na platformach innych niż Windows10.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalBytes As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TotalBytes { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalBytes : int" Usage="System.Web.HttpRequest.TotalBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów w bieżącym strumieniu wejściowym.</summary>
        <value>Liczba bajtów w strumieniu wejściowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu określa, <xref:System.Web.HttpRequest.TotalBytes%2A> czy wartość właściwości jest większa niż 1000 bajtów i zapisuje te informacje w pliku.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest_Sample1#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Unvalidated As UnvalidatedRequestValues" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UnvalidatedRequestValues ^ Unvalidated { System::Web::UnvalidatedRequestValues ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unvalidated : System.Web.UnvalidatedRequestValues" Usage="System.Web.HttpRequest.Unvalidated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartości żądania HTTP bez wyzwalania walidacji żądania.</summary>
        <value>Wartości żądania HTTP, które nie zostały sprawdzone przy użyciu walidacji żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zażądaj sprawdzenia poprawności znaczników HTML i skryptów, które mogą wskazywać potencjalny atak na skrypty między lokacjami. Domyślnie wszystkie wartości są sprawdzane przy użyciu walidacji żądania, a jeśli jakiekolwiek wartości zawierają znaczniki lub skrypty, ASP.NET <xref:System.Web.HttpRequestValidationException> zgłasza wyjątek. Użyj tej metody, Jeśli przewidujesz, że żądanie będzie zawierało znaczniki (na przykład zezwalasz użytkownikom na publikowanie zawartości zawierającej znaczniki) i chcesz uzyskać pierwotną wartość żądania.  
  
> [!IMPORTANT]
>  W przypadku użycia tej właściwości należy ręcznie sprawdzić dane pod kątem potencjalnych ataków na skrypty między lokacjami.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Web.HttpRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o adresie URL bieżącego żądania.</summary>
        <value><see cref="T:System.Uri" /> Obiekt, który zawiera adres URL bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu przypisuje <xref:System.Uri> obiekt bieżącego żądania do zmiennej obiektu i wyświetla wartość dwóch właściwości obiektu adresu URL w danych wyjściowych http.  
  
 [!code-csharp[Classic HttpRequest.Url Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
        <altmember cref="P:System.Web.HttpRequest.RawUrl" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Web.HttpRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o adresie URL poprzedniego żądania klienta połączonego z bieżącym adresem URL.</summary>
        <value>Element <see cref="T:System.Uri" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wyświetla wartość dwóch właściwości adresu URL, który powołuje klienta do bieżącej aplikacji.  
  
 [!code-csharp[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">Nagłówek żądania <see langword="Referer" /> http jest źle sformułowany i nie można go przekonwertować <see cref="T:System.Uri" /> na obiekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Web.HttpRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nieprzetworzony ciąg agenta użytkownika z przeglądarki klienta, która została dostarczona. Zwróć uwagę, że może ona mieć wartość null.</summary>
        <value>Ciąg nieprzetworzonego agenta użytkownika w przeglądarce klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu przypisuje identyfikację typu w przeglądarce żądającej do zmiennej ciągu.  
  
 [!code-csharp[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">Kontrolki serwera ASP.NET i możliwości przeglądarki</related>
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Web.HttpRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres hosta IP klienta zdalnego.</summary>
        <value>Adres IP klienta zdalnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpUtility.HtmlEncode%2A> metody do języka HTML — kodowanie wartości <xref:System.Web.HttpRequest.UserHostAddress%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metody w celu zapisania zakodowanej wartości do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Web.HttpRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę DNS klienta zdalnego.</summary>
        <value>Nazwa DNS klienta zdalnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Web.HttpUtility.HtmlEncode%2A> metody do języka HTML — kodowanie wartości <xref:System.Web.HttpRequest.UserHostName%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metody w celu zapisania zakodowanej wartości do pliku. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Web.HttpRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera posortowaną tablicę ciągów preferencji języka klienta.</summary>
        <value>Posortowana tablica ciągów preferencji języka klienta lub <see langword="null" /> wartość pusta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu przechwytuje wiele wartości zwracanych przez <xref:System.Web.HttpRequest.UserLanguages%2A> właściwość do tablicy ciągów i zapisuje każdą nazwę języka w osobnym wierszu wyjścia http.  
  
 Nazwy języków są udostępniane przez przeglądarkę i nie ma ostatecznej listy wszystkich możliwych kodów.  Zwykle składają się z kodów dwubajtowych dla języka, łącznika i dwuznakowego kodu dla kultury, na przykład "en-us" dla Stanów Zjednoczonych Angielski i "fr-CA" w języku francuskim dla Kanady.  
  
 [!code-csharp[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateInput();" />
      <MemberSignature Language="F#" Value="member this.ValidateInput : unit -&gt; unit" Usage="httpRequest.ValidateInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje <see cref="P:System.Web.HttpRequest.Cookies" />, że Walidacja następuje w przypadku kolekcji, do <see cref="P:System.Web.HttpRequest.Form" />których dostęp uzyskuje się za pomocą właściwości, i <see cref="P:System.Web.HttpRequest.QueryString" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa używa flag walidacji danych wejściowych do śledzenia <xref:System.Web.HttpRequest.Cookies%2A>, czy należy przeprowadzić walidację w kolekcjach żądań, <xref:System.Web.HttpRequest.Form%2A>do których można uzyskać dostęp za pośrednictwem właściwości, i <xref:System.Web.HttpRequest.QueryString%2A>. <xref:System.Web.HttpRequest> Metoda ustawia te flagi w taki sposób, aby kiedy wywoływane są metody dostępu <xref:System.Web.HttpRequest.Cookies%2A>dla <xref:System.Web.HttpRequest.Form%2A>, lub <xref:System.Web.HttpRequest.QueryString%2A> właściwości, wykonywane jest walidacja danych wejściowych. <xref:System.Web.HttpRequest.ValidateInput%2A> Walidacja sprawdza się, sprawdzając wszystkie dane wejściowe na zakodowanej na stałe liście potencjalnie niebezpiecznych danych.  
  
 Jeśli funkcja walidacji jest włączona na podstawie dyrektywy lub konfiguracji strony, ta metoda jest wywoływana w fazie `ProcessRequest` przetwarzania strony. <xref:System.Web.HttpRequest.ValidateInput%2A> Metoda może być wywoływana przez kod, jeśli funkcja walidacji nie jest włączona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">Z klienta odebrano potencjalnie niebezpieczne dane.</exception>
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
  </Members>
</Type>

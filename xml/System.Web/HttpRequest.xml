<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="58879141d0b088ca4dee06b7cf8aee51870ccda5" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/14/2019" /><Meta Name="ms.locfileid" Value="57943294" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Umożliwia odczyt wartości HTTP wysłane przez klienta w trakcie żądania sieci Web ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody i właściwości <xref:System.Web.HttpRequest> klasy są udostępniane za pośrednictwem `Request` właściwości <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, i <xref:System.Web.UI.UserControl> klasy.  
  
 Dostęp do danych z <xref:System.Web.HttpRequest.QueryString%2A>, <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Cookies%2A>, lub <xref:System.Web.HttpRequest.ServerVariables%2A> kolekcji, można napisać `Request["key"]`, jak pokazano w przykładzie dla <xref:System.Web.HttpRequest.QueryString%2A> właściwości.  
  
> [!NOTE]
>  Obsługa standardu Unicode dla <xref:System.Web.HttpRequest> elementów członkowskich klas wymaga usług IIS w wersji 6.0 lub nowszej.  
  
   
  
## Examples  
 Następujące przykłady dostępu <xref:System.Web.HttpRequest> wystąpienia dla bieżącego żądania przy użyciu <xref:System.Web.UI.Page.Request%2A> właściwość <xref:System.Web.UI.Page> klasy.  
  
 Można użyć uproszczoną składnię do uzyskiwania dostępu do danych z <xref:System.Web.HttpRequest.QueryString%2A>, <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Cookies%2A>, lub <xref:System.Web.HttpRequest.ServerVariables%2A> kolekcji. Można napisać `Request["key"]`.  
  
 Pierwszy przykład pokazuje, jak pobrać wartość ciągu zapytania podczas ładowania strony.  
  
```csharp  
public partial class AddToCart : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        string rawId = Request["ProductID"];  
        int productId;  
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))  
        {  
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())  
            {  
                usersShoppingCart.AddToCart(productId);  
            }  
        }  
        else  
        {  
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");  
        }  
        Response.Redirect("ShoppingCart.aspx");  
    }  
}  
```  
  
```vb  
Public Class AddToCart  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        Dim rawId = Request("ProductID")  
        Dim productId As Integer  
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then  
            Using usersShoppingCart As New ShoppingCartActions()  
                usersShoppingCart.AddToCart(productId)  
            End Using  
  
        Else  
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")  
        End If  
        Response.Redirect("ShoppingCart.aspx")  
    End Sub  
End Class  
```  
  
 Następny przykład pokazuje, jak sprawdzić, jeśli żądanie jest uwierzytelniane i pobieranie pierwotnym adresem URL.  
  
```csharp  
public partial class RestrictedPage : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        if (!Request.IsAuthenticated)  
        {  
            var rawUrl = Request.RawUrl;  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));  
        }  
    }  
}  
```  
  
```vb  
Public Class RestrictedPage  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        If Not Request.IsAuthenticated Then  
            Dim rawUrl = Request.RawUrl  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))  
        End If  
    End Sub  
End Class  
```  
  
 Projekt witryny internetowego programu Visual Studio z kodem źródłowym jest dostępna powiązany z tym tematem: [Pobierz](https://go.microsoft.com/fwlink/?LinkID=191455).  
  
 W tym przykładzie użyto <xref:System.IO.StreamWriter> klasę umożliwiającą zapisanie wartości kilku <xref:System.Web.HttpRequest> klasy właściwości do pliku. Dla właściwości typu ciąg wartości są kodowania, ponieważ są one zapisywane do pliku HTML. Właściwości, które reprezentują kolekcję krążą między, a każda para klucz/wartość zawartych w nich są zapisywane do pliku.  
  
> [!IMPORTANT]
>  W tym przykładzie ma pola tekstowego, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, że dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filename As String, url As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpRequest(System::String ^ filename, System::String ^ url, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpRequest : string * string * string -&gt; System.Web.HttpRequest" Usage="new System.Web.HttpRequest (filename, url, queryString)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku skojarzone z żądaniem.</param>
        <param name="url">Informacje dotyczące adresu URL bieżącego żądania.</param>
        <param name="queryString">Ciąg zapytania całego wysłane z żądaniem (wszystko po <c>"?"</c>).</param>
        <summary>Inicjuje <see cref="T:System.Web.HttpRequest" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie musisz utworzyć własne wystąpienie <xref:System.Web.HttpRequest> klasy. Metody i właściwości <xref:System.Web.HttpRequest> klasy są udostępniane za pośrednictwem `Request` właściwość <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, i <xref:System.Web.UI.UserControl> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza zamknięcie podstawowego połączenia TCP, co powoduje żadnych oczekujących operacji We/Wy nie powiedzie się. Można użyć tej metody w odpowiedzi na ataki przez złośliwego klienta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest metodą o bezpiecznych wątkach. Wątek może wywołać go w dowolnym momencie.  
  
 Tej metody należy używać tylko w trybie zintegrowanym. Wyjątek jest generowany, jeśli wywołujesz w trybie klasycznym. Aby określić tryb potokowy, użyj <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Web.HttpRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Typy pobiera zaakceptować tablicy ciągów MIME obsługiwane przez klienta.</summary>
        <value>Tablica ciągów MIME obsługiwane przez klienta akceptować typy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu rejestruje wiele wartości zwracanych przez <xref:System.Web.HttpRequest.AcceptTypes%2A> właściwości do zmiennej obiektu i zapisuje je na liczbę i nazwę każdego valueto osobnym wierszu danych wyjściowych HTTP.  
  
 [!code-csharp[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AnonymousID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AnonymousID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AnonymousID : string" Usage="System.Web.HttpRequest.AnonymousID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator anonimowe dla użytkownika, jeśli jest obecny.</summary>
        <value>Ciąg reprezentujący bieżący identyfikator użytkownika anonimowego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.AnonymousID%2A> Właściwość przypisuje długotrwałe Unikatowy identyfikator użytkownika bez uwierzytelnienia, który może służyć do śledzenia użytkowników i przypisać właściwości profilu użytkownika bez zapisywania danych w `Session` obiektu. Domyślnie <xref:System.Web.HttpRequest.AnonymousID%2A> właściwości są śledzone za pomocą pliku cookie, ale można ją ustawić, aby użyć identyfikatora URI po <xref:System.Web.Configuration.SessionStateSection.Cookieless%2A> atrybutu w sekcji konfiguracji Identyfikacja anonimowa jest ustawiona jako <xref:System.Web.HttpCookieMode.UseUri>, <xref:System.Web.HttpCookieMode.UseDeviceProfile>, lub <xref:System.Web.HttpCookieMode.AutoDetect> wartość. Jeśli nie chcesz już ona dostępna, na przykład gdy uwierzytelniony użytkownik anonimowy, należy jawnie usunąć plik cookie.  
  
 Identyfikacja anonimowa jest używany, gdy istnieje potrzeba do identyfikowania jednostki, które nie są uwierzytelniane i gdy jest wymagana autoryzacja. Aby uzyskać więcej informacji, zobacz [anonymousIdentification — Element (ASP.NET Settings Schema)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100))  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Web.HttpRequest.AnonymousID%2A> właściwość obsługi <xref:System.Web.Security.AnonymousIdentificationModule.Creating> zdarzenia w pliku Global.asax. W tym przykładzie ma dwie części:  
  
-   Metoda w pliku Global.asax, która obsługuje <xref:System.Web.Security.AnonymousIdentificationModule.Creating> zdarzeń.  
  
-   Strony formularzy sieci Web.  
  
 Pierwsza część w przykładzie kodu przedstawiono sposób ustawiania <xref:System.Web.HttpRequest.AnonymousID%2A> właściwość obsługi <xref:System.Web.Security.AnonymousIdentificationModule.Creating> zdarzenia w pliku Global.asax. Metody, która nosi nazwę `AnonymousIdentification_Creating` ustawia <xref:System.Web.HttpRequest.AnonymousID%2A> właściwości po utworzeniu Identyfikatora anonimowe.  
  
 [!code-csharp[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]  
  
 Druga część przykładowy kod przedstawia sposób wyświetlania nowe <xref:System.Web.HttpRequest.AnonymousID%2A> tworzone przez `AnonymousIdentification_Creating` program obsługi zdarzeń w poprzednim przykładzie.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.IsAuthenticated" />
        <altmember cref="E:System.Web.Security.AnonymousIdentificationModule.Creating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100)">anonymousIdentification — Element (ASP.NET Settings Schema)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationPath : string" Usage="System.Web.HttpRequest.ApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżka katalogu głównego aplikacji wirtualnej aplikacji ASP.NET na serwerze.</summary>
        <value>Ścieżka wirtualna bieżącej aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do konstruowania adres URL względem katalogu głównego aplikacji ze strony lub kontrolka użytkownika sieci Web, który nie znajduje się w katalogu głównym. Dzięki temu, stron i formantów udostępnionych, które istnieją na różnych poziomach struktury katalogów, aby użyć tego samego kodu, aby utworzyć łącze do zasobów w stałej lokalizacji w aplikacji.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.StreamWriter.Write%2A> metodę do zakodowania w formacie HTML, a następnie zapisać wartość <xref:System.Web.HttpRequest.ApplicationPath%2A> właściwość do pliku tekstowego. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy. Zakłada się istnienie <xref:System.IO.StreamWriter> obiektu o nazwie `sw`.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 W poniższym przykładzie użyto <xref:System.Web.HttpRequest.ApplicationPath%2A> właściwość programowo utworzyć ścieżkę do zasobu, który znajduje się w stałej lokalizacji w aplikacji. Strona która odwołuje się do zasobu ma znajdować się w tym samym katalogu co zasób.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]  
  
 Po uruchomieniu tego przykładu w aplikacji sieci Web, który nosi nazwę witryna "website1", `/WebSite1` będą wyświetlane jako wartości <xref:System.Web.HttpRequest.ApplicationPath%2A> właściwości i `/WebSite1/images/Image1.gif` będą wyświetlane jako pełna ścieżka obrazu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppRelativeCurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeCurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeCurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę wirtualną katalogu głównego aplikacji i sprawia, że względne przy użyciu tyldy (\~) Notacja do katalogu głównego aplikacji (podobnie jak w "\~/page.aspx").</summary>
        <value>Ścieżka wirtualna katalogu głównego aplikacji dla bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapewnić informacje adresu URL, które pozostaną takie same, nawet w przypadku aplikacji zmiany lokalizacji, należy użyć tej właściwości. Umożliwia to ten sam kod mapowanie adresu URL do użycia w środowisku testowym, jak i w środowisku wdrażania końcowego lub ma być używany przez kopie aplikacji sieci Web w różnych domenach.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> właściwości, aby ustawić adres URL <xref:System.Web.UI.WebControls.Image> kontrolki obrazu, w tym samym katalogu co stronę. Uruchom tę stronę, na różnych poziomach struktury katalogów, aby wyświetlić wynikowe <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> wartości właściwości.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]  
  
 W poniższym przykładzie użyto <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> właściwości, aby programowo ustawić ścieżkę do zasobu, na podstawie bieżącej ścieżki strony.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinaryRead (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ BinaryRead(int count);" />
      <MemberSignature Language="F#" Value="member this.BinaryRead : int -&gt; byte[]" Usage="httpRequest.BinaryRead count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Liczba bajtów do odczytania.</param>
        <summary>Wykonuje odczytu binarnego o określoną liczbę bajtów ze strumienia wejściowego bieżącego.</summary>
        <returns>Tablica bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.BinaryRead%2A> Metoda zapewnia zgodność za pomocą technologii ASP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ma wartość 0.  
  
—lub— 
 <paramref name="count" /> jest większa niż liczba dostępnych bajtów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberSignature Language="VB.NET" Value="Public Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); void set(System::Web::HttpBrowserCapabilities ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities with get, set" Usage="System.Web.HttpRequest.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje na temat możliwości przeglądarki klienta wysyłającego żądanie.</summary>
        <value><see cref="T:System.Web.HttpBrowserCapabilities" /> Obiektu listę możliwości przeglądarki klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod wysyła listę możliwości przeglądarki do klienta na stronie HTML.  
  
 [!code-csharp[Classic HttpRequest.Browser Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">Formanty serwera ASP.NET i możliwości przeglądarki</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificate As HttpClientCertificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpClientCertificate ^ ClientCertificate { System::Web::HttpClientCertificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificate : System.Web.HttpClientCertificate" Usage="System.Web.HttpRequest.ClientCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący certyfikat zabezpieczeń klienta dla żądania.</summary>
        <value><see cref="T:System.Web.HttpClientCertificate" /> Obiekt zawierający informacje o ustawieniach certyfikat zabezpieczeń klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod wysyła ustawienia certyfikatu klienta z powrotem do klienta na stronie HTML.  
  
 [!code-csharp[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zestaw znaków w treści jednostki.</summary>
        <value><see cref="T:System.Text.Encoding" /> Obiekt reprezentujący zestaw znaków klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne kodowanie zawartości można określić w [globalizacji — Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) pliku konfiguracji. Jeśli kodowanie zawartości jest również określony przez klienta, są zastępowane domyślnych ustawień konfiguracji.  
  
   
  
## Examples  
 Poniższy przykładowy kod przypisuje wartość reprezentującą opis bieżącego kodowania HTTP do zmiennej ciągu.  
  
 [!code-csharp[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContentLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int" Usage="System.Web.HttpRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa długość w bajtach zawartości wysłane przez klienta.</summary>
        <value>Długość, w bajtach zawartości wysłane przez klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod przypisuje wartość reprezentujący zmienna typu Liczba całkowita długość zawartości żądania przychodzącego.  
  
 [!code-csharp[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ zawartości MIME żądania przychodzącego.</summary>
        <value>Ciąg reprezentujący typ zawartości MIME żądania przychodzącego, na przykład "text/html". Dodatkowe typy MIME wspólnej obejmują "audio.wav", "image/gif" i "application/pdf".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod przypisuje wartość reprezentująca typu zawartości żądania przychodzące do zmiennej ciągu.  
  
 [!code-csharp[Classic HttpRequest.ContentType Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]  
  
 Poniższy przykład przedstawia dane wyjściowe, wytworzonego przez ten kod.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję plików cookie wysłanych przez klienta.</summary>
        <value><see cref="T:System.Web.HttpCookieCollection" /> Obiekt reprezentujący zmienne plików cookie klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program ASP.NET zawiera dwie kolekcje wewnętrzne pliku cookie. Kolekcji udostępniane za pośrednictwem <xref:System.Web.HttpRequest.Cookies%2A> zbiór <xref:System.Web.HttpRequest> zawiera pliki cookie przesyłanych przez klienta do serwera w `Cookie` nagłówka. Kolekcji udostępniane za pośrednictwem <xref:System.Web.HttpResponse.Cookies%2A> zbiór <xref:System.Web.HttpResponse> zawiera nowe pliki cookie, utworzony na serwerze i przekazywane do klienta w `Set-Cookie` nagłówka.  
  
> [!NOTE]
>  Po dodaniu pliku cookie przy użyciu <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> kolekcji, plik cookie jest natychmiast dostępna w <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> kolekcji, nawet jeśli nie została wysłana odpowiedź do klienta.  
  
   
  
## Examples  
 Poniższy przykład kodu w pętli wszystkich plików cookie wysłanych przez klienta i wysyła nazwę, datę wygaśnięcia, zabezpieczeń parametru i wartości poszczególnych plików cookie w wyniku HTTP.  
  
 [!code-csharp[Classic HttpRequest.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę wirtualną bieżącego żądania.</summary>
        <value>Ścieżka wirtualna bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> zwraca ścieżkę pliku do aktualnie wykonywanej obsługi strony. Dla scenariuszy przekierowania przy użyciu <xref:System.Web.HttpServerUtility.Execute%2A> i <xref:System.Web.HttpServerUtility.Transfer%2A> metod, oznacza to, że <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> właściwość zwraca ścieżkę do strony przekierowywane do (strona podrzędna). Jednakże, gdy klient zostanie przekierowany do innej strony <xref:System.Web.HttpRequest.FilePath%2A> właściwość zwraca ścieżkę do oryginalnej strony.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpUtility.HtmlEncode%2A> metodę do zakodowania w formacie HTML wartość <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metodę, aby zapisać zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="M:System.Web.HttpServerUtility.Execute(System.String)" />
        <altmember cref="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePathExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePathExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePathExtension : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozszerzenie nazwy pliku, który jest określony w <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> właściwości.</summary>
        <value>Rozszerzenie nazwy pliku, który jest określony w <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> właściwości.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilePath : string" Usage="System.Web.HttpRequest.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę wirtualną bieżącego żądania.</summary>
        <value>Ścieżka wirtualna bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.FilePath%2A> Nie ma właściwości <xref:System.Web.HttpRequest.PathInfo%2A> przyczepy. Na przykład adres URL http://www.contoso.com/virdir/page.html/tail, <xref:System.Web.HttpRequest.FilePath%2A> wartość /virdir/page.html.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpUtility.HtmlEncode%2A> metodę do zakodowania w formacie HTML wartość <xref:System.Web.HttpRequest.FilePath%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metodę, aby zapisać zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Files As HttpFileCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpFileCollection ^ Files { System::Web::HttpFileCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Files : System.Web.HttpFileCollection" Usage="System.Web.HttpRequest.Files" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję plików przekazanych przez klienta, w formacie wieloczęściowej wiadomości MIME.</summary>
        <value><see cref="T:System.Web.HttpFileCollection" /> Obiekt reprezentujący kolekcję plików przekazany przez klienta. Elementy <see cref="T:System.Web.HttpFileCollection" /> obiektu są typu <see cref="T:System.Web.HttpPostedFile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja plików jest wypełniana tylko podczas żądania HTTP `Content-Type` wartość to "multipart/form-data".  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla nazwy wszystkich plików w <xref:System.Web.HttpRequest.Files%2A> kolekcji.  
  
 [!code-csharp[Classic HttpRequest.Files Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpRequest.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia filtr do użycia podczas odczytu strumienia wejściowego bieżącego.</summary>
        <value>A <see cref="T:System.IO.Stream" /> obiekt ma być używany jako filtr.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy dwa nowe klasy, `QQQ1` i `QQQ2` z filtrem <xref:System.Web.HttpRequest.InputStream%2A>. Tak, aby wszystkie dane wejściowe dla wszystkich stron sieci Web platformy ASP.NET w aplikacji będą filtrowane, umieść klasy w pliku Global.asax w katalogu aplikacji ASP.NET.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Filter#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Filter#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Określony <see cref="T:System.IO.Stream" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Form { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zmiennych formularza.</summary>
        <value>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> reprezentujący kolekcję zmiennych formularza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.Form%2A> Właściwość jest wypełniana podczas żądania HTTP `Content-Type` wartość to "application/x--www-form-urlencoded" lub "multipart/form-data".  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób odczytywania wartości w kolekcji formularza, opublikowane w przeglądarce. Każdej pary nazwa/wartość w kolekcji reprezentuje kontrolkę w formularzu i jego wartość.  
  
 [!code-csharp[Classic HttpRequest.Form Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferedInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferedInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferedInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferedInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.IO.Stream" /> obiektu, który może służyć do odczytu przychodzącego treści jednostki HTTP.</summary>
        <returns>Element <see cref="T:System.IO.Stream" /> obiektu, który może służyć do odczytu przychodzącego treści jednostki HTTP.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest taka sama jak <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> z tą różnicą, że kopiuje również bajtów, które są odczytywane wewnętrznej pamięci masowej, który jest używany przez program ASP.NET do wypełniania <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Files%2A>, i <xref:System.Web.HttpRequest.InputStream%2A> właściwości. Ponieważ te informacje są zachowywane, podrzędnego kodu, takich jak strony formularzy sieci Web ASP.NET (pliki aspx) zostanie pomyślnie uruchomiona. To nie jest w przypadku <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Treść jednostki żądania został już załadowany i analizowane. Właściwości, które powodują treści jednostki do ładowania i przeanalizować należą następujące: 
<see cref="P:System.Web.HttpRequest.Form" /> Właściwości.  
  
<see cref="P:System.Web.HttpRequest.Files" /> Właściwości.  
  
<see cref="P:System.Web.HttpRequest.InputStream" /> Właściwości.  
  
<see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" /> Metody.  
  
Aby uniknąć tego wyjątku, należy wywołać <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> metoda pierwszy. Ten wyjątek również jest generowany, jeśli klient odłączy się podczas odczytywania treści jednostki.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBufferlessInputStream">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.IO.Stream" /> obiektu, który może służyć do odczytu przychodzącego treści jednostki HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.IO.Stream" /> obiektu, który może służyć do odczytu przychodzącego treści jednostki HTTP.</summary>
        <returns>Element <see cref="T:System.IO.Stream" /> obiektu, który może służyć do odczytu przychodzącego treści jednostki HTTP.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia alternatywa dla użycia <xref:System.Web.HttpRequest.InputStream%2A> właściwości. <xref:System.Web.HttpRequest.InputStream%2A> Właściwość oczekuje na całą żądanie zostało odebrane przed zwróceniem <xref:System.IO.Stream> obiektu. Z kolei <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> metoda zwraca <xref:System.IO.Stream> obiektu natychmiast. Metoda umożliwia rozpoczęcie przetwarzania treść jednostki, zanim zostały odebrane Pełna zawartość treści.  
  
 Treść jednostki (lub jako część informacji jak żądania i zostało odebrane) jest zwracany tylko wtedy, gdy obiekt jest używany, jest zwracana przez tę metodę można odczytać strumienia, wywoływania metod, takich jak <xref:System.IO.Stream.Read%2A> metody. Możesz używać parametrów <xref:System.IO.Stream.Read%2A> metodę, aby określić, jaka część treści jednostki do odczytu.  
  
 <xref:System.IO.Stream> Obiektu zwróconego przez platformę ASP.NET z tej metody obsługuje synchroniczne i asynchroniczne metody odczytu. <xref:System.IO.Stream> Obiekt implementuje interfejsy <xref:System.IO.Stream.BeginRead%2A> i <xref:System.IO.Stream.EndRead%2A> metody. Metody asynchroniczne pozwalają asynchronicznego odczytania jednostka żądania we fragmentach, podczas gdy ASP.NET zwalnia bieżącego wątku Between każdej iteracji pętli odczytu asynchronicznego.  
  
 Ta metoda może być przydatne, jeśli żądanie jest przekazywanie dużych plików i chcesz rozpocząć uzyskiwanie dostępu do zawartości pliku przed zakończeniem przekazywania. Jednakże należy używać tylko tej metody dla scenariuszy gdzie chcesz przejąć całe przetwarzanie treści jednostki. Oznacza to, że nie można użyć tej metody ze strony .aspx, ponieważ do czasu ponownego uruchomienia strony .aspx treści jednostki jest już przeczytana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Treść jednostki żądania został już załadowany i analizowane. Właściwości, które powodują treści jednostki do ładowania i przeanalizować należą następujące: 
-   <see cref="P:System.Web.HttpRequest.Form" />  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   <see cref="P:System.Web.HttpRequest.Files" />  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />  
  
Aby uniknąć tego wyjątku, należy wywołać <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> metoda pierwszy. Ten wyjątek również jest generowany, jeśli klient odłączy się podczas odczytywania treści jednostki.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream (disableMaxRequestLength As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream(bool disableMaxRequestLength);" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : bool -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream disableMaxRequestLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength"><see langword="true" /> Aby wyłączyć limit długości żądania; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera <see cref="T:System.IO.Stream" /> obiektu, który może służyć do odczytu przychodzącego treści jednostki HTTP opcjonalnie wyłączenie limitu długość żądania, który jest ustawiony w <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" /> właściwości.</summary>
        <returns>Element <see cref="T:System.IO.Stream" /> obiektu, który może służyć do odczytu przychodzącego treści jednostki HTTP.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Web.HttpRequest.GetBufferlessInputStream> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Treść jednostki żądania został już załadowany i analizowane. Właściwości, które powodują treści jednostki do ładowania i przeanalizować należą następujące: 
<see cref="P:System.Web.HttpRequest.Form" /> Właściwości.  
  
<see cref="P:System.Web.HttpRequest.Files" /> Właściwości.  
  
<see cref="P:System.Web.HttpRequest.InputStream" /> Właściwości.  
  
<see cref="M:System.Web.HttpRequest.GetBufferedInputStream" /> Metody.  
  
Aby uniknąć tego wyjątku, należy wywołać <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> metoda pierwszy. Ten wyjątek również jest generowany, jeśli klient odłączy się podczas odczytywania treści jednostki.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję nagłówków HTTP.</summary>
        <value>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> nagłówków.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę wszystkich możliwych nagłówków, zobacz [pola nagłówka żądania](https://go.microsoft.com/fwlink/?LinkId=73147) w witrynie internetowej W3C.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla nazwy i wartości wszystkich nagłówków w żądaniu HTTP.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpChannelBinding As ChannelBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ChannelBinding ^ HttpChannelBinding { System::Security::Authentication::ExtendedProtection::ChannelBinding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpChannelBinding : System.Security.Authentication.ExtendedProtection.ChannelBinding" Usage="System.Web.HttpRequest.HttpChannelBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> obiektu bieżącego <see cref="T:System.Web.HttpWorkerRequest" /> wystąpienia.</summary>
        <value><see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> Obiektu bieżącego <see cref="T:System.Web.HttpWorkerRequest" /> wystąpienia.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący <see cref="T:System.Web.HttpWorkerRequest" /> obiekt nie jest <see langword="System.Web.Hosting.IIS7WorkerRequest" /> obiektu lub <see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" /> obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Web.HttpRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metodę transferu danych HTTP (taki jak <see langword="GET" />, <see langword="POST" />, lub <see langword="HEAD" />) używany przez klienta.</summary>
        <value>Transferu danych HTTP użytą przez klienta metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpUtility.HtmlEncode%2A> metodę do zakodowania w formacie HTML wartość <xref:System.Web.HttpRequest.HttpMethod%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metodę, aby zapisać zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 Poniższy przykład pokazuje danych wyjściowych, który jest wytwarzany przez ten kod.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Web.HttpRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawartość przychodzących treści jednostki HTTP.</summary>
        <value>A <see cref="T:System.IO.Stream" /> obiekt reprezentujący zawartość przychodzące HTTP zawartości treści.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod kopiuje zawartość <xref:System.Web.HttpRequest.InputStream%2A> na ciąg.  
  
 [!code-csharp[Classic HttpRequest.InputStream Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia zarządzanych otoka metody usług IIS, która wstawia treści jednostki żądania HTTP do pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A> Przeciążenia metody zapewniają zarządzany dostęp do usług IIS 7 `IHttpRequest::InsertEntityBody` metody. Metoda IIS wstawia treści jednostki żądania HTTP (dane, które jest opublikowane przez klienta) do pamięci. Jest to przydatne, ponieważ usługi IIS nie przechowuje kopii jednostki żądania po został odczytany. <xref:System.Web.HttpRequest.InsertEntityBody%2A> Metody Utwórz kopię danych jednostki żądania HTTP i udostępnić go w usługach IIS dla dodatkowych niestandardową obsługę.  
  
> [!NOTE]
>  <xref:System.Web.HttpRequest.InsertEntityBody%2A> Przeciążenia metod pracy tylko w usługach IIS 7.0 lub nowszym, ponieważ `IHttpRequest::InsertEntityBody` metoda została dodana w usługach IIS 7.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody();" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : unit -&gt; unit" Usage="httpRequest.InsertEntityBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Udostępnia w usługach IIS kopię treści jednostki żądania HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługi IIS nie przechowuje kopię żądania, po został odczytany. Dlatego zalecane jest, czy tylko obsługa żądania HTTP, powinien przeczytać jednostki żądania.  
  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> Przeciążenie metody udostępnia w usługach IIS wraz z kopią jednostki żądania jeśli zostały wcześniej odczytane przez platformę ASP.NET. Tego przeciążenia metody jest przydatne w przypadkach, gdy program ASP.NET ma odczytu żądania jednostki i chcesz ponownie użyć istniejących danych żądania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Metoda została wywołana w usługach IIS w wersji starszej niż usług IIS 7.0.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">Aby uzyskać działających w środowisku hostowanym. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : byte[] * int * int -&gt; unit" Usage="httpRequest.InsertEntityBody (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica, która zawiera dane jednostki żądania.</param>
        <param name="offset">Liczony od zera pozycja w <paramref name="buffer" /> jaką rozpocznie się przechowywanie danych jednostki żądania.</param>
        <param name="count">Liczba bajtów do wczytania do <paramref name="buffer" /> tablicy.</param>
        <summary>Udostępnia usług IIS przy użyciu kopii w treści jednostki żądania HTTP i informacje na temat obiektu jednostki żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługi IIS nie przechowuje kopię żądania, po został odczytany. Dlatego zalecane jest, czy tylko obsługa żądania HTTP, powinien przeczytać jednostki żądania.  
  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> Przeciążenie metody jest przydatne w przypadku, gdy chcesz wykonać niestandardowe przetwarzania, takich jak wstawianie treści jednostki do pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Metoda została wywołana w usługach IIS w wersji starszej niż usług IIS 7.0.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> lub <paramref name="count" /> jest liczbą ujemną.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w <paramref name="count" /> jest większa niż dostępne miejsce w <paramref name="buffer" />, danego <paramref name="offset" /> wartość.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">Aby uzyskać działających w środowisku hostowanym. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Web.HttpRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądanie zostało uwierzytelnione.</summary>
        <value><see langword="true" /> Jeśli żądanie jest uwierzytelniane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpRequest.IsAuthenticated%2A> właściwości w celu określenia, czy został uwierzytelniony bieżącego żądania. Jeśli go nie został uwierzytelniony, żądanie jest przekierowywane do innej strony, w którym użytkownik może wprowadzić swoje poświadczenia w aplikacji sieci Web. Jest to typowa technika używana w domyślnej strony aplikacji.  
  
 [!code-csharp[System.Web.HttpRequest_Sample3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Web.HttpRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądanie pochodzi z komputera lokalnego.</summary>
        <value><see langword="true" /> Jeśli żądanie pochodzi z komputera lokalnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.IsLocal%2A> Właściwość zwraca `true` Jeśli adres IP serwera początkowego żądania jest 127.0.0.1 lub adres IP żądania jest taka sama jak adres IP serwera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Web.HttpRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy połączenie HTTP używa bezpiecznych gniazd (czyli HTTPS).</summary>
        <value><see langword="true" /> Jeśli połączenie to połączenie SSL w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu Określa, czy <xref:System.Web.HttpRequest.IsSecureConnection%2A> właściwość jest ustawiona na wartość false. Jeśli tak jest, <xref:System.Web.HttpResponse.SuppressContent%2A> właściwość jest ustawiona na true, aby zatrzymać wysłanie odpowiedzi.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Web.HttpRequest.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Nazwa elementu członkowskiego kolekcji można pobrać.</param>
        <summary>Pobiera określony obiekt z <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" />, lub <see cref="P:System.Web.HttpRequest.ServerVariables" /> kolekcji.</summary>
        <value><see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" />, Lub <see cref="P:System.Web.HttpRequest.ServerVariables" /> członka kolekcji określonego w <paramref name="key" /> parametru. Jeśli określony <paramref name="key" /> nie zostanie znaleziony, następnie <see langword="null" /> jest zwracana.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogonUserIdentity As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::WindowsIdentity ^ LogonUserIdentity { System::Security::Principal::WindowsIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogonUserIdentity : System.Security.Principal.WindowsIdentity" Usage="System.Web.HttpRequest.LogonUserIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.Principal.WindowsIdentity" /> typu dla bieżącego użytkownika.</summary>
        <value>Element <see cref="T:System.Security.Principal.WindowsIdentity" /> obiektu dla bieżącego ustawienia uwierzytelniania usługi Microsoft Internet Information Services (IIS).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.LogonUserIdentity%2A> Właściwość udostępnia właściwości i metod <xref:System.Security.Principal.WindowsIdentity> obiektu dla aktualnie podłączonego użytkownika do Microsoft Internet Information Services (IIS). Wystąpienie <xref:System.Security.Principal.WindowsIdentity> klasę, która jest uwidaczniany przez <xref:System.Web.HttpRequest.LogonUserIdentity%2A> śledzi token żądania usługi IIS i zapewnia łatwy dostęp do tego tokenu dla bieżącego żądania HTTP, trwa przetwarzanie wewnątrz programu ASP.NET. Wystąpienie <xref:System.Security.Principal.WindowsIdentity> klasy jest tworzony automatycznie, więc nie musi zostać do skonstruowane w celu uzyskania dostępu do metod i właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak pobrać <xref:System.Web.HttpRequest.LogonUserIdentity%2A> właściwość dla bieżącego użytkownika i zapisu wartości każdego elementu w pliku tekstowym. Umieść ten kod na stronie ASP.NET, odwołuje się formularza `ACTION` atrybutu.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aplikacja sieci Web jest uruchomiony w trybie zintegrowanym usług IIS 7 i <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> zdarzeń nie został jeszcze zgłoszony.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapImageCoordinates (imageFieldName As String) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ MapImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapImageCoordinates : string -&gt; int[]" Usage="httpRequest.MapImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Nazwa mapy obrazu formularza.</param>
        <summary>Parametr formularz mapy przychodzących pola obrazu odpowiednie wartości współrzędnych x i współrzędne y.</summary>
        <returns>Tablicę dwuwymiarową liczb całkowitych.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mapuje ścieżkę wirtualną w żądany adres URL do ścieżki fizycznej na serwerze dla bieżącego żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpRequest.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna (bezwzględny lub względny) dla bieżącego żądania.</param>
        <summary>Mapuje określonej ścieżki wirtualnej do ścieżki fizycznej.</summary>
        <returns>Ścieżka fizyczna na serwerze określonym przez <paramref name="virtualPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A> Właściwość zawiera potencjalnie poufnych informacji o środowisku macierzystym. Wartość zwracana nie powinien być wyświetlany użytkownikom.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpRequest.MapPath%2A> metodę, aby przekonwertować ścieżkę wirtualną do w pełni kwalifikowanej ścieżki fizycznej na serwerze. W tym przykładzie ma dwie części:  
  
-   Strony .aspx mapuje ścieżkę, odczytuje plik i wyświetla wyniki operacji odczytu.  
  
-   Klasę `UpperCaseFilterStream`, który zmienia wszystkie znaki, przekazany na wielkie litery.  
  
 Pierwsza część przykład pokazuje sposób konwertowania ścieżka wirtualna do w pełni kwalifikowaną ścieżkę fizyczną za pomocą <xref:System.Web.HttpRequest.MapPath%2A> metody. Ta ścieżka fizyczna jest następnie przekazywany do <xref:System.IO.StreamReader> obiektu, który pobiera zawartość pliku. <xref:System.Web.HttpResponse.Write%2A> Następnie wywoływana jest metoda, aby wyświetlić zawartość pliku, na stronie. <xref:System.Web.HttpResponse.Filter%2A> Właściwość będzie używany do dołączania filtru w strumieniu odpowiedzi, który sprawia, że tekst wyświetlany na stronie wszystkie wielkie litery.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 Druga część przykład przedstawia klasę, która dziedziczy z <xref:System.IO.Stream> i konwertuje wszystkie znaki w strumieniu na wielkie litery. Umieść ten kod w `App_Code` folderem w aplikacji.  
  
 [!code-csharp[System.Web.HttpRequest_Samples2#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest_Samples2#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie <see cref="T:System.Web.HttpContext" /> obiekt jest zdefiniowany dla żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String, baseVirtualDir As String, allowCrossAppMapping As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath, System::String ^ baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string * string * bool -&gt; string" Usage="httpRequest.MapPath (virtualPath, baseVirtualDir, allowCrossAppMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna (bezwzględny lub względny) dla bieżącego żądania.</param>
        <param name="baseVirtualDir">Ścieżka katalogu wirtualnego podstawowy używany do rozpoznawania względnych.</param>
        <param name="allowCrossAppMapping"><see langword="true" /> Aby wskazać, że <paramref name="virtualPath" /> może należeć do innej aplikacji; w przeciwnym razie <see langword="false" />.</param>
        <summary>Mapuje określonej ścieżki wirtualnej do ścieżki fizycznej.</summary>
        <returns>Fizyczna ścieżka na serwerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A> Właściwość zawiera potencjalnie poufnych informacji o środowisku macierzystym. Wartość zwracana nie powinien być wyświetlany użytkownikom.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="allowCrossMapping" /> jest <see langword="false" /> i <paramref name="virtualPath" /> należy do innej aplikacji.

—lub— 
Nie <see cref="T:System.Web.HttpContext" /> obiekt jest zdefiniowany dla żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapRawImageCoordinates (imageFieldName As String) As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ MapRawImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapRawImageCoordinates : string -&gt; double[]" Usage="httpRequest.MapRawImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Nazwa pola obrazu.</param>
        <summary>Mapuje przychodzące parametru formularza pole obrazu na odpowiednią x i y wartości współrzędnych.</summary>
        <returns>X i y koordynować wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Params As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Params { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Params : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Params" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję połączone <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" />, i <see cref="P:System.Web.HttpRequest.ServerVariables" /> elementów.</summary>
        <value>Element <see cref="T:System.Collections.Specialized.NameValueCollection" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pary nazwa wartość są dodawane do kolekcji w następującej kolejności:  
  
1.  Parametry ciągu zapytania.  
  
2.  Pola formularza.  
  
3.  Pliki cookie.  
  
4.  Zmiennych serwera.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak w pętli poprzez <xref:System.Web.HttpRequest.Params%2A> właściwości dla strony i sposób wyświetlania każdej pary klucz/wartość.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Params#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Params#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Path : string" Usage="System.Web.HttpRequest.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę wirtualną bieżącego żądania.</summary>
        <value>Ścieżka wirtualna bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.Path%2A> Jest łączenie <xref:System.Web.HttpRequest.FilePath%2A> i <xref:System.Web.HttpRequest.PathInfo%2A> przyczepy. Na przykład adres URL http://www.contoso.com/virdir/page.html/tail, <xref:System.Web.HttpRequest.Path%2A> jest /virdir/page.html/tail.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpUtility.HtmlEncode%2A> metodę do zakodowania w formacie HTML wartość <xref:System.Web.HttpRequest.Path%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metodę, aby zapisać zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathInfo : string" Usage="System.Web.HttpRequest.PathInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dodatkowe informacje o ścieżce dla zasobu z rozszerzeniem URL.</summary>
        <value>Dodatkowe informacje o ścieżce dla zasobu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać adres URL Http://www.contoso.com/virdir/page.html/tail, <xref:System.Web.HttpRequest.PathInfo%2A> wartość /tail.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy <xref:System.Web.HttpRequest.PathInfo%2A> właściwość zawiera pusty ciąg. Jeśli tak jest, <xref:System.IO.StreamWriter.Write%2A> metoda zapisuje ciąg wskazujący to do pliku. Jeśli nie, <xref:System.Web.HttpUtility.HtmlEncode%2A> metoda HTML koduje wartość <xref:System.Web.HttpRequest.PathInfo%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metoda zapisuje wartość zakodowana w pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest_Sample1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalApplicationPath : string" Usage="System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę pliku fizycznego systemu katalog główny aktualnie realizowanej aplikacji serwera.</summary>
        <value>Ścieżka systemu plików z katalogu głównego bieżącej aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpUtility.HtmlEncode%2A> metodę do zakodowania w formacie HTML wartość <xref:System.Web.HttpRequest.PhysicalApplicationPath%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metodę, aby zapisać zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalPath : string" Usage="System.Web.HttpRequest.PhysicalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera fizyczną ścieżkę systemu plików odpowiadający żądanego adresu URL.</summary>
        <value>Ścieżka systemu plików bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W scenariuszach przekierowania za pomocą <xref:System.Web.HttpServerUtility.Execute%2A> i <xref:System.Web.HttpServerUtility.Transfer%2A>, <xref:System.Web.HttpRequest.PhysicalPath%2A> właściwość zwraca ścieżkę do oryginalnej strony. Aby znaleźć ścieżkę fizyczną aktualnie wykonywanej strony używają <xref:System.Web.HttpRequest.MapPath%2A> metody za pomocą argumentu wejściowego zestawu jako <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpUtility.HtmlEncode%2A> metodę do zakodowania w formacie HTML wartość <xref:System.Web.HttpRequest.PhysicalPath%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metodę, aby zapisać zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.MapPath(System.String)" />
        <altmember cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zmiennych ciągu zapytania HTTP.</summary>
        <value>Zmiennych ciągu zapytania wysłane przez klienta. Klucze i wartości są zdekodowany adresu URL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje dwa sposoby uzyskania wartość zmiennej ciągu zapytania o nazwie "imię i nazwisko". W każdym przypadku, gdy adres URL jest `http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri`, wówczas wartość zwracana jest "Fadi Fakhouri", ponieważ `%20` jest dekodowana adres URL do znak spacji. Jeśli nie ma adresu URL `fullname` identyfikator ciągu zapytania o dane, zwrócona wartość będzie wynosić `null`.  
  
 Pierwszy wiersz kodu szuka klucza "imię i nazwisko" tylko w ciągu zapytania; drugi wiersz szuka klucza "imię i nazwisko" we wszystkich kolekcjach żądania HTTP. Aby uzyskać więcej informacji na temat drugi wiersz zobacz <xref:System.Web.HttpRequest.Item%2A>.  
  
```csharp  
string fullname1 = Request.QueryString["fullname"];  
string fullname2 = Request["fullname"];  
  
```  
  
```vb  
Dim fullname1 As String = Request.QueryString("fullname")  
Dim fullname2 As String = Request("fullname")  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Web.HttpRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera z pierwotnym adresem URL bieżącego żądania.</summary>
        <value>Z pierwotnym adresem URL bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwotnym adresem URL jest definiowana jako część adresu URL następujące informacje o domenie. W ciągu adresu URL http://www.contoso.com/articles/recent.aspx, pierwotnym adresem URL jest /articles/recent.aspx. Pierwotnym adresem URL zawiera ciąg zapytania, jeśli jest obecny.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpUtility.HtmlEncode%2A> metodę do zakodowania w formacie HTML wartość <xref:System.Web.HttpRequest.RawUrl%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metodę, aby zapisać zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadEntityBodyMode As ReadEntityBodyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ReadEntityBodyMode ReadEntityBodyMode { System::Web::ReadEntityBodyMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadEntityBodyMode : System.Web.ReadEntityBodyMode" Usage="System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje, czy treść jednostki żądania został odczytany i jeśli tak, jak została ona odczytana.</summary>
        <value>Wartość, która wskazuje sposób treści jednostki żądania odczytu lub że nie ma go odczytać.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana w celu uniknięcia wyjątek, który jest generowany, jeśli została już odczytana treść jednostki i odczytywać je przy użyciu niezgodna metoda zostanie podjęta próba. Metody i właściwości, które będzie odczytywał element body encji są następujące:  
  
-   <xref:System.Web.HttpRequest.Form%2A> Właściwości.  
  
-   <xref:System.Web.HttpRequest.Files%2A> Właściwości.  
  
-   <xref:System.Web.HttpRequest.InputStream%2A> Właściwości.  
  
-   <xref:System.Web.HttpRequest.GetBufferedInputStream%2A> Metody.  
  
-   <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> Metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); void set(System::Web::Routing::RequestContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.Web.Routing.RequestContext with get, set" Usage="System.Web.HttpRequest.RequestContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.Routing.RequestContext" /> wystąpienia bieżącego żądania.</summary>
        <value><see cref="T:System.Web.Routing.RequestContext" /> Wystąpienia bieżącego żądania. W przypadku żądań nietrasowanego <see cref="T:System.Web.Routing.RequestContext" /> obiekt, który jest zwracany jest pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia dostęp do <xref:System.Web.Routing.RouteData> obiektu dla bieżącego żądania. Aby uzyskać więcej informacji na temat routingu platformy ASP.NET zobacz. [Routingu platformy ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Przewodnik: Za pomocą routingu w aplikacji formularzy sieci Web platformy ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/dc88e6ba-470c-4b20-b644-35874cfd781d">Instrukcje: Dostęp do parametrów adresu URL na stronie trasowane</related>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RequestType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestType : string with get, set" Usage="System.Web.HttpRequest.RequestType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia metodę transferu danych HTTP (<see langword="GET" /> lub <see langword="POST" />) używany przez klienta.</summary>
        <value>Ciąg reprezentujący typ wywołania HTTP wysłane przez klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpUtility.HtmlEncode%2A> metodę do zakodowania w formacie HTML wartość <xref:System.Web.HttpRequest.RequestType%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metodę, aby zapisać zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveAs (filename As String, includeHeaders As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAs(System::String ^ filename, bool includeHeaders);" />
      <MemberSignature Language="F#" Value="member this.SaveAs : string * bool -&gt; unit" Usage="httpRequest.SaveAs (filename, includeHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Ścieżka dysku fizycznego.</param>
        <param name="includeHeaders">Wartość logiczna określająca, czy nagłówek HTTP powinny być zapisywane na dysku.</param>
        <summary>Żądanie HTTP zapisuje na dysku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zapisywanie kontekstu żądania na dysku może być przydatne podczas debugowania.  
  
   
  
## Examples  
 Poniższy kod wywoła przykład <xref:System.Web.HttpRequest.SaveAs%2A> metoda po załadowaniu strony. Wywołanie Określa, że żądania można zapisać jako plik tekstowy w katalogu, w którym tożsamości procesu ASP.NET przyznano uprawnienia do zapisu i że wszystkie informacje nagłówka w żądaniu uwzględniono znajduje się w pliku.  
  
 [!code-csharp[System.Web.HttpRequest_Sample6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" /> Właściwość <see cref="T:System.Web.Configuration.HttpRuntimeSection" /> ustawiono <see langword="true" /> , ale <paramref name="filename" /> nie jest ścieżką bezwzględną.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServerVariables As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ ServerVariables { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServerVariables : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.ServerVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zmiennych serwera sieci Web.</summary>
        <value>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> zmiennych serwera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę zmiennych serwera obsługiwane przez usługi IIS, zobacz [zmienne serwera usług IIS](https://go.microsoft.com/fwlink/?LinkId=52471).  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla nazwy i wartości wszystkich zmiennych nazwanym serwerze.  
  
 [!code-csharp[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimedOutToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken TimedOutToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TimedOutToken : System.Threading.CancellationToken" Usage="System.Web.HttpRequest.TimedOutToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.CancellationToken" /> obiekt, który jest uruchomiony, gdy upłynie limit czasu żądania.</summary>
        <value>Token anulowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Limit czasu można określić w pliku Web.config (zobacz <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=nameWithType>) lub programowo (zobacz <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>). Limit czasu jest mierzony od momentu, gdy żądanie jest oferowana w. Jeśli obowiązuje domyślny limit czasu w sekundach 110, token anulowania zostanie nie wcześniej niż 110 sekund po rozpoczęciu przetwarzania żądania wyzwolenia. Możesz zmienić <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType> wartości właściwości i jak długo ten token nie zostało jeszcze uruchomiony, obowiązują nowej wartości limitu czasu.  
  
 Token udostępnia obecnie 15 drugiego stopnia szczegółowości, oznacza to, że jeśli wartość limitu czasu wynosi 110 sekund, token, zostanie uruchomiony jakiś czas między 110 i 125 sekund po rozpoczęciu przetwarzania żądania. Stopień szczegółowości mogą ulec zmianie w przyszłości.  
  
 Mimo że ta właściwość jest metodą o bezpiecznych wątkach, istnieją ograniczenia związane z jego użyciem. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=nameWithType>.  
  
 Ta właściwość jest bez znaczenia, jeśli rozpoczął przetwarzanie żądania funkcji WebSockets.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TlsTokenBindingInfo As ITlsTokenBindingInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ITlsTokenBindingInfo ^ TlsTokenBindingInfo { System::Web::ITlsTokenBindingInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TlsTokenBindingInfo : System.Web.ITlsTokenBindingInfo" Usage="System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o wiązaniu tokenu protokołu TLS. Właściwość umożliwia aplikacjom, które można pobrać tokenu informacje z przychodzących żądań HTTP dla rozszerzone uwierzytelnianie.</summary>
        <value>Token powiązania dla bieżącego połączenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `null` na platformach innych niż windows10.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalBytes As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TotalBytes { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalBytes : int" Usage="System.Web.HttpRequest.TotalBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę bajtów w bieżącym strumienia wejściowego.</summary>
        <value>Liczba bajtów w strumieniu wejściowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu Określa, czy <xref:System.Web.HttpRequest.TotalBytes%2A> wartość właściwości jest większa niż 1000 bajtów i zapisuje te informacje w pliku.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest_Sample1#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Unvalidated As UnvalidatedRequestValues" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UnvalidatedRequestValues ^ Unvalidated { System::Web::UnvalidatedRequestValues ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unvalidated : System.Web.UnvalidatedRequestValues" Usage="System.Web.HttpRequest.Unvalidated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartości żądania HTTP bez powodowania weryfikacji żądań.</summary>
        <value>Wartości żądania HTTP, które nie zostały sprawdzone za pomocą weryfikacji żądań.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żądanie przeprowadzenia weryfikacji pod kątem kodu znaczników HTML i skryptu, które mogą wskazywać na potencjalny atak skryptów między witrynami. Domyślnie sprawdzane są wszystkie wartości, przy użyciu weryfikacji żądań, i jeśli wszystkie wartości zawierają kod znaczników lub skrypt, program ASP.NET zgłasza <xref:System.Web.HttpRequestValidationException> wyjątku. Użyj tej metody, jeśli spodziewasz się, że żądanie będzie zawierać znaczników (na przykład umożliwi użytkownikom wysyłanie zawartości, który zawiera kod znaczników) i chcesz przenosić nieprzetworzonej wartości żądania.  
  
> [!IMPORTANT]
>  Jeśli używasz tej właściwości, możesz ręcznie sprawdzić dane na wypadek potencjalnych ataków skryptów między witrynami.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Web.HttpRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o adresie URL bieżącego żądania.</summary>
        <value>A <see cref="T:System.Uri" /> obiekt, który zawiera adres URL bieżącego żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przypisuje przykład <xref:System.Uri> obiektu bieżące żądanie do zmiennej obiektu i wyświetla wartość dwie właściwości adresu URL obiektu wyniku HTTP.  
  
 [!code-csharp[Classic HttpRequest.Url Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
        <altmember cref="P:System.Web.HttpRequest.RawUrl" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Web.HttpRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o adresie URL poprzedniego żądania klienta, który jest połączony z bieżącym adresem URL.</summary>
        <value>Element <see cref="T:System.Uri" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wyświetla wartość dwie właściwości adresu URL określonego klienta bieżącej aplikacji.  
  
 [!code-csharp[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">HTTP <see langword="Referer" /> nagłówek żądania jest uszkodzony i nie można przekonwertować na <see cref="T:System.Uri" /> obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Web.HttpRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg agenta użytkownika raw, przeglądarki klienta, który został dostarczony. Należy pamiętać, że może to być wartość null.</summary>
        <value>Ciąg agenta użytkownika pierwotnych w przeglądarce klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod przypisuje identyfikator typu przeglądarki do zmiennej ciągu.  
  
 [!code-csharp[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">Formanty serwera ASP.NET i możliwości przeglądarki</related>
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Web.HttpRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres IP hosta zdalnego klienta.</summary>
        <value>Adres IP klienta zdalnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpUtility.HtmlEncode%2A> metodę do zakodowania w formacie HTML wartość <xref:System.Web.HttpRequest.UserHostAddress%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metodę, aby zapisać zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Web.HttpRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę DNS klienta zdalnego.</summary>
        <value>Nazwa DNS klienta zdalnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpUtility.HtmlEncode%2A> metodę do zakodowania w formacie HTML wartość <xref:System.Web.HttpRequest.UserHostName%2A> właściwości i <xref:System.IO.TextWriter.WriteLine%2A> metodę, aby zapisać zakodowaną wartość do pliku. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Web.HttpRequest> klasy.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Web.HttpRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg posortowaną tablicę Preferencje językowe klienta.</summary>
        <value>Ciąg posortowaną tablicę Preferencje językowe klienta, lub <see langword="null" /> Jeśli jest pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu rejestruje wiele wartości zwracanych przez <xref:System.Web.HttpRequest.UserLanguages%2A> właściwość w tablicy ciągów i zapisy w osobnym wierszu danych wyjściowych HTTP nazwę każdego z języków.  
  
 Nazwy języka są dostarczane przez przeglądarkę, i nie ma ostateczne listy wszystkich możliwych kodów.  Te składają się zazwyczaj z kodów dwuznakowy, języka, łącznik i dwóch znakowy kod dla kultury, takie jak "en-us" dla Stanów Zjednoczonych Język angielski i "fr-ca" Francuski (kanadyjski).  
  
 [!code-csharp[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateInput();" />
      <MemberSignature Language="F#" Value="member this.ValidateInput : unit -&gt; unit" Usage="httpRequest.ValidateInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że sprawdzanie poprawności jest wykonywane dla kolekcji, dostępne za pośrednictwem <see cref="P:System.Web.HttpRequest.Cookies" />, <see cref="P:System.Web.HttpRequest.Form" />, i <see cref="P:System.Web.HttpRequest.QueryString" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest> Klasy używa flagi walidacji danych wejściowych do śledzenia, czy ma być przeprowadzane sprawdzanie poprawności w kolekcjach żądania, dostępne za pośrednictwem <xref:System.Web.HttpRequest.Cookies%2A>, <xref:System.Web.HttpRequest.Form%2A>, i <xref:System.Web.HttpRequest.QueryString%2A> właściwości. <xref:System.Web.HttpRequest.ValidateInput%2A> Metoda ustawia tych flag, tak że w przypadku metody dostępu get dla <xref:System.Web.HttpRequest.Cookies%2A>, <xref:System.Web.HttpRequest.Form%2A>, lub <xref:System.Web.HttpRequest.QueryString%2A> właściwości są wywoływane, odbywa się sprawdzenie poprawności danych wejściowych. Sprawdzanie poprawności działa, sprawdzając wszystkie dane wejściowe zakodowane listą potencjalnie niebezpiecznych danych.  
  
 Włączenie funkcji weryfikacji przez dyrektywy strony lub Konfiguracja ta metoda jest wywoływana podczas strony `ProcessRequest` fazy przetwarzania. <xref:System.Web.HttpRequest.ValidateInput%2A> Metoda może być wywoływana przez kod, jeśli nie włączono funkcji sprawdzania poprawności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">Potencjalnie niebezpiecznych danych została odebrana od klienta.</exception>
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
  </Members>
</Type>
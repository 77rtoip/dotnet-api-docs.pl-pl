<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata><Meta Name="ms.openlocfilehash" Value="817f7a6b1aa88a3245bba49d3bc0716c95233c22" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69410249" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <TypeSignature Language="F#" Value="type HttpServerUtility = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia metody pomocnika do przetwarzania żądań sieci Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody i właściwości <xref:System.Web.HttpServerUtility> klasy są udostępniane za pomocą obiektu wewnętrznego <xref:System.Web.HttpContext.Server%2A> dostarczonego przez ASP.NET.  
  
   
  
## Examples  
 Projekt witryny sieci Web programu Visual Studio z kodem źródłowym jest dostępny do załączenia do tego tematu: [Pobierz](https://go.microsoft.com/fwlink/?LinkId=192870).  
  
 Poniższy przykład ilustruje sposób użycia <xref:System.Web.HttpServerUtility.HtmlEncode%2A> metody <xref:System.Web.HttpServerUtility.UrlEncode%2A> i metody <xref:System.Web.HttpServerUtility> klasy. <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Metoda pomaga upewnić się, że wszelkie dane wejściowe ciągu dostarczone przez użytkownika będą renderowane jako tekst statyczny w przeglądarkach zamiast skryptu wykonywalnego lub elementów HTML. <xref:System.Web.HttpServerUtility.UrlEncode%2A> Metoda koduje adresy URL w taki sposób, że są one prawidłowo przesyłane w strumieniu http.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpServerUtility.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści poprzedni wyjątek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład czyści ostatni zgłoszony wyjątek.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie serwera obiektu COM.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : string -&gt; obj" Usage="httpServerUtility.CreateObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Klasa lub typ obiektu, dla którego ma zostać utworzone wystąpienie.</param>
        <summary>Tworzy wystąpienie serwera obiektu COM identyfikowane przez identyfikator programowy (ProgID) obiektu.</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy obiekt przy użyciu identyfikatora ProgID obiektu.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie można utworzyć wystąpienia obiektu.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : Type -&gt; obj" Usage="httpServerUtility.CreateObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Reprezentujący obiekt, który ma zostać utworzony.</param>
        <summary>Tworzy wystąpienie serwera obiektu COM identyfikowane przez typ obiektu.</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectFromClsid : string -&gt; obj" Usage="httpServerUtility.CreateObjectFromClsid clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator klasy obiektu, dla którego ma zostać utworzone wystąpienie.</param>
        <summary>Tworzy wystąpienie serwera obiektu COM identyfikowane przez identyfikator klasy obiektu (CLSID).</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> metody w celu utworzenia wystąpienia serwera obiektu com.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie można utworzyć wystąpienia obiektu.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje procedurę obsługi dla określonego zasobu w kontekście bieżącego żądania i zwraca wykonanie do strony, która ją wywołała.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Execute : string -&gt; unit" Usage="httpServerUtility.Execute path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <summary>Wykonuje procedurę obsługi dla określonej ścieżki wirtualnej w kontekście bieżącego żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Metoda kontynuuje wykonywanie oryginalnej strony po zakończeniu wykonywania nowej strony. <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda bezwarunkowo przesyła wykonywanie do innego programu obsługi.  
  
 ASP.NET nie sprawdza, czy bieżący użytkownik ma uprawnienia do wyświetlania zasobu dostarczonego przez <xref:System.Web.HttpServerUtility.Execute%2A> metodę. Chociaż logika autoryzacji i uwierzytelniania ASP.NET jest uruchamiana przed wywołaniem oryginalnej obsługi zasobów, ASP.NET bezpośrednio wywołuje procedurę obsługi wskazywaną <xref:System.Web.HttpServerUtility.Execute%2A> przez metodę i nie uruchamia ponownie logiki uwierzytelniania i autoryzacji dla nowego zasoby. Jeśli zasady zabezpieczeń aplikacji wymagają, aby klienci mieli odpowiednią autoryzację w celu uzyskania dostępu do zasobu, aplikacja powinna wymusić ponowne autoryzację lub udostępnić niestandardowy mechanizm kontroli dostępu.  
  
 Można wymusić ponowną autoryzację <xref:System.Web.HttpResponse.Redirect%2A> przy użyciu metody zamiast <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A>Wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe żądanie wprowadzone do systemu, jest ono poddawane całej logiki uwierzytelniania i autoryzacji zarówno dla Internet Information Services (IIS), jak i zasad zabezpieczeń ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobu przez włączenie niestandardowej metody autoryzacji, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody, zanim aplikacja <xref:System.Web.HttpServerUtility.Execute%2A> wywoła metodę.  
  
   
  
## Examples  
 Poniższy przykład wyświetla stronę aspx "UPDATEINFO. aspx" w bieżącym katalogu. Wykonanie programu wraca do strony początkowej po wyświetleniu strony UPDATEINFO. aspx.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżąca <see cref="T:System.Web.HttpContext" /> wartość to <see langword="null" />.  
  
—lub— 
Wystąpił błąd podczas wykonywania procedury obsługi określonej przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="path" />nie jest ścieżką wirtualną.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * bool -&gt; unit" Usage="httpServerUtility.Execute (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <param name="preserveForm"><see langword="true" />Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> kolekcje i <see cref="P:System.Web.HttpRequest.Form" /> ; Aby wyczyścić kolekcje<see cref="P:System.Web.HttpRequest.Form" /> i. <see cref="P:System.Web.HttpRequest.QueryString" /> <see langword="false" /></param>
        <summary>Wykonuje procedurę obsługi dla określonej ścieżki wirtualnej w kontekście bieżącego żądania i określa, czy należy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> kolekcje i. <see cref="P:System.Web.HttpRequest.Form" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak wykonać stronę `Updateinfo.aspx` . aspx w bieżącym żądaniu i <xref:System.Web.HttpRequest.QueryString%2A> zachować kolekcje i <xref:System.Web.HttpRequest.Form%2A> . Wykonanie programu wraca do strony początkowej po `Updateinfo.aspx` wyświetleniu.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżąca <see cref="T:System.Web.HttpContext" /> wartość to <see langword="null" />.  
  
—lub— 
Wystąpił błąd podczas wykonywania procedury obsługi określonej przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="path" />nie jest ścieżką wirtualną.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.Execute (path, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <param name="writer">W <see cref="T:System.IO.TextWriter" /> celu przechwycenia danych wyjściowych.</param>
        <summary>Wykonuje procedurę obsługi dla określonej ścieżki wirtualnej w kontekście bieżącego żądania. <see cref="T:System.IO.TextWriter" /> Przechwytuje dane wyjściowe z wykonanej procedury obsługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Metoda kontynuuje wykonywanie oryginalnego żądania po zakończeniu wykonywania określonej ścieżki wirtualnej. <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda bezwarunkowo przesyła wykonywanie do innego programu obsługi.  
  
 ASP.NET nie sprawdza, czy bieżący użytkownik ma uprawnienia do wyświetlania zasobu dostarczonego przez <xref:System.Web.HttpServerUtility.Execute%2A> metodę. Chociaż logika autoryzacji i uwierzytelniania ASP.NET jest uruchamiana przed wywołaniem oryginalnej obsługi zasobów, ASP.NET bezpośrednio wywołuje procedurę obsługi wskazywaną <xref:System.Web.HttpServerUtility.Execute%2A> przez metodę i nie uruchamia ponownie logiki uwierzytelniania i autoryzacji dla nowego zasoby. Jeśli zasady zabezpieczeń aplikacji wymagają, aby klienci mieli odpowiednią autoryzację w celu uzyskania dostępu do zasobu, aplikacja powinna wymusić ponowne autoryzację lub udostępnić niestandardowy mechanizm kontroli dostępu.  
  
 Można wymusić ponowną autoryzację <xref:System.Web.HttpResponse.Redirect%2A> przy użyciu metody zamiast <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A>Wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe żądanie wprowadzone do systemu, jest ono poddawane całej logiki uwierzytelniania i autoryzacji zarówno dla Internet Information Services (IIS), jak i zasad zabezpieczeń ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobu przez włączenie niestandardowej metody autoryzacji, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody, zanim aplikacja <xref:System.Web.HttpServerUtility.Execute%2A> wywoła metodę.  
  
   
  
## Examples  
 Poniższy przykład wykonuje `Login.aspx` stronę na serwerze w bieżącym katalogu i odbiera dane wyjściowe ze strony <xref:System.IO.StringWriter> za pośrednictwem obiektu `writer`. Zapisuje strumień HTML otrzymany z `writer` do strumienia wyjściowego http.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżąca <see cref="T:System.Web.HttpContext" /> wartość to <see langword="null" />.  
  
—lub— 
Wystąpił błąd podczas wykonywania procedury obsługi określonej przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="path" />nie jest ścieżką wirtualną.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (path, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <param name="writer">W <see cref="T:System.IO.TextWriter" /> celu przechwycenia danych wyjściowych.</param>
        <param name="preserveForm"><see langword="true" />Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> kolekcje i <see cref="P:System.Web.HttpRequest.Form" /> ; Aby wyczyścić kolekcje<see cref="P:System.Web.HttpRequest.Form" /> i. <see cref="P:System.Web.HttpRequest.QueryString" /> <see langword="false" /></param>
        <summary>Wykonuje procedurę obsługi dla określonej ścieżki wirtualnej w kontekście bieżącego żądania. Przechwytuje dane wyjściowe ze strony i parametru logicznego określa, czy należy <see cref="P:System.Web.HttpRequest.QueryString" /> wyczyścić kolekcje i <see cref="P:System.Web.HttpRequest.Form" />. <see cref="T:System.IO.TextWriter" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Metoda kontynuuje wykonywanie oryginalnego żądania po zakończeniu wykonywania określonej ścieżki wirtualnej. <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda bezwarunkowo przesyła wykonywanie do innego programu obsługi.  
  
 ASP.NET nie sprawdza, czy bieżący użytkownik ma uprawnienia do wyświetlania zasobu dostarczonego przez <xref:System.Web.HttpServerUtility.Execute%2A> metodę. Chociaż logika autoryzacji i uwierzytelniania ASP.NET jest uruchamiana przed wywołaniem oryginalnej obsługi zasobów, ASP.NET bezpośrednio wywołuje procedurę obsługi wskazywaną <xref:System.Web.HttpServerUtility.Execute%2A> przez metodę i nie uruchamia ponownie logiki uwierzytelniania i autoryzacji dla nowego zasoby. Jeśli zasady zabezpieczeń aplikacji wymagają, aby klienci mieli odpowiednią autoryzację w celu uzyskania dostępu do zasobu, aplikacja powinna wymusić ponowne autoryzację lub udostępnić niestandardowy mechanizm kontroli dostępu.  
  
 Można wymusić ponowną autoryzację <xref:System.Web.HttpResponse.Redirect%2A> przy użyciu metody zamiast <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A>Wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe żądanie wprowadzone do systemu, jest ono poddawane całej logiki uwierzytelniania i autoryzacji zarówno dla Internet Information Services (IIS), jak i zasad zabezpieczeń ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobu przez włączenie niestandardowej metody autoryzacji, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody, zanim aplikacja <xref:System.Web.HttpServerUtility.Execute%2A> wywoła metodę.  
  
   
  
## Examples  
 Poniższy przykład wykonuje `Login.aspx` stronę na serwerze w bieżącym katalogu i odbiera dane wyjściowe ze strony <xref:System.IO.StringWriter> za pośrednictwem obiektu `writer`. Zapisuje strumień HTML otrzymany z `writer` do strumienia wyjściowego http. Zawartość <xref:System.Web.HttpRequest.Form%2A> kolekcji i <xref:System.Web.HttpRequest.QueryString%2A> są zachowywane.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżąca <see cref="T:System.Web.HttpContext" /> jest odwołaniem o wartości null<see langword="Nothing" /> (w Visual Basic).  
  
—lub— 
 <paramref name="path" />kończące się kropką (.).  
  
—lub— 
Wystąpił błąd podczas wykonywania procedury obsługi określonej przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />nie jest ścieżką wirtualną.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : System.Web.IHttpHandler * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (handler, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Program obsługi protokołu HTTP implementujący <see cref="T:System.Web.IHttpHandler" /> do transferu bieżącego żądania do.</param>
        <param name="writer">W <see cref="T:System.IO.TextWriter" /> celu przechwycenia danych wyjściowych.</param>
        <param name="preserveForm"><see langword="true" />Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> kolekcje i <see cref="P:System.Web.HttpRequest.Form" /> ; Aby wyczyścić kolekcje<see cref="P:System.Web.HttpRequest.Form" /> i. <see cref="P:System.Web.HttpRequest.QueryString" /> <see langword="false" /></param>
        <summary>Wykonuje procedurę obsługi dla określonej ścieżki wirtualnej w kontekście bieżącego żądania. Przechwytuje dane wyjściowe z wykonywanej procedury obsługi i parametru logicznego określa, <see cref="P:System.Web.HttpRequest.QueryString" /> czy należy wyczyścić kolekcje i <see cref="P:System.Web.HttpRequest.Form" />. <see cref="T:System.IO.TextWriter" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można napisać niestandardowe programy obsługi HTTP do przetwarzania określonych, wstępnie zdefiniowanych typów żądań HTTP w dowolnym języku, który jest zgodny z Common Language Specification (CLS). Kod wykonywalny, który jest zdefiniowany w klasach obsługi HTTP zamiast konwencjonalnych stron ASP (nazywanych również klasycznymi ASP) lub stron ASP.NET odpowiada na te konkretne żądania. Procedury obsługi protokołu HTTP umożliwiają współdziałanie z usługami żądania i odpowiedzi niskiego poziomu na serwerze sieci Web, na którym działa program Internet Information Services (IIS) i udostępnia funkcje podobne do rozszerzeń ISAPI, ale z prostszym modelem programowania.  
  
 ASP.NET nie sprawdza, czy bieżący użytkownik ma uprawnienia do wyświetlania zasobu, który jest dostarczany przez <xref:System.Web.HttpServerUtility.Execute%2A> metodę. Mimo że logika autoryzacji i uwierzytelniania ASP.NET jest uruchamiana przed wywołaniem oryginalnej obsługi zasobów, ASP.NET bezpośrednio wywołuje procedurę obsługi, która jest <xref:System.Web.HttpServerUtility.Execute%2A> wskazywana przez metodę i nie uruchamia ponownie logiki uwierzytelniania i autoryzacji dla nowy zasób. Jeśli zasady zabezpieczeń dla aplikacji wymagają, aby klienci mieli odpowiednią autoryzację w celu uzyskania dostępu do zasobu, aplikacja powinna wymusić ponowne autoryzację lub udostępnić niestandardowy mechanizm kontroli dostępu.  
  
 Można wymusić ponowną autoryzację <xref:System.Web.HttpResponse.Redirect%2A> przy użyciu metody zamiast <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe żądanie wprowadzone do systemu, jest ono poddawane całej logiki uwierzytelniania i autoryzacji zarówno dla zasad zabezpieczeń usług IIS, jak i ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobu przez włączenie niestandardowej metody autoryzacji, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody, zanim aplikacja <xref:System.Web.HttpServerUtility.Execute%2A> wywoła metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Wystąpił błąd podczas wykonywania procedury obsługi określonej przez <paramref name="handler" />.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="handler" /></exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberSignature Language="F#" Value="member this.GetLastError : unit -&gt; Exception" Usage="httpServerUtility.GetLastError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca poprzedni wyjątek.</summary>
        <returns>Poprzedni wyjątek, który został zgłoszony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład drukuje opis ostatniego błędu aplikacji w strumieniu wyjściowym protokołu HTTP. W przypadku wystąpienia błędów nie są drukowane żadne błędy.  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje ciąg, który został zakodowany w celu wyeliminowania nieprawidłowych znaków HTML.  
  
Aby zakodować lub zdekodować wartości poza aplikacją sieci Web, <see cref="T:System.Net.WebUtility" /> należy użyć klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string -&gt; string" Usage="httpServerUtility.HtmlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg HTML do zdekodowania.</param>
        <summary>Dekoduje ciąg zakodowany w formacie HTML i zwraca zdekodowany ciąg.</summary>
        <returns>Zdekodowany tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML pozwala upewnić się, że tekst jest prawidłowo wyświetlany w przeglądarce i nie jest interpretowany przez przeglądarkę jako HTML. Na przykład, jeśli ciąg tekstowy zawiera znak mniejszości (\<) lub znak większości (>), przeglądarka interpretuje te znaki jako nawias otwierający lub zamykający tag HTML. Gdy znaki są kodowane w języku HTML, są konwertowane na ciągi `&lt;` i `&gt;`, co powoduje, że przeglądarka wyświetla znak mniejszości i jest większy niż znak prawidłowy. <xref:System.Web.HttpServerUtility.HtmlDecode%2A>Dekoduje tekst, który został przesłany do serwera.  
  
 Ta metoda jest wygodnym sposobem uzyskiwania dostępu <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> do metody w czasie wykonywania z poziomu aplikacji ASP.NET. Wewnętrznie, ta metoda używa <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> do dekodowania ciągów.  
  
 W pliku związanym z kodem dla strony sieci Web ASP.NET, uzyskaj dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy `Server` za pomocą właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, `HttpContext.Current.Server` Użyj, aby uzyskać dostęp do <xref:System.Web.HttpServerUtility> wystąpienia klasy.  
  
 Na zewnątrz aplikacji sieci Web, użyj <xref:System.Net.WebUtility> klasy do kodowania lub dekodowania wartości.  
  
   
  
## Examples  
 Poniższy przykład zawiera funkcję `LoadDecodedFile`, która dekoduje dane z pliku i kopiuje go do jednego ciągu.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg HTML do zdekodowania.</param>
        <param name="output">Strumień <see cref="T:System.IO.TextWriter" /> wyjściowy zawierający zdekodowany ciąg.</param>
        <summary>Dekoduje ciąg zakodowany w formacie HTML i wysyła wynikowe dane wyjściowe <see cref="T:System.IO.TextWriter" /> do strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML pozwala upewnić się, że tekst jest prawidłowo wyświetlany w przeglądarce i nie jest interpretowany przez przeglądarkę jako HTML. Na przykład, jeśli ciąg tekstowy zawiera znak mniejszości (\<) lub znak większości (>), przeglądarka interpretuje te znaki jako nawias otwierający lub zamykający tag HTML. Gdy znaki są kodowane w języku HTML, są konwertowane na ciągi `&lt;` i `&gt;`, co powoduje, że przeglądarka wyświetla znak mniejszości i jest większy niż znak prawidłowy.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A>Dekoduje tekst, który został przesłany do serwera.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A>jest wygodnym sposobem uzyskania dostępu <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> do metody w czasie wykonywania z poziomu aplikacji ASP.NET. <xref:System.Web.HttpServerUtility.HtmlDecode%2A> Wewnętrznie używa <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> do zdekodowania ciągów.  
  
 Aby zakodować lub zdekodować wartości poza aplikacją sieci Web, <xref:System.Net.WebUtility> należy użyć klasy.  
  
   
  
## Examples  
 Poniższy przykład Dekoduje ciąg, który został zakodowany w formacie HTML na potrzeby przesyłania za pośrednictwem protokołu HTTP. Dekoduje podany ciąg o `EncodedString` nazwie, który zawiera tekst "to &lt;jest ciąg&gt;testowy." i kopiuje go do ciągu o nazwie `DecodedString` "to jest \<ciąg testowy >.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje ciąg, który ma być wyświetlany w przeglądarce.  
  
Aby zakodować lub zdekodować wartości poza aplikacją sieci Web, <see cref="T:System.Net.WebUtility" /> należy użyć klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string -&gt; string" Usage="httpServerUtility.HtmlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg tekstowy do zakodowania.</param>
        <summary>HTML — koduje ciąg i zwraca zakodowany ciąg.</summary>
        <returns>Tekst zakodowany w formacie HTML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML pozwala upewnić się, że tekst jest prawidłowo wyświetlany w przeglądarce i nie jest interpretowany przez przeglądarkę jako HTML. Na przykład, jeśli ciąg tekstowy zawiera znak mniejszości (\<) lub znak większości (>), przeglądarka interpretuje te znaki jako nawias otwierający lub zamykający tag HTML. Gdy znaki są kodowane w języku HTML, są konwertowane na ciągi `&lt;` i `&gt;`, co powoduje, że przeglądarka wyświetla znak mniejszości i jest większy niż znak prawidłowy.  
  
 Ta metoda jest wygodnym sposobem uzyskiwania dostępu <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> do metody w czasie wykonywania z poziomu aplikacji ASP.NET. Wewnętrznie, ta metoda używa <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> do kodowania ciągów.  
  
 W pliku związanym z kodem dla strony sieci Web ASP.NET, uzyskaj dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy `Server` za pomocą właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, `HttpContext.Current.Server` Użyj, aby uzyskać dostęp do <xref:System.Web.HttpServerUtility> wystąpienia klasy.  
  
 Na zewnątrz aplikacji sieci Web, użyj <xref:System.Net.WebUtility> klasy do kodowania lub dekodowania wartości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak HTML-kodować wartość, która potencjalnie kod niebezpieczny. Kod znajduje się w pliku związanym z kodem dla strony sieci Web. Wartość do kodowania jest zakodowana w tym przykładzie tylko w celu uproszczenia przykładu i wyświetlenia typu wartości, która może być zakodowana w kodzie HTML. Zazwyczaj należy wykonać kodowanie HTML wartości otrzymanej od użytkownika lub żądania. `Result`odwołuje się `Literal` do kontrolki.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 Następny przykład jest podobny do poprzedniego przykładu, z tą różnicą, że pokazuje sposób kodowania HTML wartości z klasy, która nie znajduje się w pliku związanym z kodem.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg do kodowania.</param>
        <param name="output">Strumień <see cref="T:System.IO.TextWriter" /> wyjściowy, który zawiera zakodowany ciąg.</param>
        <summary>HTML — koduje ciąg i wysyła wynikowe dane wyjściowe do <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML zapewnia, że tekst będzie poprawnie wyświetlany w przeglądarce, a nie interpretowany przez przeglądarkę jako HTML. Na przykład, jeśli ciąg tekstowy zawiera znak mniejszości (\<) lub znak większości (>), przeglądarka interpretuje te znaki jako nawias otwierający lub zamykający tag HTML. Kodowanie HTML tych dwóch znaków jest odpowiednio i `&lt;` `&gt;`, co powoduje, że przeglądarka wyświetla znak mniejszości i jest większy niż poprawna Rejestracja.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A>jest wygodnym sposobem uzyskania dostępu <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> do metody w czasie wykonywania z poziomu aplikacji ASP.NET. <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Wewnętrznie używa <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> do kodowania ciągów.  
  
 Aby zakodować lub zdekodować wartości poza aplikacją sieci Web, <xref:System.Net.WebUtility> należy użyć klasy.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg do transmisji przez HTTP. `TestString`Koduje ciąg o nazwie, który zawiera tekst "to \<jest ciąg testowy >.", i kopiuje go do ciągu o nazwie `EncodedString` "to jest &lt;ciąg&gt;testowy".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę komputera serwera.</summary>
        <value>Nazwa komputera lokalnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład zapisuje nazwę komputera serwera jako zmienną ciągu.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie można znaleźć nazwy komputera.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpServerUtility.MapPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka wirtualna w aplikacji sieci Web.</param>
        <summary>Zwraca fizyczną ścieżkę pliku odpowiadającą określonej ścieżce wirtualnej.</summary>
        <returns>Fizyczna ścieżka pliku na serwerze sieci Web, która odpowiada <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `path` jest `null` ,<xref:System.Web.HttpServerUtility.MapPath%2A> Metoda zwraca pełną ścieżkę fizyczną katalogu zawierającego bieżące żądanie dla ścieżki. Ścieżka względna nie musi określać istniejącego pliku lub folderu dla tej metody w celu zwrócenia wartości. Nie można jednak określić ścieżki poza aplikacją sieci Web.  
  
> [!IMPORTANT]
>  <xref:System.Web.HttpServerUtility.MapPath%2A> Metoda potencjalnie zawiera poufne informacje o środowisku hostingu. Wartość zwracana nie powinna być wyświetlana użytkownikom.  
  
 Aplikacja sieci Web, która znajduje się w `C:\ExampleSites\TestMapPath` , zwróci następujące wyniki:  
  
|Żądanie od|`path`|Wartość zwrócona|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|".. /OutsideApplication"|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać plik fizyczny względnej ścieżki wirtualnej. Kod znajduje się w pliku związanym z kodem dla strony sieci Web i używa obiektu domyślnego `Server` .  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 Następny przykład jest podobny do poprzedniego przykładu, z wyjątkiem pokazuje, jak pobrać ścieżkę fizyczną z klasy, która nie znajduje się w pliku związanym z kodem.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżąca <see cref="T:System.Web.HttpContext" /> wartość to <see langword="null" />.
        
—lub— 
<paramref name="path" />jest ścieżką fizyczną, ale oczekiwano ścieżki wirtualnej.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptTimeout : int with get, set" Usage="System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość limitu czasu żądania w sekundach.</summary>
        <value>Ustawienie wartości limitu czasu dla żądań.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość można ustawić w pliku Web. config przez `executionTimeout` ustawienie atrybutu elementu [httpRuntime](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) . <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> Ustawienie czasu programowo przy użyciu <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> właściwości ma pierwszeństwo przed ustawieniem Web. config.  
  
> [!NOTE]
>  Jeśli ustawisz `debug` atrybut elementu `true` [httpRuntime](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) w pliku Web <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> . config, wartość zostanie zignorowana.  
  
   
  
## Examples  
 W poniższym przykładzie limit czasu żądania jest ustawiany na 60 sekund.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżąca <see cref="T:System.Web.HttpContext" /> wartość to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Limit czasu jest <see langword="null" /> lub w przeciwnym razie nie można ustawić.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy wykonywanie bieżącej strony i rozpoczyna wykonywanie nowej strony dla bieżącego żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string -&gt; unit" Usage="httpServerUtility.Transfer path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze do wykonania.</param>
        <summary>W przypadku bieżącego żądania kończy wykonywanie bieżącej strony i rozpoczyna wykonywanie nowej strony przy użyciu określonej ścieżki URL strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przetransferowana strona powinna być inną stroną aspx. Na przykład przeniesienie do strony ASP lub asmx jest nieprawidłowe. Metoda zachowuje kolekcje<xref:System.Web.HttpRequest.Form%2A> i. <xref:System.Web.HttpRequest.QueryString%2A> <xref:System.Web.HttpServerUtility.Transfer%2A>  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A>wywołania <xref:System.Web.HttpResponse.End%2A>, które <xref:System.Threading.ThreadAbortException> zgłaszają wyjątek po zakończeniu.  
  
 ASP.NET nie sprawdza, czy bieżący użytkownik ma uprawnienia do wyświetlania zasobu dostarczonego przez <xref:System.Web.HttpServerUtility.Transfer%2A> metodę. Chociaż logika autoryzacji i uwierzytelniania ASP.NET jest uruchamiana przed wywołaniem oryginalnej obsługi zasobów, ASP.NET bezpośrednio wywołuje procedurę obsługi wskazywaną <xref:System.Web.HttpServerUtility.Transfer%2A> przez metodę i nie uruchamia ponownie logiki uwierzytelniania i autoryzacji dla nowego zasoby. Jeśli zasady zabezpieczeń aplikacji wymagają, aby klienci mieli odpowiednią autoryzację w celu uzyskania dostępu do zasobu, aplikacja powinna wymusić ponowne autoryzację lub udostępnić niestandardowy mechanizm kontroli dostępu.  
  
 Można wymusić ponowną autoryzację <xref:System.Web.HttpResponse.Redirect%2A> przy użyciu metody zamiast <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Metoda wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe żądanie wprowadzone do systemu, jest ono poddawane całej logiki uwierzytelniania i autoryzacji zarówno dla Internet Information Services (IIS), jak i zasad zabezpieczeń ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobu przez włączenie niestandardowej metody autoryzacji, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody, zanim aplikacja <xref:System.Web.HttpServerUtility.Transfer%2A> wywoła metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string * bool -&gt; unit" Usage="httpServerUtility.Transfer (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze do wykonania.</param>
        <param name="preserveForm"><see langword="true" />Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> kolekcje i <see cref="P:System.Web.HttpRequest.Form" /> ; Aby wyczyścić kolekcje<see cref="P:System.Web.HttpRequest.Form" /> i. <see cref="P:System.Web.HttpRequest.QueryString" /> <see langword="false" /></param>
        <summary>Kończy wykonywanie bieżącej strony i rozpoczyna wykonywanie nowej strony przy użyciu określonej ścieżki URL strony. Określa, czy należy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> kolekcje <see cref="P:System.Web.HttpRequest.Form" /> i.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przetransferowana strona powinna być inną stroną aspx. Na przykład przeniesienie do strony ASP lub asmx jest nieprawidłowe.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A>wywołania <xref:System.Web.HttpResponse.End%2A>, które <xref:System.Threading.ThreadAbortException> zgłaszają wyjątek po zakończeniu.  
  
 Jeśli ustawisz `preserveForm` parametr na `true`, Strona docelowa będzie mogła uzyskać dostęp do stanu widoku <xref:System.Web.UI.Page.PreviousPage%2A> poprzedniej strony przy użyciu właściwości.  
  
 Ze względów bezpieczeństwa należy zachować `enableViewStateMac` atrybut ustawiony na. `true` ASP.NET nie sprawdza, czy bieżący użytkownik ma uprawnienia do wyświetlania zasobu dostarczonego przez <xref:System.Web.HttpServerUtility.Transfer%2A> metodę. Chociaż logika autoryzacji i uwierzytelniania ASP.NET jest uruchamiana przed wywołaniem oryginalnej obsługi zasobów, ASP.NET bezpośrednio wywołuje procedurę obsługi wskazywaną <xref:System.Web.HttpServerUtility.Transfer%2A> przez metodę i nie uruchamia ponownie logiki uwierzytelniania i autoryzacji dla nowego zasoby. Jeśli zasady zabezpieczeń aplikacji wymagają, aby klienci mieli odpowiednią autoryzację w celu uzyskania dostępu do zasobu, aplikacja powinna wymusić ponowne autoryzację lub udostępnić niestandardowy mechanizm kontroli dostępu.  
  
 Można wymusić ponowną autoryzację <xref:System.Web.HttpResponse.Redirect%2A> przy użyciu metody zamiast <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Metoda wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe żądanie wprowadzone do systemu, jest ono poddawane całej logiki uwierzytelniania i autoryzacji zarówno dla Internet Information Services (IIS), jak i zasad zabezpieczeń ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobu przez włączenie niestandardowej metody autoryzacji, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody, zanim aplikacja <xref:System.Web.HttpServerUtility.Transfer%2A> wywoła metodę.  
  
   
  
## Examples  
 Poniższy przykład wykonuje nową stronę w tym samym katalogu, w którym znajduje się bieżąca strona.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Bieżące żądanie strony jest wywołaniem zwrotnym.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : System.Web.IHttpHandler * bool -&gt; unit" Usage="httpServerUtility.Transfer (handler, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Program obsługi protokołu HTTP implementujący <see cref="T:System.Web.IHttpHandler" /> do transferu bieżącego żądania do.</param>
        <param name="preserveForm"><see langword="true" />Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> kolekcje i <see cref="P:System.Web.HttpRequest.Form" /> ; Aby wyczyścić kolekcje<see cref="P:System.Web.HttpRequest.Form" /> i. <see cref="P:System.Web.HttpRequest.QueryString" /> <see langword="false" /></param>
        <summary>Kończy wykonywanie bieżącej strony i rozpoczyna wykonywanie nowego żądania przy użyciu niestandardowego programu obsługi protokołu HTTP, który implementuje <see cref="T:System.Web.IHttpHandler" /> interfejs i określa, czy <see cref="P:System.Web.HttpRequest.QueryString" /> wyczyścić kolekcje i <see cref="P:System.Web.HttpRequest.Form" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można napisać niestandardowe programy obsługi HTTP do przetwarzania określonych, wstępnie zdefiniowanych typów żądań HTTP w dowolnym języku, który jest zgodny z Common Language Specification (CLS). Kod wykonywalny, który jest zdefiniowany w klasach obsługi HTTP zamiast konwencjonalnych stron ASP (nazywanych również klasycznymi ASP) lub stron ASP.NET odpowiada na te konkretne żądania. Procedury obsługi protokołu HTTP umożliwiają współdziałanie z usługami żądania i odpowiedzi niskiego poziomu na serwerze sieci Web, na którym działa program Internet Information Services (IIS) i udostępnia funkcje podobne do rozszerzeń ISAPI, ale z prostszym modelem programowania.  
  
 Jeśli ustawisz `preserveForm` parametr na `true`, Strona docelowa będzie mogła uzyskać dostęp do stanu widoku <xref:System.Web.UI.Page.PreviousPage%2A> poprzedniej strony przy użyciu właściwości.  
  
 Ze względów bezpieczeństwa należy zachować `enableViewStateMac` atrybut ustawiony na. `true` ASP.NET nie sprawdza, czy bieżący użytkownik ma uprawnienia do wyświetlania zasobu dostarczonego przez <xref:System.Web.HttpServerUtility.Transfer%2A> metodę. Chociaż logika autoryzacji i uwierzytelniania ASP.NET jest uruchamiana przed wywołaniem oryginalnej obsługi zasobów, ASP.NET bezpośrednio wywołuje procedurę obsługi wskazywaną <xref:System.Web.HttpServerUtility.Transfer%2A> przez metodę i nie uruchamia ponownie logiki uwierzytelniania i reguły autoryzacji dla nowego zasoby. Jeśli zasady zabezpieczeń dla aplikacji wymagają, aby klienci mieli odpowiednią autoryzację w celu uzyskania dostępu do zasobu, aplikacja powinna wymusić ponowne autoryzację lub udostępnić niestandardowy mechanizm kontroli dostępu.  
  
 Można wymusić ponowną autoryzację <xref:System.Web.HttpResponse.Redirect%2A> przy użyciu metody zamiast <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Metoda wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe żądanie wprowadzone do systemu, jest ono poddawane całej logiki uwierzytelniania i autoryzacji zarówno dla zasad zabezpieczeń usług IIS, jak i ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobu przez włączenie niestandardowej metody autoryzacji, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody, zanim aplikacja <xref:System.Web.HttpServerUtility.Transfer%2A> wywoła metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Bieżące żądanie strony jest wywołaniem zwrotnym.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje asynchroniczne wykonywanie określonego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A>wprowadzono w .NET Framework w wersji 3,5. Aby uzyskać informacje podsumowujące dotyczące .NET Framework, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string -&gt; unit" Usage="httpServerUtility.TransferRequest path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze do wykonania.</param>
        <summary>Wykonuje asynchroniczne wykonywanie określonego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> To Przeciążenie metody wywołuje Przeciążenie `preserveForm` z `headers` `null` `null` parametrem`false`ustawionym na, `method` parametrustawionyna,parametr`preserveUser` ustawiony na, a parametr ustawiony na `true`wartość. Aby uzyskać więcej informacji, zobacz sekcję "uwagi" w <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> obszarze przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga trybu [!INCLUDE[iisver](~/includes/iisver-md.md)]zintegrowanego potoku.</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępny do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze do wykonania.</param>
        <param name="preserveForm"><see langword="true" />Aby zachować <see cref="P:System.Web.HttpRequest.Form" /> kolekcję; <see langword="false" /> Aby<see cref="P:System.Web.HttpRequest.Form" /> wyczyścić kolekcję.</param>
        <summary>Wykonuje asynchroniczne wykonywanie określonego adresu URL i zachowuje parametry ciągu zapytania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> To Przeciążenie wywołuje Przeciążenie `preserveForm` z parametrem ustawionym na `method` wartość przekazaną `null`, parametrem `headers` ustawionym na, parametrem ustawionym na `null`, `preserveUser` i ustawionym parametrem. do `true`programu. Aby uzyskać więcej informacji, zobacz sekcję "uwagi" w <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>temacie.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A>wprowadzono w .NET Framework w wersji 3,5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga trybu [!INCLUDE[iisver](~/includes/iisver-md.md)]zintegrowanego potoku.</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępny do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze do wykonania.</param>
        <param name="preserveForm"><see langword="true" />Aby zachować <see cref="P:System.Web.HttpRequest.Form" /> kolekcję; <see langword="false" /> Aby<see cref="P:System.Web.HttpRequest.Form" /> wyczyścić kolekcję.</param>
        <param name="method">Metoda HTTP do użycia podczas wykonywania nowego żądania.</param>
        <param name="headers"><see cref="T:System.Collections.Specialized.NameValueCollection" /> Nagłówek żądania dla nowego żądania.</param>
        <summary>Wykonuje asynchroniczne wykonywanie określonego adresu URL przy użyciu określonej metody i nagłówków HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana podczas uruchamiania z trybem zintegrowanego potoku w programie w [!INCLUDE[iisver](~/includes/iisver-md.md)] celu zezwalania na przesyłanie żądań z jednego typu zasobu do innego podczas wykonywania żądania docelowego z prawidłowym kontekstem żądania. Na przykład można użyć <xref:System.Web.HttpServerUtility.TransferRequest%2A> metody do transferu żądania dla strony aspx do żądania dla strony XML.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> Metoda wykonuje asynchroniczne wykonywanie przez określony adres URL z następującymi warunkami:  
  
-   `path` Jeśli parametr określa ciąg zapytania, będzie używany jako nowy ciąg zapytania. Jeśli ciąg zapytania nie zostanie uwzględniony, ciąg zapytania dla żądania zostanie ponownie użyty.  
  
-   `method` Jeśli parametr jest określony, zostanie użyty. `null`W takim przypadku zostanie użyta metoda http oryginalnego żądania.  
  
-   Jeśli parametr ma `true`wartość, bieżąca treść jednostki żądania będzie dostępna dla żądania docelowego. `preserveForm` Pozwala to na przesyłanie wpisów formularzy i przekazywania.  
  
-   Jeśli tożsamość użytkownika jest obecnie ustawiona dla oryginalnego żądania, tożsamość zostanie przeniesiona do nowego żądania. Dzięki temu uwierzytelnione żądania mogą ponownie używać wyniku uwierzytelniania dla nowego żądania. Jeśli nie chcesz, aby użytkownik był transferowany, przed przetransferem należy `null` ustawić na oryginalne żądanie użytkownika.  
  
-   `headers` Jeśli parametr jest określony, nowe żądanie zostanie wykonane z określonymi nagłówkami. Można go użyć do zmodyfikowania nagłówków i plików cookie żądania dla nowego żądania lub dodania specjalnego nagłówka określającego miejsce otrzymania oryginalnego żądania.  
  
     Ta metoda wywołuje <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> Przeciążenie metody `preserveUser` z parametrem ustawionym na `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga [!INCLUDE[iisver](~/includes/iisver-md.md)] uruchomienia w trybie zintegrowanym.</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępny do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers, preserveUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveUser" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka.</param>
        <param name="preserveForm"><see langword="true" />Aby zachować <see cref="P:System.Web.HttpRequest.Form" /> kolekcję; <see langword="false" /> Aby<see cref="P:System.Web.HttpRequest.Form" /> wyczyścić kolekcję.</param>
        <param name="method">Metoda HTTP do użycia w nowym żądaniu.</param>
        <param name="headers"><see cref="T:System.Collections.Specialized.NameValueCollection" /> Obiekt, który zawiera nagłówki żądań dla nowego żądania.</param>
        <param name="preserveUser"><see langword="true" />Aby zachować tożsamość użytkownika; w przeciwnym razie. <see langword="false" /> Inne przeciążenia metody wywołują to Przeciążenie z tym parametrem ustawionym na <see langword="true" />.</param>
        <summary>Wykonuje asynchroniczne wykonywanie określonego adresu URL przy użyciu określonej metody HTTP, nagłówków i ścieżki, a opcjonalnie zachowuje wartości formularzy i tożsamość użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz sekcję "uwagi" w <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>temacie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga trybu [!INCLUDE[iisver](~/includes/iisver-md.md)]zintegrowanego potoku.</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępny do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje ciąg, który został zakodowany do transmisji HTTP, a następnie wysyłany do serwera w adresie URL.  
  
Aby zakodować lub zdekodować wartości poza aplikacją sieci Web, <see cref="T:System.Net.WebUtility" /> należy użyć klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string -&gt; string" Usage="httpServerUtility.UrlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg tekstowy do zdekodowania.</param>
        <summary>URL — Dekoduje ciąg i zwraca zdekodowany ciąg.</summary>
        <returns>Zdekodowany tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresów URL zapewnia, że wszystkie przeglądarki poprawnie przesyłają tekst w ciągach adresów URL. Znaki takie jak znak zapytania (?), handlowego "i" (&), ukośnik (/) i spacje mogą być obcinane lub uszkodzone w niektórych przeglądarkach. W związku z tym te znaki muszą być zakodowane `<a>` w tagach lub w ciągach zapytań, w których ciągi mogą być ponownie wysyłane przez przeglądarkę w ciągu żądania.  
  
 Ta metoda jest wygodnym sposobem uzyskiwania dostępu <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> do metody w czasie wykonywania z poziomu aplikacji ASP.NET. Wewnętrznie, ta metoda używa <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> do dekodowania ciągów.  
  
 W pliku związanym z kodem dla strony sieci Web ASP.NET, uzyskaj dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy `Server` za pomocą właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, `HttpContext.Current.Server` Użyj, aby uzyskać dostęp do <xref:System.Web.HttpServerUtility> wystąpienia klasy.  
  
 Na zewnątrz aplikacji sieci Web, użyj <xref:System.Net.WebUtility> klasy do kodowania lub dekodowania wartości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak odkodować adres URL wartości pobranej z ciągu zapytania. Kod znajduje się w pliku związanym z kodem dla strony sieci Web. `ReturnPage`odwołuje się `HyperLink` do kontrolki.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 Następny przykład jest podobny do poprzedniego przykładu, z tą różnicą, że pokazuje, jak odkodować wartość adresu URL z klasy, która nie znajduje się w pliku związanym z kodem.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg HTML do zdekodowania.</param>
        <param name="output">Strumień <see cref="T:System.IO.TextWriter" /> wyjściowy zawierający zdekodowany ciąg.</param>
        <summary>Dekoduje ciąg HTML otrzymany w adresie URL i wysyła wynikowe dane wyjściowe do <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresów URL zapewnia, że wszystkie przeglądarki poprawnie przesyłają tekst w ciągach adresów URL. Znaki takie jak znak zapytania (?), handlowego "i" (&), ukośnik (/) i spacje mogą być obcinane lub uszkodzone w niektórych przeglądarkach. W związku z tym te znaki muszą być zakodowane `<a>` w tagach lub w ciągach zapytań, w których ciągi mogą być ponownie wysyłane przez przeglądarkę w ciągu żądania.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A>jest wygodnym sposobem uzyskania dostępu <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> do metody w czasie wykonywania z poziomu aplikacji ASP.NET. <xref:System.Web.HttpServerUtility.UrlDecode%2A> Wewnętrznie używa <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> do zdekodowania ciągów.  
  
 Aby zakodować lub zdekodować wartości poza aplikacją sieci Web, <xref:System.Net.WebUtility> należy użyć klasy.  
  
   
  
## Examples  
 Poniższy przykład Dekoduje ciąg o nazwie `EncodedString` (otrzymany w adresie URL) do ciągu o nazwie. `DecodedString`  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje ciąg w celu niezawodnej transmisji HTTP z serwera sieci Web do klienta za pośrednictwem adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A>jest wygodnym sposobem uzyskania dostępu <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do metody w czasie wykonywania z poziomu aplikacji ASP.NET. <xref:System.Web.HttpServerUtility.UrlEncode%2A> Wewnętrznie używa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do kodowania ciągów.  
  
 Aby zakodować lub zdekodować wartości poza aplikacją sieci Web, <xref:System.Net.WebUtility> należy użyć klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string -&gt; string" Usage="httpServerUtility.UrlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Tekst do kodowania URL.</param>
        <summary>URL — koduje ciąg i zwraca zakodowany ciąg.</summary>
        <returns>Tekst zakodowany w adresie URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresów URL zapewnia, że wszystkie przeglądarki poprawnie przesyłają tekst w ciągach adresów URL. Znaki takie jak znak zapytania (?), handlowego "i" (&), ukośnik (/) i spacje mogą być obcinane lub uszkodzone w niektórych przeglądarkach. W związku z tym te znaki muszą być zakodowane `<a>` w tagach lub w ciągach zapytań, w których ciągi mogą być ponownie wysyłane przez przeglądarkę w ciągu żądania.  
  
 Ta metoda jest wygodnym sposobem uzyskiwania dostępu <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do metody w czasie wykonywania z poziomu aplikacji ASP.NET. Wewnętrznie, ta metoda używa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do kodowania ciągów.  
  
 W pliku związanym z kodem dla strony sieci Web ASP.NET, uzyskaj dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy `Server` za pomocą właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, `HttpContext.Current.Server` Użyj, aby uzyskać dostęp do <xref:System.Web.HttpServerUtility> wystąpienia klasy.  
  
 Na zewnątrz aplikacji sieci Web, użyj <xref:System.Net.WebUtility> klasy do kodowania lub dekodowania wartości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać adresu URL kodowania wartości, która jest używana jako wartość ciągu zapytania hiperłącza. Kod znajduje się w pliku związanym z kodem dla strony sieci Web. Wartość do kodowania jest zakodowana w tym przykładzie tylko w celu uproszczenia przykładu i wyświetlenia typu wartości, która może być zakodowana przy użyciu adresu URL. Zazwyczaj należy zakodować adres URL i wartość otrzymaną od użytkownika lub żądania. `NextPage`odwołuje się `HyperLink` do kontrolki.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 Następny przykład jest podobny do poprzedniego przykładu, z tą różnicą, że pokazuje, jak adres URL — Koduj wartość z klasy, która nie znajduje się w pliku związanym z kodem.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg tekstowy do zakodowania.</param>
        <param name="output">Strumień <see cref="T:System.IO.TextWriter" /> wyjściowy, który zawiera zakodowany ciąg.</param>
        <summary>URL — koduje ciąg i wysyła wynikowe dane wyjściowe do <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresów URL zapewnia, że wszystkie przeglądarki poprawnie przesyłają tekst w ciągach adresów URL. Znaki takie jak znak zapytania (?), handlowego "i" (&), ukośnik (/) i spacje mogą być obcinane lub uszkodzone w niektórych przeglądarkach. W związku z tym te znaki muszą być zakodowane `<a>` w tagach lub w ciągach zapytań, w których ciągi mogą być ponownie wysyłane przez przeglądarkę w ciągu żądania.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A>jest wygodnym sposobem uzyskania dostępu <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do metody w czasie wykonywania z poziomu aplikacji ASP.NET. <xref:System.Web.HttpServerUtility.UrlEncode%2A> Wewnętrznie używa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do kodowania ciągów.  
  
 Aby zakodować lub zdekodować wartości poza aplikacją sieci Web, <xref:System.Net.WebUtility> należy użyć klasy.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg do transmisji przez HTTP. Koduje ciąg o nazwie `TestString`, który zawiera tekst "to \<jest ciąg testowy >.", i kopiuje go do ciągu o nazwie `EncodedString` "This + is + a +% 3cTest + String% 3e.".  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlPathEncode : string -&gt; string" Usage="httpServerUtility.UrlPathEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Tekst do kodowania URL.</param>
        <summary>Nie należy używać; przeznaczone tylko do zgodności z przeglądarką. Użyj <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>Tekst zakodowany w adresie URL.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenDecode : string -&gt; byte[]" Usage="System.Web.HttpServerUtility.UrlTokenDecode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">Token ciągu adresu URL do dekodowania.</param>
        <summary>Dekoduje token ciągu adresu URL do jego równoważnej tablicy bajtowej przy użyciu podstawowych cyfr 64.</summary>
        <returns>Tablica bajtowa zawierająca zdekodowany token ciągu adresu URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Metoda konwertuje token ciągu adresu URL, który koduje dane binarne jako bazowe 64 cyfry, do swojej równoważnej reprezentacji tablicy bajtów. Użyj metody <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> , aby zdekodować tokeny przesłane w adresie URL i zakodować przy <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>użyciu.  
  
 Metoda zwróci pustą tablicę bajtową, `input` Jeśli parametr ma długość mniejszą niż jeden. <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="input" /> parametru to <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenEncode : byte[] -&gt; string" Usage="System.Web.HttpServerUtility.UrlTokenEncode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">Tablica bajtów do zakodowania.</param>
        <summary>Koduje tablicę bajtową na równoważną reprezentację w postaci ciągu przy użyciu podstawowych cyfr 64, które są użyteczne do przesyłania na adres URL.</summary>
        <returns>Ciąg zawierający zakodowany token, jeśli *Długość* tablicy bajtowej jest większa niż 1; w przeciwnym razie, pusty ciąg ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> Metoda konwertuje tablicę bajtową na równoważną reprezentację ciągu zakodowaną z podstawowymi 64 cyframi. Otrzymany ciąg tokenu może być przesyłany przy użyciu adresu URL.  
  
 Zwraca pusty ciąg, `input` Jeśli parametr ma długość mniejszą niż jeden. <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="input" /> parametru to <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>

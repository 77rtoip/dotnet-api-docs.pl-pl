<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="af79683dbebba2bc232c66a7a70dd0748a5935a9" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30694766" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia metody pomocnicze do przetwarzania żądań sieci Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody i właściwości <xref:System.Web.HttpServerUtility> klasy są dostępne za pośrednictwem wewnętrznego <xref:System.Web.HttpContext.Server%2A> obiekt udostępniany przez platformę ASP.NET.  
  
   
  
## Examples  
 Projekt programu Visual Studio Web lokacji z kodem źródłowym jest dostępna powiązany z tym tematem: [Pobierz](http://go.microsoft.com/fwlink/?LinkId=192870).  
  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Web.HttpServerUtility.HtmlEncode%2A> — metoda i <xref:System.Web.HttpServerUtility.UrlEncode%2A> metody <xref:System.Web.HttpServerUtility> klasy. <xref:System.Web.HttpServerUtility.HtmlEncode%2A> — Metoda gwarantuje, że dane wejściowe dowolnego ciągu podanego przez użytkownika, będzie traktowany jako tekst statyczny w przeglądarkach zamiast pliku wykonywalnego skryptu lub elementów HTML. <xref:System.Web.HttpServerUtility.UrlEncode%2A> Metoda koduje adresów URL, dzięki czemu są one poprawnie przekazywane w strumieniu HTTP.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści poprzedniego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład powoduje wyczyszczenie ostatniego wyjątku, który został zgłoszony.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie obiektu COM serwera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Klasa lub typ obiektu do utworzenia wystąpienia.</param>
        <summary>Tworzy wystąpienie obiektu COM, identyfikowany przez identyfikator programowy obiektu (ProgID) serwera.</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy obiekt przy użyciu obiektu ProgID.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie można utworzyć wystąpienia obiektu.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący obiekt do utworzenia.</param>
        <summary>Tworzy wystąpienie obiektu COM identyfikowanych według typu obiektu serwera.</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator klasy obiektu do utworzenia wystąpienia.</param>
        <summary>Tworzy wystąpienie obiektu COM, identyfikowany przez identyfikator klasy obiektu (CLSID) serwera.</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> metodę, aby utworzyć wystąpienie obiektu COM serwera.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie można utworzyć wystąpienia obiektu.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje program obsługi dla określonego zasobu w kontekście bieżącego żądania i zwraca wykonanie do strony, która ją wywołała.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <summary>Program obsługi dla określonej ścieżki wirtualnej jest wykonywany w kontekście bieżącego żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Metoda kontynuuje wykonywanie oryginalnego strony po zakończeniu wykonywania nowej strony. <xref:System.Web.HttpServerUtility.Transfer%2A> Metody bezwarunkowo przenosi wykonanie do innego programu obsługi.  
  
 Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlenia zasobu dostarczonych przez <xref:System.Web.HttpServerUtility.Execute%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalne obsługi zasobów, ASP.NET bezpośrednio wywołuje wskazywanym przez program obsługi <xref:System.Web.HttpServerUtility.Execute%2A> metody i nie zostanie uruchomiona ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń aplikacji wymaga klientów ma odpowiednie uprawnienia dostępu do zasobu, należy wymusić ponowna autoryzacja lub mechanizm niestandardowych kontroli dostępu aplikacji.  
  
 Ponowna autoryzacja można wymusić za pomocą <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ ta przekierowania jest nowe żądanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń zarówno usługi Internet Information Services (IIS), jak i platformy ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacji niestandardowej, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Execute%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono strony .aspx "Updateinfo.aspx" w bieżącym katalogu. Po wyświetleniu strony Updateinfo.aspx, wykonanie programu zwraca do strony początkowej.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest <see langword="null" />.  
  
 \- lub -  
  
 Wystąpił błąd podczas wykonywania program obsługi określony przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="path" /> nie jest ścieżką wirtualną.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Wykonuje w kontekście bieżącego żądania programu obsługi dla określonej ścieżki wirtualnej i określa, czy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób wykonania strony .aspx `Updateinfo.aspx` w bieżącym żądaniu i Zachowaj <xref:System.Web.HttpRequest.QueryString%2A> i <xref:System.Web.HttpRequest.Form%2A> kolekcji. Zwraca wykonywania programu do strony początkowej po `Updateinfo.aspx` jest wyświetlany.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest <see langword="null" />.  
  
 \- lub -  
  
 Wystąpił błąd podczas wykonywania program obsługi określony przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="path" /> nie jest ścieżką wirtualną.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Do przechwytywania danych wyjściowych.</param>
        <summary>Program obsługi dla określonej ścieżki wirtualnej jest wykonywany w kontekście bieżącego żądania. A <see cref="T:System.IO.TextWriter" /> przechwytuje dane wyjściowe z wykonanie programu obsługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Metoda kontynuuje wykonywanie oryginalnego żądania po zakończeniu wykonywania określonej ścieżki wirtualnej. <xref:System.Web.HttpServerUtility.Transfer%2A> Metody bezwarunkowo przenosi wykonanie do innego programu obsługi.  
  
 Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlenia zasobu dostarczonych przez <xref:System.Web.HttpServerUtility.Execute%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalne obsługi zasobów, ASP.NET bezpośrednio wywołuje wskazywanym przez program obsługi <xref:System.Web.HttpServerUtility.Execute%2A> metody i nie zostanie uruchomiona ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń aplikacji wymaga klientów ma odpowiednie uprawnienia dostępu do zasobu, należy wymusić ponowna autoryzacja lub mechanizm niestandardowych kontroli dostępu aplikacji.  
  
 Ponowna autoryzacja można wymusić za pomocą <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ ta przekierowania jest nowe żądanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń zarówno usługi Internet Information Services (IIS), jak i platformy ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacji niestandardowej, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Execute%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wykonuje `Login.aspx` strony na serwerze w bieżącym katalogu i odbiera dane wyjściowe ze strony za pomocą <xref:System.IO.StringWriter> obiektu `writer`. Zapisuje strumienia HTML otrzymanych od `writer` HTTP output strumienia.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest <see langword="null" />.  
  
 \- lub -  
  
 Wystąpił błąd podczas wykonywania program obsługi określony przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="path" /> nie jest ścieżką wirtualną.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Do przechwytywania danych wyjściowych.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Program obsługi dla określonej ścieżki wirtualnej jest wykonywany w kontekście bieżącego żądania. A <see cref="T:System.IO.TextWriter" /> przechwytywania dane wyjściowe strony i parametrem logicznym Określa, czy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Metoda kontynuuje wykonywanie oryginalnego żądania po zakończeniu wykonywania określonej ścieżki wirtualnej. <xref:System.Web.HttpServerUtility.Transfer%2A> Metody bezwarunkowo przenosi wykonanie do innego programu obsługi.  
  
 Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlenia zasobu dostarczonych przez <xref:System.Web.HttpServerUtility.Execute%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalne obsługi zasobów, ASP.NET bezpośrednio wywołuje wskazywanym przez program obsługi <xref:System.Web.HttpServerUtility.Execute%2A> metody i nie zostanie uruchomiona ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń aplikacji wymaga klientów ma odpowiednie uprawnienia dostępu do zasobu, należy wymusić ponowna autoryzacja lub mechanizm niestandardowych kontroli dostępu aplikacji.  
  
 Ponowna autoryzacja można wymusić za pomocą <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ ta przekierowania jest nowe żądanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń zarówno usługi Internet Information Services (IIS), jak i platformy ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacji niestandardowej, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Execute%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wykonuje `Login.aspx` strony na serwerze w bieżącym katalogu i odbiera dane wyjściowe ze strony za pomocą <xref:System.IO.StringWriter> obiektu `writer`. Zapisuje strumienia HTML otrzymanych od `writer` HTTP output strumienia. Zawartość <xref:System.Web.HttpRequest.Form%2A> i <xref:System.Web.HttpRequest.QueryString%2A> kolekcje są zachowywane.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).  
  
 \- lub -  
  
 <paramref name="path" /> kończy się kropką (.).  
  
 \- lub -  
  
 Wystąpił błąd podczas wykonywania program obsługi określony przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> nie jest ścieżką wirtualną.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">Program obsługi HTTP, który implementuje <see cref="T:System.Web.IHttpHandler" /> transferu bieżącego żądania.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Do przechwytywania danych wyjściowych.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Program obsługi dla określonej ścieżki wirtualnej jest wykonywany w kontekście bieżącego żądania. A <see cref="T:System.IO.TextWriter" /> dane wyjściowe Przechwytywanie obsługi wykonane i parametrem logicznym Określa, czy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można pisać niestandardowe programy obsługi HTTP do przetwarzania określonych, wstępnie zdefiniowanych typów żądań HTTP w dowolnym języku zgodnym z typowych specyfikacji języka (CLS). Kod wykonywalny, który jest zdefiniowany w klasach programu obsługi HTTP zamiast z konwencjonalnej stron ASP (nazywany także klasyczne środowisko ASP) lub stron ASP.NET odpowiada te określone żądania. Programów obsługi HTTP Zezwalaj na potrzeby interakcji z niskiego poziomu żądań i odpowiedzi usługi serwera sieci Web, na którym działa program Internet Information Services (IIS), które udostępniają funkcje, które są podobne do rozszerzenia ISAPI, ale z prostszych model programowania.  
  
 Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlania zasobów, która jest dostarczana przez <xref:System.Web.HttpServerUtility.Execute%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalne obsługi zasobów, ASP.NET bezpośrednio wywołuje program obsługi, który jest wskazywany przez <xref:System.Web.HttpServerUtility.Execute%2A> metody i nie zostanie uruchomiona ponownie logikę uwierzytelniania i autoryzacji Nowy zasób. Jeśli zasady zabezpieczeń aplikacji wymaga klientów ma odpowiednich uprawnień do uzyskania dostępu do zasobu, należy wymusić ponowna autoryzacja lub mechanizm niestandardowych kontroli dostępu aplikacji.  
  
 Ponowna autoryzacja można wymusić za pomocą <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ ta przekierowania jest nowe żądanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń zarówno usług IIS i platformy ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacji niestandardowej, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Execute%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Wystąpił błąd podczas wykonywania program obsługi określony przez <paramref name="handler" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handler" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca poprzedni wyjątek.</summary>
        <returns>Poprzedni wyjątek został zgłoszony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla opis ostatniego błędu aplikacji do strumienia wyjściowego HTTP. Wyświetla "Bez błędów" Jeśli zostały napotkane żadne błędy.  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje ciąg, który został zakodowany w celu wyeliminowania nieprawidłowych znaków HTML.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, użyj <see cref="T:System.Net.WebUtility" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg HTML do zdekodowania.</param>
        <summary>Dekoduje ciąg kodowany w formacie HTML i zwraca Dekodowany ciąg.</summary>
        <returns>Tekst zdekodowana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML upewnia się, że tekst jest poprawnie wyświetlany w przeglądarce i nie jest interpretowany przez przeglądarkę jako HTML. Na przykład, jeśli ciąg tekstowy zawiera mniej niż znak (\<) lub większą niż znak (>), przeglądarka może zinterpretować te znaki jako otwierający lub zamykający nawias kwadratowy tagu HTML. W przypadku znaków kodowania HTML są konwertowane na ciągi `&lt;` i `&gt;`, co powoduje, że przeglądarkę, aby wyświetlić mniej niż znak i jest większy niż Zaloguj się poprawnie. <xref:System.Web.HttpServerUtility.HtmlDecode%2A> dekoduje tekst, który zostały przekazane do serwera.  
  
 Jest to wygodny sposób dostępu do <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> metody w czasie wykonywania w aplikacji ASP.NET. Wewnętrznie ta metoda używa <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> zdekodować ciągów.  
  
 W pliku CodeBehind dla strony sieci web platformy ASP.NET, należy uzyskać dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy za pomocą `Server` właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, użyj `HttpContext.Current.Server` można uzyskać dostępu do wystąpienia <xref:System.Web.HttpServerUtility> klasy.  
  
 Poza aplikacją sieci web, użyj <xref:System.Net.WebUtility> klasy do kodowania i dekodowania wartości.  
  
   
  
## Examples  
 Poniższy przykład zawiera funkcję `LoadDecodedFile`, które dekoduje dane z pliku i kopiuje go do jednego ciągu.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg HTML do zdekodowania.</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> Strumienia wyjściowego, który zawiera Dekodowany ciąg.</param>
        <summary>Dekoduje ciąg kodowany w formacie HTML i wysyła dane wyjściowe do powstałe w ten sposób <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML upewnia się, że tekst jest poprawnie wyświetlany w przeglądarce i nie jest interpretowany przez przeglądarkę jako HTML. Na przykład, jeśli ciąg tekstowy zawiera mniej niż znak (\<) lub większą niż znak (>), przeglądarka może zinterpretować te znaki jako otwierający lub zamykający nawias kwadratowy tagu HTML. W przypadku znaków kodowania HTML są konwertowane na ciągi `&lt;` i `&gt;`, co powoduje, że przeglądarkę, aby wyświetlić mniej niż znak i jest większy niż Zaloguj się poprawnie.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> dekoduje tekst, który zostały przekazane do serwera.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> jest to wygodny sposób dostępu <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> metody w czasie wykonywania w aplikacji ASP.NET. Wewnętrznie <xref:System.Web.HttpServerUtility.HtmlDecode%2A> używa <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> zdekodować ciągów.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, użyj <xref:System.Net.WebUtility> klasy.  
  
   
  
## Examples  
 Poniższy przykład Dekoduje ciąg, który został zakodowany w formacie HTML do przesłania za pośrednictwem protokołu HTTP. Dekoduje on podany ciąg o nazwie `EncodedString` zawierającej tekst "to &lt;ciąg testu&gt;." i kopiuje go do parametrów o nazwie `DecodedString` jako "to \<ciąg testu >.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje ciąg do wyświetlania w przeglądarce.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, użyj <see cref="T:System.Net.WebUtility" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg tekstowy do kodowania.</param>
        <summary>Ciąg koduje HTML i zwraca ciąg kodowany jako.</summary>
        <returns>Tekst kodowany w formacie HTML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML upewnia się, że tekst jest poprawnie wyświetlany w przeglądarce i nie jest interpretowany przez przeglądarkę jako HTML. Na przykład, jeśli ciąg tekstowy zawiera mniej niż znak (\<) lub większą niż znak (>), przeglądarka może zinterpretować te znaki jako otwierający lub zamykający nawias kwadratowy tagu HTML. W przypadku znaków kodowania HTML są konwertowane na ciągi `&lt;` i `&gt;`, co powoduje, że przeglądarkę, aby wyświetlić mniej niż znak i jest większy niż Zaloguj się poprawnie.  
  
 Jest to wygodny sposób dostępu do <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> metody w czasie wykonywania w aplikacji ASP.NET. Wewnętrznie ta metoda używa <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> do kodowania ciągów.  
  
 W pliku CodeBehind dla strony sieci web platformy ASP.NET, należy uzyskać dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy za pomocą `Server` właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, użyj `HttpContext.Current.Server` można uzyskać dostępu do wystąpienia <xref:System.Web.HttpServerUtility> klasy.  
  
 Poza aplikacją sieci web, użyj <xref:System.Net.WebUtility> klasy do kodowania i dekodowania wartości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak kodowanie HTML wartość która potencjalnie kodów niebezpieczny kod. Kod znajduje się w pliku CodeBehind dla strony sieci web. Wartość do zakodowania jest ustalony w tym przykładzie tylko w celu uproszczenia przykładzie i pokazania typ wartości, które może być kodowania HTML. Zwykle ma kodowania HTML wartość otrzymanej od użytkownika lub żądanie. `Result` odwołuje się do `Literal` formantu.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 Kolejnym przykładzie jest podobny do poprzedniego przykładu, z wyjątkiem widoczny jest sposób kodowania HTML wartość z zakresu od wewnątrz klasy nie jest w pliku CodeBehind.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg do kodowania.</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> Strumienia wyjściowego, który zawiera ciąg zakodowany.</param>
        <summary>Ciąg koduje HTML i wysyła wynikowe dane wyjściowe do <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML gwarantuje, że tekst będzie poprawnie wyświetlany w przeglądarce nie interpretowany przez przeglądarkę jako HTML. Na przykład, jeśli ciąg tekstowy zawiera mniej niż znak (\<) lub większą niż znak (>), przeglądarka może zinterpretować te znaki jako otwierający lub zamykający nawias kwadratowy tagu HTML. Kodowanie HTML z tych dwóch znaków jest `&lt;` i `&gt;`, co powoduje, że przeglądarkę, aby wyświetlić mniej niż znak i jest większy niż Zaloguj się poprawnie.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> jest to wygodny sposób dostępu <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> metody w czasie wykonywania w aplikacji ASP.NET. Wewnętrznie <xref:System.Web.HttpServerUtility.HtmlEncode%2A> używa <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> do kodowania ciągów.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, użyj <xref:System.Net.WebUtility> klasy.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg w celu przesyłania przy użyciu protokołu HTTP. Koduje go parametrów o nazwie `TestString`, zawierającej tekst "to \<ciąg testu >." i kopiuje go do parametrów o nazwie `EncodedString` jako "to &lt;ciąg testu&gt;.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę komputera serwera.</summary>
        <value>Nazwa komputera lokalnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przechowuje nazwę komputera serwera jako zmienna typu ciąg.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie można odnaleźć nazwy komputera.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka wirtualna aplikacji sieci Web.</param>
        <summary>Zwraca ścieżka fizyczna do pliku, który odpowiada do określonej ścieżki wirtualnej.</summary>
        <returns>Ścieżka fizyczna do pliku na serwerze sieci Web, która odpowiada <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `path` jest `null`, <xref:System.Web.HttpServerUtility.MapPath%2A> metoda zwraca pełną ścieżkę fizyczną katalogu, która zawiera bieżące żądanie dla ścieżki. Ścieżka względna nie trzeba określić istniejący plik lub folder dla tej metody zwrócić wartość. Jednak nie można określić ścieżki poza aplikacji sieci Web.  
  
> [!IMPORTANT]
>  <xref:System.Web.HttpServerUtility.MapPath%2A> Metoda zawiera potencjalnie poufnych informacji o środowisku macierzystym. Wartość zwracana powinna niewidoczne dla użytkowników.  
  
 Aplikacja sieci Web, która znajduje się w `C:\ExampleSites\TestMapPath` zwróci następujące wyniki:  
  
|Żądania od|`path`|Wartości zwracane|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|".. / OutsideApplication "|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać fizycznego pliku względną ścieżką wirtualną. Kod znajduje się w pliku CodeBehind dla strony sieci web i korzysta z domyślnego `Server` obiektu.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 Kolejnym przykładzie jest podobny do poprzedniego przykładu, z wyjątkiem widoczny jest sposób pobrać ścieżki fizycznej z wewnątrz klasy, która nie znajduje się w pliku CodeBehind.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest <see langword="null" />.
        
—lub— 
        
<paramref name="path" /> jest ścieżką fizyczną, ale oczekiwano ścieżki wirtualnej.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera i ustawia wartość limitu czasu żądania w sekundach.</summary>
        <value>Ustawienie wartości limitu czasu dla żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> w pliku Web.config można ustawić właściwości przez ustawienie `executionTimeout` atrybut elementu. Ustawienie limitu czasu programowo z <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> właściwości mają pierwszeństwo przed ustawieniem pliku Web.config.  
  
> [!NOTE]
>  Jeśli ustawisz `debug` atrybut element, aby `true` w pliku Web.config wartość <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> zostaną zignorowane.  
  
   
  
## Examples  
 Poniższy przykład ustawia limit czasu żądania 60 sekund.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Limit czasu jest <see langword="null" /> lub, w przeciwnym razie nie można ustawić.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy wykonywanie bieżącej strony i rozpoczyna się wykonanie nowej strony dla bieżącego żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze do wykonania.</param>
        <summary>Dla bieżącego żądania kończy wykonywanie bieżącej strony i uruchamia wykonywanie nowej strony przy użyciu określonej ścieżki adresu URL strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strona przekazanego powinna być innej strony .aspx. Na przykład transferu do strony ASP lub .asmx jest nieprawidłowy. <xref:System.Web.HttpServerUtility.Transfer%2A> Zachowuje metody <xref:System.Web.HttpRequest.QueryString%2A> i <xref:System.Web.HttpRequest.Form%2A> kolekcji.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> wywołania <xref:System.Web.HttpResponse.End%2A>, który zgłasza <xref:System.Threading.ThreadAbortException> wyjątek po zakończeniu.  
  
 Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlenia zasobu dostarczonych przez <xref:System.Web.HttpServerUtility.Transfer%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalne obsługi zasobów, ASP.NET bezpośrednio wywołuje wskazywanym przez program obsługi <xref:System.Web.HttpServerUtility.Transfer%2A> metody i nie zostanie uruchomiona ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń aplikacji wymaga klientów ma odpowiednie uprawnienia dostępu do zasobu, należy wymusić ponowna autoryzacja lub mechanizm niestandardowych kontroli dostępu aplikacji.  
  
 Ponowna autoryzacja można wymusić za pomocą <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Metoda wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ ta przekierowania jest nowe żądanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń zarówno usługi Internet Information Services (IIS), jak i platformy ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacji niestandardowej, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Transfer%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze do wykonania.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Kończy wykonywanie bieżącej strony i rozpoczyna się wykonanie nowej strony przy użyciu określonej ścieżki adresu URL strony. Określa, czy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strona przekazanego powinna być innej strony .aspx. Na przykład transferu do strony ASP lub .asmx jest nieprawidłowy.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> wywołania <xref:System.Web.HttpResponse.End%2A>, który zgłasza <xref:System.Threading.ThreadAbortException> wyjątek po zakończeniu.  
  
 Jeśli ustawisz `preserveForm` parametr `true`, strony docelowej będą mogli uzyskać dostępu do stanu widoku poprzedniej strony za pomocą <xref:System.Web.UI.Page.PreviousPage%2A> właściwości.  
  
 Ze względów bezpieczeństwa należy przechowywać `enableViewStateMac` ustawić atrybutu `true`. Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlenia zasobu dostarczonych przez <xref:System.Web.HttpServerUtility.Transfer%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalne obsługi zasobów, ASP.NET bezpośrednio wywołuje wskazywanym przez program obsługi <xref:System.Web.HttpServerUtility.Transfer%2A> metody i nie zostanie uruchomiona ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń aplikacji wymaga klientów ma odpowiednie uprawnienia dostępu do zasobu, należy wymusić ponowna autoryzacja lub mechanizm niestandardowych kontroli dostępu aplikacji.  
  
 Ponowna autoryzacja można wymusić za pomocą <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Metoda wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ ta przekierowania jest nowe żądanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń zarówno usługi Internet Information Services (IIS), jak i platformy ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacji niestandardowej, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Transfer%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wykonuje nowej strony, w tym samym katalogu co bieżąca strona.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Bieżącego żądania strony jest wywołaniem zwrotnym.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">Program obsługi HTTP, który implementuje <see cref="T:System.Web.IHttpHandler" /> transferu bieżącego żądania.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Kończy wykonywanie bieżącej strony i rozpoczyna się wykonanie nowe żądanie przy użyciu niestandardowy program obsługi HTTP, który implementuje <see cref="T:System.Web.IHttpHandler" /> interfejsu i określa, czy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można pisać niestandardowe programy obsługi HTTP do przetwarzania określonych, wstępnie zdefiniowanych typów żądań HTTP w dowolnym języku zgodnym z typowych specyfikacji języka (CLS). Kod wykonywalny, który jest zdefiniowany w klasach programu obsługi HTTP zamiast z konwencjonalnej stron ASP (nazywany także klasyczne środowisko ASP) lub stron ASP.NET odpowiada te określone żądania. Programów obsługi HTTP Zezwalaj na potrzeby interakcji z niskiego poziomu żądań i odpowiedzi usługi serwera sieci Web, na którym działa program Internet Information Services (IIS), które udostępniają funkcje, które są podobne do rozszerzenia ISAPI, ale z prostszych model programowania.  
  
 Jeśli ustawisz `preserveForm` parametr `true`, strony docelowej będą mogli uzyskać dostępu do stanu widoku poprzedniej strony za pomocą <xref:System.Web.UI.Page.PreviousPage%2A> właściwości.  
  
 Ze względów bezpieczeństwa należy przechowywać `enableViewStateMac` ustawić atrybutu `true`. Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlenia zasobu dostarczonych przez <xref:System.Web.HttpServerUtility.Transfer%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalne obsługi zasobów, ASP.NET bezpośrednio wywołuje wskazywanym przez program obsługi <xref:System.Web.HttpServerUtility.Transfer%2A> — metoda i czy nie, uruchom ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń aplikacji wymaga klientów ma odpowiednie uprawnienia dostępu do zasobu, należy wymusić ponowna autoryzacja lub mechanizm niestandardowych kontroli dostępu aplikacji.  
  
 Ponowna autoryzacja można wymusić za pomocą <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Metoda wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ ta przekierowania jest nowe żądanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń zarówno usług IIS i platformy ASP.NET.  
  
 Można sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacji niestandardowej, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Transfer%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Bieżącego żądania strony jest wywołaniem zwrotnym.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje asynchroniczny wykonanie określonego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> wprowadzono w programie .NET Framework w wersji 3.5. Aby uzyskać podsumowanie informacji o programie .NET Framework, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze do wykonania.</param>
        <summary>Wykonuje asynchroniczny wykonanie określonego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie tej metody wymaga <xref:System.Web.HttpServerUtility.TransferRequest%2A> przeciążenia z `preserveForm` ustawiona `false`, `method` ustawiona `null`, `headers` ustawiona `null`i `preserveUser` Ustaw parametr `true`. Aby uzyskać więcej informacji, zobacz sekcję "Uwagi" w <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga trybu zintegrowanego potoku [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępna do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze do wykonania.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Wykonuje asynchroniczny wykonanie określonego adresu URL i zachowuje parametrów ciągu zapytania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołuje tego przeciążenia <xref:System.Web.HttpServerUtility.TransferRequest%2A> przeciążenia z `preserveForm` parametru ustawioną wartość przekazano, `method` ustawiona `null`, `headers` ustawiona `null`i `preserveUser` zestaw parametrów Aby `true`. Aby uzyskać więcej informacji, zobacz sekcję "Uwagi" w <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> wprowadzono w programie .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga trybu zintegrowanego potoku [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępna do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze do wykonania.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <param name="method">Metoda HTTP do użycia podczas wykonywania nowe żądanie.</param>
        <param name="headers">A <see cref="T:System.Collections.Specialized.NameValueCollection" /> nagłówków żądania dla nowego żądania.</param>
        <summary>Wykonuje asynchroniczny wykonanie określonego adresu URL za pomocą określonej metody HTTP i nagłówków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana podczas uruchamiania w trybie zintegrowanym potoku [!INCLUDE[iisver](~/includes/iisver-md.md)] umożliwia przetwarzanie żądań do można przenosić od jednego zasobu typu do drugiego podczas wykonywania żądania docelowych z kontekstu żądania poprawne. Na przykład można użyć <xref:System.Web.HttpServerUtility.TransferRequest%2A> metody transferu żądanie strony ASPX na żądanie strony XML.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> Metoda wykonuje asynchroniczne podrzędnych wykonanie określonego adresu URL z następujących warunków:  
  
-   Jeśli `path` parametr określa ciąg zapytania, będzie on używany jako nowe parametry zapytania. Jeśli ciąg zapytania nie jest włączone, ciąg zapytania żądania będą ponownie używane.  
  
-   Jeśli `method` parametr jest określony, będzie on używany. Jeśli jest `null`, zostanie użyta metoda HTTP oryginalnego żądania.  
  
-   Jeśli `preserveForm` parametr jest `true`, bieżącej treści jednostki żądania będą dostępne na żądanie docelowe. Umożliwia wpisów formularza i przekazuje je do przeniesienia.  
  
-   Jeśli tożsamości użytkownika jest obecnie ustawiona dla oryginalnego żądania, tożsamość zostanie przeniesiona do nowego żądania. Dzięki temu uwierzytelnianych żądań ponownego używania wynik uwierzytelniania dla nowego żądania. Jeśli nie chcesz, aby użytkownik, który ma zostać przesłany, Ustaw użytkownika `null` na oryginalne żądanie przed przeniesieniem.  
  
-   Jeśli `headers` parametr jest określony, nowe żądanie będzie wykonywane za pomocą określonego nagłówków. Może służyć do modyfikowania nagłówki żądania i pliki cookie dla nowego żądania lub Dodaj specjalne nagłówek, który określa, gdzie otrzymano oryginalne żądanie.  
  
     Ta metoda wywołuje <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> przeciążenie metody z `preserveUser` ustawiono parametr `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga [!INCLUDE[iisver](~/includes/iisver-md.md)] działają w trybie zintegrowanym.</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępna do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="preserveUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <param name="method">Metoda HTTP do użycia w nowe żądanie.</param>
        <param name="headers">A <see cref="T:System.Collections.Specialized.NameValueCollection" /> obiekt, który zawiera nagłówki żądania dla nowego żądania.</param>
        <param name="preserveUser">
          <see langword="true" /> Aby zachować tożsamość użytkownika; w przeciwnym razie <see langword="false" />. Inne przeciążenia metody tej metody wywołać tego przeciążenia z tym parametrem ustawioną <see langword="true" />.</param>
        <summary>Wykonuje asynchroniczne wykonanie określonego adresu URL przy użyciu określonej metody HTTP, nagłówki i ścieżkę, a opcjonalnie zachowuje wartości formularza i tożsamości użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz sekcję "Uwagi" w <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga trybu zintegrowanego potoku [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępna do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje ciąg, który został kodowane transmisji HTTP, a następnie wysyłane do serwera w adresie URL.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, użyj <see cref="T:System.Net.WebUtility" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg tekstowy do zdekodowania.</param>
        <summary>Adres URL dekoduje ciągiem i zwraca Dekodowany ciąg.</summary>
        <returns>Tekst zdekodowana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresu URL zapewnia wszystkie przeglądarki poprawnie przekazuje tekstu w ciągach adresu URL. Znaki, takie jak pytanie znaku (?), handlowego "i" (&), ukośnik znaku (/) i spacje może obcięty lub uszkodzona przez niektóre przeglądarki. W związku z tym te znaki muszą być kodowane w `<a>` znaczników lub w zapytaniu ciągi, gdzie ciągi mogą być ponownie wysyłane przez przeglądarki w ciągu żądania.  
  
 Jest to wygodny sposób dostępu do <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> metody w czasie wykonywania w aplikacji ASP.NET. Wewnętrznie ta metoda używa <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> zdekodować ciągów.  
  
 W pliku CodeBehind dla strony sieci web platformy ASP.NET, należy uzyskać dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy za pomocą `Server` właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, użyj `HttpContext.Current.Server` można uzyskać dostępu do wystąpienia <xref:System.Web.HttpServerUtility> klasy.  
  
 Poza aplikacją sieci web, użyj <xref:System.Net.WebUtility> klasy do kodowania i dekodowania wartości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób adres URL zdekodować wartość które są pobierane z ciągu zapytania. Kod znajduje się w pliku CodeBehind dla strony sieci web. `ReturnPage` odwołuje się do `HyperLink` formantu.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 Kolejnym przykładzie jest podobny do poprzedniego przykładu, z wyjątkiem widoczny jest sposób zdekodować adresu URL wartość z zakresu od wewnątrz klasy nie jest w pliku CodeBehind.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg HTML do zdekodowania.</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> Strumienia wyjściowego, który zawiera Dekodowany ciąg.</param>
        <summary>Dekoduje ciąg HTML odebrane w adresie URL, a następnie wysyła dane wyjściowe do powstałe w ten sposób <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresu URL zapewnia wszystkie przeglądarki poprawnie przekazuje tekstu w ciągach adresu URL. Znaki, takie jak pytanie znaku (?), handlowego "i" (&), ukośnik znaku (/) i spacje może obcięty lub uszkodzona przez niektóre przeglądarki. W związku z tym te znaki muszą być kodowane w `<a>` znaczników lub w zapytaniu ciągi, gdzie ciągi mogą być ponownie wysyłane przez przeglądarki w ciągu żądania.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> jest to wygodny sposób dostępu <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> metody w czasie wykonywania w aplikacji ASP.NET. Wewnętrznie <xref:System.Web.HttpServerUtility.UrlDecode%2A> używa <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> zdekodować ciągów.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, użyj <xref:System.Net.WebUtility> klasy.  
  
   
  
## Examples  
 Poniższy przykład dekoduje parametrów o nazwie `EncodedString` (odebrana w adresie URL) w ciągu o nazwie `DecodedString`.  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje ciąg niezawodnej transmisji HTTP na serwerze sieci Web z klientem za pośrednictwem adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> jest to wygodny sposób dostępu <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metody w czasie wykonywania w aplikacji ASP.NET. Wewnętrznie <xref:System.Web.HttpServerUtility.UrlEncode%2A> używa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do kodowania ciągów.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, użyj <xref:System.Net.WebUtility> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Tekst do kodowania adresu URL.</param>
        <summary>Ciąg koduje adresu URL i zwraca ciąg kodowany jako.</summary>
        <returns>Tekst zakodowane w adresie URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresu URL zapewnia wszystkie przeglądarki poprawnie przekazuje tekstu w ciągach adresu URL. Znaki, takie jak pytanie znaku (?), handlowego "i" (&), ukośnik znaku (/) i spacje może obcięty lub uszkodzona przez niektóre przeglądarki. W związku z tym te znaki muszą być kodowane w `<a>` znaczników lub w zapytaniu ciągi, gdzie ciągi mogą być ponownie wysyłane przez przeglądarki w ciągu żądania.  
  
 Jest to wygodny sposób dostępu do <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metody w czasie wykonywania w aplikacji ASP.NET. Wewnętrznie ta metoda używa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do kodowania ciągów.  
  
 W pliku CodeBehind dla strony sieci web platformy ASP.NET, należy uzyskać dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy za pomocą `Server` właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, użyj `HttpContext.Current.Server` można uzyskać dostępu do wystąpienia <xref:System.Web.HttpServerUtility> klasy.  
  
 Poza aplikacją sieci web, użyj <xref:System.Net.WebUtility> klasy do kodowania i dekodowania wartości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób kodowania adresu URL wartość służące jako wartość ciągu kwerendy hiperłącza. Kod znajduje się w pliku CodeBehind dla strony sieci web. Wartość do zakodowania jest ustalony w tym przykładzie tylko w celu uproszczenia przykładzie i pokazania typ wartości, które może być kodowania adresu URL. Zwykle ma kodowania adresu URL wartość otrzymanej od użytkownika lub żądanie. `NextPage` odwołuje się do `HyperLink` formantu.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 Kolejnym przykładzie jest podobny do poprzedniego przykładu, z wyjątkiem widoczny jest sposób kodowania adresu URL wartość z zakresu od wewnątrz klasy nie jest w pliku CodeBehind.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg tekstowy do kodowania.</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> Strumienia wyjściowego, który zawiera ciąg zakodowany.</param>
        <summary>Ciąg koduje adresu URL i wysyła wynikowe dane wyjściowe do <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresu URL zapewnia wszystkie przeglądarki poprawnie przekazuje tekstu w ciągach adresu URL. Znaki, takie jak pytanie znaku (?), handlowego "i" (&), ukośnik znaku (/) i spacje może obcięty lub uszkodzona przez niektóre przeglądarki. W związku z tym te znaki muszą być kodowane w `<a>` znaczników lub w zapytaniu ciągi, gdzie ciągi mogą być ponownie wysyłane przez przeglądarki w ciągu żądania.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> jest to wygodny sposób dostępu <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metody w czasie wykonywania w aplikacji ASP.NET. Wewnętrznie <xref:System.Web.HttpServerUtility.UrlEncode%2A> używa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do kodowania ciągów.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, użyj <xref:System.Net.WebUtility> klasy.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg w celu przesyłania przy użyciu protokołu HTTP. Koduje go parametrów o nazwie `TestString`, zawierającej tekst "to \<ciąg testu >." i kopiuje go do parametrów o nazwie `EncodedString` jako "to + jest + % 3cTest + ciąg % 3e.".  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Tekst do kodowania adresu URL.</param>
        <summary>Nie używaj; przeznaczone tylko dla zgodność z przeglądarkami. Użyj <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>Tekst zakodowane w adresie URL.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Token ciągu adresu URL do zdekodowania.</param>
        <summary>Dekoduje tokenem ciągu adresu URL, do jego tablicy bajtów równoważne przy użyciu podstawowych cyfr 64.</summary>
        <returns>Tablica bajtów zawierająca dekodowane token ciągu adresu URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Metoda konwertuje tokenem ciągu adresu URL, który koduje dane binarne jako podstawowych cyfr 64, na jej reprezentację tablicy bajtów równoważne. Użyj <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> metody w celu zdekodowania tokenów przesyłane na adres URL i zakodowane przy użyciu <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>.  
  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> — Metoda zwraca tablicę bajtów pusty w przypadku `input` parametr ma długość mniejszą niż jeden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="input" /> parametr jest <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="input">Tablica bajtów do kodowania.</param>
        <summary>Koduje tablicy bajtów w reprezentacji równoważne ciągu przy użyciu podstawowych cyfr 64, można używać w celu przesłania go na adres URL.</summary>
        <returns>Ciąg zawierający zakodowany token Jeśli tablica bajtów *długość* jest większa niż jeden; w przeciwnym razie ciąg pusty ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> Metoda konwertuje tablicę bajtów na równoważne reprezentację zakodowane za pomocą podstawowych cyfr 64. Wynikowy ciąg tokenu można przesyłane na adres URL.  
  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> Zwraca pusty ciąg, gdy `input` parametr ma długość mniejszą niż jeden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="input" /> parametr jest <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
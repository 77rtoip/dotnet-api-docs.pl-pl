<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80eb5a3f30a3ad4a39f49dca9820cd97cfa81308" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37529052" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <TypeSignature Language="F#" Value="type HttpServerUtility = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia metody pomocnicze do przetwarzania żądań sieci Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody i właściwości <xref:System.Web.HttpServerUtility> klasy są udostępniane za pośrednictwem wewnętrznego <xref:System.Web.HttpContext.Server%2A> obiekt udostępniany przez platformę ASP.NET.  
  
   
  
## Examples  
 Projekt witryny internetowego programu Visual Studio z kodem źródłowym jest dostępna powiązany z tym tematem: [Pobierz](http://go.microsoft.com/fwlink/?LinkId=192870).  
  
 Poniższy przykład pokazuje sposób użycia <xref:System.Web.HttpServerUtility.HtmlEncode%2A> metody i <xref:System.Web.HttpServerUtility.UrlEncode%2A> metody <xref:System.Web.HttpServerUtility> klasy. <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Metoda pomaga upewnić się, że dane wejściowe dowolny ciąg, dostarczone przez użytkownika, będzie renderowana jako tekst statyczny w przeglądarkach zamiast pliku wykonywalnego skryptu lub elementów HTML. <xref:System.Web.HttpServerUtility.UrlEncode%2A> Metoda koduje adresy URL, dzięki czemu są one prawidłowo przekazane w strumieniu HTTP.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpServerUtility.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści poprzedniego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład usuwa ostatni wyjątek, który został zgłoszony.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie obiektu modelu COM serwera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : string -&gt; obj" Usage="httpServerUtility.CreateObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Klasy lub typ obiektu do utworzenia wystąpienia.</param>
        <summary>Tworzy wystąpienie serwera obiektu COM identyfikowane za pomocą obiektu identyfikator programowy (ProgID).</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy obiekt przy użyciu identyfikatora obiektu.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie można utworzyć wystąpienia obiektu.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : Type -&gt; obj" Usage="httpServerUtility.CreateObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący obiekt do utworzenia.</param>
        <summary>Tworzy wystąpienie serwera obiektu COM identyfikowanych według typu obiektu.</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectFromClsid : string -&gt; obj" Usage="httpServerUtility.CreateObjectFromClsid clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator klasy obiektu, aby utworzyć wystąpienie.</param>
        <summary>Tworzy wystąpienie serwera obiektu COM identyfikowane przez identyfikator klasy obiektu (CLSID).</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> metodę w celu utworzenia wystąpienia obiektu modelu COM serwera.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie można utworzyć wystąpienia obiektu.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje program obsługi dla określonego zasobu w kontekście bieżącego żądania i zwraca wykonanie do strony, które je wywołało.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Execute : string -&gt; unit" Usage="httpServerUtility.Execute path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <summary>Program obsługi dla określonej ścieżki wirtualnej jest wykonywany w kontekście bieżącego żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Metoda kontynuuje wykonywanie oryginalną stronę po zakończeniu wykonywania nowej strony. <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda bezwarunkowo przenosi wykonanie do innego programu obsługi.  
  
 Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlania zasobów dostarczanych przez <xref:System.Web.HttpServerUtility.Execute%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalnego obsługi zasobów, ASP.NET bezpośrednio wywołuje program obsługi, wskazywanym przez <xref:System.Web.HttpServerUtility.Execute%2A> metody i nie zostanie uruchomiona ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń Twojej aplikacji wymaga klientom autoryzacji dostępu do zasobu, aplikacja powinna wymuszenia ponownej autoryzacji lub mechanizm kontroli dostępu niestandardowych.  
  
 Istnieje możliwość wymuszenia ponownej autoryzacji przy użyciu <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe wezwanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń Internet Information Services (IIS) i platformy ASP.NET.  
  
 Możesz sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacja niestandardowa, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Execute%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla strony .aspx "Updateinfo.aspx" w bieżącym katalogu. Po wyświetleniu strony Updateinfo.aspx wykonywania programu zwraca się do strony początkowej.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest <see langword="null" />.  \- lub — wystąpił błąd podczas wykonywania procedury obsługi określony przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  \- lub - <paramref name="path" /> nie jest ścieżką wirtualną.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * bool -&gt; unit" Usage="httpServerUtility.Execute (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Program obsługi dla określonej ścieżki wirtualnej jest wykonywany w kontekście bieżącego żądania i określa, czy należy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak wykonać strony .aspx `Updateinfo.aspx` w bieżącym żądaniu i Zachowaj <xref:System.Web.HttpRequest.QueryString%2A> i <xref:System.Web.HttpRequest.Form%2A> kolekcji. Wykonywanie programu powraca do strony początkowej po `Updateinfo.aspx` jest wyświetlana.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest <see langword="null" />.  \- lub — wystąpił błąd podczas wykonywania procedury obsługi określony przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  \- lub - <paramref name="path" /> nie jest ścieżką wirtualną.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.Execute (path, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Do przechwytywania danych wyjściowych.</param>
        <summary>Program obsługi dla określonej ścieżki wirtualnej jest wykonywany w kontekście bieżącego żądania. A <see cref="T:System.IO.TextWriter" /> przechwytuje dane wyjściowe z wykonanych programu obsługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Metoda kontynuuje wykonywanie oryginalnego żądania po zakończeniu wykonywania określonej ścieżki wirtualnej. <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda bezwarunkowo przenosi wykonanie do innego programu obsługi.  
  
 Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlania zasobów dostarczanych przez <xref:System.Web.HttpServerUtility.Execute%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalnego obsługi zasobów, ASP.NET bezpośrednio wywołuje program obsługi, wskazywanym przez <xref:System.Web.HttpServerUtility.Execute%2A> metody i nie zostanie uruchomiona ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń Twojej aplikacji wymaga klientom autoryzacji dostępu do zasobu, aplikacja powinna wymuszenia ponownej autoryzacji lub mechanizm kontroli dostępu niestandardowych.  
  
 Istnieje możliwość wymuszenia ponownej autoryzacji przy użyciu <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe wezwanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń Internet Information Services (IIS) i platformy ASP.NET.  
  
 Możesz sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacja niestandardowa, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Execute%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wykonuje `Login.aspx` strony na serwerze w bieżącym katalogu i odbiera dane wyjściowe ze strony za pomocą <xref:System.IO.StringWriter> obiektu `writer`. Zapisuje otrzymane od strumienia HTML `writer` HTTP strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest <see langword="null" />.  \- lub — wystąpił błąd podczas wykonywania procedury obsługi określony przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  \- lub - <paramref name="path" /> nie jest ścieżką wirtualną.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (path, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL do wykonania.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Do przechwytywania danych wyjściowych.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Program obsługi dla określonej ścieżki wirtualnej jest wykonywany w kontekście bieżącego żądania. A <see cref="T:System.IO.TextWriter" /> przechwytywania danych wyjściowych strony i parametrem logicznym Określa, czy należy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> Metoda kontynuuje wykonywanie oryginalnego żądania po zakończeniu wykonywania określonej ścieżki wirtualnej. <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda bezwarunkowo przenosi wykonanie do innego programu obsługi.  
  
 Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlania zasobów dostarczanych przez <xref:System.Web.HttpServerUtility.Execute%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalnego obsługi zasobów, ASP.NET bezpośrednio wywołuje program obsługi, wskazywanym przez <xref:System.Web.HttpServerUtility.Execute%2A> metody i nie zostanie uruchomiona ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń Twojej aplikacji wymaga klientom autoryzacji dostępu do zasobu, aplikacja powinna wymuszenia ponownej autoryzacji lub mechanizm kontroli dostępu niestandardowych.  
  
 Istnieje możliwość wymuszenia ponownej autoryzacji przy użyciu <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe wezwanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń Internet Information Services (IIS) i platformy ASP.NET.  
  
 Możesz sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacja niestandardowa, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Execute%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wykonuje `Login.aspx` strony na serwerze w bieżącym katalogu i odbiera dane wyjściowe ze strony za pomocą <xref:System.IO.StringWriter> obiektu `writer`. Zapisuje otrzymane od strumienia HTML `writer` HTTP strumienia wyjściowego. Zawartość <xref:System.Web.HttpRequest.Form%2A> i <xref:System.Web.HttpRequest.QueryString%2A> kolekcje są zachowywane.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).  \- lub - <paramref name="path" /> kończy się kropką (.).  \- lub — wystąpił błąd podczas wykonywania procedury obsługi określony przez <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> nie jest ścieżką wirtualną.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : System.Web.IHttpHandler * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (handler, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">Program obsługi HTTP, który implementuje <see cref="T:System.Web.IHttpHandler" /> transferowania bieżącego żądania.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Do przechwytywania danych wyjściowych.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Program obsługi dla określonej ścieżki wirtualnej jest wykonywany w kontekście bieżącego żądania. A <see cref="T:System.IO.TextWriter" /> przechwytywania danych wyjściowych wykonanych obsługi i parametrem logicznym Określa, czy należy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz tworzyć niestandardowe funkcje obsługi protokołu HTTP do przetwarzania określonych, wstępnie zdefiniowanych typów żądań HTTP w dowolnym języku, który jest zgodny z Common Language Specification (CLS). Kod wykonywalny, który jest zdefiniowany w klasy programu obsługi HTTP zamiast konwencjonalne stron ASP (nazywany także klasyczne środowisko ASP) lub stron ASP.NET odnosi się do tych określonych żądań. Zezwalaj na funkcje obsługi protokołu HTTP do interakcji z niskiego poziomu żądania i odpowiedzi usługi serwera sieci Web, na którym działa program Internet Information Services (IIS), które udostępniają funkcje, które są podobne do rozszerzeń ISAPI, ale prostszym modelu programowania.  
  
 Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlania zasobów, która jest dostarczana przez <xref:System.Web.HttpServerUtility.Execute%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalnego obsługi zasobów, ASP.NET bezpośrednio wywołuje program obsługi, który jest wskazywany przez <xref:System.Web.HttpServerUtility.Execute%2A> metody i nie zostanie uruchomiona ponownie logika uwierzytelniania i autoryzacji Nowy zasób. Jeśli zasady zabezpieczeń dla aplikacji wymaga klientom autoryzacji do uzyskania dostępu do zasobu, aplikacja powinna wymuszenia ponownej lub mechanizm kontroli dostępu niestandardowych.  
  
 Istnieje możliwość wymuszenia ponownej autoryzacji przy użyciu <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Execute%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe wezwanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń usług IIS i platformy ASP.NET.  
  
 Możesz sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacja niestandardowa, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Execute%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Wystąpił błąd podczas wykonywania procedury obsługi określony przez <paramref name="handler" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handler" /> Parametr <see langword="null" />.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberSignature Language="F#" Value="member this.GetLastError : unit -&gt; Exception" Usage="httpServerUtility.GetLastError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość poprzedniego wyjątku.</summary>
        <returns>Poprzedniego wyjątku, który został zgłoszony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla opis ostatniego błędu aplikacji do strumienia wyjściowego HTTP. Jeśli zostały napotkane żadne błędy, drukuje "No błędy".  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje ciąg, który został zakodowany w celu wyeliminowania nieprawidłowych znaków HTML.  Do kodowania i dekodowania wartości spoza aplikacji sieci web, należy użyć <see cref="T:System.Net.WebUtility" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string -&gt; string" Usage="httpServerUtility.HtmlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg HTML do odkodowania.</param>
        <summary>Dekoduje ciąg zakodowany w formacie HTML i zwraca Dekodowany ciąg.</summary>
        <returns>Zdekodowany tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML sprawia, że się, że tekst jest poprawnie wyświetlana w przeglądarce, a nie interpretowany przez przeglądarkę jako kod HTML. Na przykład, jeśli ciąg tekstowy zawiera mniej niż znak (\<) lub nowszej znak większości (>), przeglądarki będzie interpretować te znaki jako otwierania lub zamykającego nawiasu potraktowane jak tag HTML. Jeśli znaki są zakodowane w formacie HTML, są one konwertowane na ciągi `&lt;` i `&gt;`, co powoduje, że przeglądarki wyświetlić mniej niż logowania i większa niż podpisać poprawnie. <xref:System.Web.HttpServerUtility.HtmlDecode%2A> dekoduje tekst, który została przesłana do serwera.  
  
 Ta metoda jest wygodny sposób, aby uzyskać dostęp do <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> metody w czasie wykonywania z aplikacji ASP.NET. Wewnętrznie ta metoda używa <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> do dekodowania ciągów znaków.  
  
 W pliku związanym z kodem dla strony sieci web ASP.NET, dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy za pomocą `Server` właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, należy użyć `HttpContext.Current.Server` dostęp do wystąpienia programu <xref:System.Web.HttpServerUtility> klasy.  
  
 Poza aplikacji sieci web, należy użyć <xref:System.Net.WebUtility> klasy do kodowania i dekodowania wartości.  
  
   
  
## Examples  
 Poniższy przykład zawiera funkcję `LoadDecodedFile`, które dekoduje dane z pliku i kopiuje go do jednego ciągu.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg HTML do odkodowania.</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> Strumienia wyjściowego, który zawiera Dekodowany ciąg.</param>
        <summary>Dekoduje ciąg zakodowany w formacie HTML, a następnie wysyła dane wyjściowe do wynikowy <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML sprawia, że się, że tekst jest poprawnie wyświetlana w przeglądarce, a nie interpretowany przez przeglądarkę jako kod HTML. Na przykład, jeśli ciąg tekstowy zawiera mniej niż znak (\<) lub nowszej znak większości (>), przeglądarki będzie interpretować te znaki jako otwierania lub zamykającego nawiasu potraktowane jak tag HTML. Jeśli znaki są zakodowane w formacie HTML, są one konwertowane na ciągi `&lt;` i `&gt;`, co powoduje, że przeglądarki wyświetlić mniej niż logowania i większa niż podpisać poprawnie.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> dekoduje tekst, który została przesłana do serwera.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> to wygodny sposób, aby uzyskać dostęp do <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> metody w czasie wykonywania z aplikacji ASP.NET. Wewnętrznie <xref:System.Web.HttpServerUtility.HtmlDecode%2A> używa <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> do dekodowania ciągów znaków.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, należy użyć <xref:System.Net.WebUtility> klasy.  
  
   
  
## Examples  
 Poniższy przykład Dekoduje ciąg, który został zakodowany w formacie HTML do przesłania za pośrednictwem protokołu HTTP. Dekoduje on podany ciąg o nazwie `EncodedString` zawierający tekst "to &lt;testowany ciąg&gt;." i kopiuje go do parametrów o nazwie `DecodedString` jako "to \<ciąg testu >.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje ciąg do wyświetlenia w przeglądarce.  Do kodowania i dekodowania wartości spoza aplikacji sieci web, należy użyć <see cref="T:System.Net.WebUtility" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string -&gt; string" Usage="httpServerUtility.HtmlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg tekstowy do zakodowania.</param>
        <summary>HTML koduje ciąg i zwraca ciąg zakodowany.</summary>
        <returns>Tekst kodowany w formacie HTML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML sprawia, że się, że tekst jest poprawnie wyświetlana w przeglądarce, a nie interpretowany przez przeglądarkę jako kod HTML. Na przykład, jeśli ciąg tekstowy zawiera mniej niż znak (\<) lub nowszej znak większości (>), przeglądarki będzie interpretować te znaki jako otwierania lub zamykającego nawiasu potraktowane jak tag HTML. Jeśli znaki są zakodowane w formacie HTML, są one konwertowane na ciągi `&lt;` i `&gt;`, co powoduje, że przeglądarki wyświetlić mniej niż logowania i większa niż podpisać poprawnie.  
  
 Ta metoda jest wygodny sposób, aby uzyskać dostęp do <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> metody w czasie wykonywania z aplikacji ASP.NET. Wewnętrznie ta metoda używa <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> do zakodowania ciągów.  
  
 W pliku związanym z kodem dla strony sieci web ASP.NET, dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy za pomocą `Server` właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, należy użyć `HttpContext.Current.Server` dostęp do wystąpienia programu <xref:System.Web.HttpServerUtility> klasy.  
  
 Poza aplikacji sieci web, należy użyć <xref:System.Net.WebUtility> klasy do kodowania i dekodowania wartości.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak kodowanie HTML wartość która potencjalnie kody niebezpieczny kod. Kod znajduje się w pliku CodeBehind dla strony sieci web. Wartość do zakodowania jest ustalony w tym przykładzie, tylko do uprościć przykład ukazują typ wartości, które może być kodowanie HTML. Zwykle jak kodowanie HTML wartość, która odebrane od użytkownika lub żądania. `Result` odwołuje się do `Literal` kontroli.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 Następny przykład jest podobny do poprzedniego przykładu, z wyjątkiem pokazuje jak kodowanie HTML wartość z zakresu od wewnątrz klasy który nie jest w pliku związanym z kodem.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg do kodowania.</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> Strumienia wyjściowego, który zawiera ciąg zakodowany.</param>
        <summary>HTML koduje ciąg i wysyła wynikowy dane wyjściowe do <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie HTML gwarantuje, czy tekst będzie prawidłowo wyświetlany w przeglądarce, nie jest interpretowany przez przeglądarkę jako kod HTML. Na przykład, jeśli ciąg tekstowy zawiera mniej niż znak (\<) lub nowszej znak większości (>), przeglądarka będzie interpretować te znaki jako otwierania lub zamykającego nawiasu potraktowane jak tag HTML. Kodowanie HTML, który z tych dwóch znaków jest `&lt;` i `&gt;`, odpowiednio, co powoduje, że przeglądarki wyświetlić mniej niż logowania i większa niż podpisać poprawnie.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> to wygodny sposób, aby uzyskać dostęp do <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> metody w czasie wykonywania z aplikacji ASP.NET. Wewnętrznie <xref:System.Web.HttpServerUtility.HtmlEncode%2A> używa <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> do zakodowania ciągów.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, należy użyć <xref:System.Net.WebUtility> klasy.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg przesyłania przy użyciu protokołu HTTP. Koduje go jako parametrów o nazwie `TestString`, który zawiera tekst "to \<testowany ciąg >." i kopiuje go do parametrów o nazwie `EncodedString` jako "to &lt;testowany ciąg&gt;.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę komputera serwera.</summary>
        <value>Nazwa komputera lokalnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przechowuje nazwę komputera serwera jako zmiennej ciągu.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nie można odnaleźć nazwy komputera.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpServerUtility.MapPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka wirtualna aplikacji sieci Web.</param>
        <summary>Zwraca ścieżka fizyczna do pliku, który odnosi się do określonej ścieżki wirtualnej.</summary>
        <returns>Ścieżka fizyczna do pliku na serwerze sieci Web, która odpowiada <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `path` jest `null`, <xref:System.Web.HttpServerUtility.MapPath%2A> metoda zwraca pełną ścieżkę fizyczną katalogu, który zawiera bieżące żądanie dla ścieżki. Ścieżka względna nie trzeba określić istniejący plik lub folder dla tej metody w celu zwrócenia wartości. Jednak nie można określić ścieżki spoza aplikacji sieci Web.  
  
> [!IMPORTANT]
>  <xref:System.Web.HttpServerUtility.MapPath%2A> Metoda zawiera potencjalnie poufnych informacji o środowisku macierzystym. Wartość zwracana nie powinien być wyświetlany użytkownikom.  
  
 Aplikacja sieci Web, która znajduje się w `C:\ExampleSites\TestMapPath` zwróci następujące wyniki:  
  
|Żądania z|`path`|Zwrócona wartość|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|".. / OutsideApplication "|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można pobrać pliku fizycznego względnej ścieżki wirtualnej. Kod znajduje się w pliku związanym z kodem dla strony sieci web i korzysta z domyślnego `Server` obiektu.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 Następny przykład jest podobny do poprzedniego przykładu, jednak pokazuje, jak pobrać ścieżki fizycznej z w obrębie klasy, która nie znajduje się w pliku CodeBehind.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest <see langword="null" />.
 - lub - <paramref name="path" /> jest ścieżka fizyczna, ale oczekiwano ścieżki wirtualnej.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptTimeout : int with get, set" Usage="System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera i ustawia wartość limitu czasu żądania w ciągu kilku sekund.</summary>
        <value>Ustawienie wartości limitu czasu żądania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> Właściwość można ustawić w pliku Web.config, ustawiając `executionTimeout` atrybut tego elementu. Konfigurowanie limitu czasu programowo przy użyciu <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> właściwości mają pierwszeństwo przed ustawieniem pliku Web.config.  
  
> [!NOTE]
>  Jeśli ustawisz `debug` atrybut elementu do `true` w pliku Web.config, wartością <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> zostaną zignorowane.  
  
   
  
## Examples  
 W poniższym przykładzie ustawiono limit czasu żądania do 60 sekund.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Bieżący <see cref="T:System.Web.HttpContext" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Limit czasu jest <see langword="null" /> lub w przeciwnym razie nie można ustawić.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy wykonywanie bieżącej strony i rozpoczyna wykonywanie nowego strony dla bieżącego żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string -&gt; unit" Usage="httpServerUtility.Transfer path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze w celu wykonania.</param>
        <summary>Dla bieżącego żądania kończy wykonywanie bieżącej strony i rozpoczyna wykonywanie nową stronę przy użyciu określonej ścieżki URL strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strona przekazanego powinna być innej strony .aspx. Na przykład przeniesienie do strony ASP lub .asmx jest nieprawidłowy. <xref:System.Web.HttpServerUtility.Transfer%2A> Zachowuje metoda <xref:System.Web.HttpRequest.QueryString%2A> i <xref:System.Web.HttpRequest.Form%2A> kolekcji.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> wywołania <xref:System.Web.HttpResponse.End%2A>, który zgłasza <xref:System.Threading.ThreadAbortException> wyjątek po jego ukończeniu.  
  
 Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlania zasobów dostarczanych przez <xref:System.Web.HttpServerUtility.Transfer%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalnego obsługi zasobów, ASP.NET bezpośrednio wywołuje program obsługi, wskazywanym przez <xref:System.Web.HttpServerUtility.Transfer%2A> metody i nie zostanie uruchomiona ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń Twojej aplikacji wymaga klientom autoryzacji dostępu do zasobu, aplikacja powinna wymuszenia ponownej autoryzacji lub mechanizm kontroli dostępu niestandardowych.  
  
 Istnieje możliwość wymuszenia ponownej autoryzacji przy użyciu <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Metoda wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe wezwanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń Internet Information Services (IIS) i platformy ASP.NET.  
  
 Możesz sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacja niestandardowa, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Transfer%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string * bool -&gt; unit" Usage="httpServerUtility.Transfer (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze w celu wykonania.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Kończy wykonywanie bieżącej strony i rozpoczyna wykonywanie nowej strony przy użyciu określonej ścieżki URL strony. Określa, czy należy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strona przekazanego powinna być innej strony .aspx. Na przykład przeniesienie do strony ASP lub .asmx jest nieprawidłowy.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> wywołania <xref:System.Web.HttpResponse.End%2A>, który zgłasza <xref:System.Threading.ThreadAbortException> wyjątek po jego ukończeniu.  
  
 Jeśli ustawisz `preserveForm` parametr `true`, strony docelowej będą mogli uzyskać dostęp do stanu widoku poprzedniej strony, korzystając <xref:System.Web.UI.Page.PreviousPage%2A> właściwości.  
  
 Ze względów bezpieczeństwa należy zachować `enableViewStateMac` ustawioną wartość atrybutu `true`. Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlania zasobów dostarczanych przez <xref:System.Web.HttpServerUtility.Transfer%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalnego obsługi zasobów, ASP.NET bezpośrednio wywołuje program obsługi, wskazywanym przez <xref:System.Web.HttpServerUtility.Transfer%2A> metody i nie zostanie uruchomiona ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń Twojej aplikacji wymaga klientom autoryzacji dostępu do zasobu, aplikacja powinna wymuszenia ponownej autoryzacji lub mechanizm kontroli dostępu niestandardowych.  
  
 Istnieje możliwość wymuszenia ponownej autoryzacji przy użyciu <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Metoda wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe wezwanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń Internet Information Services (IIS) i platformy ASP.NET.  
  
 Możesz sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacja niestandardowa, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Transfer%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wykonuje nową stronę w tym samym katalogu co bieżącej strony.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Bieżącego żądania strony jest wywołanie zwrotne.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : System.Web.IHttpHandler * bool -&gt; unit" Usage="httpServerUtility.Transfer (handler, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">Program obsługi HTTP, który implementuje <see cref="T:System.Web.IHttpHandler" /> transferowania bieżącego żądania.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji; <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Kończy wykonywanie bieżącej strony i rozpoczyna wykonywanie nowego żądania przy użyciu niestandardowy program obsługi HTTP, który implementuje <see cref="T:System.Web.IHttpHandler" /> interfejs i określa, czy należy wyczyścić <see cref="P:System.Web.HttpRequest.QueryString" /> i <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz tworzyć niestandardowe funkcje obsługi protokołu HTTP do przetwarzania określonych, wstępnie zdefiniowanych typów żądań HTTP w dowolnym języku, który jest zgodny z Common Language Specification (CLS). Kod wykonywalny, który jest zdefiniowany w klasy programu obsługi HTTP zamiast konwencjonalne stron ASP (nazywany także klasyczne środowisko ASP) lub stron ASP.NET odnosi się do tych określonych żądań. Zezwalaj na funkcje obsługi protokołu HTTP do interakcji z niskiego poziomu żądania i odpowiedzi usługi serwera sieci Web, na którym działa program Internet Information Services (IIS), które udostępniają funkcje, które są podobne do rozszerzeń ISAPI, ale prostszym modelu programowania.  
  
 Jeśli ustawisz `preserveForm` parametr `true`, strony docelowej będą mogli uzyskać dostęp do stanu widoku poprzedniej strony, korzystając <xref:System.Web.UI.Page.PreviousPage%2A> właściwości.  
  
 Ze względów bezpieczeństwa należy zachować `enableViewStateMac` ustawioną wartość atrybutu `true`. Program ASP.NET nie sprawdza, czy bieżący użytkownik jest autoryzowany do wyświetlania zasobów dostarczanych przez <xref:System.Web.HttpServerUtility.Transfer%2A> metody. Mimo że logiki autoryzację i uwierzytelnianie ASP.NET jest uruchamiany przed wywołaniem oryginalnego obsługi zasobów, ASP.NET bezpośrednio wywołuje program obsługi, wskazywanym przez <xref:System.Web.HttpServerUtility.Transfer%2A> metoda i ma nie ponownie logiki uwierzytelniania i autoryzacji dla nowego zasób. Jeśli zasady zabezpieczeń dla aplikacji wymaga klientom autoryzacji dostępu do zasobu, aplikacja powinna wymuszenia ponownej autoryzacji lub mechanizm kontroli dostępu niestandardowych.  
  
 Istnieje możliwość wymuszenia ponownej autoryzacji przy użyciu <xref:System.Web.HttpResponse.Redirect%2A> zamiast metody <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpResponse.Redirect%2A> Metoda wykonuje przekierowanie po stronie klienta, w którym przeglądarka żąda nowego zasobu. Ponieważ przekierowanie to nowe wezwanie wejścia do systemu, podlega całą logikę uwierzytelniania i autoryzacji zasad zabezpieczeń usług IIS i platformy ASP.NET.  
  
 Możesz sprawdzić, czy użytkownik ma uprawnienia do wyświetlania zasobów poprzez wykorzystanie metody autoryzacja niestandardowa, która używa <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody przed wywołania aplikacji <xref:System.Web.HttpServerUtility.Transfer%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Bieżącego żądania strony jest wywołanie zwrotne.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje asynchroniczne wykonywanie określonego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> wprowadzono w programie .NET Framework w wersji 3.5. Aby uzyskać podsumowanie informacji na temat programu .NET Framework, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string -&gt; unit" Usage="httpServerUtility.TransferRequest path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze w celu wykonania.</param>
        <summary>Wykonuje asynchroniczne wykonywanie określonego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia metody wywołuje <xref:System.Web.HttpServerUtility.TransferRequest%2A> przeciążenia z `preserveForm` parametr `false`, `method` parametr `null`, `headers` parametr `null`i `preserveUser` Parametr `true`. Aby uzyskać więcej informacji, zobacz sekcję "Uwagi" w <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga trybu zintegrowanego potoku [! INCLUDE[iisver](~/includes/iisver-MD.MD)].</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępny do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze w celu wykonania.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.Form" /> kolekcji <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <summary>Wykonuje asynchroniczne wykonywanie określonego adresu URL i zachowuje parametry ciągu zapytania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołuje to przeciążenie <xref:System.Web.HttpServerUtility.TransferRequest%2A> przeciążenia z `preserveForm` parametrem ustawionym na wartość przekazano, `method` parametr `null`, `headers` parametr `null`i `preserveUser` zestaw parametrów Aby `true`. Aby uzyskać więcej informacji, zobacz sekcję "Uwagi" w <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> został wprowadzony w .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga trybu zintegrowanego potoku [! INCLUDE[iisver](~/includes/iisver-MD.MD)].</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępny do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka adresu URL nowej strony na serwerze w celu wykonania.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.Form" /> kolekcji <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <param name="method">Metoda HTTP do użycia podczas wykonywania nowe żądanie.</param>
        <param name="headers">A <see cref="T:System.Collections.Specialized.NameValueCollection" /> nagłówków żądania dla nowego żądania.</param>
        <summary>Wykonuje asynchroniczne wykonywanie określonego adresu URL, za pomocą określonej metody HTTP i nagłówków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana podczas uruchamiania w trybie zintegrowanym potoku [!INCLUDE[iisver](~/includes/iisver-md.md)] umożliwia przetwarzanie żądania przeniesienia z jednym zasobem typu na inny podczas wykonywania żądania docelowej z kontekstem właściwe żądanie. Na przykład, można użyć <xref:System.Web.HttpServerUtility.TransferRequest%2A> metody, aby przesłać żądanie dla strony ASPX żądanie dla strony XML.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> Metoda wykonuje wykonanie asynchroniczne podrzędnych pod określony adres URL z następujących warunków:  
  
-   Jeśli `path` parametr określa ciąg zapytania, będzie służyć jako nowego ciągu zapytania. Jeśli nie ciągu zapytania jest włączone, ciąg zapytania żądania będzie ponownie używane.  
  
-   Jeśli `method` parametr jest określony, będzie on używany. Jeśli jest `null`, zostanie użyta metoda HTTP żądania oryginalnej.  
  
-   Jeśli `preserveForm` parametr jest `true`, bieżącej treści jednostki żądania będą dostępne na żądanie docelowe. Zezwala na formularzu wpisów i przekazuje do przeniesienia.  
  
-   Jeśli tożsamość użytkownika aktualnie jest ustawiony na oryginalne żądanie, tożsamość zostaną przesłane do nowego żądania. Dzięki temu uwierzytelnianych żądań ponownego używania wynik uwierzytelniania dla nowego żądania. Jeśli chcesz, aby użytkownik należy dokonać, Ustaw użytkownika `null` na oryginalne żądanie przed przeniesieniem.  
  
-   Jeśli `headers` parametr jest określony, nowe żądanie będzie wykonywany określone nagłówki. Może służyć do modyfikowania nagłówki żądania i pliki cookie dla nowego żądania lub Dodaj nagłówek specjalne, który określa, gdzie oryginalne żądanie zostało przesłane.  
  
     Ta metoda wywołuje <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> przeciążenie metody z `preserveUser` parametr `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga [! INCLUDE[iisver](~/includes/iisver-MD.MD)] działający w trybie zintegrowanym.</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępny do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers, preserveUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="preserveUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka.</param>
        <param name="preserveForm">
          <see langword="true" /> Aby zachować <see cref="P:System.Web.HttpRequest.Form" /> kolekcji <see langword="false" /> wyczyść <see cref="P:System.Web.HttpRequest.Form" /> kolekcji.</param>
        <param name="method">Metoda HTTP do użycia w nowe żądanie.</param>
        <param name="headers">A <see cref="T:System.Collections.Specialized.NameValueCollection" /> obiekt, który zawiera nagłówki żądania dla nowego żądania.</param>
        <param name="preserveUser">
          <see langword="true" /> Aby zachować tożsamość użytkownika; w przeciwnym razie <see langword="false" />. Inne metody przeciążenia tej metody wywołać tego przeciążenia z tym parametrem ustawionym <see langword="true" />.</param>
        <summary>Wykonuje asynchroniczne wykonywanie określonego adresu URL, za pomocą określonej metody HTTP, nagłówków i ścieżkę, a opcjonalnie zachowuje wartości formularza i tożsamości użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz sekcję "Uwagi" w <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie wymaga trybu zintegrowanego potoku [! INCLUDE[iisver](~/includes/iisver-MD.MD)].</exception>
        <exception cref="T:System.Web.HttpException">Serwer nie jest dostępny do obsługi żądania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje ciąg, który został zakodowany na potrzeby transmisji HTTP, a następnie wysyłane do serwera w adresie URL.  Do kodowania i dekodowania wartości spoza aplikacji sieci web, należy użyć <see cref="T:System.Net.WebUtility" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string -&gt; string" Usage="httpServerUtility.UrlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg tekstowy do odkodowania.</param>
        <summary>Adres URL Dekoduje ciąg i zwraca Dekodowany ciąg.</summary>
        <returns>Zdekodowany tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresu URL zapewnia wszystkie przeglądarki poprawnie prześle tekstu w ciągów adresów URL. Znaki, takie jak pytanie znaku (?), handlowe "i" (&), ukośnika oznaczyć (/) i miejsca do magazynowania może być obcięte lub uszkodzone przez niektóre przeglądarki. W rezultacie, następujące znaki musi być zakodowany za `<a>` tagów lub w zapytaniu ciągów, gdzie ciągi mogą być ponownie wysyłane przez przeglądarkę w ciągu żądania.  
  
 Ta metoda jest wygodny sposób, aby uzyskać dostęp do <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> metody w czasie wykonywania z aplikacji ASP.NET. Wewnętrznie ta metoda używa <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> do dekodowania ciągów znaków.  
  
 W pliku związanym z kodem dla strony sieci web ASP.NET, dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy za pomocą `Server` właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, należy użyć `HttpContext.Current.Server` dostęp do wystąpienia programu <xref:System.Web.HttpServerUtility> klasy.  
  
 Poza aplikacji sieci web, należy użyć <xref:System.Net.WebUtility> klasy do kodowania i dekodowania wartości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób na dekodowanie URL wartość, które są pobierane z ciągu zapytania. Kod znajduje się w pliku CodeBehind dla strony sieci web. `ReturnPage` odwołuje się do `HyperLink` kontroli.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 Następny przykład jest podobny do poprzedniego przykładu, z wyjątkiem pokazuje jak dekodowanie URL wartość z zakresu od wewnątrz klasy który nie jest w pliku związanym z kodem.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg HTML do odkodowania.</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> Strumienia wyjściowego, który zawiera Dekodowany ciąg.</param>
        <summary>Dekoduje ciąg HTML, odbierane w adresie URL, a następnie wysyła dane wyjściowe do wynikowy <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresu URL zapewnia wszystkie przeglądarki poprawnie prześle tekstu w ciągów adresów URL. Znaki, takie jak pytanie znaku (?), handlowe "i" (&), ukośnika oznaczyć (/) i miejsca do magazynowania może być obcięte lub uszkodzone przez niektóre przeglądarki. W rezultacie, następujące znaki musi być zakodowany za `<a>` tagów lub w zapytaniu ciągów, gdzie ciągi mogą być ponownie wysyłane przez przeglądarkę w ciągu żądania.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> to wygodny sposób, aby uzyskać dostęp do <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> metody w czasie wykonywania z aplikacji ASP.NET. Wewnętrznie <xref:System.Web.HttpServerUtility.UrlDecode%2A> używa <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> do dekodowania ciągów znaków.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, należy użyć <xref:System.Net.WebUtility> klasy.  
  
   
  
## Examples  
 Poniższy przykład Dekoduje ciąg o nazwie `EncodedString` (odebrana w adresie URL) do parametrów o nazwie `DecodedString`.  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje ciąg niezawodne transmisji HTTP z serwera sieci Web do klienta za pośrednictwem adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> to wygodny sposób, aby uzyskać dostęp do <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metody w czasie wykonywania z aplikacji ASP.NET. Wewnętrznie <xref:System.Web.HttpServerUtility.UrlEncode%2A> używa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do zakodowania ciągów.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, należy użyć <xref:System.Net.WebUtility> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string -&gt; string" Usage="httpServerUtility.UrlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Tekst do zakodowania w formacie adresu URL.</param>
        <summary>Adres URL koduje ciąg i zwraca ciąg zakodowany.</summary>
        <returns>Tekst zakodowane w adresie URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresu URL zapewnia wszystkie przeglądarki poprawnie prześle tekstu w ciągów adresów URL. Znaki, takie jak pytanie znaku (?), handlowe "i" (&), ukośnika oznaczyć (/) i miejsca do magazynowania może być obcięte lub uszkodzone przez niektóre przeglądarki. W rezultacie, następujące znaki musi być zakodowany za `<a>` tagów lub w zapytaniu ciągów, gdzie ciągi mogą być ponownie wysyłane przez przeglądarkę w ciągu żądania.  
  
 Ta metoda jest wygodny sposób, aby uzyskać dostęp do <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metody w czasie wykonywania z aplikacji ASP.NET. Wewnętrznie ta metoda używa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do zakodowania ciągów.  
  
 W pliku związanym z kodem dla strony sieci web ASP.NET, dostęp do wystąpienia <xref:System.Web.HttpServerUtility> klasy za pomocą `Server` właściwości. W klasie, która nie znajduje się w pliku związanym z kodem, należy użyć `HttpContext.Current.Server` dostęp do wystąpienia programu <xref:System.Web.HttpServerUtility> klasy.  
  
 Poza aplikacji sieci web, należy użyć <xref:System.Net.WebUtility> klasy do kodowania i dekodowania wartości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób kodowania adresu URL wartość, które jest używana jako wartość ciągu zapytania, hiperłącza. Kod znajduje się w pliku CodeBehind dla strony sieci web. Wartość do zakodowania jest ustalony w tym przykładzie, tylko do uprościć przykład ukazują typ wartości, które może być kodowanie adresu URL. Zwykle jak kodowanie adresu URL wartość, która odebrane od użytkownika lub żądania. `NextPage` odwołuje się do `HyperLink` kontroli.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 Następny przykład jest podobny do poprzedniego przykładu, z wyjątkiem pokazuje sposób kodowania adresu URL wartość z zakresu od wewnątrz klasy nie jest w pliku związanym z kodem.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg tekstowy do zakodowania.</param>
        <param name="output">
          <see cref="T:System.IO.TextWriter" /> Strumienia wyjściowego, który zawiera ciąg zakodowany.</param>
        <summary>Adres URL koduje ciąg i wysyła wynikowy dane wyjściowe do <see cref="T:System.IO.TextWriter" /> strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie adresu URL zapewnia wszystkie przeglądarki poprawnie prześle tekstu w ciągów adresów URL. Znaki, takie jak pytanie znaku (?), handlowe "i" (&), ukośnika oznaczyć (/) i miejsca do magazynowania może być obcięte lub uszkodzone przez niektóre przeglądarki. W rezultacie, następujące znaki musi być zakodowany za `<a>` tagów lub w zapytaniu ciągów, gdzie ciągi mogą być ponownie wysyłane przez przeglądarkę w ciągu żądania.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> to wygodny sposób, aby uzyskać dostęp do <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metody w czasie wykonywania z aplikacji ASP.NET. Wewnętrznie <xref:System.Web.HttpServerUtility.UrlEncode%2A> używa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> do zakodowania ciągów.  
  
 Do kodowania i dekodowania wartości spoza aplikacji sieci web, należy użyć <xref:System.Net.WebUtility> klasy.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg przesyłania przy użyciu protokołu HTTP. Koduje go jako parametrów o nazwie `TestString`, który zawiera tekst "to \<testowany ciąg >." i kopiuje go do parametrów o nazwie `EncodedString` jako "to + jest + % 3cTest + ciąg % 3e.".  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlPathEncode : string -&gt; string" Usage="httpServerUtility.UrlPathEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Tekst do zakodowania w formacie adresu URL.</param>
        <summary>Nie używaj; przeznaczona tylko dla zgodności z przeglądarką. Użyj <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>Tekst, który zakodowane w adresie URL.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenDecode : string -&gt; byte[]" Usage="System.Web.HttpServerUtility.UrlTokenDecode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Token ciągu adresu URL do odkodowania.</param>
        <summary>Dekoduje token ciągu adresu URL, do jego tablica bajtowej równoważne, przy użyciu podstawowych cyfr 64.</summary>
        <returns>Tablica bajtów zawierająca zdekodowany token ciągu adresu URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Metoda konwertuje token ciągu adresu URL, które koduje dane binarne jako podstawowych cyfr 64, na jego reprezentację w postaci tablicy bajtów równoważne. Użyj <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> metody do tokenów odkodowania przesyłane na adres URL i zakodowane przy użyciu <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>.  
  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> Metoda zwróci bajtowych pusta tablica, jeśli `input` parametru wynosi mniej niż jeden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="input" /> parametr <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenEncode : byte[] -&gt; string" Usage="System.Web.HttpServerUtility.UrlTokenEncode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="input">Tablica bajtów do zakodowania.</param>
        <summary>Koduje tablicy typu byte na jego reprezentację ciągu równoważnego przy użyciu podstawowych cyfr 64, można używać w celu przesłania go na adres URL.</summary>
        <returns>Ciąg zawierający zakodowany token czy tablica bajtów * długość * jest większa niż jeden; w przeciwnym razie pusty ciąg ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> Metoda konwertuje tablicę bajtów na reprezentację ciągu równoważnego zakodowanych przy użyciu podstawowych cyfr 64. Token ciągu wynikowego mogą zostać przesłane na adres URL.  
  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> Zwraca pusty ciąg, jeśli `input` parametru wynosi mniej niż jeden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="input" /> parametr <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
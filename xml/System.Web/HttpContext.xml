<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="408424d74271b90ba42777a6e94139324fab5fa9" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69396628" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Hermetyzuje wszystkie informacje specyficzne dla protokołu HTTP dotyczące pojedynczego żądania HTTP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy dziedziczące <xref:System.Web.IHttpModule> interfejsy i <xref:System.Web.IHttpHandler> są <xref:System.Web.HttpContext> podane odwołanie do obiektu dla bieżącego żądania HTTP. Obiekt zapewnia dostęp do wewnętrznych <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>i <xref:System.Web.HttpContext.Server%2A> właściwości żądania.  
  
> [!IMPORTANT] 
> Ten obiekt jest gotowy do wyrzucania elementów <xref:System.Web.HttpRequest> bezużytecznych po zakończeniu. Jego użycie po zakończeniu żądania może prowadzić do niezdefiniowanego zachowania, takiego jak <xref:System.NullReferenceException>.
>
> Ten obiekt jest dostępny tylko w wątku sterowanym przez ASP.NET. Użycie w wątkach w tle może prowadzić do niezdefiniowanego zachowania.

## Examples  
 W poniższym przykładzie pokazano, jak uzyskać dostęp i wyświetlić właściwości <xref:System.Web.HttpContext> obiektu. Kontekst bieżącego żądania HTTP jest dostępny przy użyciu <xref:System.Web.UI.Page.Context%2A> właściwości <xref:System.Web.UI.Page> obiektu.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">Kwestia kontekstu</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.HttpContext" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr"><see cref="T:System.Web.HttpWorkerRequest" /> Obiekt dla bieżącego żądania HTTP.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Web.HttpContext" /> klasy, która używa określonego obiektu procesu roboczego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request"><see cref="T:System.Web.HttpRequest" /> Obiekt dla bieżącego żądania HTTP.</param>
        <param name="response"><see cref="T:System.Web.HttpResponse" /> Obiekt dla bieżącego żądania HTTP.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Web.HttpContext" /> klasy przy użyciu określonych obiektów żądanie i odpowiedź.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.WebSockets.AspNetWebSocket" /> Akceptuje żądanie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">Funkcja użytkownika.</param>
        <summary><see cref="T:System.Web.WebSockets.AspNetWebSocket" /> Akceptuje żądanie przy użyciu określonej funkcji użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest równoznaczne z wywołaniem <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> przeciążenia metody i przekazaniem `null` `options` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="userFunc" /></exception>
        <exception cref="T:System.NotSupportedException">Żądanie nie <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> jest żądaniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">Funkcja użytkownika.</param>
        <param name="options">Obiekt Options.</param>
        <summary><see cref="T:System.Web.WebSockets.AspNetWebSocket" /> Akceptuje żądanie przy użyciu określonej funkcji użytkownika i obiektu opcji.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="userFunc" /></exception>
        <exception cref="T:System.NotSupportedException">Żądanie nie <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> jest żądaniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">, <see cref="T:System.Exception" /> Aby dodać do kolekcji wyjątków.</param>
        <summary>Dodaje wyjątek do kolekcji wyjątków dla bieżącego żądania HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Obiekt kontekstu HTTP.</param>
        <summary>Wywołuje zdarzenie wirtualne, które występuje po zakończeniu części HTTP żądania.</summary>
        <returns>Token subskrypcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje przed <xref:System.Web.WebSockets.AspNetWebSocket> rozpoczęciem połączenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="callback" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tablicę błędów zebranych podczas przetwarzania żądania HTTP.</summary>
        <value>Tablica <see cref="T:System.Exception" /> obiektów dla bieżącego żądania HTTP.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy operacje asynchroniczne są dozwolone podczas przetwarzania żądań ASP.NET, gdy nie są oczekiwane.</summary>
        <value><see langword="false" />Jeśli ASP.NET zgłosi wyjątek, gdy asynchroniczny interfejs API jest używany w czasie, gdy nie jest oczekiwany; w przeciwnym razie. <see langword="true" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta flaga nie jest ustawiona na `true`, ASP.NET zgłosi wyjątek w przypadku wykrycia nieprawidłowej aplikacji przy użyciu asynchronicznego interfejsu API. Taka sytuacja może wystąpić, jeśli spróbujesz wywołać metodę asynchroniczną w ramach potoku przetwarzania żądania, gdzie operacje asynchroniczne nie są oczekiwane, lub jeśli nadal istnieją zaległe działania asynchroniczne, gdy moduł asynchroniczny lub procedura obsługi sygnalizuje ukończenie. Takie zachowanie jest przeznaczone jako sieć zabezpieczeń, aby szybko wiedzieć, czy piszesz kod asynchroniczny, który nie mieści się w oczekiwanych wzorcach i może mieć ujemne skutki uboczne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.HttpApplicationState" /> Pobiera obiekt dla bieżącego żądania HTTP.</summary>
        <value><see cref="T:System.Web.HttpApplicationState" /> Dla bieżącego żądania HTTP.  
  
Aby uzyskać <see cref="T:System.Web.HttpApplication" /> obiekt dla bieżącego żądania HTTP, użyj <see cref="P:System.Web.HttpContext.ApplicationInstance" />. (ASP.NET używa <see langword="ApplicationInstance" /> <see langword="Application" /> zamiast nazwy właściwości, aby odwołać się do bieżącego <see cref="T:System.Web.HttpApplication" /> wystąpienia w celu uniknięcia pomyłek między ASP.NET i klasycznym ASP. W klasycznym środowisku <see langword="Application" /> ASP odwołuje się do globalnego słownika stanu aplikacji.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Web.HttpApplication" /> obiekt dla bieżącego żądania HTTP.</summary>
        <value><see cref="T:System.Web.HttpApplication" /> Dla bieżącego żądania HTTP.  
  
ASP.NET używa <see langword="ApplicationInstance" /> zamiastnazwy<see cref="T:System.Web.HttpApplication" /> właściwości ,abyodwołaćsiędobieżącegowystąpieniawceluuniknięciapomyłekmiędzyASP.NETi<see langword="Application" /> klasycznym ASP. W klasycznym środowisku <see langword="Application" /> ASP odwołuje się do globalnego słownika stanu aplikacji.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Aplikacja sieci Web działa w ramach usług IIS 7,0 w trybie zintegrowanym i podjęto próbę zmiany wartości właściwości z wartości innej niż null na <see langword="null" />.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który zawiera flagi odnoszące się do asynchronicznego trybu wstępnego ładowania.</summary>
        <value>Obiekt, który zawiera flagi odnoszące się do asynchronicznego trybu wstępnego ładowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy pierwszej próbie dostępu do tej właściwości obiekt, który zawiera flagi dla trybu ładowania asynchronicznego jest ładowany z <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> ustawienia w pliku konfiguracji.  
  
 Mimo że ta właściwość może być ustawiana programowo, zmiana wartości właściwości ma wpływ tylko wtedy, gdy właściwość jest ustawiona `ExecuteRequestHandler` przed krokiem w potoku żądania ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.Caching.Cache" /> Pobiera obiekt dla bieżącej domeny aplikacji.</summary>
        <value><see cref="T:System.Web.Caching.Cache" /> Dla bieżącej domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieje jedno wystąpienie <xref:System.Web.Caching.Cache> klasy na domenę aplikacji. W związku <xref:System.Web.Caching.Cache> z tym obiekt, który jest zwracany <xref:System.Web.HttpContext.Cache%2A> przez właściwość jest <xref:System.Web.Caching.Cache> obiektem dla wszystkich żądań w domenie aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie błędy dla bieżącego żądania HTTP.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Web.HttpContext" /> obiekt dla bieżącego żądania HTTP.</summary>
        <value><see cref="T:System.Web.HttpContext" /> Wystąpienie bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest właściwością <xref:System.Web.HttpContext> statyczną klasy. Właściwość przechowuje <xref:System.Web.HttpContext> wystąpienie, które ma zastosowanie do bieżącego żądania. Właściwości tego wystąpienia są niestatycznymi właściwościami <xref:System.Web.HttpContext> klasy.  
  
 Można również użyć <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> właściwości, aby <xref:System.Web.HttpContext> uzyskać dostęp do obiektu dla bieżącego żądania HTTP.  
  
   
  
## Examples  
 <xref:System.Web.HttpContext.Current%2A> Poniższy przykład kodu używa właściwości, aby <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> uzyskać dostęp <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> do metod <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> i właściwości. Przykład tworzy trzy wyjątki niestandardowe przy użyciu <xref:System.Web.HttpContext.AddError%2A> metody i <xref:System.Web.HttpContext.AllErrors%2A> używa właściwości do załadowania tych wyjątków do tablicy. Następnie zapisuje tablicę na stronie zawierającej i używa <xref:System.Web.HttpContext.ClearError%2A> metody do czyszczenia wszystkich błędów <xref:System.Web.UI.Page.Context%2A> we właściwości.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.IHttpHandler" /> Pobiera obiekt, który reprezentuje aktualnie wykonywaną procedurę obsługi.</summary>
        <value><see cref="T:System.Web.IHttpHandler" /> Reprezentuje aktualnie wykonywaną procedurę obsługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aktualnie wykonywany program obsługi, do którego odwołuje <xref:System.Web.HttpContext.CurrentHandler%2A> się właściwość, może być inny niż program obsługi, do którego <xref:System.Web.HttpContext.Handler%2A> odwołuje się właściwość. Taka sytuacja może wystąpić, gdy zażądano innego programu <xref:System.Web.HttpServerUtility.Execute%2A> obsługi przy użyciu <xref:System.Web.HttpServerUtility.Transfer%2A> metody lub metody. Po zakończeniu przetwarzania aktualnie wykonywanej procedury obsługi zostanie przywrócony poprzednio określony program obsługi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Obsługa protokołu HTTP i moduły HTTP — Omówienie</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą bieżące <see cref="T:System.Web.HttpApplication" /> zdarzenie, które jest przetwarzane. <see cref="T:System.Web.RequestNotification" /></summary>
        <value>Jedna z <see cref="T:System.Web.RequestNotification" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość wymaga zintegrowanego trybu potokowego w [!INCLUDE[iisver](~/includes/iisver-md.md)] i co najmniej .NET Framework w wersji 3,0. <xref:System.Web.HttpContext.CurrentNotification%2A> Gdy jest dostępna, właściwość zwraca <xref:System.Web.RequestNotification> wartość. Wartość <xref:System.Web.HttpContext.CurrentNotification%2A> właściwości wskazuje, które zdarzenie <xref:System.Web.HttpApplication> w wystąpieniu aktualnie przetwarza żądanie.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> Właściwość nie jest przeznaczona do ustawiania. Zamiast tego jest ustawiany przez [!INCLUDE[iisver](~/includes/iisver-md.md)] podczas przetwarzania żądania w potoku ASP.NET. <xref:System.Web.HttpContext.CurrentNotification%2A> Ustawienie właściwości spowoduje błąd kompilacji.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A>wprowadzono w .NET Framework w wersji 3,5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak użyć właściwości <xref:System.Web.HttpContext.CurrentNotification%2A> , aby określić, jakie zdarzenie <xref:System.Web.HttpApplication> dla obiektu obsługującego bieżące żądanie jest przetwarzane. W tym przykładzie program obsługi zdarzeń obsługuje kilka zdarzeń <xref:System.Web.HttpApplication> obiektu, <xref:System.Web.HttpContext.CurrentNotification%2A> a właściwość określa kod, który jest wywoływany dla każdego obsługiwanego zdarzenia.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Operacja wymaga zintegrowanego trybu potokowego [!INCLUDE[iisver](~/includes/iisver-md.md)] w i co najmniej .NET Framework wersji 3,0.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, którego <see cref="M:System.IDisposable.Dispose" /> Metoda musi zostać wywołana, <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> gdy zostanie zakończona część połączenia żądania.</param>
        <summary>Umożliwia wywoływanie <see cref="M:System.IDisposable.Dispose" /> metody obiektu, <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> gdy zostanie ukończona część połączenia tego żądania.</summary>
        <returns>Token subskrypcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda obiektu docelowego jest wywoływana po zakończeniu zarówno części HTTP żądania <xref:System.Web.WebSockets.AspNetWebSocket> , jak i połączenia. <xref:System.IDisposable.Dispose%2A> <xref:System.Web.HttpContext> Obiekt nie jest dostępny do inspekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pierwszy błąd (jeśli istnieje) podczas przetwarzania żądania HTTP.</summary>
        <value>Pierwszy <see cref="T:System.Exception" /> dla bieżącego procesu żądania HTTP/odpowiedzi; w przeciwnym razie, <see langword="null" /> Jeśli podczas przetwarzania żądania HTTP nie zostały zebrane żadne błędy. Wartość domyślna to <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Tag konfiguracji aplikacji, dla którego zażądano informacji.</param>
        <summary>Zwraca informacje o żądanych konfiguracjach dla bieżącej aplikacji.</summary>
        <returns>Obiekt zawierający informacje o konfiguracji. (Rzutowanie zwróconej sekcji konfiguracji na odpowiedni typ konfiguracji przed użyciem).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetAppConfig%2A> Metoda jest przestarzała. <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> Użyj metody <xref:System.Web.Configuration.WebConfigurationManager> klasy, aby uzyskać informacje o konfiguracji bieżącej aplikacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Tag konfiguracji, dla którego zażądano informacji.</param>
        <summary>Zwraca informacje o żądanych konfiguracjach dla bieżącego żądania HTTP.</summary>
        <returns>Określona <see cref="T:System.Configuration.ConfigurationSection" /> ,<see langword="null" /> Jeśli sekcja nie istnieje lub obiekt wewnętrzny, jeśli sekcja nie jest dostępna w czasie wykonywania. (Rzutowanie zwróconego obiektu na odpowiedni typ konfiguracji przed użyciem).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetConfig%2A> Metoda jest przestarzała. Użyj metody <xref:System.Web.HttpContext.GetSection%2A> , aby uzyskać informacje o konfiguracji dla bieżącego żądania HTTP.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zasób poziomu aplikacji.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Zasoby w aplikacjach</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Układ witryny sieci Web ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> Właściwość żądanego obiektu zasobu.</param>
        <param name="resourceKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> Właściwość żądanego obiektu zasobu.</param>
        <summary>Pobiera obiekt zasobów na poziomie aplikacji na podstawie określonych <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> właściwości i. <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /></summary>
        <returns><see cref="T:System.Object" /> Reprezentuje żądany obiekt zasobów na poziomie aplikacji; w przeciwnym razie wartość null, jeśli obiekt zasobu nie zostanie znaleziony lub jeśli obiekt zasobu zostanie znaleziony, ale nie ma żądanej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca zasób globalny przy użyciu kultury określonej <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> we właściwości. <xref:System.Web.HttpContext.GetGlobalResourceObject%2A>  
  
> [!NOTE]
>  W niektórych środowiskach edycji, takich jak [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], Edytor może zgłosić wyjątek czasu <xref:System.Resources.MissingManifestResourceException> projektowania, jeśli używasz kropki (.) w globalnej nazwie klucza zasobu. Nie ma to jednak wpływu na możliwość edytowania lub zapisywania pliku i można zignorować ten błąd.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie znaleziono obiektu zasobu z określonym <paramref name="classKey" /> parametrem.  
  
—lub— 
Główny zestaw nie zawiera zasobów dla kultury neutralnej, a te zasoby są wymagane, ponieważ brakuje odpowiedniego zestawu satelickiego.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Zasoby w aplikacjach</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Układ witryny sieci Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> Właściwość żądanego obiektu zasobu.</param>
        <param name="resourceKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> Właściwość żądanego obiektu zasobu.</param>
        <param name="culture">Ciąg reprezentujący <see cref="T:System.Globalization.CultureInfo" /> obiekt żądanego zasobu.</param>
        <summary>Pobiera obiekt zasobów na poziomie aplikacji na podstawie określonych <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> <see cref="T:System.Globalization.CultureInfo" /> właściwości i <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> obiektu.</summary>
        <returns>Reprezentuje żądany obiekt zasobów na poziomie aplikacji, który jest zlokalizowany dla określonej kultury; w przeciwnym razie, <see langword="null" /> Jeśli obiekt zasobu nie zostanie znaleziony lub zostanie znaleziony obiekt zasobu, ale nie ma żądanego <see cref="T:System.Object" /> wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> Obiekt reprezentuje kulturę, dla której zasób został zlokalizowany. Jeśli zasób nie jest zlokalizowany dla tej kultury, wyszukiwanie będzie podążać za procesem rezerwowym w celu zlokalizowania odpowiedniego zasobu. Aby uzyskać więcej informacji, zobacz [pakowanie i wdrażanie zasobów](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  W niektórych środowiskach edycji, takich jak Visual Web Developer, Edytor może zgłosić wyjątek czasu <xref:System.Resources.MissingManifestResourceException> projektowania, jeśli używasz kropki (.) w globalnej nazwie klucza zasobu. Nie ma to jednak wpływu na możliwość edytowania lub zapisywania pliku i można zignorować ten błąd.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Obiekt zasobu, dla którego nie znaleziono <paramref name="classKey" /> określonego parametru.  
  
—lub— 
Główny zestaw nie zawiera zasobów dla kultury neutralnej, a te zasoby są wymagane, ponieważ brakuje odpowiedniego zestawu satelickiego.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Zasoby w aplikacjach</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zasób na poziomie strony.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Zasoby w aplikacjach</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Układ witryny sieci Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath"><see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> Właściwość obiektu zasobu lokalnego.</param>
        <param name="resourceKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> Właściwość żądanego obiektu zasobu.</param>
        <summary>Pobiera obiekt zasobów na poziomie strony na podstawie określonych <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> właściwości i. <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /></summary>
        <returns>Reprezentujący żądany obiekt zasobów na poziomie strony; w przeciwnym razie, <see langword="null" /> Jeśli <paramref name="resourceKey" /> zostanie znaleziony pasujący obiekt zasobu, ale nie parametr. <see cref="T:System.Object" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca zasób lokalny przy użyciu kultury określonej <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> we właściwości. <xref:System.Web.HttpContext.GetLocalResourceObject%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie znaleziono obiektu zasobu dla podanego <paramref name="virtualPath" /> parametru.</exception>
        <exception cref="T:System.ArgumentException">Określony <paramref name="virtualPath" /> parametr nie znajduje się w katalogu głównym bieżącej aplikacji.</exception>
        <exception cref="T:System.InvalidOperationException">Nie odnaleziono klasy zasobów dla strony.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Zasoby w aplikacjach</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Układ witryny sieci Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Instrukcje: Programowe pobieranie wartości zasobów</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath"><see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> Właściwość obiektu zasobu lokalnego.</param>
        <param name="resourceKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> Właściwość żądanego obiektu zasobu.</param>
        <param name="culture">Ciąg reprezentujący <see cref="T:System.Globalization.CultureInfo" /> obiekt żądanego obiektu zasobu.</param>
        <summary>Pobiera obiekt zasobów na poziomie strony na podstawie określonych <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> <see cref="T:System.Globalization.CultureInfo" /> właściwości i <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> obiektu.</summary>
        <returns>Reprezentuje żądany obiekt zasobu lokalnego, który jest zlokalizowany dla określonej kultury; w przeciwnym razie <see langword="null" /> , jeśli <paramref name="resourceKey" /> zostanie znaleziony pasujący obiekt zasobu, ale nie parametr. <see cref="T:System.Object" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zasób nie jest zlokalizowany dla tej kultury, wyszukiwanie będzie podążać za procesem rezerwowym w celu zlokalizowania odpowiedniego zasobu. Aby uzyskać więcej informacji, zobacz [pakowanie i wdrażanie zasobów](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie znaleziono obiektu zasobu dla podanego <paramref name="virtualPath" /> parametru.</exception>
        <exception cref="T:System.ArgumentException">Określony <paramref name="virtualPath" /> parametr nie znajduje się w katalogu głównym bieżącej aplikacji.</exception>
        <exception cref="T:System.InvalidOperationException">Nie odnaleziono klasy zasobów dla strony.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Zasoby w aplikacjach</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Układ witryny sieci Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Instrukcje: Programowe pobieranie wartości zasobów</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sectionName">Ścieżka sekcji konfiguracji (w formacie XPath) i nazwa elementu konfiguracji.</param>
        <summary>Pobiera określoną sekcję konfiguracyjną dla domyślnej konfiguracji bieżącej aplikacji.</summary>
        <returns>Określona <see cref="T:System.Configuration.ConfigurationSection" /> ,<see langword="null" /> Jeśli sekcja nie istnieje lub obiekt wewnętrzny, jeśli sekcja nie jest dostępna w czasie wykonywania.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Web.IHttpHandler" /> obiekt odpowiedzialny za przetwarzanie żądania HTTP.</summary>
        <value>Osoba <see cref="T:System.Web.IHttpHandler" /> odpowiedzialna za przetwarzanie żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Handler%2A> Właściwość zawiera odwołanie do programu obsługi, który przetwarza żądanie HTTP. Procedurę obsługi można określić za pomocą elementu [httpHandlers](https://msdn.microsoft.com/library/24ca01f3-7141-4fdc-acac-71c0733cf6c2) lub przy użyciu niestandardowego programu obsługi zdefiniowanego w kodzie użytkownika. Aby uzyskać więcej informacji na temat programów obsługi, zobacz [Obsługa protokołu HTTP i moduły HTTP — Omówienie](https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 Odwołanie do <xref:System.Web.HttpContext.Handler%2A> właściwości pozostanie takie samo, nawet po zmianie bieżącej strony przez metodę po stronie serwera, <xref:System.Web.HttpServerUtility.Execute%2A> na przykład metodę lub <xref:System.Web.HttpServerUtility.Transfer%2A> metodę.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Obsługa protokołu HTTP i moduły HTTP — Omówienie</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dla bieżącego żądania HTTP są włączone błędy niestandardowe.</summary>
        <value><see langword="true" />Jeśli błędy niestandardowe są włączone; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące żądanie HTTP jest w trybie debugowania.</summary>
        <value><see langword="true" />Jeśli żądanie jest w trybie debugowania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która jest bieżącym punktem przetwarzania w potoku ASP.NET zaraz po <see cref="T:System.Web.HttpApplication" /> zakończeniu przetwarzania zdarzenia.</summary>
        <value><see langword="true" />Jeśli błędy niestandardowe są włączone; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest obsługiwana tylko w trybie zintegrowanym w [!INCLUDE[iisver](~/includes/iisver-md.md)] i co najmniej .NET Framework 3,0. <xref:System.Web.HttpContext.IsPostNotification%2A> Gdy jest dostępna, właściwość zwraca wartość logiczną, która wskazuje, czy zdarzenie w <xref:System.Web.HttpApplication> obiekcie zostało zakończone.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> Właściwość nie jest przeznaczona do ustawiania. Zamiast tego jest on dostarczany przez [!INCLUDE[iisver](~/includes/iisver-md.md)] środowisko uruchomieniowe ASP.NET dla każdego powiadomienia. <xref:System.Web.HttpContext.IsPostNotification%2A> Ustawienie właściwości spowoduje błąd kompilacji.  
  
 W scenariuszach, w których wiele zdarzeń <xref:System.Web.HttpApplication> obiektu jest obsługiwanych przez jedną procedurę obsługi zdarzeń, można <xref:System.Web.HttpContext.IsPostNotification%2A> użyć <xref:System.Web.RequestNotification> właściwości w połączeniu z wyliczeniem, aby precyzyjnie określić, gdzie w cyklu życia aplikacji bieżąca żądanie to.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A>wprowadzono w .NET Framework w wersji 3,5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia właściwości, <xref:System.Web.HttpContext.IsPostNotification%2A> aby określić, kiedy zdarzenie <xref:System.Web.HttpApplication> obiektu zakończyło przetwarzanie wszystkich skojarzonych programów obsługi zdarzeń. Procedura obsługi zdarzeń niestandardowych w tym przykładzie obsługuje kilka zdarzeń <xref:System.Web.HttpApplication> obiektu, <xref:System.Web.HttpContext.IsPostNotification%2A> a właściwość jest używana do określenia, jaki kod jest wywoływany po obsłudze określonego zdarzenia.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Operacja wymaga zintegrowanego trybu potokowego w [!INCLUDE[iisver](~/includes/iisver-md.md)] i co najmniej .NET Framework 3,0.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądanie jest <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> żądaniem.</summary>
        <value><see langword="true" />Jeśli żądanie jest <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> żądaniem; w przeciwnym razie, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `true` czy żądanie zawiera wstępne <xref:System.Web.WebSockets.AspNetWebSocket> uzgadnianie, a `WebSocket` moduł usług IIS jest aktywny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy połączenie jest uaktualniane z połączenia HTTP do <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> połączenia.</summary>
        <value><see langword="true" />Jeśli połączenie jest uaktualniane; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję klucz/wartość, za pomocą której można organizować i udostępniać dane między <see cref="T:System.Web.IHttpModule" /> interfejsem <see cref="T:System.Web.IHttpHandler" /> i interfejsem w trakcie żądania HTTP.</summary>
        <value>Kolekcja <see cref="T:System.Collections.IDictionary" /> klucz/wartość, która zapewnia dostęp do pojedynczej wartości w kolekcji przez określony klucz.</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms972109.aspx">Kwestia kontekstu</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do wystąpienia usługi Page-Instrumentation dla tego żądania.</summary>
        <value>Wystąpienie usługi Page-Instrumentation dla tego żądania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.IHttpHandler" /> Pobiera obiekt dla programu obsługi nadrzędnej.</summary>
        <value><see cref="T:System.Web.IHttpHandler" /> Wystąpienie lub<see langword="null" /> Jeśli nie znaleziono poprzedniej procedury obsługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.PreviousHandler%2A> Właściwość odnosi się do ostatniego programu obsługi przed wykonaniem bieżącego żądania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Obsługa protokołu HTTP i moduły HTTP — Omówienie</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.Profile.ProfileBase" /> Pobiera obiekt dla bieżącego profilu użytkownika.</summary>
        <value>A <see cref="T:System.Web.Profile.ProfileBase" /> Jeśli plik konfiguracji aplikacji zawiera definicję właściwości profilu; <see langword="null" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Profile%2A> Właściwość jest używana do trwałego przechowywania danych strukturalnych przy użyciu bezpiecznego typu interfejsu API. Gdy uzyskuje się dostęp do właściwości,ależadnawartośćniejestobecna,zwracanejestpustewystąpienie;<xref:System.Web.HttpContext.Profile%2A> `null` nie jest zwracany.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Obiekt, który powinien przetworzyć żądanie.</param>
        <summary>Umożliwia określenie programu obsługi żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku ustawienia `handler` `null`opcji domyślny program obsługi zostanie użyty do przetworzenia żądania. Można ustawić `handler` jako procedurę obsługi asynchronicznej lub synchroniczną procedurę obsługi. Program obsługi musi implementować <xref:System.Web.IHttpHandler> interfejs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda została wywołana <see cref="E:System.Web.HttpApplication.MapRequestHandler" /> po wystąpieniu zdarzenia. <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.HttpRequest" /> Pobiera obiekt dla bieżącego żądania HTTP.</summary>
        <value><see cref="T:System.Web.HttpRequest" /> Dla bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zapewnia programistyczny dostęp do właściwości i metod <xref:System.Web.HttpRequest> klasy. <xref:System.Web.HttpContext.Request%2A> Ponieważ strony ASP.NET zawierają odwołanie domyślne <xref:System.Web> do przestrzeni nazw (która <xref:System.Web.HttpContext> zawiera klasę), można odwoływać się do członków <xref:System.Web.HttpRequest> na stronie. aspx bez używania w pełni kwalifikowanego odwołania do klasy do <xref:System.Web.HttpContext>. Na przykład można użyć `Request.Browser` programu w celu uzyskania możliwości przeglądarki klienta. Jeśli jednak chcesz użyć elementów członkowskich <xref:System.Web.HttpRequest> z modułu ASP.NET z kodem związanym, musisz uwzględnić odwołanie <xref:System.Web> do przestrzeni nazw w module i w pełni kwalifikowane odwołanie do aktualnie aktywnego kontekstu żądania/odpowiedzi i <xref:System.Web> Klasa, która ma być używana. Na przykład na stronie powiązanej z kodem należy określić w pełni kwalifikowaną nazwę `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  ASP.NET zgłosi wyjątek, jeśli spróbujesz użyć tej właściwości, gdy <xref:System.Web.HttpRequest> obiekt jest niedostępny. Na przykład może to być prawdziwe w metodzie Application_Start pliku Global. asax lub w metodzie, która jest wywoływana z metody Application_Start. W tym czasie nie utworzono jeszcze żądania HTTP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Aplikacja sieci Web działa w ramach usług IIS 7 w trybie zintegrowanym.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.HttpResponse" /> Pobiera obiekt dla bieżącej odpowiedzi HTTP.</summary>
        <value><see cref="T:System.Web.HttpResponse" /> Dla bieżącej odpowiedzi HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zapewnia programistyczny dostęp do właściwości i metod <xref:System.Web.HttpResponse> klasy. <xref:System.Web.HttpContext.Response%2A> Ponieważ strony ASP.NET zawierają odwołanie domyślne <xref:System.Web> do przestrzeni nazw (która <xref:System.Web.HttpContext> zawiera klasę), można odwoływać się do członków <xref:System.Web.HttpContext> na stronie. aspx bez używania w pełni kwalifikowanego odwołania do klasy do <xref:System.Web.HttpContext>. Na przykład można użyć `Response.Write("some output")` , aby zapisać dane wyjściowe do strumienia wyjściowego http. Jeśli jednak chcesz użyć elementów członkowskich <xref:System.Web.HttpResponse> z modułu ASP.NET z kodem związanym, musisz uwzględnić odwołanie <xref:System.Web> do przestrzeni nazw w module i w pełni kwalifikowane odwołanie do aktualnie aktywnego kontekstu żądania/odpowiedzi i klasy w <xref:System.Web> , którego chcesz użyć. Na przykład na stronie powiązanej z kodem należy określić w pełni kwalifikowaną nazwę `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Aplikacja sieci Web działa w ramach usług IIS 7 w trybie zintegrowanym.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekierowuje żądanie dla zasobu do innej ścieżki niż ten, który jest wskazywany przez żądany adres URL. <see cref="Overload:System.Web.HttpContext.RewritePath" />jest używany w stanie sesji bez plików cookie do rozdzielania identyfikatorów sesji z adresów URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do ponownego zapisywania wewnętrznego.</param>
        <summary>Ponownie zapisuje adres URL przy użyciu podanej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%29> Metoda przekierowuje żądanie dla zasobu do innej ścieżki niż ta, która jest wskazywana przez żądany adres URL. Jeśli trzeba zresetować ścieżkę wirtualną tak, aby żądania od klienta dotyczące zasobów serwera zostały prawidłowo rozwiązane, Użyj przeciążenia tej metody, która przyjmuje `rebaseClientPath` parametr i ustaw parametr na. `false`  
  
 Ponowne zapisywanie adresów URL jest przydatne, gdy chcesz zmienić strukturę stron w aplikacji sieci Web i chcesz się upewnić, że osoby, które mają stare adresy URL, nadal mogą używać ich po przeniesieniu stron. Ponowne zapisywanie adresów URL umożliwia nieprzezroczyste przekazywanie żądań do nowej lokalizacji strony.  
  
 Jeśli chcesz umożliwić witrynie korzystanie z adresów URL, które są bardziej przyjazne dla użytkownika i są zoptymalizowane pod kątem aparatów wyszukiwania, bardziej niezawodną alternatywą jest użycie routingu ASP.NET. Aby uzyskać więcej informacji, zobacz [ASP.NET routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać metody, <xref:System.Web.HttpContext.RewritePath%2A> aby umożliwić witrynie sieci Web odpowiadanie na adresy URL, które nie odzwierciedlają struktury plików w witrynie sieci Web. Pierwszy blok kodu to strona sieci Web ASP.NET o nazwie RewritePath. aspx. Wymaga ciągu zapytania. Jeśli nazwa witryny to WebSite1, adres URL `http://localhost/WebSite1/RewritePath.aspx?page=1` wyświetla "Strona 1" w przeglądarce. Blok kodu, który następuje po stronie sieci Web, `Application_BeginRequest` to program obsługi zdarzeń w pliku Global. asax. Ten kod przechwytuje żądania dotyczące adresów URL `http://localhost/WebSite1/page1` , takich jak i konwertuje je na formularz, który jest wymagany dla RewritePath. aspx przed przetworzeniem. W związku z tym `http://localhost/WebSite1/page1` adres URL wywołuje RewritePath. aspx z parametrem zapytania-String, który wyświetla "Page 1" w przeglądarce. Jeśli otrzymasz adres URL `http://localhost/WebSite1/page1` , na przykład, zostanie wywołane <xref:System.Web.HttpContext.RewritePath%2A> Przeciążenie metody, która umożliwia <xref:System.Web.HttpRequest.PathInfo%2A> podanie wartości właściwości oraz parametru ciągu zapytania.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" /> Parametr nie znajduje się w katalogu głównym bieżącej aplikacji.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Przewodnik: Używanie routingu ASP.NET w aplikacji formularzy sieci Web</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do ponownego zapisywania wewnętrznego.</param>
        <param name="rebaseClientPath"><see langword="true" />Aby zresetować ścieżkę wirtualną; <see langword="false" /> aby zachować ścieżkę wirtualną bez zmian.</param>
        <summary>Ponownie zapisuje adres URL przy użyciu podanej ścieżki i wartości logicznej określającej, czy ścieżka wirtualna zasobów serwera jest modyfikowana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wywoływana <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> przez metodę z `rebaseClientPath` parametrem ustawionym na `true`. <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> Aby upewnić się, że ścieżka wirtualna używana do konstruowania ścieżek do zasobów nie jest modyfikowana, `rebaseClientPath` ustaw parametr `false`na. Typowy scenariusz, w którym można ustawić wartość `rebaseClientPath` `false` , to w przypadku konieczności ponownego zapisania adresu URL i użycia motywów i przekierowania adresu URL do zasobu znajdującego się w innym folderze niż żądany zasób.  
  
 Ponowne zapisywanie adresów URL jest przydatne, gdy chcesz zmienić strukturę stron w aplikacji sieci Web i chcesz się upewnić, że osoby, które mają stare adresy URL, nadal mogą używać ich po przeniesieniu stron. Ponowne zapisywanie adresów URL umożliwia nieprzezroczyste przekazywanie żądań do nowej lokalizacji strony.  
  
 Jeśli chcesz umożliwić witrynie korzystanie z adresów URL, które są bardziej przyjazne dla użytkownika i są zoptymalizowane pod kątem aparatów wyszukiwania, bardziej niezawodną alternatywą jest użycie routingu ASP.NET. Aby uzyskać więcej informacji, zobacz [ASP.NET routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Aby zapoznać się z przykładem kodu <xref:System.Web.HttpContext.RewritePath%28System.String%29> , zapoznaj się z przeciążeniem metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" /> Parametr nie znajduje się w katalogu głównym bieżącej aplikacji.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Przewodnik: Używanie routingu ASP.NET w aplikacji formularzy sieci Web</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">Ścieżka do ponownego zapisywania wewnętrznego.</param>
        <param name="pathInfo">Dodatkowe informacje o ścieżce dla zasobu. Aby uzyskać więcej informacji, zobacz <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Ciąg zapytania żądania.</param>
        <summary>Ponownie zapisuje adres URL przy użyciu podanej ścieżki, informacji o ścieżce i informacji o ciągu zapytania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%2A> Metoda przekierowuje żądanie zasobu do innego zasobu bez zmiany adresu URL.  
  
 Parametr nie zawiera zawartości `pathInfo`parametru. `filePath` Dla adresu URL http://www.microsoft.com/virdir/page.html/tail `filePath`parametrma http://www.microsoft.com/virdir/page.htmlwartość, a parametrtotail.`pathInfo`  
  
 Ponowne zapisywanie adresów URL jest przydatne, gdy chcesz zmienić strukturę stron w aplikacji sieci Web i chcesz się upewnić, że osoby, które mają stare adresy URL, nadal mogą używać ich po przeniesieniu stron. Ponowne zapisywanie adresów URL umożliwia nieprzezroczyste przekazywanie żądań do nowej lokalizacji strony.  
  
 Jeśli chcesz umożliwić witrynie korzystanie z adresów URL, które są bardziej przyjazne dla użytkownika i są zoptymalizowane pod kątem aparatów wyszukiwania, bardziej niezawodną alternatywą jest użycie routingu ASP.NET. Aby uzyskać więcej informacji, zobacz [ASP.NET routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Aby zapoznać się z przykładem kodu, w tym przykładem przeciążenia metody, <xref:System.Web.HttpContext.RewritePath%28System.String%29> zapoznaj się z przeciążeniem metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> Parametr nie znajduje się w katalogu głównym bieżącej aplikacji.</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" /> Parametr nie znajduje się w katalogu głównym bieżącej aplikacji.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Przewodnik: Używanie routingu ASP.NET w aplikacji formularzy sieci Web</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="pathInfo" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="queryString" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filePath">Wirtualna ścieżka do zasobu obsługującego żądanie.</param>
        <param name="pathInfo">Dodatkowe informacje o ścieżce do użycia w przekierowaniu adresu URL. Aby uzyskać więcej informacji, zobacz <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Ciąg zapytania żądania, który ma być używany w przekierowaniu adresu URL.</param>
        <param name="setClientFilePath"><see langword="true" />Aby ustawić ścieżkę pliku używaną dla zasobów klienta do wartości <paramref name="filePath" /> parametru; w przeciwnym razie. <see langword="false" /></param>
        <summary>Ponownie zapisuje adres URL przy użyciu podanej ścieżki wirtualnej, informacji o ścieżce, informacji o ciągu zapytania oraz wartości logicznej określającej, czy ścieżka pliku klienta jest ustawiona na ścieżkę ponownego zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr nie zawiera zawartości `pathInfo` parametru. `filePath` Dla adresu URL http://www.microsoft.com/virdir/page.html/tail `filePath`parametrma http://www.microsoft.com/virdir/page.htmlwartość, a parametrtotail.`pathInfo`  
  
 Aby upewnić się, że ścieżka wirtualna używana do konstruowania ścieżek do zasobów nie jest modyfikowana, `setClientFilePath` ustaw parametr `false`na. Typowy scenariusz, w którym można ustawić wartość `setClientFilePath` `false` , to w przypadku konieczności ponownego zapisania adresu URL i użycia motywów i przekierowania adresu URL do zasobu znajdującego się w innym folderze niż żądany zasób.  
  
 Ponowne zapisywanie adresów URL jest przydatne, gdy chcesz zmienić strukturę stron w aplikacji sieci Web i chcesz się upewnić, że osoby, które mają stare adresy URL, nadal mogą używać ich po przeniesieniu stron. Ponowne zapisywanie adresów URL umożliwia nieprzezroczyste przekazywanie żądań do nowej lokalizacji strony.  
  
 Jeśli chcesz umożliwić witrynie korzystanie z adresów URL, które są bardziej przyjazne dla użytkownika i są zoptymalizowane pod kątem aparatów wyszukiwania, bardziej niezawodną alternatywą jest użycie routingu ASP.NET. Aby uzyskać więcej informacji, zobacz [ASP.NET routing](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Aby zapoznać się z przykładem kodu <xref:System.Web.HttpContext.RewritePath%28System.String%29> , zapoznaj się z przeciążeniem metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> Parametr nie znajduje się w katalogu głównym bieżącej aplikacji.</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" /> Parametr nie znajduje się w katalogu głównym bieżącej aplikacji.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Przewodnik: Używanie routingu ASP.NET w aplikacji formularzy sieci Web</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.HttpServerUtility" /> Pobiera obiekt, który dostarcza metody służące do przetwarzania żądań sieci Web.</summary>
        <value><see cref="T:System.Web.HttpServerUtility" /> Dla bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zapewnia programistyczny dostęp do właściwości i metod <xref:System.Web.HttpServerUtility> klasy. <xref:System.Web.HttpContext.Server%2A> Ponieważ strony ASP.NET zawierają odwołanie domyślne <xref:System.Web> do przestrzeni nazw (która <xref:System.Web.HttpContext> zawiera klasę), można odwoływać się do członków <xref:System.Web.HttpContext> na stronie. aspx bez używania w pełni kwalifikowanego odwołania do klasy do <xref:System.Web.HttpContext>. Na przykład można użyć `Server.CreateObject("MyCOMComponent")` , aby utworzyć wystąpienie obiektu com na serwerze. Jeśli jednak chcesz użyć elementów członkowskich <xref:System.Web.HttpServerUtility> z modułu ASP.NET z kodem związanym, musisz uwzględnić odwołanie <xref:System.Web> do przestrzeni nazw w module i w pełni kwalifikowane odwołanie do aktualnie aktywnego kontekstu żądania/odpowiedzi i <xref:System.Web> Klasa, która ma być używana. Na przykład na stronie powiązanej z kodem należy określić w pełni kwalifikowaną nazwę `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.SessionState.HttpSessionState" /> Pobiera obiekt dla bieżącego żądania HTTP.</summary>
        <value><see cref="T:System.Web.SessionState.HttpSessionState" /> Obiekt dla bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zapewnia programistyczny dostęp do właściwości i metod <xref:System.Web.SessionState.HttpSessionState> klasy. <xref:System.Web.HttpContext.Session%2A>  
  
 Aby móc korzystać z stanu sesji, należy go włączyć. Informacje o sposobie włączania stanu sesji znajdują się w temacie **Konfigurowanie stanu sesji** w programie [ASP.NET — omówienie stanu sesji](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Informacje o sposobach zapisywania wartości w stanie sesji znajdują się [w temacie How to: Zapisz wartości w stanie](https://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165)sesji. Informacje o sposobie odczytywania wartości z stanu sesji znajdują się [w temacie How to: Odczytaj wartości z stanu](https://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5)sesji.  
  
   
  
## Examples  
 W poniższych przykładach pokazano, jak zapisać wartości w stanie sesji i jak odczytywać wartości z stanu sesji.  
  
 Te przykłady wymagają:  
  
-   Aplikacja ASP.NET z włączonym stanem sesji.  
  
-   Klasa strony formularzy sieci Web, która ma dostęp do <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> właściwości lub dowolnej klasy, która ma dostęp <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> do właściwości.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">Jedna z wartości wyliczenia, która określa, jakiego typu zachowanie stanu sesji jest wymagane.</param>
        <summary>Ustawia typ zachowania stanu sesji, który jest wymagany w celu obsługi żądania HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W implementacji domyślnej ASP.NET program obsługi żądań HTTP wskazuje, czy wymaga stanu sesji przez implementację <xref:System.Web.SessionState.IRequiresSessionState> interfejsu <xref:System.Web.SessionState.IReadOnlySessionState> lub interfejsu. <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Metoda<xref:System.Web.SessionState.SessionStateBehavior> i Wyliczenie umożliwiają dostarczenie bardziej szczegółowych informacji o rodzaju obsługi stanu sesji, która jest wymagana w celu obsługi żądania. Aby uzyskać więcej informacji, zobacz <xref:System.Web.SessionState.SessionStateBehavior> Wyliczenie.  
  
 Metoda musi być wywoływana <xref:System.Web.HttpApplication.AcquireRequestState> przed zdarzeniem potoku. <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Wywołania, które wystąpiły w trakcie lub po tym <xref:System.InvalidOperationException> zdarzeniu, spowodują wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda została wywołana po <see cref="E:System.Web.HttpApplication.AcquireRequestState" /> wywołaniu zdarzenia.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy <see cref="T:System.Web.Security.UrlAuthorizationModule" /> obiekt powinien pominąć sprawdzanie autoryzacji dla bieżącego żądania.</summary>
        <value><see langword="true" />Jeśli <see cref="T:System.Web.Security.UrlAuthorizationModule" /> program<see langword="false" />powinien pominąć sprawdzanie autoryzacji; w przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.SkipAuthorization%2A> Właściwość jest przeznaczona do użycia zaawansowanego przez moduły uwierzytelniania, które muszą przekierować do strony, która zezwala na połączenia anonimowe. Moduł uwierzytelniania formularzy i moduł uwierzytelniania paszportu są ustawiani <xref:System.Web.HttpContext.SkipAuthorization%2A> podczas przekierowywania do skonfigurowanej strony logowania. <xref:System.Web.HttpContext.SkipAuthorization%2A> Ustawienie`ControlPrincipal` wymaga ustawienia flagi. Aby uzyskać informacje na `ControlPrincipal` temat flagi, <xref:System.Security.Permissions.SecurityPermissionFlag>Zobacz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Typ <see cref="T:System.Web.HttpContext" /> usługi, dla której ma zostać ustawiony dostawca usług.</param>
        <summary>Zwraca obiekt dla bieżącego typu usługi.</summary>
        <returns>A <see cref="T:System.Web.HttpContext" />; w przeciwnym <see langword="null" /> razie, jeśli nie zostanie znaleziona żadna usługa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przydatna do uzyskania dostępu do bazowego <xref:System.Web.HttpWorkerRequest> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy środowisko uruchomieniowe ASP.NET powinno <see cref="M:System.Threading.Thread.Abort" /> wywoływać na wątku obsługującym to żądanie, gdy limit czasu żądania upłynął.</summary>
        <value><see langword="true" />Jeśli <see cref="M:System.Threading.Thread.Abort" /> zostanie wywołana, <see langword="false" />gdy wątek przejdzie w limit czasu; w przeciwnym razie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programach obsługi i modułach, które używają <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> właściwości do implementowania operacji w ramach spółdzielni, można <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> wyłączyć zachowanie, które domyślnie ASP.NET wykonuje, gdy żądanie przeprowadzi limit czasu. Ustawienie tej właściwości na `false` może pomóc upewnić się, że procedury anulowania i czyszczenia zostaną uruchomione bez przerywania pracy przez ASP.NET.  
  
 Jeśli ustawisz tę właściwość na `false`, ASP.NET nie będzie automatycznie wyświetlał strony błędu "Upłynął limit czasu żądania", gdy wystąpi limit czasu. Aplikacja odpowiada za odpowiednio Ustawianie zawartości odpowiedzi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera początkową sygnaturę czasową bieżącego żądania HTTP.</summary>
        <value>Sygnatura czasowa bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sygnatura czasowa zwracana <xref:System.Web.HttpContext.Timestamp%2A> z właściwości jest czasem lokalnym serwera i jest ustawiana podczas tworzenia wystąpienia <xref:System.Web.HttpContext> obiektu. Czas lokalny jest równy czasowi UTC i przesunięciu czasu UTC.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.TraceContext" /> Pobiera obiekt dla bieżącej odpowiedzi HTTP.</summary>
        <value><see cref="T:System.Web.TraceContext" /> Dla bieżącej odpowiedzi HTTP.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o zabezpieczeniach dla bieżącego żądania HTTP.</summary>
        <value>Informacje o zabezpieczeniach dla bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zapewnia programistyczny dostęp do właściwości i metod <xref:System.Security.Principal.IPrincipal> interfejsu. <xref:System.Web.HttpContext.User%2A>  
  
 Ponieważ strony ASP.NET zawierają odwołanie domyślne <xref:System.Web> do przestrzeni nazw (która <xref:System.Web.HttpContext> zawiera klasę), można odwoływać się do członków <xref:System.Web.HttpContext> na stronie. aspx bez używania w pełni kwalifikowanego odwołania do klasy do <xref:System.Web.HttpContext>. Na przykład można użyć `User.Identity.Name` , aby uzyskać nazwę użytkownika, w którym imieniu jest uruchomiony bieżący proces. Jeśli jednak chcesz użyć elementów członkowskich <xref:System.Security.Principal.IPrincipal> z modułu ASP.NET z kodem związanym, musisz uwzględnić odwołanie <xref:System.Web> do przestrzeni nazw w module i w pełni kwalifikowane odwołanie do aktualnie aktywnego kontekstu żądania/odpowiedzi i <xref:System.Web> Klasa, która ma być używana. Na przykład na stronie powiązanej z kodem należy określić w pełni kwalifikowaną nazwę `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Web.HttpContext.User%2A> jak uzyskać dostęp do właściwości bieżącego użytkownika za pomocą właściwości. Te właściwości są używane do ustawiania tytułu strony sieci Web.  
  
 Jeśli aplikacja używa uwierzytelniania systemu Windows, nazwa użytkownika obejmuje domenę. Na przykład tytuł strony to "Strona główna dla domena\nazwa użytkownika".  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions/using-oauth-providers-with-mvc">Korzystanie z dostawców uwierzytelniania OAuth we wzorcu MVC 4</related>
        <related type="ExternalDocumentation" href="/aspnet/web-forms/overview/getting-started/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">Wprowadzenie z formularzami sieci Web ASP.NET 4,5 — Wyewidencjonowywanie i płatność w systemie PayPal</related>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization">NerdDinner — Zabezpieczanie aplikacji przy użyciu uwierzytelniania i autoryzacji</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera negocjowany protokół, który został wysłany z serwera do klienta w celu <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> połączenia.</summary>
        <value>Negocjowany protokół.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uporządkowaną listę protokołów żądanych przez klienta.</summary>
        <value>Żądane protokoły lub <see langword="null" /> Jeśli <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> nie jest to żądanie lub jeśli żadna lista nie jest obecna.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

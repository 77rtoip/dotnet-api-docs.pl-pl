<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="571c854e5bea1aa3323080495177f0636cdef671" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37586941" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Hermetyzuje wszystkie informacje specyficzne dla protokołu HTTP dotyczące indywidualnego żądania HTTP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które dziedziczą <xref:System.Web.IHttpModule> i <xref:System.Web.IHttpHandler> interfejsy odwołanie do <xref:System.Web.HttpContext> obiektu dla bieżącego żądania HTTP. Obiekt umożliwia dostęp do wewnętrznych <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>, i <xref:System.Web.HttpContext.Server%2A> właściwości dla żądania.  
  
> [!IMPORTANT] 
> Ten obiekt jest gotowy do wyrzucania elementów bezużytecznych podczas <xref:System.Web.HttpRequest> zostało zakończone. Jego użycie po ukończeniu żądania może prowadzić do niezdefiniowanego zachowania, takich jak <xref:System.NullReferenceException>.
>
> Ten obiekt jest dostępna tylko w wątku kontrolowanych przez platformę ASP.NET. Użycie wątków w tle może spowodować niezdefiniowane zachowanie.

## Examples  
 Projekt witryny internetowego programu Visual Studio z kodem źródłowym jest dostępna powiązany z tym tematem: [Pobierz](http://go.microsoft.com/fwlink/?LinkId=192422).  
  
 Poniższy przykład pokazuje, jak uzyskać dostęp i wyświetlić właściwości <xref:System.Web.HttpContext> obiektu. Kontekst bieżącego żądania HTTP odbywa się za pomocą <xref:System.Web.UI.Page.Context%2A> właściwość <xref:System.Web.UI.Page> obiektu.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.HttpContext" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">
          <see cref="T:System.Web.HttpWorkerRequest" /> Obiektu dla bieżącego żądania HTTP.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.HttpContext" /> klasę, która używa obiektu określonego żądania procesu roboczego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">
          <see cref="T:System.Web.HttpRequest" /> Obiektu dla bieżącego żądania HTTP.</param>
        <param name="response">
          <see cref="T:System.Web.HttpResponse" /> Obiektu dla bieżącego żądania HTTP.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.HttpContext" /> przy użyciu określonych obiektów żądań i odpowiedzi.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Akceptuje <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> żądania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">Funkcja użytkownika.</param>
        <summary>Akceptuje <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> żądania przy użyciu określonej funkcji użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest równoważne z wywoływaniem <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> metoda przeciążenia i przekazywać `null` dla `options` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userFunc" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Żądanie nie jest <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">Funkcja użytkownika.</param>
        <param name="options">Obiekt opcji.</param>
        <summary>Akceptuje <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> żądania za pomocą obiektu funkcji i opcji określonego użytkownika.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userFunc" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Żądanie nie jest <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">
          <see cref="T:System.Exception" /> Do dodania do zbierania wyjątków.</param>
        <summary>Dodaje wyjątek do zbierania wyjątków dla bieżącego żądania HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Obiekt kontekstu HTTP.</param>
        <summary>Zgłasza zdarzenie wirtualnego, który występuje, gdy kończy się część protokołu HTTP żądania.</summary>
        <returns>Token subskrypcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje przed <xref:System.Web.WebSockets.AspNetWebSocket> rozpoczyna się połączenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tablicę błędów zgromadzonych podczas przetwarzania żądania HTTP.</summary>
        <value>Tablica <see cref="T:System.Exception" /> obiekty dla bieżącego żądania HTTP.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy operacje asynchroniczne są dozwolone podczas części podczas nie oczekuje się przetwarzanie żądania programu ASP.NET.</summary>
        <value>
          <see langword="false" /> w przypadku ASP.NET spowoduje zgłoszenie wyjątku, gdy asynchronicznego interfejsu API jest używany w czasie, gdy nie jest oczekiwane; w przeciwnym razie <see langword="true" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta flaga nie jest równa `true`, ASP.NET, które spowoduje zgłoszenie wyjątku w przypadku wykrycia aplikacji niewłaściwie async interfejsu API. Taka sytuacja może wystąpić, jeśli zostanie podjęta próba wywołania metody asynchronicznej podczas części żądanie przetwarzania potoku, w której nie oczekiwano operacji asynchronicznych, czy ma nadal pozostałych zadań asynchronicznych, gdy moduł asynchronicznego lub obsługi sygnalizuje zakończenie. To zachowanie jest przeznaczona zabezpieczenie Cię powiadomić na wczesnym etapie, jeśli piszesz kod asynchroniczny, który nie mieści się oczekiwane wzorce i może mieć negatywne skutki uboczne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.HttpApplicationState" /> obiektu dla bieżącego żądania HTTP.</summary>
        <value>
          <see cref="T:System.Web.HttpApplicationState" /> Dla bieżącego żądania HTTP.  Aby uzyskać <see cref="T:System.Web.HttpApplication" /> obiektu dla bieżącego żądania HTTP, użyj <see cref="P:System.Web.HttpContext.ApplicationInstance" />. (Platforma ASP.NET używa <see langword="ApplicationInstance" /> zamiast <see langword="Application" /> jako nazwa właściwości do odwoływania się do bieżącego <see cref="T:System.Web.HttpApplication" /> wystąpienia, aby uniknąć pomyłki platformy ASP.NET i classic ASP. W klasycznej technologii ASP <see langword="Application" /> odwołuje się do słownika stanów globalnej aplikacji.)</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Web.HttpApplication" /> obiektu dla bieżącego żądania HTTP.</summary>
        <value>
          <see cref="T:System.Web.HttpApplication" /> Dla bieżącego żądania HTTP.  Aplikacja ASP.NET używa <see langword="ApplicationInstance" /> zamiast <see langword="Application" /> jako nazwa właściwości do odwoływania się do bieżącego <see cref="T:System.Web.HttpApplication" /> wystąpienia, aby uniknąć pomyłki platformy ASP.NET i classic ASP. W klasycznej technologii ASP <see langword="Application" /> odwołuje się do słownika stanu aplikacji globalnej.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Aplikacja sieci Web jest uruchomiony w ramach usług IIS 7.0 w trybie zintegrowanym i próbowano zmienić wartości właściwości z wartość inną niż null do <see langword="null" />.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który zawiera flagi, które odnoszą się do asynchronicznego trybu wstępnego ładowania.</summary>
        <value>Obiekt, który zawiera flagi, które odnoszą się do asynchronicznego trybu wstępnego ładowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest dostępny, po raz pierwszy obiekt, który zawiera flagi dla trybie asynchronicznym wstępnego ładowania jest ładowany z <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> ustawienia w pliku konfiguracji.  
  
 Mimo że tę właściwość można ustawić programowo, zmieniając wartość właściwości ma znaczenie tylko wtedy, jeśli właściwość została ustawiona przed `ExecuteRequestHandler` krok w Potok żądań ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.Caching.Cache" /> obiektu dla bieżącej domeny aplikacji.</summary>
        <value>
          <see cref="T:System.Web.Caching.Cache" /> Dla bieżącej domeny aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieje jedno wystąpienie <xref:System.Web.Caching.Cache> klasy dla domeny aplikacji. W rezultacie <xref:System.Web.Caching.Cache> obiektu, który jest zwracany przez <xref:System.Web.HttpContext.Cache%2A> właściwość <xref:System.Web.Caching.Cache> obiektu dla wszystkich żądań w domenie aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkich błędów dla bieżącego żądania HTTP.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Web.HttpContext" /> obiektu dla bieżącego żądania HTTP.</summary>
        <value>
          <see cref="T:System.Web.HttpContext" /> Wystąpienia dla bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest właściwość statyczna <xref:System.Web.HttpContext> klasy. Magazyny właściwość <xref:System.Web.HttpContext> wystąpienia, która ma zastosowanie do bieżącego żądania. Właściwości tego wystąpienia są niestatycznej właściwości <xref:System.Web.HttpContext> klasy.  
  
 Można również użyć <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> właściwości w celu uzyskania dostępu do <xref:System.Web.HttpContext> obiektu dla bieżącego żądania HTTP.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.HttpContext.Current%2A> właściwości w celu uzyskania dostępu do <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> i <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> metod i <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> właściwości. Przykład tworzy trzy niestandardowe wyjątków za pomocą <xref:System.Web.HttpContext.AddError%2A> metody i używa <xref:System.Web.HttpContext.AllErrors%2A> właściwości można załadować tych wyjątków do tablicy. Następnie zapisuje tablicy do strony zawierającej i używa <xref:System.Web.HttpContext.ClearError%2A> metodę, aby wyczyścić wszystkie błędy z <xref:System.Web.UI.Page.Context%2A> właściwości.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.IHttpHandler" /> obiekt, który reprezentuje aktualnie wykonywany program obsługi.</summary>
        <value>
          <see cref="T:System.Web.IHttpHandler" /> Który reprezentuje aktualnie wykonywany program obsługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aktualnie wykonywanej program obsługi, który odwołuje się do niej <xref:System.Web.HttpContext.CurrentHandler%2A> właściwość może być inny niż program obsługi, który odwołuje się do niej <xref:System.Web.HttpContext.Handler%2A> właściwości. Taka sytuacja może wystąpić, gdy zażądano innego programu obsługi przy użyciu <xref:System.Web.HttpServerUtility.Execute%2A> metody lub <xref:System.Web.HttpServerUtility.Transfer%2A> metody. Po zakończeniu przetwarzania obsługi aktualnie wykonywanej pracy wcześniej określonym program obsługi zostanie przywrócony.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.RequestNotification" /> wartość, która wskazuje bieżący <see cref="T:System.Web.HttpApplication" /> zdarzenia, które przetwarza.</summary>
        <value>Jedną z <see cref="T:System.Web.RequestNotification" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.CurrentNotification%2A> Właściwość wymaga trybu zintegrowanego potoku w [!INCLUDE[iisver](~/includes/iisver-md.md)] i co najmniej programu .NET Framework w wersji 3.0 lub nowszej. Jeśli są dostępne, właściwość ta zwraca <xref:System.Web.RequestNotification> wartość. Wartość <xref:System.Web.HttpContext.CurrentNotification%2A> właściwość wskazuje, które zdarzenia w <xref:System.Web.HttpApplication> wystąpienia trwa jego przetwarzanie żądania.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> Właściwość nie jest przeznaczona do ustawienia. Zamiast tego jest on ustawiony przez [!INCLUDE[iisver](~/includes/iisver-md.md)] podczas przetwarzania żądania w potoku ASP.NET. Ustawienie <xref:System.Web.HttpContext.CurrentNotification%2A> właściwości spowoduje błąd kompilacji.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> został wprowadzony w .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Web.HttpContext.CurrentNotification%2A> właściwości, aby określić, jakie zdarzenia <xref:System.Web.HttpApplication> obiektu, który obsługuje bieżące żądanie jest przetwarzane. W tym przykładzie program obsługi zdarzeń obsługuje kilka zdarzeń <xref:System.Web.HttpApplication> obiektu, a <xref:System.Web.HttpContext.CurrentNotification%2A> właściwość określa, jaki kod jest wywoływana dla każdego zdarzenia, które są obsługiwane.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Operacja wymaga trybu zintegrowanego potoku w [! INCLUDE[iisver](~/includes/iisver-MD.MD)] i co najmniej programu .NET Framework w wersji 3.0 lub nowszej.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt którego <see cref="M:System.IDisposable.Dispose" /> metoda musi zostać wywołana kiedy <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> połączenia część żądania zostało zakończone.</param>
        <summary>Umożliwia to obiektowi <see cref="M:System.IDisposable.Dispose" /> metoda wywoływana, gdy <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> połączenia część to żądanie zostało zakończone.</summary>
        <returns>Token subskrypcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IDisposable.Dispose%2A> Metoda obiektu docelowego jest wywoływana po części HTTP żądania i <xref:System.Web.WebSockets.AspNetWebSocket> zakończył połączenie. <xref:System.Web.HttpContext> Obiekt nie jest dostępny w celu przeprowadzenia inspekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przetwarzanie żądań pobiera pierwszego błędu (jeśli istnieje) zebranych podczas HTTP.</summary>
        <value>Pierwszy <see cref="T:System.Exception" /> dla bieżącego żądania HTTP/odpowiedzi procesu; w przeciwnym razie <see langword="null" /> Jeśli żadne błędy były zbierane podczas przetwarzania żądania HTTP. Wartość domyślna to <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Żądania dotyczące tag konfiguracji aplikacji.</param>
        <summary>Zwraca żądane informacje o konfiguracji dla bieżącej aplikacji.</summary>
        <returns>Obiekt zawierający informacje o konfiguracji. (Rzutowany sekcji konfiguracji zwracany typ prawidłowej konfiguracji przed użyciem).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetAppConfig%2A> Metoda jest przestarzała. Użyj <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> metody <xref:System.Web.Configuration.WebConfigurationManager> klasy, aby uzyskać informacje o konfiguracji dla bieżącej aplikacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Tag konfiguracji, dla którego żądana informacja.</param>
        <summary>Zwraca żądane informacje o konfiguracji dla bieżącego żądania HTTP.</summary>
        <returns>Określony <see cref="T:System.Configuration.ConfigurationSection" />, <see langword="null" /> Jeśli sekcja nie istnieje, lub Obiekt wewnętrzny, jeśli sekcji nie jest dostępny w czasie wykonywania. (Rzutować zwracany obiekt odpowiedni typ konfiguracji przed użyciem).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetConfig%2A> Metoda jest przestarzała. Użyj <xref:System.Web.HttpContext.GetSection%2A> metodę, aby uzyskać informacje o konfiguracji dla bieżącego żądania HTTP.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zasób na poziomie aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> właściwości obiektu żądanego zasobu.</param>
        <param name="resourceKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> właściwości obiektu żądanego zasobu.</param>
        <summary>Pobiera obiekt zasobów na poziomie aplikacji na podstawie <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> i <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> właściwości.</summary>
        <returns>
          <see cref="T:System.Object" /> Reprezentujący obiekt żądanego zasobu na poziomie aplikacji; w przeciwnym razie wartość null, jeśli nie można odnaleźć obiektu zasobu lub obiektu zasobu zostanie znaleziony, ale go nie ma wymaganej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> Metoda zwraca globalnego zasobu przy użyciu kultury, który jest określony w <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> właściwości.  
  
> [!NOTE]
>  W niektórych edycji środowisk, takich jak [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], edytor może zgłosić czasu projektowania <xref:System.Resources.MissingManifestResourceException> wyjątek, jeśli używasz kropki (.) w nazwie klucza zasobu globalnego. Jednak nie wpływa to na możliwość edytowania lub zapisać plik, i możesz zignorować ten błąd.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Obiekt zasobu z danym <paramref name="classKey" /> nie znaleziono parametru.  \- -główny zestaw nie zawiera zasobów dla kultury neutralnej lub te zasoby są wymagane, ponieważ brakuje zestawu satelickiego odpowiednie.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> właściwości obiektu żądanego zasobu.</param>
        <param name="resourceKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> właściwości obiektu żądanego zasobu.</param>
        <param name="culture">Ciąg, który reprezentuje <see cref="T:System.Globalization.CultureInfo" /> obiektu żądanego zasobu.</param>
        <summary>Pobiera obiekt zasobów na poziomie aplikacji na podstawie <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> i <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> właściwości, a następnie na <see cref="T:System.Globalization.CultureInfo" /> obiektu.</summary>
        <returns>
          <see cref="T:System.Object" /> Reprezentujący obiekt żądanego zasobu na poziomie aplikacji, który jest zlokalizowany dla określonej kultury; w przeciwnym razie, <see langword="null" /> Jeśli nie można odnaleźć obiektu zasobu lub obiektu zasobu zostanie znaleziony, ale nie ma żądanego Właściwość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> Obiekt reprezentuje kulturę, dla którego został zlokalizowany zasób. Jeśli zasób nie jest zlokalizowana dla tej kultury, wyszukiwanie będzie występować rezerwowego procesu, aby zlokalizować odpowiedni zasób. Aby uzyskać więcej informacji, zobacz [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  W niektórych środowiskach edycji, takie jak Visual Web Developer, edytor może zgłosić czasu projektowania <xref:System.Resources.MissingManifestResourceException> wyjątek, jeśli używasz kropki (.) w nazwie klucza zasobu globalnego. Jednak nie wpływa to na możliwość edytowania lub zapisać plik, i możesz zignorować ten błąd.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Obiekt zasobu, dla którego określony <paramref name="classKey" /> nie znaleziono parametru.  \- -główny zestaw nie zawiera zasobów dla kultury neutralnej lub te zasoby są wymagane, ponieważ brakuje zestawu satelickiego odpowiednie.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zasób na poziomie strony.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">
          <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> Właściwości dla obiektu zasobu lokalnego.</param>
        <param name="resourceKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> właściwości obiektu żądanego zasobu</param>
        <summary>Pobiera obiekt na poziomie strony zasobu na podstawie <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> i <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> właściwości.</summary>
        <returns>
          <see cref="T:System.Object" /> Reprezentujący obiekt żądanego zasobu na poziomie strony; w przeciwnym razie <see langword="null" /> przypadku znalezienia dopasowania obiektu zasobu ale nie <paramref name="resourceKey" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetLocalResourceObject%2A> Metoda zwraca zasobów lokalnych przy użyciu kultury, który jest określony w <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie można odnaleźć obiektu zasobów dla określonego <paramref name="virtualPath" /> parametru.</exception>
        <exception cref="T:System.ArgumentException">Określony <paramref name="virtualPath" /> parametr nie jest w katalogu głównym bieżącej aplikacji.</exception>
        <exception cref="T:System.InvalidOperationException">Nie znaleziono klasy zasobów dla strony.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">
          <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> Właściwości dla obiektu zasobu lokalnego.</param>
        <param name="resourceKey">Ciąg, który reprezentuje <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> właściwości obiektu żądanego zasobu.</param>
        <param name="culture">Ciąg, który reprezentuje <see cref="T:System.Globalization.CultureInfo" /> obiektu żądanego zasobu.</param>
        <summary>Pobiera obiekt na poziomie strony zasobu na podstawie <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> i <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> właściwości, a następnie na <see cref="T:System.Globalization.CultureInfo" /> obiektu.</summary>
        <returns>
          <see cref="T:System.Object" /> Reprezentujący obiekt żądany zasób lokalny, który jest zlokalizowany dla określonej kultury; w przeciwnym razie <see langword="null" /> przypadku znalezienia dopasowania obiektu zasobu ale nie <paramref name="resourceKey" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zasób nie jest zlokalizowana dla tej kultury, wyszukiwanie będzie występować rezerwowego procesu, aby zlokalizować odpowiedni zasób. Aby uzyskać więcej informacji, zobacz [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie można odnaleźć obiektu zasobów dla określonego <paramref name="virtualPath" /> parametru.</exception>
        <exception cref="T:System.ArgumentException">Określony <paramref name="virtualPath" /> parametr nie jest w katalogu głównym bieżącej aplikacji.</exception>
        <exception cref="T:System.InvalidOperationException">Nie znaleziono klasy zasobów dla strony.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Ścieżka do sekcji konfiguracji (w formacie XPath) i nazwę elementu konfiguracji.</param>
        <summary>Pobiera sekcję konfiguracji określony dla bieżącej aplikacji domyślnej konfiguracji.</summary>
        <returns>Określony <see cref="T:System.Configuration.ConfigurationSection" />, <see langword="null" /> Jeśli sekcja nie istnieje, lub Obiekt wewnętrzny, jeśli sekcji nie jest dostępny w czasie wykonywania.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Web.IHttpHandler" /> obiektu odpowiedzialna za przetwarzanie żądania HTTP.</summary>
        <value>
          <see cref="T:System.Web.IHttpHandler" /> Odpowiedzialna za przetwarzanie żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Handler%2A> Właściwość zawiera odwołanie do programu obsługi, który przetwarza żądania HTTP. Program obsługi można określić przy użyciu elementu lub za pomocą niestandardowych procedurę obsługi zdefiniowaną w kodzie użytkownika. Aby uzyskać więcej informacji na temat obsługi, zobacz [programów obsługi HTTP i przegląd moduły HTTP](http://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 Odwołanie do <xref:System.Web.HttpContext.Handler%2A> właściwości pozostaną takie same, nawet po zakończeniu bieżącej strony został zmieniony przez metodę po stronie serwera, takie jak <xref:System.Web.HttpServerUtility.Execute%2A> metody lub <xref:System.Web.HttpServerUtility.Transfer%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy błędy niestandardowe są włączone dla bieżącego żądania HTTP.</summary>
        <value>
          <see langword="true" /> Jeśli błędy niestandardowe są włączone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące żądanie HTTP jest w trybie debugowania.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie jest w trybie debugowania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która jest bieżącą przetwarzania punktu w ASP.NET potoku tuż za <see cref="T:System.Web.HttpApplication" /> zdarzeń zakończeniu przetwarzania.</summary>
        <value>
          <see langword="true" /> Jeśli błędy niestandardowe są włączone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.IsPostNotification%2A> Właściwość jest obsługiwana tylko w trybie zintegrowanym [!INCLUDE[iisver](~/includes/iisver-md.md)] i co najmniej programu .NET Framework 3.0. Jeśli są dostępne, właściwości zwracają wartość logiczną, wskazującą, czy zdarzenie w <xref:System.Web.HttpApplication> obiektu zakończeniu przetwarzania.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> Właściwość nie jest przeznaczona do ustawienia. Zamiast tego jest ona udostępniana przed [!INCLUDE[iisver](~/includes/iisver-md.md)] do środowiska uruchomieniowego platformy ASP.NET dla każdego powiadomienia. Ustawienie <xref:System.Web.HttpContext.IsPostNotification%2A> właściwości spowoduje błąd kompilacji.  
  
 W scenariuszach gdzie wielu zdarzeń z <xref:System.Web.HttpApplication> obiektu są obsługiwane przez jedna procedura obsługi zdarzeń, możesz użyć <xref:System.Web.HttpContext.IsPostNotification%2A> właściwość w połączeniu z <xref:System.Web.RequestNotification> wyliczeniu, aby precyzyjnie określić, gdzie w cyklu życia aplikacji bieżącego to żądanie.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> został wprowadzony w .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Web.HttpContext.IsPostNotification%2A> właściwości w celu określenia, gdy zdarzenie <xref:System.Web.HttpApplication> obiektu zakończył przetwarzanie całej obsługi skojarzone ze zdarzeniem. Program obsługi zdarzeń niestandardowych w tym przykładzie obsługuje kilka zdarzeń <xref:System.Web.HttpApplication> obiektu i <xref:System.Web.HttpContext.IsPostNotification%2A> właściwość jest używana do określenia, jaki kod jest wywoływana po określone zdarzenie jest obsługiwane.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Operacja wymaga trybu zintegrowanego potoku w [! INCLUDE[iisver](~/includes/iisver-MD.MD)] i co najmniej programu .NET Framework 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy żądanie jest <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> żądania.</summary>
        <value>
          <see langword="true" /> Jeśli żądanie jest <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> żądania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `true` Jeśli żądanie zawiera wstępne <xref:System.Web.WebSockets.AspNetWebSocket> uzgadniania i `WebSocket` modułu IIS jest aktywny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy połączenie jest uaktualniany z połączenia HTTP <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> połączenia.</summary>
        <value>
          <see langword="true" /> Jeśli połączenie jest uaktualniany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję kluczy/wartości, który może służyć do organizowania i udostępnianie danych między <see cref="T:System.Web.IHttpModule" /> interfejsu i <see cref="T:System.Web.IHttpHandler" /> interfejsu podczas żądania HTTP.</summary>
        <value>
          <see cref="T:System.Collections.IDictionary" /> Kluczy/wartości kolekcji, która zapewnia dostęp do poszczególnych wartości w kolekcji przy użyciu określonego klucza.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do wystąpienia usługi Instrumentacji strony dla tego żądania.</summary>
        <value>Wystąpienie usługi Instrumentacji strony dla tego żądania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.IHttpHandler" /> obiekt obsługi nadrzędnej.</summary>
        <value>
          <see cref="T:System.Web.IHttpHandler" /> Wystąpienia lub <see langword="null" /> Jeśli żadna procedura obsługi nie poprzedniej została odnaleziona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.PreviousHandler%2A> Właściwość do ostatniego odpowiada obsługi przed bieżącego żądania zostało wykonane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.Profile.ProfileBase" /> obiektu dla bieżącego profilu użytkownika.</summary>
        <value>A <see cref="T:System.Web.Profile.ProfileBase" /> Jeśli plik konfiguracji aplikacji zawiera definicję dla tego profilu właściwości; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Web.HttpContext.Profile%2A> właściwość jest używana do trwałego przechowywania danych strukturalnych za pomocą interfejsu API bezpiecznegop typu. Gdy <xref:System.Web.HttpContext.Profile%2A> dostępu do właściwości, ale wartość nie jest obecny, zwracany jest puste wystąpienie; `null` nie jest zwracana.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">Obiekt, który powinien przetworzyć żądania.</param>
        <summary>Umożliwia określenie program obsługi żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ustawisz `handler` do `null`, domyślny program obsługi zostanie użyty do przetwarzania żądania. Możesz ustawić `handler` albo asynchronicznej obsługi lub nieprawidłowego synchroniczne. Program obsługi musi implementować <xref:System.Web.IHttpHandler> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> Metoda została wywołana po <see cref="E:System.Web.HttpApplication.MapRequestHandler" /> wystąpiło zdarzenie.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.HttpRequest" /> obiektu dla bieżącego żądania HTTP.</summary>
        <value>
          <see cref="T:System.Web.HttpRequest" /> Dla bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Request%2A> Właściwość zapewnia programowy dostęp do właściwości i metod <xref:System.Web.HttpRequest> klasy. Ponieważ strony ASP.NET zawiera domyślne odwołanie do <xref:System.Web> przestrzeni nazw (który zawiera <xref:System.Web.HttpContext> klasy), możesz odwoływać się do elementów członkowskich <xref:System.Web.HttpRequest> na stronie .aspx bez korzystania z klasy w pełni kwalifikowane odwołanie do <xref:System.Web.HttpContext>. Na przykład, można użyć `Request.Browser` można pobrać możliwości przeglądarki klienta. Jednak jeśli chcesz używać członkowie <xref:System.Web.HttpRequest> z modułu związanym z kodem programu ASP.NET, należy dołączyć odwołanie do <xref:System.Web> przestrzeni nazw w module i w pełni kwalifikowane odwołanie do kontekstu aktualnie aktywnych żądań/odpowiedzi oraz klasy w <xref:System.Web> , którego chcesz użyć. Na przykład na stronie związanym z kodem należy określić w pełni kwalifikowana nazwa `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  ASP.NET spowoduje zgłoszenie wyjątku, Jeśli spróbujesz użyć tej właściwości, gdy <xref:System.Web.HttpRequest> obiekt nie jest dostępny. Na przykład będzie to wartość true w pliku Global.asax metody Application_Start lub w metodzie, która jest wywoływana z metody Application_Start. W tym czasie żądanie HTTP nie została jeszcze utworzona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Aplikacja sieci Web jest uruchomiony w ramach usług IIS 7 w trybie zintegrowanym.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.HttpResponse" /> obiektu dla bieżącej odpowiedzi HTTP.</summary>
        <value>
          <see cref="T:System.Web.HttpResponse" /> Dla bieżącej odpowiedzi HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Response%2A> Właściwość zapewnia programowy dostęp do właściwości i metod <xref:System.Web.HttpResponse> klasy. Ponieważ strony ASP.NET zawiera domyślne odwołanie do <xref:System.Web> przestrzeni nazw (który zawiera <xref:System.Web.HttpContext> klasy), możesz odwoływać się do elementów członkowskich <xref:System.Web.HttpContext> na stronie .aspx bez korzystania z klasy w pełni kwalifikowane odwołanie do <xref:System.Web.HttpContext>. Na przykład, można użyć `Response.Write("some output")` do zapisywania danych wyjściowych w strumieniu wyjściowym HTTP. Jednakże jeśli chcesz używać członkowie <xref:System.Web.HttpResponse> z modułu związanym z kodem programu ASP.NET, należy dołączyć odwołanie do <xref:System.Web> przestrzeni nazw w module i w pełni kwalifikowane odwołanie do kontekstu aktualnie aktywnych żądań/odpowiedzi i klasy w <xref:System.Web> , którego chcesz użyć. Na przykład na stronie związanym z kodem należy określić w pełni kwalifikowana nazwa `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Aplikacja sieci Web jest uruchomiony w ramach usług IIS 7 w trybie zintegrowanym.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekierowuje żądanie do zasobu z inną ścieżką niż ten, który jest wskazywany przez żądany adres URL. <see cref="Overload:System.Web.HttpContext.RewritePath" /> jest używany w stan sesji cookieless oddzielić sesji z adresów URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka wewnętrzne ponowne zapisywanie adresów.</param>
        <summary>Ponownie zapisuje adres URL, za pomocą podanej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%29> Metoda przekierowuje żądania zasobu z inną ścieżką niż ten, który jest wskazywany przez żądany adres URL. Jeśli trzeba zresetować ścieżkę wirtualną tak, aby poprawnie rozpoznać żądania od klienta na potrzeby zasobów serwera, użyj przeciążenia tej metody, która przyjmuje `rebaseClientPath` parametru i ustawić dla parametru `false`.  
  
 Ponownego zapisywania adresów URL jest przydatne w przypadku, gdy chcesz zmienić strukturę stron w aplikacji sieci Web i chcesz upewnić się, że osoby, które zakładki starych adresów URL można nadal z nich korzysta po przesunięciu stron. Ponownego zapisywania adresów URL umożliwia przezroczyste przekazywania żądań do nowej lokalizacji strony.  
  
 Jeśli chcesz umożliwić lokacji do użytku adresy URL, które są bardziej czytelne i są zoptymalizowane pod kątem wyszukiwarek, bardziej niezawodne alternatywą jest używają routingu platformy ASP.NET. Aby uzyskać więcej informacji, zobacz [routingu platformy ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Web.HttpContext.RewritePath%2A> metodę umożliwiającą włączenie witryny sieci Web odpowiedzieć na adresy URL, które odzwierciedlają strukturę pliku w witrynie sieci Web. Pierwszy blok kodu jest na stronie sieci Web platformy ASP.NET, który nosi nazwę RewritePath.aspx. Wymaga to ciąg zapytania. Jeśli nazwa lokacji jest witryna "website1" i adresu URL `http://localhost/WebSite1/RewritePath.aspx?page=1` wyświetli "Strona 1" w przeglądarce. Blok kodu, który następuje po stronie sieci Web jest `Application_BeginRequest` program obsługi zdarzeń w pliku Global.asax. Ten kod przechwytuje żądania dla adresu URL takich jak `http://localhost/WebSite1/page1` i konwertuje je na formularz, który jest wymagany dla RewritePath.aspx, zanim zostaną one przetworzone. W związku z tym, adres URL `http://localhost/WebSite1/page1` wywołuje RewritePath.aspx za pomocą parametru ciągu zapytania, który wyświetla "Strona 1" w przeglądarce. Jeśli adres URL, takich jak `http://localhost/WebSite1/page1` zostanie odebrana, przeciążenia <xref:System.Web.HttpContext.RewritePath%2A> jest wywoływana, umożliwia podanie wartości <xref:System.Web.HttpRequest.PathInfo%2A> właściwości, a także zapytania parametr typu string.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="path" /> Parametr nie jest w katalogu głównym bieżącej aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka wewnętrzne ponowne zapisywanie adresów.</param>
        <param name="rebaseClientPath">
          <see langword="true" /> Aby zresetować ścieżki wirtualnej; <see langword="false" /> zapewnienie ścieżkę wirtualną bez zmian.</param>
        <summary>Ponownie zapisuje adresu URL przy użyciu podanej ścieżce i wartość logiczna określająca, czy ścieżka wirtualna dla zasobów serwera zostanie zmodyfikowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> Metoda jest wywoływana przez <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> metody z `rebaseClientPath` parametr `true`. Aby upewnić się, że ścieżka wirtualna, która służy do konstruowania ścieżek do zasobów nie jest modyfikowany, należy ustawić `rebaseClientPath` parametr `false`. Typowy scenariusz, w którym można ustawić `rebaseClientPath` do `false` jest konieczne ponowne zapisywanie adresów URL, gdy użytkownik korzysta z tematów i przekierowywanie adresu URL do zasobu, znajduje się w innym folderze niż żądany zasób.  
  
 Ponownego zapisywania adresów URL jest przydatne w przypadku, gdy chcesz zmienić strukturę stron w aplikacji sieci Web i chcesz upewnić się, że osoby, które zakładki starych adresów URL można nadal z nich korzysta po przesunięciu stron. Ponownego zapisywania adresów URL umożliwia przezroczyste przekazywania żądań do nowej lokalizacji strony.  
  
 Jeśli chcesz umożliwić lokacji do użytku adresy URL, które są bardziej czytelne i są zoptymalizowane pod kątem wyszukiwarek, bardziej niezawodne alternatywą jest używają routingu platformy ASP.NET. Aby uzyskać więcej informacji, zobacz [routingu platformy ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Dla przykładu kodu zobacz <xref:System.Web.HttpContext.RewritePath%28System.String%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="path" /> Parametr nie jest w katalogu głównym bieżącej aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">Ścieżka wewnętrzne ponowne zapisywanie adresów.</param>
        <param name="pathInfo">Dodatkowe informacje o ścieżce dla zasobu. Aby uzyskać więcej informacji, zobacz <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Ciąg zapytania żądania.</param>
        <summary>Ponownie zapisuje adres URL przy użyciu podanej ścieżce, informacje o ścieżce i informacji o ciągu zapytania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%2A> Metoda przekierowuje żądanie do zasobu do innego zasobu bez wprowadzania zmian w adresie URL.  
  
 `filePath` Nie ma parametru `pathInfo` zawartości parametru. Adres URL http://www.microsoft.com/virdir/page.html/tail, `filePath` parametr jest http://www.microsoft.com/virdir/page.htmli `pathInfo` parametr jest ogon.  
  
 Ponownego zapisywania adresów URL jest przydatne w przypadku, gdy chcesz zmienić strukturę stron w aplikacji sieci Web i chcesz upewnić się, że osoby, które zakładki starych adresów URL można nadal z nich korzysta po przesunięciu stron. Ponownego zapisywania adresów URL umożliwia przezroczyste przekazywania żądań do nowej lokalizacji strony.  
  
 Jeśli chcesz umożliwić lokacji do użytku adresy URL, które są bardziej czytelne i są zoptymalizowane pod kątem wyszukiwarek, bardziej niezawodne alternatywą jest używają routingu platformy ASP.NET. Aby uzyskać więcej informacji, zobacz [routingu platformy ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Dla przykładu kodu, w tym przykładzie tego przeciążenia metody, zobacz <xref:System.Web.HttpContext.RewritePath%28System.String%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr nie jest w katalogu głównym bieżącej aplikacji.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="filePath" /> Parametr nie jest w katalogu głównym bieżącej aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">Ścieżka wirtualna do zasobu, który obsługuje żądanie.</param>
        <param name="pathInfo">Dodatkowe informacje o ścieżce dla adresu URL przekierowania. Aby uzyskać więcej informacji, zobacz <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Ciąg zapytania żądania dla adresu URL przekierowania.</param>
        <param name="setClientFilePath">
          <see langword="true" /> Aby ustawić ścieżkę pliku używana dla zasobów klienta do wartości <c>filePath</c> parametru; w przeciwnym razie <see langword="false" />.</param>
        <summary>Ponownie zapisuje przy użyciu podanej ścieżki wirtualnej, informacje o ścieżce, informacji o ciągu zapytania i wartość logiczną, która określa, czy ścieżka pliku klienta jest ustawiona ścieżka ponownego zapisywania adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `filePath` Parametru nie ma zawartości `pathInfo` parametru. Adres URL http://www.microsoft.com/virdir/page.html/tail, `filePath` parametr jest http://www.microsoft.com/virdir/page.htmli `pathInfo` parametr jest ogon.  
  
 Aby upewnić się, że ścieżka wirtualna, która służy do konstruowania ścieżek do zasobów nie jest modyfikowany, należy ustawić `setClientFilePath` parametr `false`. Typowy scenariusz, w którym można ustawić `setClientFilePath` do `false` jest konieczne ponowne zapisywanie adresów URL, gdy użytkownik korzysta z tematów i przekierowywanie adresu URL do zasobu, znajduje się w innym folderze niż żądany zasób.  
  
 Ponownego zapisywania adresów URL jest przydatne w przypadku, gdy chcesz zmienić strukturę stron w aplikacji sieci Web i chcesz upewnić się, że osoby, które zakładki starych adresów URL można nadal z nich korzysta po przesunięciu stron. Ponownego zapisywania adresów URL umożliwia przezroczyste przekazywania żądań do nowej lokalizacji strony.  
  
 Jeśli chcesz umożliwić lokacji do użytku adresy URL, które są bardziej czytelne i są zoptymalizowane pod kątem wyszukiwarek, bardziej niezawodne alternatywą jest używają routingu platformy ASP.NET. Aby uzyskać więcej informacji, zobacz [routingu platformy ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Dla przykładu kodu zobacz <xref:System.Web.HttpContext.RewritePath%28System.String%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr nie jest w katalogu głównym bieżącej aplikacji.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="filePath" /> Parametr nie jest w katalogu głównym bieżącej aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.HttpServerUtility" /> obiekt, który udostępnia metody używane podczas przetwarzania żądania sieci Web.</summary>
        <value>
          <see cref="T:System.Web.HttpServerUtility" /> Dla bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Server%2A> Właściwość zapewnia programowy dostęp do właściwości i metod <xref:System.Web.HttpServerUtility> klasy. Ponieważ strony ASP.NET zawiera domyślne odwołanie do <xref:System.Web> przestrzeni nazw (który zawiera <xref:System.Web.HttpContext> klasy), możesz odwoływać się do elementów członkowskich <xref:System.Web.HttpContext> na stronie .aspx bez korzystania z klasy w pełni kwalifikowane odwołanie do <xref:System.Web.HttpContext>. Na przykład, można użyć `Server.CreateObject("MyCOMComponent")` do tworzenia wystąpienia obiektu COM na tym serwerze. Jednak jeśli chcesz używać członkowie <xref:System.Web.HttpServerUtility> z modułu związanym z kodem programu ASP.NET, należy dołączyć odwołanie do <xref:System.Web> przestrzeni nazw w module i w pełni kwalifikowane odwołanie do kontekstu aktualnie aktywnych żądań/odpowiedzi oraz klasy w <xref:System.Web> , którego chcesz użyć. Na przykład na stronie związanym z kodem należy określić w pełni kwalifikowana nazwa `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.SessionState.HttpSessionState" /> obiektu dla bieżącego żądania HTTP.</summary>
        <value>
          <see cref="T:System.Web.SessionState.HttpSessionState" /> Obiektu dla bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Session%2A> Właściwość zapewnia programowy dostęp do właściwości i metod <xref:System.Web.SessionState.HttpSessionState> klasy.  
  
 Aby można było używać stanu sesji, musisz ją włączyć. Aby uzyskać informacje o sposobie włączania stanu sesji, zobacz **stanu sesji Konfigurowanie** w [ASP.NET Session State Overview](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Aby uzyskać informacje o tym, jak można zapisać wartości w stanie sesji, zobacz [porady: zapisywanie wartości stanu sesji](http://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165). Aby uzyskać informacje o tym, jak odczytać wartości z stanu sesji, zobacz [porady: odczyt wartości ze stanu sesji](http://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5).  
  
   
  
## Examples  
 W poniższych przykładach pokazano, jak można zapisać wartości w stanie sesji oraz sposób odczytywania wartości z stanu sesji.  
  
 Wymagaj tych przykładach:  
  
-   Aplikacja platformy ASP.NET, która ma stan sesji włączone.  
  
-   Klasa strony formularzy sieci Web, który ma dostęp do <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> właściwości lub dowolnej klasy, które ma dostęp do <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> właściwości.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">Jedną z wartości wyliczenia, które określa, jakiego rodzaju zachowania stanu sesji jest wymagana.</param>
        <summary>Ustawia typ zachowania stanu sesji, który jest wymagany w celu obsługi żądań HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W implementacji domyślnej programu ASP.NET, żądania programu obsługi HTTP wskazuje, czy wymaga stanu sesji dzięki wdrożeniu <xref:System.Web.SessionState.IRequiresSessionState> interfejsu lub <xref:System.Web.SessionState.IReadOnlySessionState> interfejsu. <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Metody i <xref:System.Web.SessionState.SessionStateBehavior> wyliczenie pozwalają więcej szczegółowych informacji o tym, jakiego rodzaju obsługę pozaprocesowych stanów sesji jest wymagane w celu obsługi żądania. Aby uzyskać więcej informacji, zobacz <xref:System.Web.SessionState.SessionStateBehavior> wyliczenia.  
  
 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> Metoda musi zostać wywołana przed <xref:System.Web.HttpApplication.AcquireRequestState> potoku zdarzeń. Wywołania, które występują podczas lub po tym zdarzeniu spowoduje, że <xref:System.InvalidOperationException> wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda została wywołana po <see cref="E:System.Web.HttpApplication.AcquireRequestState" /> zdarzenia zostało podniesione.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy <see cref="T:System.Web.Security.UrlAuthorizationModule" /> obiektu należy pominąć sprawdzanie autoryzacji dla bieżącego żądania.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Web.Security.UrlAuthorizationModule" /> należy pominąć sprawdzanie autoryzacji; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.SkipAuthorization%2A> Właściwość jest przeznaczona dla zaawansowanych przez moduły uwierzytelniania, które konieczne przekierowanie do strony, która zezwala na połączenia anonimowe. Moduł uwierzytelniania formularzy i moduł uwierzytelniania usługi Passport, ustawiają <xref:System.Web.HttpContext.SkipAuthorization%2A> podczas przekierowanie do strony logowania skonfigurowany. Ustawienie <xref:System.Web.HttpContext.SkipAuthorization%2A> wymaga `ControlPrincipal` ustawienie flagi. Aby uzyskać informacje o `ControlPrincipal` Flaga, zobacz <xref:System.Security.Permissions.SecurityPermissionFlag>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Rodzaj <see cref="T:System.Web.HttpContext" /> usługi, aby ustawić dostawcę usług.</param>
        <summary>Zwraca obiekt dla bieżącego typu usługi.</summary>
        <returns>A <see cref="T:System.Web.HttpContext" />; w przeciwnym razie <see langword="null" /> Jeśli żadna usługa nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przydatna w celu uzyskania dostępu do podstawowych <xref:System.Web.HttpWorkerRequest> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy środowisko uruchomieniowe ASP.NET powinien wywoływać <see cref="M:System.Threading.Thread.Abort" /> w wątku, który jest obsługi tego żądania, gdy upłynie limit czasu żądania.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="M:System.Threading.Thread.Abort" /> zostanie wywoływane kiedy wątek czasu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Programy obsługi i modułów, które korzystają z <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> właściwości do zaimplementowania kooperatywne anulowanie może chcieć wyłączyć <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> zachowanie, które wykonuje ASP.NET domyślnie, gdy upłynie limit czasu żądania. Ustawienie tej właściwości na `false` może pomóc upewnić się, że procedury anulowania i czyszczenia uruchomią się bez przez program ASP.NET.  
  
 Jeśli ta właściwość jest ustawiona na `false`, ASP.NET nie będą automatycznie wyświetlane strony błędu "Przekroczono limit czasu żądania", gdy zostanie przekroczony limit czasu. Aplikacja jest odpowiedzialna za odpowiednie ustawienie zawartości odpowiedzi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera początkowy sygnaturę czasową bieżącego żądania HTTP.</summary>
        <value>Sygnatura czasowa bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sygnatura czasowa zwróciło <xref:System.Web.HttpContext.Timestamp%2A> właściwość jest czas lokalny serwera i jest ustawiany podczas procesu tworzenia wystąpienia <xref:System.Web.HttpContext> obiektu. Czas lokalny jest równy czas UTC, a także przesunięcie czasu UTC.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Web.TraceContext" /> obiektu dla bieżącej odpowiedzi HTTP.</summary>
        <value>
          <see cref="T:System.Web.TraceContext" /> Dla bieżącej odpowiedzi HTTP.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o zabezpieczeniach dla bieżącego żądania HTTP.</summary>
        <value>Informacje o zabezpieczeniach dla bieżącego żądania HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.User%2A> Właściwość zapewnia programowy dostęp do właściwości i metod <xref:System.Security.Principal.IPrincipal> interfejsu.  
  
 Ponieważ strony ASP.NET zawiera domyślne odwołanie do <xref:System.Web> przestrzeni nazw (który zawiera <xref:System.Web.HttpContext> klasy), możesz odwoływać się do elementów członkowskich <xref:System.Web.HttpContext> na stronie .aspx bez korzystania z klasy w pełni kwalifikowane odwołanie do <xref:System.Web.HttpContext>. Na przykład, można użyć `User.Identity.Name` można odczytać nazwy użytkownika, w którego imieniu bieżący proces jest uruchomiony. Jednak jeśli chcesz używać członkowie <xref:System.Security.Principal.IPrincipal> z modułu związanym z kodem programu ASP.NET, należy dołączyć odwołanie do <xref:System.Web> przestrzeni nazw w module i w pełni kwalifikowane odwołanie do kontekstu aktualnie aktywnych żądań/odpowiedzi oraz klasy w <xref:System.Web> , którego chcesz użyć. Na przykład na stronie związanym z kodem należy określić w pełni kwalifikowana nazwa `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać dostęp do właściwości bieżącego użytkownika za pośrednictwem <xref:System.Web.HttpContext.User%2A> właściwości. Te właściwości są używane do ustawiania tytuł strony sieci Web.  
  
 Jeśli aplikacja korzysta z uwierzytelniania Windows, nazwa użytkownika zawiera domenę. Na przykład tytuł strony będzie "Strona główna domena\nazwa_użytkownika".  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wynegocjowanym protokołem, który została wysłana z serwera do klienta dla <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> połączenia.</summary>
        <value>Wynegocjowanym protokołem.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uporządkowaną listą protokołów zażądane przez klienta.</summary>
        <value>Żądane protokoły lub <see langword="null" /> Jeśli nie jest to <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> żądania lub jeśli lista nie jest obecny.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9894bbaba80ad2a849c8969ac12ac02519aa6b4e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37586928" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Hermetyzuje informacje o odpowiedzi HTTP z operacji programu ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody i właściwości <xref:System.Web.HttpResponse> klasy są udostępniane za pośrednictwem <xref:System.Web.HttpApplication.Response%2A> właściwość <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, i <xref:System.Web.UI.UserControl> klasy.  
  
 Następujące metody <xref:System.Web.HttpResponse> klasy są obsługiwane tylko w scenariuszach post Wstecz, a nie podczas asynchronicznego wpis z powrotem scenariuszy:  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Aktualizacje stron częściowych są włączone, gdy używasz <xref:System.Web.UI.UpdatePanel> kontrolki do aktualizowania wybranych regionów strony zamiast aktualizowania całej strony z powrotem wpis. Aby uzyskać więcej informacji, zobacz [UpdatePanel informacje o formancie](http://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) i [Przegląd renderowanie części strony](http://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 Poniższy przykład pobiera trzy prostokąty nakładające się po żądaniu strony. Na początku kodu, ustawiając <xref:System.Web.HttpResponse.ContentType%2A> właściwości image/jpeg, tak aby cała strona będzie renderowana jako obraz JPEG. Następnie wywołuje kod <xref:System.Web.HttpResponse.Clear%2A> metodę, aby upewnić się, że żadna zawartość nadmiarowe jest wysyłany z tą odpowiedzią. Następnie kod ustawia <xref:System.Web.HttpResponse.BufferOutput%2A> właściwości na wartość true, aby całkowicie przetwarzania strony przed wysłaniem go do klienta wysyłającego żądanie. Następnie są tworzone dwa obiekty, które umożliwia rysowanie prostokątów: <xref:System.Drawing.Bitmap> i <xref:System.Drawing.Graphics> obiektu. Zmienne utworzone na stronie są używane jako współrzędne Rysowanie prostokątów i ciąg, który pojawia się wewnątrz największy prostokąt.  
  
 Podczas rysowania trzy prostokąty i ciąg, który pojawia się wewnątrz nich <xref:System.Drawing.Bitmap> są zapisywane <xref:System.IO.Stream> obiekt, który jest skojarzony z <xref:System.Web.HttpResponse.OutputStream%2A> JPEG ustawiono właściwość i jego format. Kod wywołuje <xref:System.Drawing.Image.Dispose%2A> i <xref:System.Drawing.Graphics.Dispose%2A> metody, aby zwolnić zasoby używane przez dwa obiekty rysowania. Na koniec kod wywołuje <xref:System.Web.HttpResponse.Flush%2A> metodę, aby wysłać buforowaną odpowiedź do klienta wysyłającego żądanie.  
  
> [!NOTE]
>  W kodzie <xref:System.Web.HttpResponse> obiekt jest określany przez słowo kluczowe `Response`. Na przykład `Response.Clear()` odwołuje się do <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> metody. <xref:System.Web.UI.Page> Klasa ma właściwość o nazwie <xref:System.Web.UI.Page.Response%2A> który uwidacznia bieżące wystąpienie <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Element <see cref="T:System.IO.TextWriter" /> obiektu, który umożliwia niestandardowych wyniku HTTP.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.HttpResponse" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski obsługuje infrastrukturę programu .NET Framework i nie jest przeznaczony do użycia bezpośrednio w kodzie.  
  
 Metody i właściwości <xref:System.Web.HttpResponse> klasy są udostępniane za pośrednictwem wewnętrznego <xref:System.Web.HttpContext.Response%2A> obiektu w programie ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">Plik, klucz pamięci podręcznej lub <see cref="T:System.Web.Caching.CacheDependency" /> do dodania do listy zależności aplikacji.</param>
        <summary>Kojarzy zestaw zależności pamięci podręcznej z odpowiedzi w celu ułatwienia unieważniania odpowiedzi, jeśli jest ona przechowywana w wyjściowej pamięci podręcznej oraz określonej zależności zmienią się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddCacheDependency%2A> Metoda umożliwia zależności między buforowane odpowiedzi i <xref:System.Web.Caching.CacheDependency> obiektu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia zależności pamięci podręcznej przy użyciu <xref:System.Web.HttpResponse.AddCacheDependency%2A> metody i <xref:System.Web.Caching.CacheDependency> obiektu.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencies" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana za późno w potoku przetwarzania w pamięci podręcznej, po odpowiedzi z pamięci podręcznej został już utworzony.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawia, że ważności buforowaną odpowiedź zależy od innych elementów w pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">
          <see cref="T:System.Collections.ArrayList" /> Zawierającą klucze ze słownika elementów, które bieżąca buforowana odpowiedź zależy od.</param>
        <summary>Sprawia, że ważności buforowaną odpowiedź zależy od innych elementów w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli elementy wymienione w `cacheKeys` parametru są usuwane z pamięci podręcznej i buforowaną odpowiedź do bieżącego elementu jest nieprawidłowy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia strony ASP.NET, która jest buforowane dane wyjściowe. Tworzy kod strony <xref:System.Collections.ArrayList> obiektu klucze, które są skojarzone z elementami, które są przechowywane w <xref:System.Web.Caching.Cache> obiektu. Następnie kod przekazuje <xref:System.Collections.ArrayList> jako parametr w wywołaniu <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> metody. To sprawia, że odpowiedź dane wyjściowe pamięci podręcznej nie jest prawidłowa, jeśli dowolny z plików określonych w <xref:System.Collections.ArrayList> zmiany.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Tablica klucze elementów, które odpowiedzi z pamięci podręcznej jest zależny od.</param>
        <summary>Sprawia, że ważność elementu w pamięci podręcznej zależny od innego elementu w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy którykolwiek z `cacheKey`s są usuwane z pamięci podręcznej i buforowaną odpowiedź do bieżącego elementu jest nieprawidłowy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Klucz elementu, który zależy odpowiedzi z pamięci podręcznej.</param>
        <summary>Sprawia, że ważności buforowaną odpowiedź zależy od innego elementu w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element odpowiadający `cacheKey` parametr zostanie usunięty z pamięci podręcznej, buforowaną odpowiedź do bieżącego elementu jest nieprawidłowy.  
  
   
  
## Examples  
 Poniższy przykład jest kontrolkę użytkownika ASP.NET wyjściowe pamięci podręcznej. Kod dla kontrolki wywołuje <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> metoda kluczem elementu przechowywanego w <xref:System.Web.Caching.Cache> przekazano obiekt jako parametr. Jeśli element nie istnieje w pamięci podręcznej, zostaje unieważniony odpowiedź kontrolki, która została zapisana w pamięci podręcznej danych wyjściowych. Oznacza to, że na kolejne żądanie nową wersję formantu odpowiedzi zostaną dodane do wyjściowej pamięci podręcznej.  
  
 Następnie kod sprawdza, czy element skojarzony z `bookData` klucz jest przechowywany w `Cache` obiektu i wyświetli jeden z dwóch wierszy tekstu zależne od wyniku. Następnie kod ustawia <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> właściwość <xref:System.Web.UI.WebControls.DataGrid> formant, który nosi nazwę `dgBooks`, przy użyciu wywołania do niestandardowego `DataHelper` klasy udostępnione `GetBookData` metody i wypełnienie klasy <xref:System.Web.UI.WebControls.DataGrid> z <xref:System.Web.UI.Control.DataBind%2A> metody.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje grupę nazw plików do kolekcji nazw plików, na których jest zależna bieżąca odpowiedź.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Kolekcja plików do dodania.</param>
        <summary>Dodaje grupę nazw plików do kolekcji nazw plików, na których jest zależna bieżąca odpowiedź.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład jest strony ASP.NET, która jest buforowane dane wyjściowe. Tworzy kod strony <xref:System.Collections.ArrayList> ścieżki plików, a następnie przekazuje <xref:System.Collections.ArrayList> jako parametr w wywołaniu <xref:System.Web.HttpResponse.AddFileDependencies%2A> metody. To sprawia, że jeśli nieprawidłowe odpowiedzi z pamięci podręcznej danych wyjściowych plików określonych w <xref:System.Collections.ArrayList> zmiany.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">Tablica plików do dodania.</param>
        <summary>Tablica nazw plików są dodawane do kolekcji nazw plików, na których jest zależna bieżąca odpowiedź.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład dodaje tablicę nazw plików na <xref:System.Web.HttpResponse.AddFileDependencies%2A> Lista zależności pliku. Jeśli zmieni się pliki, zostaje unieważniony odpowiedzi z pamięci podręcznej.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do dodania.</param>
        <summary>Dodaje nazwę pojedynczego pliku do kolekcji nazw plików, na których jest zależna bieżąca odpowiedź.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kiedy używasz <xref:System.Web.HttpResponse.AddFileDependency%2A> metodę, aby dodać zależność pliku, należy także określić programowo, albo w sposób deklaratywny, buforowanie danych wyjściowych. Na przykład aby określić sposób deklaratywny buforowaniu danych wyjściowych, należy użyć dyrektywy. Aby uzyskać więcej informacji, zobacz [porady: dane wyjściowe strony w pamięci podręcznej o zależnościach plików](http://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak określić nazwę pojedynczego pliku <xref:System.Web.HttpResponse.AddFileDependency%2A> Lista zależności pliku. Jeśli zmieni się plik zostaje unieważniony odpowiedzi z pamięci podręcznej.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa nagłówka HTTP, aby dodać <c>wartość</c> do.</param>
        <param name="value">Ciąg do dodania do nagłówka.</param>
        <summary>Dodaje nagłówek HTTP do strumienia wyjściowego. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> zapewnia zgodność z wcześniejszymi wersjami programu ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> jest taka sama jak <xref:System.Web.HttpResponse.AppendHeader%2A> i jest dostępna tylko dla zgodności z wcześniejszymi wersjami programu ASP. Za pomocą platformy ASP.NET, należy użyć <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda wywołania zwrotnego.</param>
        <summary>[Obsługiwane w programie .NET Framework 4.5.2 i nowszych wersjach]  Rejestruje wywołanie zwrotne, które środowisko uruchomieniowe ASP.NET będzie wywoływać bezpośrednio przed odpowiedzi wysłany nagłówki dla tego żądania.</summary>
        <returns>
          <see cref="T:System.Web.ISubscriptionToken" /> Obiekt, który reprezentuje subskrypcję do pseudo-zdarzeń OnSendingHeaders.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Metoda AddOnSendingHeaders nie jest wywoływana, jeśli moduł macierzysty najpierw czyści odpowiedzi.  
  
 OnSendingHeaders pseudo-zdarzenia różni się od IHttpModule poziom zdarzenia potoku, w tym jest subskrypcji na żądanie, a nie subskrypcji poszczególnych aplikacji. Celem jest czy wywołania zwrotnego może modyfikować kodu stanu odpowiedzi lub może ustawić plik cookie odpowiedzi lub nagłówek. Inne uwagi dotyczące użycia i ostrzeżenia:  
  
-   Ta metoda jest efektywne tylko wtedy, gdy usługi IIS są uruchamiane w potoku trybu zintegrowanego potoku i tylko wtedy, gdy nagłówki odpowiedzi nie zostało jeszcze wysłane dla bieżącego żądania.  
  
-   Środowisko uruchomieniowe ASP.NET nie gwarantuje nic o wątku, który wywołanie zwrotne jest wywoływana. Na przykład wywołanie zwrotne mogą być wywoływane synchronicznie w wątku w tle, jeżeli odbywa się opróżnienie tła. <xref:System.Web.HttpContext.Current%2A> nie musi być dostępny w takich wątków.  
  
-   Wywołanie zwrotne nie mogą wywoływać dowolną metodę, która manipuluje treści jednostki odpowiedzi lub który skutkuje opróżnienie. Na przykład, wywołanie zwrotne nie mogą wywoływać <xref:System.Web.HttpResponse.Redirect%2A>, zgodnie z tej metody może manipulować treści jednostki odpowiedzi.  
  
-   Wywołanie zwrotne musi zawierać tylko krótko działających synchroniczny kod. Podjęto próbę wywołania operacji asynchronicznej lub zaczekaj na takich operacji może spowodować zakleszczenia.  
  
-   Wywołanie zwrotne nie może zgłaszać wyjątek; w przeciwnym razie zachowanie jest niezdefiniowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">
          <see cref="T:System.Web.HttpCookie" /> Do dodania do strumienia wyjściowego.</param>
        <summary>Dodaje plik cookie protokołu HTTP do kolekcji wewnętrzne pliku cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy nowy plik cookie o nazwie `LastVisit`, ustawia wartość pliku cookie do bieżącej daty i godziny i dołącza plik cookie do bieżącej kolekcji plików cookie. Wszystkie pliki cookie w kolekcji cookie są wysyłane do klienta w `Set-Cookie` strumienia wyjściowego nagłówek HTTP.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Plik cookie jest dołączany po wysłaniu nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa nagłówka HTTP, aby dodać do strumienia wyjściowego.</param>
        <param name="value">Ciąg do dołączenia do nagłówka.</param>
        <summary>Dodaje nagłówek HTTP do strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz <xref:System.Web.HttpResponse.AppendHeader%2A> metody do wysyłania nagłówków specyficznych dla pamięci podręcznej i jednocześnie użyć modelu obiektów pamięci podręcznej (<xref:System.Web.HttpResponse.Cache%2A>) można ustawić zasady pamięci podręcznej, nagłówki odpowiedzi HTTP, które odnoszą się do pamięci podręcznej (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, i `Vary`) mogą zostać usunięte, gdy jest używany model obiektów w pamięci podręcznej. To zachowanie umożliwia ASP.NET do obsługi najbardziej restrykcyjne ustawienia. Rozważmy na przykład strona, która zawiera formanty użytkownika. Jeśli te kontrolki mają zasady powodujące konflikty pamięci podręcznej, najbardziej restrykcyjne zasady pamięci podręcznej będą używane. Jeśli jeden formant użytkownika ustawia nagłówek "`Cache-Control: Public`"i inny formant użytkownika ustawia nagłówek bardziej restrykcyjne"`Cache-Control: Private`" za pośrednictwem wywołania <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, a następnie "`Cache-Control: Private`" Nagłówek będą wysyłane z odpowiedzią.  
  
 Aby uzyskać listę standardowych nagłówków HTTP/1.1, zobacz sekcję 14, "Definicje pól nagłówka" w [Hypertext Transfer Protocol — HTTP/1.1](http://go.microsoft.com/fwlink/?LinkID=73147) specyfikację w witrynie sieci Web konsorcjum World Wide Web Consortium (W3C).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Web.HttpResponse.AppendHeader%2A> metodę, aby dodać niestandardowy nagłówek do <xref:System.Web.HttpResponse> obiektu wysłane do klienta wysyłającego żądanie.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nagłówek jest dołączany po wysłaniu nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Tekst, który można dodać do pliku dziennika.</param>
        <summary>Dodaje informacje dziennika niestandardowego do pliku dziennika usług Internet Information Services (IIS).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby umożliwić określonego ciągu, które mają być rejestrowane w pliku dziennika, należy najpierw włączyć **zapytanie URI** opcji **rozszerzone właściwości rejestrowania w programie** okno dialogowe lokacji, które mają być rejestrowane działania w usługach IIS .  
  
 Aby dostosować rozszerzonej rejestrowania w usługach IIS 6.0, wykonaj następujące kroki:  
  
1.  W Menedżerze usług IIS, rozwiń węzeł komputera lokalnego, rozwiń folder w sieci Web lub witryny FTP, kliknij prawym przyciskiem myszy witrynę sieci Web lub FTP, a następnie kliknij przycisk **właściwości**.  
  
2.  Kliknij przycisk **sieci Web lub witryny FTP** , a następnie wybierz pozycję **włączyć rejestrowanie** pole wyboru (Jeśli nie została jeszcze wybrana).  
  
3.  W **format aktywnego dziennika** kliknij **rozszerzony Format W3C pliku dziennika**.  
  
4.  Kliknij przycisk **właściwości**.  
  
5.  Kliknij przycisk **zaawansowane** , a następnie wybierz właściwości, które chcesz rejestrować, a następnie kliknij przycisk **OK**.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dołączyć ciąg w dzienniku.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna do zasobu.</param>
        <summary>Dodaje identyfikator sesji na ścieżkę wirtualną, jeśli korzysta z sesji <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> stan sesji i zwraca połączone ścieżki. Jeśli <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> stan sesji nie jest używany, <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> zwraca oryginalnej ścieżki wirtualnej.</summary>
        <returns>
          <paramref name="virtualPath" /> z sesją dodaje identyfikator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> jest używany tylko z sesjami cookieless do konstruowania bezwzględne odwołania HREF.  
  
   
  
## Examples  
 Poniższy przykład deklaruje zmienną ciągu o nazwie `urlConverted`i ustawia ją na wynik <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> wywołania metody. Kod następnie przekazuje wartość zmiennej do <xref:System.Web.UI.WebControls.HyperLink> kontrolki <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> właściwości.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Obiekt wywołania zwrotnego.</param>
        <param name="state">Stan odpowiedzi.</param>
        <summary>Wysyła obecnie buforowaną odpowiedź do klienta.</summary>
        <returns>Asynchroniczny obiekt wyniku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli podstawowe <xref:System.Web.HttpWorkerRequest> obiekt obsługuje asynchroniczne operacje opróżniania i ta metoda jest wywoływana z Zdarzenie asynchroniczne modułu lub nieprawidłowego asynchronicznego, operacja opróżniania jest wykonywana asynchronicznie. W przeciwnym razie operacja opróżniania są wykonywane synchronicznie. Asynchronicznego opróżniania jest obsługiwana dla usług IIS 6.0 i nowszych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Odpowiedź została już zakończona.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Bajty do zapisu do strumienia wyjściowego.</param>
        <summary>Zapisuje ciąg binarny znaków do strumienia wyjściowego HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład odczytuje plik tekstowy do buforu i zapisuje buforu strumienia wyjściowego HTTP.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do buforowania danych wyjściowych i wysyłanie do niej po pełną odpowiedź zakończeniu przetwarzania.</summary>
        <value>
          <see langword="true" /> Jeśli dane wyjściowe do klienta jest buforowana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Buffer%2A> Właściwość jest przestarzała zastąpiona ceną <xref:System.Web.HttpResponse.BufferOutput%2A> właściwość i jest dostępna tylko dla zgodności z wcześniejszymi wersjami programu ASP. Za pomocą platformy ASP.NET, należy użyć <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do buforowania danych wyjściowych i wysyłanie do niej po stronie zakończenia zakończeniu przetwarzania.</summary>
        <value>
          <see langword="true" /> Jeśli dane wyjściowe do klienta jest buforowana; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ustawia <xref:System.Web.HttpResponse.ContentType%2A> odpowiedź na image/jpeg, wywołuje <xref:System.Web.HttpResponse.Clear%2A> metodę, aby usunąć pozostałe zawartość, która może zostać dołączony do odpowiedzi, a następnie ustawia <xref:System.Web.HttpResponse.BufferOutput%2A> właściwości na wartość true, dzięki czemu będzie całej strony przetworzone przed wysłaniem żadnej zawartości do klienta wysyłającego żądanie.  
  
 Aby uzyskać kompletny przykład, zobacz <xref:System.Web.HttpResponse> klasy.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zasady buforowania (takie jak wygaśnięcia czasu ustawienia prywatności i różnią się w klauzulach) strony sieci Web.</summary>
        <value>
          <see cref="T:System.Web.HttpCachePolicy" /> Obiekt, który zawiera informacje na temat zasad buforowania bieżącej odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład zapisuje bieżące zasady pamięci podręcznej do strumienia wyjściowego HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see langword="Cache-Control" /> nagłówka HTTP, który pasuje do jednej z <see cref="T:System.Web.HttpCacheability" /> wartości wyliczenia.</summary>
        <value>Reprezentacja ciągu <see cref="T:System.Web.HttpCacheability" /> wartość wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości `Private`, `Public`, i `No-Cache` są ciągami i muszą być ujęte w znaki cudzysłowu (""). Jeśli <xref:System.Web.HttpResponse.CacheControl%2A> właściwość jest ustawiona na wartość, która nie pasuje do jednej z <xref:System.Web.HttpCacheability> wartości wyliczenia, a następnie <xref:System.ArgumentException> zgłaszany. Jeśli <xref:System.Web.HttpResponse.CacheControl%2A> właściwość nie jest ustawiona, buforowania odpowiedzi jest ustawiona na <xref:System.Web.HttpCacheability.NoCache>.  
  
 `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, I <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> właściwości zostały wycofane. Zamiast tego metody <xref:System.Web.HttpCachePolicy> klasy są dostępne za pośrednictwem <xref:System.Web.HttpResponse.Cache%2A> wewnętrzne obiektu do kontrolowania Internet Information Services (IIS), dane wyjściowe pamięci podręcznej i pamięci podręczne klientów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Zestaw wartości ciągu nie pasuje do jednej z <see cref="T:System.Web.HttpCacheability" /> wartości wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zestaw znaków HTTP w strumieniu wyjściowym.</summary>
        <value>Zestaw znaków HTTP w strumieniu wyjściowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Charset` Właściwość może być ustawiona na `null` do pomijania HTTP `Content-Type` nagłówka.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy zestaw znaków ze strumienia wyjściowego jest centralnym Środkowoeuropejski (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see langword="Charset" /> Właściwość została ustawiona po nagłówki zostały wysłane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści całą zawartość danych wyjściowych z buforu strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Clear%2A> Metoda usuwaj informacje nagłówka.  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Web.HttpResponse.ContentType%2A> odpowiedź na image/jpeg, wywołuje <xref:System.Web.HttpResponse.Clear%2A> metodę, aby usunąć pozostałe zawartość, która może zostać dołączony do odpowiedzi, a następnie ustawia <xref:System.Web.HttpResponse.BufferOutput%2A> true tak, aby pełna strona właściwości przetworzone przed wysłaniem żadnej zawartości do klienta wysyłającego żądanie.  
  
 Aby uzyskać kompletny przykład, zobacz <xref:System.Web.HttpResponse> klasy.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści całą zawartość danych wyjściowych z buforu strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ClearContent%2A> Metoda usuwaj informacje nagłówka.  
  
   
  
## Examples  
 Poniższy przykład Czyści całą zawartość strumienia buforu.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie nagłówki z buforu strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Web.HttpResponse.ClearHeaders%2A> metodę, aby upewnić się, że żadne nagłówki są wysyłane z bieżącej odpowiedzi. Ta technika może być szczególnie ważne, jeśli odpowiedź ASP.NET generuje obrazu, na przykład plik JPEG. W tym przykładzie <xref:System.Web.HttpResponse.ContentType%2A> właściwość jest ustawiona na image/jpeg.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nagłówki są czyszczone po wysłaniu nagłówków HTTP.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.CancellationToken" /> obiekt, który jest uruchomiony, gdy klient odłączy się.</summary>
        <value>Token anulowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten interfejs API jest metodą o bezpiecznych wątkach. Istnieją jednak pewne ograniczenia dotyczące używania token anulowania. Nieprawidłowe wykorzystanie może doprowadzić do Sytuacje wyścigu, zakleszczenia lub inne nieoczekiwane zachowania. Należy przestrzegać następujących wytycznych:  
  
-   Upewnij się, nie wywoływać ten interfejs API poza granicami pojedynczego żądania, ponieważ zlikwiduje token anulowania na końcu żądania programu ASP.NET. Nie ma żadnej gwarancji, że token nigdy nie zostanie zastąpiona usługą stanem anulowane, zanim zostanie on usunięty. Na przykład jeśli żądanie zakończy się bez użycia klienta o odłączony, token zostanie usunięte bez konieczności najpierw zostało anulowane.  
  
-   Nie Czekaj <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, jak to pozbawia asynchroniczne powiadomienia i może spowodować, że zakleszczenia.  
  
-   Nie wywołuj <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> przeciążenia, które wywołują wywołania zwrotnego w oryginalnym <xref:System.Threading.SynchronizationContext> obiektu.  
  
-   Nie używaj <xref:System.Web.HttpContext> obiektu lub inne niż wątkowo ASP.NET wewnętrzne obiekty z w ramach wywołania zwrotnego do <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> metody. Wywołanie zwrotne może działać równocześnie z innymi ASP.NET lub kod aplikacji.  
  
-   Przedstawione metody wywołania zwrotnego krótko działających i bez blokowania.  
  
-   Starań, aby uniknąć generowania wyjątków z w obrębie metody wywołania zwrotnego.  
  
 Ta właściwość jest obsługiwana tylko w Internet Information Service (IIS) 7.5 lub nowszy w trybie zintegrowanym. Jeśli wywołujesz bez właściwego usług IIS w wersji lub potoku trybu, <xref:System.PlatformNotSupportedException> zgłaszany. Aby określić wersję usług IIS, należy użyć <xref:System.Web.HttpRuntime.IISVersion%2A>. Aby określić tryb potokowy, użyj <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka połączenie gniazda do klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kończy połączenie klienta w sposób nagły i nie jest przeznaczony do normalnego przetwarzania żądania HTTP. Metoda wysyła pakiet resetowania do klienta, co może powodować dane odpowiedzi, które są buforowane na serwerze, kliencie lub gdzieś między można go porzucić.  
  
 Jednak zazwyczaj należy wywołać <xref:System.Web.HttpApplication.CompleteRequest%2A> zamiast tego, aby przejść od razu do <xref:System.Web.HttpApplication.EndRequest> zdarzeń i wysłać odpowiedź do klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zestaw znaków HTTP w strumieniu wyjściowym.</summary>
        <value>Element <see cref="T:System.Text.Encoding" /> obiektu, który zawiera informacje o zestawie znaków w bieżącej odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne `ContentEncoding` można określić w pliku konfiguracji platformy ASP.NET w [globalizacji — Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) sekcji. Jeśli <xref:System.Web.HttpResponse.ContentEncoding%2A> jest określony przez klienta, są zastępowane domyślnych ustawień konfiguracji.  
  
   
  
## Examples  
 Poniższy przykład zapisuje zrozumiałą dla użytkownika opis kodowanie do strumienia wyjściowego zestawu znaków.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Podjęto próbę ustawienia <see cref="P:System.Web.HttpResponse.ContentEncoding" /> do <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ HTTP MIME w strumieniu wyjściowym.</summary>
        <value>Typ HTTP MIME w strumieniu wyjściowym. Wartość domyślna to "<see langword="text/html" />".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ustawia <xref:System.Web.HttpResponse.ContentType%2A> odpowiedź na image/jpeg, wywołuje <xref:System.Web.HttpResponse.Clear%2A> metodę, aby usunąć pozostałe zawartość, która może zostać dołączony do odpowiedzi, a następnie ustawia <xref:System.Web.HttpResponse.BufferOutput%2A> true tak, aby pełna strona właściwości przetworzone przed wysłaniem żadnej zawartości do klienta wysyłającego żądanie.  
  
 Aby uzyskać kompletny przykład, zobacz <xref:System.Web.HttpResponse> klasy.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.ContentType" /> Właściwość jest ustawiona na <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję plików cookie odpowiedzi.</summary>
        <value>Kolekcja plików cookie odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program ASP.NET zawiera dwie kolekcje wewnętrzne pliku cookie. Kolekcji udostępniane za pośrednictwem <xref:System.Web.HttpRequest.Cookies%2A> zbiór <xref:System.Web.HttpRequest> zawiera pliki cookie przesyłanych przez klienta do serwera w `Cookie` nagłówka. Kolekcji udostępniane za pośrednictwem <xref:System.Web.HttpResponse.Cookies%2A> zbiór <xref:System.Web.HttpResponse> zawiera nowe pliki cookie, utworzony na serwerze i przekazywane do klienta w `Set-Cookie` nagłówka.  
  
 Po dodaniu pliku cookie przy użyciu <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> kolekcji, plik cookie jest natychmiast dostępna w <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> kolekcji, nawet jeśli nie została wysłana odpowiedź do klienta.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy plik cookie o nazwie `LastVisit`, ustawia wartość pliku cookie do bieżącej daty i godziny i dodaje plik cookie do bieżącej kolekcji plików cookie. Wszystkie pliki cookie w kolekcji cookie są wysyłane do klienta w `Set-Cookie` strumienia wyjściowego nagłówek HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyłącza buforowanie jądra dla bieżącej odpowiedzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pamięć podręczna jądra nie jest obsługiwana, ta metoda nie ma znaczenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyłącza IIS buforowanie w trybie użytkownika dla tej odpowiedzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli buforowanie w trybie użytkownika usług IIS nie jest obsługiwany, Metoda ta zwraca bez wykonywania żadnych czynności.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wysyła wszystkie aktualnie buforowanych wyników do klienta, zatrzymuje wykonywanie strony i zgłasza <see cref="E:System.Web.HttpApplication.EndRequest" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna tylko dla zgodności za pomocą technologii ASP — czyli potrzeby utrzymywania zgodności z technologią programowanie sieci Web opartych na modelu COM, która poprzedzała ASP.NET. Jeśli chcesz przejść od razu do <xref:System.Web.HttpApplication.EndRequest> zdarzeń i wysyłania odpowiedzi do klienta, to zazwyczaj lepiej jest wywołać <xref:System.Web.HttpApplication.CompleteRequest%2A> zamiast tego.  
  
 Aby naśladują zachowanie `End` metody stron ASP, ta metoda próbuje podnieść <xref:System.Threading.ThreadAbortException> wyjątku. Jeśli ta próba zakończy się pomyślnie, wątek wywołujący zostanie przerwana, co jest szkodliwa dla wydajności witryny. W tym przypadku, żaden kod po wywołaniu <xref:System.Web.HttpResponse.End%2A> metoda jest wykonywana.  
  
 Jeśli <xref:System.Web.HttpResponse.End%2A> metoda nie będzie mógł zgłosić <xref:System.Threading.ThreadAbortException>, zamiast tego opróżnia bajtów odpowiedzi do klienta. Robi to synchronicznie, który może być również szkodliwa dla wydajności witryny.  
  
 W obu przypadkach (czy <xref:System.Threading.ThreadAbortException> pomyślnie zgłaszany jest wyjątek), potok odpowiedzi wyprzedzeniem skacze do <xref:System.Web.HttpApplication.EndRequest> zdarzeń.  
  
 <xref:System.Web.HttpApplication.CompleteRequest%2A> Metody nie zgłaszała wyjątku i kodu po wywołaniu <xref:System.Web.HttpApplication.CompleteRequest%2A> metoda może zostać wykonana. Jeśli chcesz uniknąć wykonywania kolejnych kodu, a spadek wydajności <xref:System.Web.HttpResponse.End%2A> jest dopuszczalna, można wywołać <xref:System.Web.HttpResponse.End%2A> zamiast <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">Wywołanie <see cref="M:System.Web.HttpResponse.End" /> zakończył działanie bieżącego żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Asynchroniczny obiekt wyniku.</param>
        <summary>Kończy operację asynchroniczną opróżniania.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Asynchronicznego opróżniania nie jest obsługiwana i <paramref name="asyncResult" /> parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Asynchronicznego opróżniania nie jest obsługiwana i <paramref name="asyncResult" /> nie można rzutować parametr <c>FlushAsyncResult</c> obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę minut przed wygaśnięciem strony buforowanej w przeglądarce. Po powrocie do tej samej stronie przed jego wygaśnięciem, wyświetlana jest wersja pamięci podręcznej. <see cref="P:System.Web.HttpResponse.Expires" /> zapewnia zgodność z wcześniejszymi wersjami programu ASP.</summary>
        <value>Liczba minut, zanim wygaśnie strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> i <xref:System.Web.HttpResponse.CacheControl%2A> właściwości zostały zaniechane i zastąpione metody <xref:System.Web.HttpCachePolicy> dostępne za pośrednictwem klasy <xref:System.Web.HttpResponse.Cache%2A> wewnętrzne obiektu do kontrolowania Internet Information Services (IIS) wyjściową pamięć podręczną i zapisuje w pamięci podręcznej klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bezwzględny Data i godzina, od którego należy usunąć buforowane informacje z pamięci podręcznej. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> zapewnia zgodność z wcześniejszymi wersjami programu ASP.</summary>
        <value>Data i godzina, jaką strona wygasa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, I <xref:System.Web.HttpResponse.CacheControl%2A> właściwości zostały zaniechane i zastąpione metody <xref:System.Web.HttpCachePolicy> dostępne za pośrednictwem klasy <xref:System.Web.HttpResponse.Cache%2A> wewnętrzne obiektu do kontrolowania Internet Information Services (IIS) wyjściową pamięć podręczną i zapisuje w pamięci podręcznej klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt filtr opakowywanie służy do modyfikowania treści jednostki HTTP, przed rozpoczęciem transmisji.</summary>
        <value>
          <see cref="T:System.IO.Stream" /> Obiektu, który działa jako filtr danych wyjściowych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu `Stream` obiektu i ustaw <xref:System.Web.HttpResponse.Filter%2A> właściwości `Stream` obiektu, HTTP wszystkie dane wyjściowe wysyłane przez <xref:System.Web.HttpResponse.Write%2A> przechodzą przez filtr.  
  
   
  
## Examples  
 Poniższy przykład jest strony ASP.NET, która ustawia <xref:System.Web.HttpResponse.Filter%2A> właściwość nowe wystąpienie klasy `UpperCaseFilter` klasy niestandardowej <xref:System.IO.Stream> klasę, która konwertuje cały tekst, który przechodzi na wielkie litery. Informacje o żądaniu są zapisywane do pliku tekstowego, a następnie <xref:System.Web.HttpResponse.Filter%2A> właściwość jest ustawiona. Po przygotowaniu filtr odpowiedzi, kod wywołuje <xref:System.Web.HttpRequest.MapPath%2A> metodę, aby uzyskać ścieżkę bezwzględną do pliku tekstowego o nazwie `TestFile.txt` służy jako źródło dla zawartości odpowiedzi. Następnie kod tworzy nową <xref:System.IO.StreamReader> obiektu do odczytania pliku tekstowego, od początku do końca, a następnie wywołania <xref:System.Web.HttpResponse.Write%2A> metodę, aby wyświetlić zawartość pliku, na stronie.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Filtrowanie nie jest dozwolone z jednostką.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wysyła wszystkie aktualnie buforowanych wyników do klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wymusza aktualnie wszystkie buforowane dane wyjściowe do wysłania do klienta. <xref:System.Web.HttpResponse.Flush%2A> Metodę można wywoływać wielokrotnie podczas przetwarzania żądania.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Drawing.Graphics.Save%2A> metodę, aby zapisać <xref:System.Drawing.Bitmap> obiekt <xref:System.Web.HttpResponse.OutputStream%2A> właściwości i konwertuje formatu obrazu JPEG. Następnie wywołuje kod `Dispose` metody <xref:System.Drawing.Bitmap> obiektu i <xref:System.Drawing.Graphics> obiektu, przy zwalnianiu zasobów, które za pomocą. Następnie wywołuje <xref:System.Web.HttpResponse.Flush%2A> metody do wysyłania zawartości odpowiedzi do klienta wysyłającego żądanie.  
  
 Aby uzyskać kompletny przykład, zobacz <xref:System.Web.HttpResponse> klasy.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Pamięć podręczna jest opróżniany po wysłaniu odpowiedzi.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie wysyła wszystkie aktualnie buforowanych wyników do klienta.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task" /> reprezentujący operację asynchroniczną.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.Encoding" /> obiekt, który reprezentuje kodowania dla bieżącego nagłówka strumienia wyjściowego.</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> Zawierający informacje dotyczące zestawu dla bieżącego nagłówka znaków.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.HeaderEncoding%2A> Właściwość daje możliwość wyłączenia lub zmienić <xref:System.Text.Encoding> obiektu w nagłówku odpowiedzi za pomocą <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, lub <xref:System.Text.UTF8Encoding> obiektu. Domyślne kodowanie wartość jest <xref:System.Text.UTF8Encoding> klasy.  
  
 Zmieniając typ <xref:System.Web.HttpResponse.HeaderEncoding%2A> właściwości, możesz potencjalnie zwiększają ryzyko niektórych złośliwych ataków lub przyczyny poufnych danych za pomocą nagłówka odpowiedzi. Nagłówek ataki przez iniekcję kodu można uniknąć, w części, pozostawiając <xref:System.Web.HttpResponse.HeaderEncoding%2A> właściwości odpowiedzi ustawieniem domyślnym. Złamanie usterce aplikacji można echo ponownie powierzyć dane jako części nagłówka odpowiedzi. Jeśli <xref:System.Web.HttpResponse.HeaderEncoding%2A> jest wyłączona ze względu na wymagania dla kontynuacji linii w nagłówku lub jeśli dowolny nagłówek jest zbudowany na podstawie wyniku niezaufanych danych, dane nagłówka powinien być weryfikowany pod przed wysłaniem do strumienia odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość kodowania jest <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Wartość kodowania jest <see cref="P:System.Text.Encoding.Unicode" />.  \- lub - nagłówki zostały już wysłane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję nagłówków odpowiedzi.</summary>
        <value>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> nagłówków odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Headers%2A> Właściwość jest obsługiwana tylko z [!INCLUDE[iisver](~/includes/iisver-md.md)] trybu zintegrowanego potoku i co najmniej programu .NET Framework 3.0. Podczas próby uzyskania dostępu do <xref:System.Web.HttpResponse.Headers%2A> właściwość i jeden z tych dwóch warunków nie jest spełniony, <xref:System.PlatformNotSupportedException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Operacja wymaga trybu zintegrowanego potoku w [! INCLUDE[iisver](~/includes/iisver-MD.MD)] i co najmniej programu .NET Framework w wersji 3.0 lub nowszej.</exception>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Obsługiwane w programie .NET Framework 4.5.2 i nowszych wersjach]  Pobiera wartość wskazującą, czy nagłówki odpowiedzi została zapisana.</summary>
        <value>
          <see langword="true" /> Jeśli nagłówki odpowiedzi w zapisanych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy klient jest nadal połączony z serwerem.</summary>
        <value>
          <see langword="true" /> Jeśli klient jest obecnie połączony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.IsClientConnected%2A> Właściwość zwraca `false` gdy są spełnione następujące warunki:  
  
-   Połączenie z klientem zostało zakończone. Taka sytuacja może wystąpić, jeśli <xref:System.Web.HttpResponse.Close%2A> wywołano metodę, lub jeśli kliencie zatrzymana wykonywanie strony sieci Web lub przeglądania do innej strony.  
  
-   <xref:System.Web.HttpWorkerRequest> Obiekt, który obsługuje żądania jest `null` lub <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> metoda zwraca `false`. Jeśli niestandardowa <xref:System.Web.HttpWorkerRequest> obiekt obsługi żądania, a następnie <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> metoda może być ustawiona na podstawie kryteriów niestandardowych. Na przykład żądanie niestandardowego procesu roboczego może spowodować limit czasu po upływie określonego czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Web.HttpResponse.IsClientConnected%2A> właściwość do sprawdzenia, czy klient, który żąda strony pozostaje nawiązanie połączenia z serwerem. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> ma wartość true, kod wywołuje <xref:System.Web.HttpResponse.Redirect%2A> metody i klienta zostaną wyświetlone innej strony. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> ma wartość FAŁSZ, a następnie kod wywołuje <xref:System.Web.HttpResponse.End%2A> metody i całego procesu przetwarzania strony zostanie zakończony.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość logiczną wskazującą, czy klient jest przesyłany do nowej lokalizacji.</summary>
        <value>
          <see langword="true" /> Jeśli wartość określonego nagłówka żądania lokalizacji jest inny niż bieżąca lokalizacja; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> właściwość o <xref:System.Web.HttpResponse.RedirectLocation%2A> właściwość do testów i określić, czy bezwzględny identyfikator URI przesyłane do klienta w HTTP `Location` nagłówka różni się od bieżącego identyfikatora URI i nowe zamierzony identyfikator URI, który jest zostaną przeniesione do.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Umożliwia danych wyjściowych tekst wychodzących strumienia odpowiedzi HTTP.</summary>
        <value>Element <see cref="T:System.IO.TextWriter" /> obiektu, który umożliwia niestandardowe dane wyjściowe do klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład jest strony ASP.NET, która zawiera <xref:System.Web.UI.WebControls.TextBox> formantu, który ma jej <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> właściwością <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Kodu strony przyjmuje tekst, który użytkownik wprowadza w <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, używa <xref:System.Web.HttpServerUtility.HtmlEncode%2A> metody w formacie HTML, kodowanie i <xref:System.Web.HttpResponse.Output%2A> właściwości mają być wyświetlane na stronie ciąg zakodowany.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Umożliwia wyjście binarne do wychodzących treści zawartości HTTP.</summary>
        <value>We/Wy <see cref="T:System.IO.Stream" /> reprezentujący nieprzetworzonej zawartości wychodzących treści zawartości HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od programu .NET Framework w wersji 2.0, korzystając z <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metoda strumień we/wy, zwrócony przez <xref:System.Web.HttpResponse.OutputStream%2A> właściwości, może zostać zgłoszone następujące wyjątki:  
  
-   <xref:System.ArgumentOutOfRangeException>, jeśli `offset` lub `count` parametr ma ujemną wartość lub jeśli `buffer` długość parametru minus `offset` parametr jest mniejsza niż zero.  
  
-   <xref:System.ArgumentNullException>, jeśli `buffer` parametr `null`.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Drawing.Image.Save%2A> metodę, aby zapisać <xref:System.Drawing.Bitmap> obiekt <xref:System.Web.HttpResponse.OutputStream%2A> właściwości i konwertuje obraz na JPEG format. Następnie kod wywołuje metodę Dispose dla <xref:System.Drawing.Bitmap> obiektu i <xref:System.Drawing.Graphics> obiektu, przy zwalnianiu zasobów, które były one używane. Na koniec kod wywołuje <xref:System.Web.HttpResponse.Flush%2A> metody do wysyłania zawartości odpowiedzi do klienta wysyłającego żądanie.  
  
 Aby uzyskać kompletny przykład, zobacz <xref:System.Web.HttpResponse> klasy.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> nie jest dostępna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do dodania do <see langword="PICS-Label" /> nagłówka.</param>
        <summary>Dołącza HTTP <see langword="PICS-Label" /> nagłówka do strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Platformy dla Internetu zawartości wyboru (PICS) jest standardem World Wide Web Consortium (W3C) do tworzenia zawartości etykiet. PICS jest zasadniczo języka do tworzenia system ocen.  
  
 Każda wartość może być etykietę PICS; Program ASP.NET nie sprawdza poprawności etykiety. Maksymalna długość ciągu to 255 znaków. Aby uzyskać więcej informacji na temat PICS standardów i składni, zobacz [World Wide Web Consortium](http://go.microsoft.com/fwlink/?LinkID=37125) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład jest strony ASP.NET, który wyświetla obraz. Kod wywołuje strony <xref:System.Web.HttpResponse.Pics%2A> metodę, aby ustawić HTTP `PICS-Label` nagłówka odpowiedzi. Ciąg, który jest przekazywany jako parametr do <xref:System.Web.HttpResponse.Pics%2A> metoda reprezentuje etykietę klasyfikacji, wygenerowany z witryny sieci Web internetowe zawartości Rating Association (ICRA).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Promuje uzgodnionego obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Adres URL żądania wypychania. Powinno być ścieżka wirtualna względną zasobu, który serwer chce wypchnąć do klienta.</param>
        <summary>Ten interfejs API jest do obsługi aplikacji wysyłanie powiadomień wypychanych zobowiązuje się do klientów protokołu HTTP 2.0. Więcej szczegółów można znaleźć w odniesieniu do protokołu Http2 wypychania przez serwer w [8.2 sekcji specyfikacji protokołu HTTP/2: wypychanie serwera] (https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise jest niejednoznaczne i aplikacje nie powinny mieć logikę, która zależy od niego. Jego jedynym celem jest zaletą wydajności w niektórych przypadkach. Istnieje wiele warunków (protokół i wykonania), które mogą powodować całkowicie ignorowanie żądań wypychania. Oczekiwania zależy od uruchomienia i zapominać.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">Adres URL żądania wypychania. Powinno być ścieżka wirtualna względną zasobu, który serwer chce wypchnąć do klienta.</param>
        <param name="method">Metoda żądania HTTP, używany przez żądanie wypychania.</param>
        <param name="headers">Nagłówek żądania HTTP, używany przez żądanie wypychania.</param>
        <summary>Ten interfejs API jest do obsługi aplikacji wysyłanie powiadomień wypychanych zobowiązuje się do klientów protokołu HTTP 2.0. Więcej szczegółów można znaleźć w odniesieniu do protokołu Http2 wypychania przez serwer w [8.2 sekcji specyfikacji protokołu HTTP/2: wypychanie serwera] (https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise jest niejednoznaczne i aplikacje nie powinny mieć logikę, która zależy od niego. Jego jedynym celem jest zaletą wydajności w niektórych przypadkach. Istnieje wiele warunków (protokół i wykonania), które mogą powodować całkowicie ignorowanie żądań wypychania. Oczekiwania zależy od uruchomienia i zapominać.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekierowuje klienta do nowego adresu URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacji docelowej. Może to być ścieżka wirtualna powiązane z wątkiem aplikacji.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL i umożliwia określenie nowego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Web.HttpResponse.Redirect%2A> jest równoważne z wywoływaniem <xref:System.Web.HttpResponse.Redirect%2A> z drugim parametrem równa `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> wywołania <xref:System.Web.HttpResponse.End%2A> która zgłasza <xref:System.Threading.ThreadAbortException> wyjątek po jego ukończeniu. Ten wyjątek ma niekorzystny wpływ na wydajność aplikacji sieci Web. Dlatego zaleca się że zamiast tego przeciążenia można używać <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenia i przekazywać `false` dla `endResponse` parametr, a następnie wywołania <xref:System.Web.HttpApplication.CompleteRequest%2A> metody. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpResponse.End%2A> metody.  
  
> [!NOTE]
>  Dla stron tylko dla urządzeń przenośnych Jeśli aplikacja zależy od cookieless sesji lub może odbierać żądania z urządzeń przenośnych, które wymagają cookieless sesji przy użyciu tyldy (~) w ścieżce może spowodować utworzenie nowej sesji i utracić dane sesji. Do ustawiania właściwości na formant mobilny ze ścieżką, takie jak "~ / ścieżkę", są rozpoznawane przy użyciu ścieżki <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / ścieżkę" przed przypisaniem go do właściwości.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302. Jest to alternatywny sposób kontrola jest przekazywana do innej strony <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda jest zazwyczaj bardziej efektywne, ponieważ nie spowoduje komunikację dwustronną do klienta. Aby uzyskać więcej informacji, zobacz [jak: przekierować użytkowników do innej strony](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 Poniższy przykład powoduje bezwarunkowe przekierowania do innej witryny sieci Web.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Przekierowanie, zostanie podjęta po wysłaniu nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacji docelowej.</param>
        <param name="endResponse">Wskazuje, czy należy zakończyć wykonywanie bieżącej strony.</param>
        <summary>Przekierowuje klienta do nowego adresu URL. Określa nowy adres URL i tego, czy należy zakończyć wykonywanie bieżącej strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezwzględny adres URL (na przykład http://www.contoso.com/default.aspx) lub względny adres URL (na przykład Default.aspx) może zostać określony dla lokalizacji docelowej, ale niektóre przeglądarki mogą odrzucić względnym adresem URL.  
  
 Kiedy używasz tej metody w obsłudze strony można zakończyć żądania dla jednej stronie i Rozpocznij nowe żądanie dla strony innego zestawu `endResponse` do `false` , a następnie wywołać <xref:System.Web.HttpApplication.CompleteRequest%2A> metody. Jeśli określisz `true` dla `endResponse` parametru, ta metoda wywołuje <xref:System.Web.HttpResponse.End%2A> metoda oryginalnego żądania, który generuje <xref:System.Threading.ThreadAbortException> wyjątek po jego ukończeniu. Ten wyjątek ma niekorzystny wpływ na wydajność aplikacji sieci Web, dlatego przekazywanie `false` dla `endResponse` parametru jest zalecane. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpResponse.End%2A> metody.  
  
> [!NOTE]
>  Dla stron dla urządzeń przenośnych Jeśli aplikacja zależy od cookieless sesji lub może odbierać żądania z urządzeń przenośnych, które wymagają cookieless sesji przy użyciu tyldy (~) w ścieżce można utworzyć nowej sesji i może spowodować utratę danych sesji. Do ustawiania właściwości na formant mobilny ze ścieżką, takie jak "~ / ścieżkę", są rozpoznawane przy użyciu ścieżki <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / ścieżkę" przed przypisaniem go do właściwości.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302. Jest to alternatywny sposób kontrola jest przekazywana do innej strony <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda jest zazwyczaj bardziej efektywne, ponieważ nie spowoduje komunikację dwustronną do klienta. Aby uzyskać więcej informacji, zobacz [jak: przekierować użytkowników do innej strony](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Web.HttpResponse.IsClientConnected%2A> właściwość do sprawdzenia, czy klient, który żąda strony pozostaje nawiązanie połączenia z serwerem. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> ma wartość true, kod wywołuje <xref:System.Web.HttpResponse.Redirect%2A> metody i klienta zostaną wyświetlone innej strony. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> ma wartość FAŁSZ, a następnie kod wywołuje <xref:System.Web.HttpResponse.End%2A> metody i całego procesu przetwarzania strony zostanie zakończony.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> Nazwa zawiera znak nowego wiersza.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie, zostanie podjęta po wysłaniu nagłówków HTTP.</exception>
        <exception cref="T:System.ApplicationException">Żądanie strony jest wynikiem wywołania zwrotnego.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość HTTP <see langword="Location" /> nagłówka.</summary>
        <value>Bezwzględny identyfikator URI, który są przesyłane do klientów w protokole HTTP <see langword="Location" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak używać tej właściwości, aby określić adres URL przekierowania w przypadku, gdy kod trwałe przekierowanie za pomocą kodu odpowiedzi HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nagłówki HTTP zostały już zapisane.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje przekierowanie trwałe z żądany adres URL określony adres URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacja, aby przekierować żądania.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL, pod określony adres URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> Przeciążenie metody zawiera kod stanu HTTP 301 w odpowiedzi oraz adres URL przekierowania żądania. Kod stanu HTTP 301 jest standardowy kod w odpowiedzi HTTP. Wskazuje, czy istnieje trwałe przekierowanie, i zapewnia lokalizacji przekierowania.  
  
 Wywoływanie <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> metoda przeciążenia kończy odpowiedź.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> zawiera znak nowego wiersza (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacja, aby przekierować żądania.</param>
        <param name="endResponse">
          <see langword="true" /> Aby zakończyć odpowiedź; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL, pod określony adres URL i udostępnia opcję, aby ukończyć odpowiedzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> Przeciążenie metody zawiera kod stanu HTTP 301 w odpowiedzi oraz adres URL przekierowania żądania. Tego przeciążenia metody zapewnia również możliwość określenia, czy do zakończenia, czy wykonać odpowiedzi, po przeprowadzeniu przekierowania. Kod stanu HTTP 301 jest standardowy kod w odpowiedzi HTTP. Wskazuje, czy istnieje trwałe przekierowanie, i zapewnia lokalizacji przekierowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> zawiera znak nowego wiersza (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametru trasy i/lub nazwy trasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda Konwertuje obiekt, który jest przekazywany w `routeValues` do <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> obiektu za pomocą <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Następnie wywoływana jest metoda, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy, który ma następujące parametry, które są nazwane `productid` i `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowywanie podjęto próbę po przesłanych nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL, używając nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda konwertuje nazwę trasy, który jest przekazywany `routeName` do adresu URL za pomocą <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metody.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy, o nazwie `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowywanie podjęto próbę po przesłanych nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda wywołuje <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodę, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy, który ma następujące parametry, które są nazwane `productid` i `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowywanie podjęto próbę po przesłanych nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu nazwy trasy i wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda Konwertuje obiekt, który jest przekazywany w `routeValues` do <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> obiektu za pomocą <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Następnie wywoływana jest metoda, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy, o nazwie `Product` i który ma następujące parametry, które są nazwane `productid` i `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowywanie podjęto próbę po przesłanych nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu nazwy trasy i wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Metoda jest wywoływana, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy, o nazwie `Product` i który ma następujące parametry, które są nazwane `productid` i `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowywanie podjęto próbę po przesłanych nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL nowy adres URL przy użyciu wartości parametru trasy i/lub nazwy trasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL nowy adres URL przy użyciu wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda Konwertuje obiekt, który jest przekazywany w `routeValues` do <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> obiektu za pomocą <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Następnie wywoływana jest metoda, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy, który ma następujące parametry, które są nazwane `productid` i `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowywanie podjęto próbę po przesłanych nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL nowy adres URL, używając nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda konwertuje nazwę trasy, który jest przekazywany `routeName` do adresu URL za pomocą <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metody.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy, o nazwie `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowywanie podjęto próbę po przesłanych nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL nowy adres URL przy użyciu wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda wywołuje <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodę, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy, który ma następujące parametry, które są nazwane `productid` i `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowywanie podjęto próbę po przesłanych nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL nowy adres URL przy użyciu wartości parametru trasy i nazwa trasy, która odpowiada nowemu adresowi URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.HttpResponse.RedirectPermanent%2A> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda Konwertuje obiekt, który jest przekazywany w `routeValues` do <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> obiektu za pomocą <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Następnie wywoływana jest metoda, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy, o nazwie `Product` i który ma następujące parametry, które są nazwane `productid` i `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowywanie podjęto próbę po przesłanych nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL nowy adres URL przy użyciu nazwy trasy i wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda wywołuje <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodę, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy, o nazwie `Product` i który ma następujące parametry, które są nazwane `productid` i `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowywanie podjęto próbę po przesłanych nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usunięcie buforowanych elementów z pamięci podręcznej danych wyjściowych za pomocą domyślny dostawca wyjściowej pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Bezwzględna ścieżka wirtualna do elementów, które są usuwane z pamięci podręcznej.</param>
        <summary>Usuwa z pamięci podręcznej wszystkie buforowane elementy, które są skojarzone z domyślny dostawca wyjściowej pamięci podręcznej. Ta metoda jest statyczna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z domyślny dostawca wyjściowej pamięci podręcznej. Wywołaj <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> metodę, aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z niestandardowych dostawców pamięci podręcznej danych wyjściowych, które są określone w pliku konfiguracji witryny sieci Web.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> nie jest bezwzględna ścieżka wirtualna.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Bezwzględna ścieżka wirtualna elementów, które są usuwane z pamięci podręcznej.</param>
        <param name="providerName">Dostawca, który służy do usuwania artefaktów pamięci podręcznej danych wyjściowych, które są skojarzone z określoną ścieżką.</param>
        <summary>Używa określonego dostawcy pamięci podręcznej danych wyjściowych, aby usunąć wszystkie elementy pamięci podręcznej danych wyjściowych, które są skojarzone z określoną ścieżką.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z niestandardowych dostawców pamięci podręcznej danych wyjściowych, które są określone w pliku konfiguracji witryny sieci Web. Aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z domyślny dostawca wyjściowej pamięci podręcznej, należy wywołać <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest nieprawidłową ścieżką.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Plik cookie w kolekcji do zaktualizowania.</param>
        <summary>Ponieważ <b>HttpResponse.SetCookie</b> metoda jest przeznaczona wyłącznie do użytku wewnętrznego, nie należy wywołać go w kodzie. Zamiast tego możesz wywołać <b>HttpResponse.Cookies.Set</b> metody, jak w poniższym przykładzie pokazano.<br /> Aktualizuje istniejący plik cookie w kolekcji plików cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład aktualizuje wartość istniejący plik cookie.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Próbowano ustawić plik cookie po nagłówków HTTP zostały wysłane.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zestawy <see langword="Status" /> wiersza, który jest zwracany do klienta.</summary>
        <value>Ustawienie kod stanu powoduje, że ciąg opisujący stan wyniku HTTP do zwrócenia do klienta. Wartość domyślna to 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> przestarzała zastąpiona ceną <xref:System.Web.HttpResponse.StatusDescription%2A> i jest dostępna tylko dla zgodności z wcześniejszymi wersjami programu ASP. Za pomocą platformy ASP.NET, należy użyć <xref:System.Web.HttpResponse.StatusDescription%2A> zamiast tego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Stan jest ustawiony na nieprawidłowy kod stanu.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod stanu HTTP wyjścia zwróconego do klienta.</summary>
        <value>Liczba całkowita reprezentująca stan wyniku HTTP zwracany do klienta. Wartość domyślna to 200 (OK). Listę kodów stanu prawidłowe na ten temat można znaleźć w [kodów stanu Http] (http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza kod stanu ze strumienia wyjściowego. Jeśli kod stanu nie jest równy 200, dodatkowy kod jest wykonywany.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.StatusCode" /> jest ustawiana po wysłaniu nagłówków HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg stanu HTTP wyjścia zwróconego do klienta.</summary>
        <value>Ciąg, który opisuje stan wyniku HTTP zwracany do klienta. Wartość domyślna to "OK". Listę kodów stanu prawidłowe na ten temat można znaleźć w [kodów stanu Http] (http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza ciąg stanu strumienia wyjściowego. Jeśli stan nie jest równa "OK", dodatkowy kod jest wykonywany.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="StatusDescription" /> jest ustawiana po wysłaniu nagłówków HTTP.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wybrana wartość ma długość większą niż 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość kwalifikujących się kod stanu odpowiedzi.</summary>
        <value>Wartość całkowitą, która reprezentuje [! Kod stanu podrzędnego include[iisver](~/includes/iisver-MD.MD)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.SubStatusCode%2A> Właściwość jest obsługiwana tylko w trybie zintegrowanym potoku [!INCLUDE[iisver](~/includes/iisver-md.md)] i co najmniej programu .NET Framework w wersji 3.0 lub nowszej. Po ustawieniu <xref:System.Web.HttpResponse.SubStatusCode%2A> właściwości, stan jest zalogowany [!INCLUDE[iisver](~/includes/iisver-md.md)] skonfigurowanie śledzenia nieudanych żądań nie powiodło się. Niezależnie od tego, czy skonfigurowano śledzenie, kod nigdy nie są wysyłane w ramach ostatecznej odpowiedzi na żądanie. Aby uzyskać więcej informacji, zobacz [rozwiązywania problemów nie powiodło się żądania za pomocą śledzenia nieudanych żądań w usługach IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Web.HttpResponse.SubStatusCode%2A> właściwość w obsłudze zdarzeń dla <xref:System.Web.HttpApplication> wystąpienie <xref:System.Web.HttpApplication.PostAuthenticateRequest> zdarzeń. Umieść plik kodu w folderze App_Code aplikacji sieci Web i skonfigurować plik Web.config w celu zarejestrowania modułu. Aby uzyskać więcej informacji, zobacz [wskazówki: tworzenie i rejestrowanie niestandardowy moduł HTTP](http://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Operacja wymaga trybu zintegrowanego potoku w [! INCLUDE[iisver](~/includes/iisver-MD.MD)] i co najmniej programu .NET Framework w wersji 3.0 lub nowszej.</exception>
        <exception cref="T:System.Web.HttpException">Kod stanu jest ustawiona, po wysłaniu wszystkich nagłówków HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy połączenie obsługuje sygnał asynchronicznych operacji opróżniania.</summary>
        <value>
          <see langword="true" /> Jeśli połączenie obsługuje sygnał asynchronicznych operacji opróżniania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do wysłania zawartości HTTP klienta.</summary>
        <value>
          <see langword="true" /> Pomija wyjście; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Następujące testy przykład czy <xref:System.Web.HttpRequest.IsSecureConnection%2A> właściwość jest ustawiona na wartość false. Jeśli tak jest, <xref:System.Web.HttpResponse.SuppressContent%2A> właściwość jest ustawiona na true, aby zatrzymać wysłanie odpowiedzi.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Obsługiwane w programie .NET Framework 4.5.2 i nowszych wersjach]  Pobiera lub ustawia wartość wskazującą, czy pominąć domyślna <c>kontrola pamięci podręcznej: prywatnych</c> nagłówek dla bieżącej odpowiedzi HTTP.</summary>
        <value>
          <see langword="true" /> Aby pominąć domyślne <c>kontrola pamięci podręcznej: prywatnych</c> nagłówek dla bieżącej odpowiedzi HTTP; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie wysyła ASP.NET `Cache-Control: private` nagłówek odpowiedzi, chyba że zasady jawnego pamięci podręcznej została określona dla tej odpowiedzi. Ta właściwość umożliwia pominięcie tego nagłówka odpowiedzi domyślne na podstawie danego żądania. Nadal można pominąć nagłówka dla całej aplikacji, ustawiając <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> w [httpRuntime — Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) lub [outputCache elemencie dla buforowania (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Należy zachować ostrożność podczas pomijania domyślnie `Cache-Control: private` nagłówek jako serwery proxy i innych pośredników mogą traktować odpowiedzi bez tego pliku nagłówkowego jako podlega buforowaniu, domyślnie. Takie podejście może prowadzić do niepotrzebnemu buforowaniu poufne informacje. Zobacz [dokumencie RFC 2616, s. 13.4](http://tools.ietf.org/html/rfc2616) Aby uzyskać więcej informacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy ma być pomijana przekierowania uwierzytelniania formularzy do strony logowania.</summary>
        <value>
          <see langword="true" /> Jeśli ma być pomijana przekierowania uwierzytelniania formularzy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie uwierzytelnianie formularzy konwertuje kodów stanu HTTP 401 na 302 w celu przekierowania do strony logowania. Nie jest ona odpowiednia dla niektórych klas błędy, takie jak podczas uwierzytelniania powiedzie się, ale Autoryzacja nie powiedzie się lub gdy bieżące żądanie dotyczy żądanie usługi sieci web lub interfejsu AJAX. Ta właściwość zapewnia sposób, aby pominąć redirect zachowanie i wysyła do klienta, oryginalnym kod stanu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje określony plik bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP bez buforowania go w pamięci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w wyniku HTTP.</param>
        <summary>Zapisuje określony plik bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP, bez buforowania go w pamięci.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> Parametr <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w wyniku HTTP.</param>
        <param name="offset">Pozycja w pliku do rozpoczęcia do zapisywania danych wyjściowych HTTP.</param>
        <param name="length">Liczba bajtów, które mają być przekazywane.</param>
        <summary>Zapisuje określoną część pliku bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP bez buforowania go w pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określisz 0 jako `offset` parametr i wartość -1 jako `length` parametr, jest wysyłany cały plik.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="offset" /> Parametru jest mniejsza niż zero.  \- lub — <paramref name="length" /> parametr jest mniejsza niż -1.  \- lub — <paramref name="length" /> parametr określa liczbę bajtów, która jest większa niż liczba bajtów, ten plik zawiera minus przesunięcie.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie spoza procesu roboczego nie jest obsługiwane.  \- lub — w odpowiedzi nie będzie wykorzystywać <see cref="T:System.Web.HttpWriter" /> obiektu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> Parametr jest mniejsza od zera lub większa od rozmiaru pliku.  \- lub — <paramref name="length" /> parametr jest mniejsza niż -1 lub większa od wartości <paramref name="offset" /> parametru plus rozmiar pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy [! Błędy niestandardowe include[iisver](~/includes/iisver-MD.MD)] są wyłączone.</summary>
        <value>
          <see langword="true" /> Aby wyłączyć błędów niestandardowych usług IIS; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> Właściwość jest używana tylko wtedy, gdy aplikacja jest hostowana w usługach IIS 7.0. Podczas pracy w trybie klasycznym w usługach IIS 7.0 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> właściwości wartość domyślna to `true`. Podczas pracy w trybie zintegrowanym <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> właściwości wartość domyślna to `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje informacje w strumieniu wyjściowym odpowiedzi HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Znak do zapisu HTTP strumienia wyjściowego.</param>
        <summary>Zapisuje znak w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy szereg stałych, które są zapisywane do strony ASP.NET przy użyciu metody zapisu. Kod wywołuje tę wersję metody zapisu, aby zapisywać stałych pojedynczy znak na stronie.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Object" /> Można zapisać do strumienia wyjściowego HTTP.</param>
        <summary>Zapisuje <see cref="T:System.Object" /> do strumienia odpowiedzi HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg do zapisu HTTP strumienia wyjściowego.</param>
        <summary>Zapisuje ciąg w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamicznie generowanym stron HTML można wprowadzać zagrożenia bezpieczeństwa, jeśli dane wejściowe otrzymane z klientów sieci Web nie zostanie zweryfikowana, po odebraniu przez klienta lub je jest przesyłane z powrotem do klienta. Złośliwy skrypt, który jest osadzony w danych wejściowych, przesłany do witryny sieci Web i później ponownie zapisana w do klienta mogą być wyświetlane pochodzącym z zaufanego źródła. To zagrożenie bezpieczeństwa jest określany jako atak skryptów między witrynami. Zawsze należy sprawdzić, czy dane odebrane od klienta, będzie on przesyłany z witryny do przeglądarki klienta.  
  
 Ponadto zawsze wtedy, gdy możesz zapisać jako plik HTML żadnych danych, która została odebrana jako dane wejściowe, możesz należy kodować je przy użyciu technik, takich jak <xref:System.Web.HttpServerUtility.HtmlEncode%2A> lub <xref:System.Web.HttpServerUtility.UrlEncode%2A> do uniemożliwić wykonanie przez złośliwy skrypt. Ta technika jest przydatne w przypadku danych, która nie została zweryfikowana, jeśli zostało przesłane.  
  
 Zakoduj lub filtrowanie danych, należy określić zestaw znaków dla stron sieci Web tak, aby filtr można zidentyfikować i usuń wszelkie bajt sekwencje, które nie należą do ustawić (na przykład sekwencje inny niż alfanumeryczny) i może potencjalnie złośliwy skrypt osadzony w je.  
  
 Aby uzyskać więcej informacji na temat ataki z użyciem skryptów między witrynami, zobacz artykuł Q252985, "Jak można zapobiec Cross-Site Scripting problemy z zabezpieczeniami" w [wiedzy Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?LinkID=37115) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład zwraca nazwę klienta do przeglądarki klienta. <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Metoda usuwa wszelkie złośliwy skrypt i nieprawidłowych znaków, które może zostały przesłane w `UserName` pola wejściowego.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków do zapisania.</param>
        <param name="index">Pozycja w tablicy znaków, w którym rozpoczyna się zapisywanie.</param>
        <param name="count">Liczba znaków do pisania, rozpoczynając od <c>indeksu</c>.</param>
        <summary>Zapisuje tablicę znaków w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy szereg stałych, które są zapisywane do strony ASP.NET przy użyciu metody zapisu. Kod wywołuje tę wersję metody zapisu, aby zapisywać stałych pojedynczy znak na stronie.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje określony plik bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w wyniku HTTP.</param>
        <summary>Zapisuje zawartość określonego pliku bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP jako blokowania plików.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany przy użyciu tej metody jest zależna od konfiguracji sprzętu serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406, "PRB: Response.WriteFile nie można pobrać dużych plików" w [wiedzy Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład zapisuje całą zawartość pliku tekstowego o nazwie `Login.txt` (który może zawierać literału kontrolek HTML tekstu i danych wejściowych) bezpośrednio do strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu do bloku pamięci.</param>
        <param name="readIntoMemory">Wskazuje, czy plik zostanie zapisany do bloku pamięci.</param>
        <summary>Zapisuje zawartość określonego pliku bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP jako bloku pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany przy użyciu tej metody jest zależna od konfiguracji sprzętu serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406, "PRB: Response.WriteFile nie można pobrać dużych plików" w [wiedzy Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład zapisuje plik w pamięci.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Dojście do pliku pliku do zapisu do strumienia wyjściowego HTTP.</param>
        <param name="offset">Pozycja bajtów w pliku, w której rozpocznie się zapisywanie.</param>
        <param name="size">Liczba bajtów do zapisu do strumienia wyjściowego.</param>
        <summary>Zapisuje określony plik bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany przy użyciu tej metody jest zależna od konfiguracji sprzętu serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406, "PRB: Response.WriteFile nie można pobrać dużych plików" w [wiedzy Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład zapisuje całą zawartość pliku tekstowego o nazwie `Login.txt` (który może zawierać literału kontrolek HTML tekstu i danych wejściowych) bezpośrednio do strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileHandler" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> jest mniejsza niż 0.  \- lub - <paramref name="size" /> jest większy niż rozmiar pliku minus <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu HTTP strumienia wyjściowego.</param>
        <param name="offset">Pozycja bajtów w pliku, w której rozpocznie się zapisywanie.</param>
        <param name="size">Liczba bajtów do zapisu do strumienia wyjściowego.</param>
        <summary>Zapisuje określony plik bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany przy użyciu tej metody jest zależna od konfiguracji sprzętu serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406, "PRB: Response.WriteFile nie można pobrać dużych plików" w [wiedzy Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład zapisuje całą zawartość pliku tekstowego o nazwie `Login.txt` (które mogą zawierać tekst dosłowny, jak i HTML kontrolki wejściowe) bezpośrednio do strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> jest mniejsza niż 0.  \- lub - <paramref name="size" /> jest większy niż rozmiar pliku minus <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda, kontrolki użytkownika lub obiekt do zastąpienia.</param>
        <summary>Umożliwia wstawianie bloków podstawienia odpowiedzi do odpowiedzi, który umożliwia dynamiczne generowanie określony reakcji regionów dla odpowiedzi na dane wyjściowe pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.HttpResponse.WriteSubstitution%2A> metody do zastępowania po pamięci podręcznej w pamięci podręcznej danych wyjściowych strony. Przekazując <xref:System.Web.HttpContext> obiektu do metody wywołania zwrotnego z wymaganych <xref:System.Web.HttpResponseSubstitutionCallback> podpisu, możesz zastąpić dane wyjściowe pamięci podręcznej zawartości w dowolnej podanej lokalizacji pamięci podręcznej stron. Aby zainicjować zastąpienia, należy wywołać <xref:System.Web.HttpResponse.WriteSubstitution%2A> metody, podając mu metody wywołania zwrotnego, która musi być bezpieczny dla wątków i może być jedną z następujących czynności:  
  
-   Metoda statyczna kontenera kontrolki użytkownika lub strony.  
  
-   Statyczną lub metodę na innym obiekcie dowolnego wystąpienia.  
  
 Pierwsze żądanie do strony <xref:System.Web.HttpResponse.WriteSubstitution%2A> wywołania <xref:System.Web.HttpResponseSubstitutionCallback> delegata do generowania danych wyjściowych. Następnie dodaje bufor podstawienia w odpowiedzi, która zachowuje pełnomocnika do wywołania na przyszłe żądania. Na koniec spadku buforowania po stronie klienta z publicznej tylko do serwera, do zapewnienia przyszłych żądań do wywołania ponownie stronę delegata przez nie pamięci podręcznej na kliencie.  
  
> [!NOTE]
>  Podstawianie po pamięci podręcznej nie jest obsługiwana dla kontrolki użytkownika pamięci podręcznej, w których buforowanie danych wyjściowych jest stosowana na poziomie kontroli użytkownika. Jest to również nazywane fragmentu pamięci podręcznej. Aby uzyskać więcej informacji, zobacz [buforowanie części strony ASP.NET](http://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Celem <paramref name="callback" /> parametr jest typu <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6b29f2b5d1f887402088aa5a0a4159673bf5d4de" /><Meta Name="ms.sourcegitcommit" Value="43c8e74d92c78325492baf27e41b400443f0dfbf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/08/2019" /><Meta Name="ms.locfileid" Value="68858095" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Hermetyzuje informacje o odpowiedzi HTTP z operacji ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody i <xref:System.Web.HttpResponse> właściwości klasy są udostępniane <xref:System.Web.HttpApplication.Response%2A> przez właściwość <xref:System.Web.HttpApplication>klasy, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, i <xref:System.Web.UI.UserControl> .  
  
 Następujące metody <xref:System.Web.HttpResponse> klasy są obsługiwane tylko w scenariuszach ogłaszania zwrotnego, a nie w scenariuszach asynchronicznego powrotu po stronie:  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Aktualizacje części strony są włączane w przypadku używania <xref:System.Web.UI.UpdatePanel> kontrolek do aktualizowania wybranych regionów strony zamiast aktualizowania całej strony przy użyciu wpisu zwrotnego. Aby uzyskać więcej informacji, zobacz temat [formant UpdatePanel — Omówienie](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) i [Przegląd renderowania części strony](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 Poniższy przykład rysuje trzy nakładające się prostokąty po zażądaniu strony. Kod rozpoczyna się od ustawienia <xref:System.Web.HttpResponse.ContentType%2A> właściwości na Image/JPEG, dzięki czemu cała strona będzie renderowana jako obraz JPEG. Następnie kod wywołuje <xref:System.Web.HttpResponse.Clear%2A> metodę, aby upewnić się, że żadna nadmiarowa zawartość nie jest wysyłana z tą odpowiedzią. Następnie kod ustawia <xref:System.Web.HttpResponse.BufferOutput%2A> właściwość na true, aby strona była całkowicie przetworzona przed wysłaniem do żądającego klienta. Tworzone są dwa obiekty służące do rysowania prostokątów: <xref:System.Drawing.Bitmap> <xref:System.Drawing.Graphics> a i obiektu. Zmienne utworzone na stronie są używane jako współrzędne do rysowania prostokątów i ciąg, który pojawia się wewnątrz największego prostokąta.  
  
 Gdy są rysowane trzy prostokąty i ciąg znajdujący się wewnątrz nich, <xref:System.Drawing.Bitmap> jest on zapisywany <xref:System.IO.Stream> do obiektu <xref:System.Web.HttpResponse.OutputStream%2A> , który jest skojarzony z właściwością i jego format jest ustawiony na JPEG. Kod wywołuje <xref:System.Drawing.Image.Dispose%2A> metody i <xref:System.Drawing.Graphics.Dispose%2A> , aby zwolnić zasoby używane przez dwa obiekty rysunkowe. Na koniec kod wywołuje <xref:System.Web.HttpResponse.Flush%2A> metodę w celu wysłania buforowanej odpowiedzi do żądającego klienta.  
  
> [!NOTE]
>  W kodzie, <xref:System.Web.HttpResponse> obiekt jest określany za pomocą słowa kluczowego `Response`. Na przykład `Response.Clear()` odwołuje się <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> do metody. Klasa ma właściwość o nazwie <xref:System.Web.UI.Page.Response%2A> , która <xref:System.Web.HttpResponse>uwidacznia bieżące wystąpienie. <xref:System.Web.UI.Page>  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> Obiekt, który umożliwia niestandardowe dane wyjściowe protokołu HTTP.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.HttpResponse" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski obsługuje infrastrukturę programu .NET Framework i nie jest przeznaczony do użycia bezpośrednio w kodzie.  
  
 Metody i właściwości <xref:System.Web.HttpResponse> klasy są udostępniane za pomocą obiektu wewnętrznego <xref:System.Web.HttpContext.Response%2A> w ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">Plik, klucz pamięci podręcznej <see cref="T:System.Web.Caching.CacheDependency" /> lub do dodania do listy zależności aplikacji.</param>
        <summary>Kojarzy zestaw zależności pamięci podręcznej z odpowiedzią, aby ułatwić unieważnienie odpowiedzi, jeśli jest ona przechowywana w wyjściowej pamięci podręcznej, a określone zależności zmieniają się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia tworzenie zależności między buforowanymi odpowiedziami <xref:System.Web.Caching.CacheDependency> a obiektem. <xref:System.Web.HttpResponse.AddCacheDependency%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób tworzenia zależności pamięci podręcznej przy użyciu <xref:System.Web.HttpResponse.AddCacheDependency%2A> metody <xref:System.Web.Caching.CacheDependency> i obiektu.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="dependencies" /></exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana zbyt późno w potoku przetwarzania pamięci podręcznej po utworzeniu pamięci podręcznej.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Buforowanie stron ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawia, że ważność buforowanej odpowiedzi zależy od innych elementów w pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys"><see cref="T:System.Collections.ArrayList" /> Zawiera klucze elementów, od których zależy bieżąca buforowana odpowiedź.</param>
        <summary>Sprawia, że ważność buforowanej odpowiedzi zależy od innych elementów w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy elementy określone w `cacheKeys` parametrze zostaną usunięte z pamięci podręcznej, buforowana odpowiedź bieżącego elementu jest nieprawidłowa.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia strony ASP.NET, która jest w pamięci podręcznej. Kod strony tworzy <xref:System.Collections.ArrayList> obiekt kluczy, które są skojarzone z elementami, które są przechowywane <xref:System.Web.Caching.Cache> w obiekcie. Następnie kod przekazuje <xref:System.Collections.ArrayList> jako parametr w wywołaniu <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> metody. Powoduje to, że nieprawidłowa nieważna odpowiedź wyjściowa, jeśli którykolwiek z plików określonych w <xref:System.Collections.ArrayList> zmianie.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Buforowanie stron ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Tablica kluczy elementów, od których zależy buforowanej odpowiedzi.</param>
        <summary>Sprawia, że ważność buforowanego elementu zależała od innego elementu w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku usunięcia dowolnego `cacheKey`z pamięci podręcznej odpowiedź z pamięci podręcznej bieżącego elementu jest nieprawidłowa.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Buforowanie stron ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Klucz elementu, od którego zależy buforowana odpowiedź.</param>
        <summary>Sprawia, że ważność buforowanej odpowiedzi zależy od innego elementu w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element odpowiadający `cacheKey` parametrowi zostanie usunięty z pamięci podręcznej, buforowana odpowiedź bieżącego elementu jest nieprawidłowa.  
  
   
  
## Examples  
 Poniższy przykład to ASP.NET formant użytkownika, który jest wyprowadzany w pamięci podręcznej. Kod dla kontrolki wywołuje <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> metodę z kluczem elementu przechowywanego <xref:System.Web.Caching.Cache> w obiekcie przekazaną jako parametr. Jeśli element nie istnieje w pamięci podręcznej, odpowiedź kontrolki, która była przechowywana w wyjściowej pamięci podręcznej, jest unieważniona. Oznacza to, że w następnym żądaniu zostanie dodana nowa wersja odpowiedzi kontrolki do wyjściowej pamięci podręcznej.  
  
 Następnie kod sprawdza, czy element skojarzony z `bookData` kluczem jest przechowywany `Cache` w obiekcie i wyświetla jeden z dwóch wierszy tekstu zależnie od wyniku. <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> Następnie kod ustawia właściwość <xref:System.Web.UI.WebControls.DataGrid> kontrolki o nazwie `dgBooks`, z wywołaniem metody udostępnionej <xref:System.Web.UI.Control.DataBind%2A> `GetBookData` klasy niestandardowej `DataHelper` i wypełnia <xref:System.Web.UI.WebControls.DataGrid> przy użyciu metody.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Buforowanie stron ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje grupę nazw plików do kolekcji nazw plików, od których zależy bieżąca odpowiedź.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Kolekcja plików do dodania.</param>
        <summary>Dodaje grupę nazw plików do kolekcji nazw plików, od których zależy bieżąca odpowiedź.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład to ASP.NET Strona danych wyjściowych w pamięci podręcznej. Kod strony tworzy <xref:System.Collections.ArrayList> ścieżki plików, a następnie <xref:System.Collections.ArrayList> przekazuje jako parametr <xref:System.Web.HttpResponse.AddFileDependencies%2A> w wywołaniu metody. Powoduje to, że buforowana odpowiedź jest nieprawidłowa, jeśli którykolwiek z plików określonych <xref:System.Collections.ArrayList> w zmianach zostanie zmieniony.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Buforowanie stron ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filenames">Tablica plików do dodania.</param>
        <summary>Dodaje tablicę nazw plików do kolekcji nazw plików, od których zależy bieżąca odpowiedź.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład dodaje tablicę nazw plików do <xref:System.Web.HttpResponse.AddFileDependencies%2A> listy zależności plików. W przypadku zmiany plików buforowana odpowiedź jest unieważniona.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Buforowanie stron ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do dodania.</param>
        <summary>Dodaje pojedynczą nazwę pliku do kolekcji nazw plików, od których zależy bieżąca odpowiedź.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy używasz <xref:System.Web.HttpResponse.AddFileDependency%2A> metody do dodawania zależności pliku, należy również określić programowe buforowanie danych wyjściowych lub deklaratywnie. Na przykład aby określić buforowanie danych wyjściowych w sposób deklaratywny, należy użyć dyrektywy [@ OutputCache](https://msdn.microsoft.com/library/28a9e101-fb44-4198-9cb6-b8a52312fec2) . Aby uzyskać więcej informacji, zobacz [jak: Buforuj dane wyjściowe stron z zależnościami](https://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db)plików.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodać pojedynczą nazwę pliku do <xref:System.Web.HttpResponse.AddFileDependency%2A> listy zależności plików. Jeśli plik ulegnie zmianie, buforowana odpowiedź jest unieważniona.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Buforowanie stron ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa nagłówka HTTP, który ma zostać dodany <paramref name="value" /> do.</param>
        <param name="value">Ciąg, który ma zostać dodany do nagłówka.</param>
        <summary>Dodaje nagłówek HTTP do strumienia wyjściowego. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />zapewnia zgodność z wcześniejszymi wersjami ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A>jest taka sama jak <xref:System.Web.HttpResponse.AppendHeader%2A> i jest dostępna tylko w przypadku zgodności z wcześniejszymi wersjami ASP. Za pomocą ASP.NET, <xref:System.Web.HttpResponse.AppendHeader%2A>Użyj.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda wywołania zwrotnego.</param>
        <summary>Rejestruje wywołanie zwrotne, które zostanie wywołane przez środowisko uruchomieniowe ASP.NET przed wysłaniem nagłówków odpowiedzi dla tego żądania.</summary>
        <returns><see cref="T:System.Web.ISubscriptionToken" /> Obiekt reprezentujący subskrypcję pseudoklasy OnSendingHeaders.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Metoda AddOnSendingHeaders nie jest wywoływana, jeśli moduł macierzysty najpierw opróżnia odpowiedź.  
  
 Pseudo-Event OnSendingHeaders różni się od zdarzenia potoku na poziomie IHttpModule w przypadku subskrypcji na żądanie, a nie subskrypcji dla poszczególnych aplikacji. Zamiarem jest to, że wywołanie zwrotne może zmodyfikować kod stanu odpowiedzi lub można ustawić plik cookie lub nagłówek odpowiedzi. Inne uwagi dotyczące użycia i zastrzeżenia:  
  
-   Ta metoda jest skuteczna tylko wtedy, gdy usługi IIS działają w potoku zintegrowanego trybu potokowego i tylko wtedy, gdy nagłówki odpowiedzi nie zostały jeszcze wysłane dla bieżącego żądania.  
  
-   Środowisko uruchomieniowe ASP.NET nie gwarantuje żadnej informacji o wątku, w którym wywołano wywołanie zwrotne. Na przykład wywołanie zwrotne może być wywoływane synchronicznie w wątku w tle w przypadku wykonywania opróżniania w tle. <xref:System.Web.HttpContext.Current%2A>nie ma gwarancji, że jest on dostępny w takim wątku.  
  
-   Wywołanie zwrotne nie może wywoływać żadnej metody, która operuje na treści jednostki odpowiedzi lub powoduje, że jest to wartość opróżniania. Na przykład wywołanie zwrotne nie może wywołać <xref:System.Web.HttpResponse.Redirect%2A>, ponieważ ta metoda może manipulować treścią jednostki odpowiedzi.  
  
-   Wywołanie zwrotne musi zawierać tylko krótki kod synchroniczny. Podjęto próbę wywołania asynchronicznej operacji lub zaczekaj na taką operację, może to spowodować zakleszczenie.  
  
-   Wywołanie zwrotne nie może zgłosić wyjątku; zachowanie w przeciwnym razie jest niezdefiniowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie"><see cref="T:System.Web.HttpCookie" /> Do dodania do strumienia wyjściowego.</param>
        <summary>Dodaje plik cookie HTTP do kolekcji wewnętrznej plików cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy nowy plik cookie o nazwie `LastVisit`, ustawia wartość pliku cookie na bieżącą datę i godzinę oraz dołącza plik cookie do bieżącej kolekcji plików cookie. Wszystkie pliki cookie w kolekcji plików cookie są wysyłane do klienta w `Set-Cookie` nagłówku przy użyciu strumienia wyjściowego http.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Po wysłaniu nagłówków HTTP jest dołączany plik cookie.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa nagłówka HTTP, który ma zostać dodany do strumienia wyjściowego.</param>
        <param name="value">Ciąg do dołączenia do nagłówka.</param>
        <summary>Dodaje nagłówek HTTP do strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Web.HttpResponse.AppendHeader%2A> używasz metody do wysyłania nagłówków specyficznych dla pamięci podręcznej i w tym samym czasie, użyj modelu obiektów<xref:System.Web.HttpResponse.Cache%2A>pamięci podręcznej (), aby ustawić zasady pamięci podręcznej, `Expires`nagłówki odpowiedzi HTTP, które odnoszą się do buforowania (`Cache-Control`,, `Last-Modified`, `Pragma` i`Vary`) mogą zostać usunięte, gdy jest używany model obiektów pamięci podręcznej. To zachowanie umożliwia ASP.NETom zachowanie najbardziej restrykcyjnych ustawień. Rozważmy na przykład stronę, która zawiera kontrolki użytkownika. Jeśli te kontrolki mają sprzeczne zasady pamięci podręcznej, zostaną użyte najbardziej restrykcyjne zasady pamięci podręcznej. Jeśli jeden z formantów użytkownika ustawi nagłówek "`Cache-Control: Public`", a inna kontrolka użytkownika ustawia bardziej restrykcyjny`Cache-Control: Private`nagłówek "" przez <xref:System.Web.HttpCachePolicy.SetCacheability%2A>wywołania do, wówczas`Cache-Control: Private`nagłówek "" zostanie wysłany z odpowiedzią.  
  
 Aby zapoznać się z listą standardowych nagłówków HTTP/1.1, zobacz sekcję 14 "definicje pól nagłówków" w specyfikacji [protokołu HTTP/1.1](https://go.microsoft.com/fwlink/?LinkID=73147) w witrynie sieci Web organizacja World Wide Web Consortium (W3C).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Web.HttpResponse.AppendHeader%2A> metodę w celu dodania niestandardowego nagłówka <xref:System.Web.HttpResponse> do obiektu wysłanego do żądającego klienta.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nagłówek jest dołączany po wysłaniu nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Tekst, który ma zostać dodany do pliku dziennika.</param>
        <summary>Dodaje niestandardowe informacje dziennika do pliku dziennika Internet Information Services (IIS).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zezwolić na zarejestrowanie określonego ciągu w pliku dziennika, należy najpierw włączyć opcję **kwerendy identyfikatora URI** okna dialogowego **Rozszerzone właściwości rejestrowania** dla witryny, dla której chcesz rejestrować aktywność w usługach IIS.  
  
 Aby dostosować rejestrowanie rozszerzone w usługach IIS 6,0, wykonaj następujące kroki:  
  
1.  W Menedżerze usług IIS rozwiń węzeł komputer lokalny, rozwiń folder witryny sieci Web lub FTP, kliknij prawym przyciskiem myszy witrynę sieci Web lub FTP, a następnie kliknij polecenie **Właściwości**.  
  
2.  Kliknij kartę **Witryna sieci Web lub FTP** , a następnie zaznacz pole wyboru **Włącz rejestrowanie** (jeśli nie zostało jeszcze zaznaczone).  
  
3.  W polu **aktywny format dziennika** kliknij pozycję **rozszerzony format W3C pliku dziennika**.  
  
4.  Kliknij pozycję **Właściwości**.  
  
5.  Kliknij kartę **Zaawansowane** , wybierz właściwości, które chcesz zarejestrować, a następnie kliknij przycisk **OK**.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dołączyć ciąg do dziennika.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=36829">Pomoc produktu Windows Server 2003</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna do zasobu.</param>
        <summary>Dodaje identyfikator sesji do ścieżki wirtualnej, jeśli sesja używa <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> stanu sesji i zwraca połączoną ścieżkę. Jeśli <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> stan sesji nie jest używany, <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> funkcja Zwraca oryginalną ścieżkę wirtualną.</summary>
        <returns><paramref name="virtualPath" /> Z wstawionym identyfikatorem sesji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A>jest używany tylko z sesjami bez plików cookie do konstruowania bezwzględnych HREF.  
  
   
  
## Examples  
 Poniższy przykład deklaruje zmienną ciągu o nazwie `urlConverted`i ustawia ją na wynik <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> wywołania metody. Następnie kod przekazuje wartość zmiennej do <xref:System.Web.UI.WebControls.HyperLink> <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> właściwości kontrolki.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Obiekt wywołania zwrotnego.</param>
        <param name="state">Stan odpowiedzi.</param>
        <summary>Wysyła aktualnie buforowaną odpowiedź do klienta.</summary>
        <returns>Asynchroniczny obiekt wyniku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli obiekt źródłowy <xref:System.Web.HttpWorkerRequest> obsługuje asynchroniczne operacje opróżniania i ta metoda jest wywoływana z asynchronicznego zdarzenia modułu lub z procedury obsługi asynchronicznej, operacja opróżniania jest wykonywana asynchronicznie. W przeciwnym razie operacja opróżniania jest wykonywana synchronicznie. Asynchroniczne opróżnianie jest obsługiwane dla usług IIS 6,0 i nowszych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Odpowiedź została już zakończona.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Bajty do zapisu w strumieniu wyjściowym.</param>
        <summary>Zapisuje ciąg znaków binarnych w strumieniu wyjściowym protokołu HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład odczytuje plik tekstowy do buforu i zapisuje bufor w strumieniu wyjściowym protokołu HTTP.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy buforować dane wyjściowe i wysyłać po zakończeniu przetwarzania kompletnej odpowiedzi.</summary>
        <value><see langword="true" />Jeśli dane wyjściowe klienta są buforowane; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość została uznana za przestarzałą na <xref:System.Web.HttpResponse.BufferOutput%2A> rzecz właściwości i jest dostarczana tylko w celu zapewnienia zgodności z wcześniejszymi wersjami ASP. <xref:System.Web.HttpResponse.Buffer%2A> Za pomocą ASP.NET, <xref:System.Web.HttpResponse.BufferOutput%2A>Użyj.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy buforować dane wyjściowe i wysyłać je po zakończeniu przetwarzania całej strony.</summary>
        <value><see langword="true" />Jeśli dane wyjściowe klienta są buforowane; w <see langword="false" />przeciwnym razie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ustawia <xref:System.Web.HttpResponse.ContentType%2A> Właściwość odpowiedzi na Image/JPEG, <xref:System.Web.HttpResponse.Clear%2A> wywołuje metodę w celu usunięcia innej zawartości, która może być dołączona do odpowiedzi <xref:System.Web.HttpResponse.BufferOutput%2A> , a następnie ustawia właściwość na true, aby cała strona była przetwarzane przed wysłaniem jakiejkolwiek zawartości do żądającego klienta.  
  
 Pełny przykład można znaleźć w <xref:System.Web.HttpResponse> klasie.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Zasady buforowania (takie jak czas wygaśnięcia, ustawienia prywatności i różne klauzule) strony sieci Web.</summary>
        <value><see cref="T:System.Web.HttpCachePolicy" /> Obiekt, który zawiera informacje o zasadach buforowania bieżącej odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład zapisuje właściwości bieżącej zasady pamięci podręcznej w strumieniu wyjściowym protokołu HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see langword="Cache-Control" /> nagłówek HTTP pasujący do jednej <see cref="T:System.Web.HttpCacheability" /> z wartości wyliczenia.</summary>
        <value>Reprezentacja wartości wyliczenia w <see cref="T:System.Web.HttpCacheability" /> postaci ciągu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości dla `Private`, `Public`, i `No-Cache` są ciągami i muszą być ujęte w cudzysłów (""). Jeśli właściwość jest ustawiona na wartość, która nie jest zgodna <xref:System.Web.HttpCacheability> z jedną z wartości <xref:System.ArgumentException> wyliczenia, zostanie zgłoszony. <xref:System.Web.HttpResponse.CacheControl%2A> Jeśli właściwość nie jest ustawiona, buforowanie odpowiedzi jest ustawione na <xref:System.Web.HttpCacheability.NoCache>. <xref:System.Web.HttpResponse.CacheControl%2A>  
  
 Właściwości `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A> i<xref:System.Web.HttpResponse.ExpiresAbsolute%2A> są przestarzałe. Zamiast tego metody <xref:System.Web.HttpCachePolicy> klasy są dostępne <xref:System.Web.HttpResponse.Cache%2A> za pomocą obiektu wewnętrznego do kontrolowania wyjściowej pamięci podręcznej Internet Information Services (IIS) i pamięci podręcznej klienta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Zestaw wartości ciągu nie jest zgodny z jedną z <see cref="T:System.Web.HttpCacheability" /> wartości wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zestaw znaków HTTP w strumieniu wyjściowym.</summary>
        <value>Zestaw znaków HTTP w strumieniu wyjściowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość może być ustawiona na `null` wartość pomijania nagłówka HTTP `Content-Type`. `Charset`  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy zestaw znaków strumienia wyjściowego to Europa Środkowa (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see langword="Charset" /> Właściwość została ustawiona po wysłaniu nagłówków.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie dane wyjściowe ze strumienia bufora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Clear%2A> Metoda nie czyści informacji nagłówka.  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Web.HttpResponse.ContentType%2A> Właściwość odpowiedzi na Image/JPEG, <xref:System.Web.HttpResponse.Clear%2A> wywołuje metodę w celu usunięcia innej zawartości, która może być dołączona do odpowiedzi <xref:System.Web.HttpResponse.BufferOutput%2A> , a następnie ustawia właściwość na true, aby ukończyć pełną stronę przetwarzane przed wysłaniem jakiejkolwiek zawartości do żądającego klienta.  
  
 Pełny przykład można znaleźć w <xref:System.Web.HttpResponse> klasie.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie dane wyjściowe ze strumienia bufora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ClearContent%2A> Metoda nie czyści informacji nagłówka.  
  
   
  
## Examples  
 Poniższy przykład czyści całą zawartość ze strumienia bufora.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie nagłówki ze strumienia bufora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Web.HttpResponse.ClearHeaders%2A> metodę, aby upewnić się, że żadne nagłówki nie są wysyłane z bieżącą odpowiedzią. Ta technika może być szczególnie ważna, jeśli odpowiedź ASP.NET generuje obraz, taki jak plik JPEG. W tym przykładzie <xref:System.Web.HttpResponse.ContentType%2A> właściwość jest ustawiona na Image/JPEG.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Po wysłaniu nagłówków HTTP nagłówki są czyszczone.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.CancellationToken" /> Pobiera obiekt, który jest wyzwalany po rozłączeniu klienta.</summary>
        <value>Token anulowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten interfejs API jest bezpieczny wątkowo. Istnieją jednak pewne ograniczenia dotyczące sposobu używania tokenu anulowania. Niewłaściwe użycie go może prowadzić do warunków wyścigu, zakleszczeniów lub innych nieoczekiwanych zachowań. Należy pamiętać o następujących wytycznych:  
  
-   Upewnij się, że nie można wywołać tego interfejsu API poza granicami pojedynczego żądania, ponieważ ASP.NET usunie token anulowania na końcu żądania. Nie ma gwarancji, że token zostanie kiedykolwiek przeniesiony do stanu anulowanego przed jego usunięciem. Na przykład jeśli żądanie zakończy się bez odłączenia klienta, token zostanie usunięty bez wcześniejszego anulowania.  
  
-   Nie czekaj na <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, ponieważ to zakłóca przeznaczenie asynchronicznej powiadomienia i może spowodować zakleszczenie.  
  
-   Nie wywołuj <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> przeciążeń, które wywołują wywołanie zwrotne <xref:System.Threading.SynchronizationContext> dla oryginalnego obiektu.  
  
-   Nie należy używać <xref:System.Web.HttpContext> obiektu ani innych wewnętrznych obiektów ASP.NET innych niż wątki z wywołania zwrotnego dostarczonego <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> do metody. Wywołanie zwrotne może być uruchomione równolegle z innym ASP.NET lub kodem aplikacji.  
  
-   Zachowuj, że metody wywołania zwrotnego są wykonywane krótko i bez blokowania.  
  
-   Podejmuj wszelkie wysiłki, aby uniknąć zgłaszania wyjątków z metod wywołania zwrotnego.  
  
 Ta właściwość jest obsługiwana tylko w programie Internet Information Service (IIS) w wersji 7,5 lub nowszej w trybie zintegrowanym. Jeśli zostanie on wywołany bez odpowiedniej wersji usług IIS lub trybu potokowego <xref:System.PlatformNotSupportedException> , zostanie zgłoszony. Aby określić wersję usług IIS, użyj <xref:System.Web.HttpRuntime.IISVersion%2A>. Aby określić tryb potokowy, użyj <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka połączenie gniazda z klientem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przerywa połączenie z klientem w nieoczekiwany sposób i nie jest przeznaczona do normalnego przetwarzania żądań HTTP. Metoda wysyła pakiet resetowania do klienta, co może spowodować, że dane odpowiedzi są buforowane na serwerze, kliencie lub gdzieś między elementami do porzucenia.  
  
 Jednak zazwyczaj należy wywołać <xref:System.Web.HttpApplication.CompleteRequest%2A> zamiast tego, jeśli chcesz przejść <xref:System.Web.HttpApplication.EndRequest> do zdarzenia i wysłać odpowiedź do klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zestaw znaków HTTP w strumieniu wyjściowym.</summary>
        <value><see cref="T:System.Text.Encoding" /> Obiekt, który zawiera informacje o zestawie znaków bieżącej odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `ContentEncoding` domyślną można określić w pliku konfiguracji ASP.NET w sekcji [globalizacja (Schemat ustawień ASP.NET)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) . Jeśli <xref:System.Web.HttpResponse.ContentEncoding%2A> jest określony przez klienta, domyślne ustawienia konfiguracji są zastępowane.  
  
   
  
## Examples  
 Poniższy przykład zapisuje czytelny dla człowieka opis kodowania zestawu znaków do strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Podjęto próbę <see cref="P:System.Web.HttpResponse.ContentEncoding" /> ustawienia <see langword="null" />wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ protokołu HTTP MIME strumienia wyjściowego.</summary>
        <value>Typ MIME protokołu HTTP strumienia wyjściowego. Wartość domyślna to "<see langword="text/html" />".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ustawia <xref:System.Web.HttpResponse.ContentType%2A> Właściwość odpowiedzi na Image/JPEG, <xref:System.Web.HttpResponse.Clear%2A> wywołuje metodę w celu usunięcia innej zawartości, która może być dołączona do odpowiedzi <xref:System.Web.HttpResponse.BufferOutput%2A> , a następnie ustawia właściwość na true, aby ukończyć pełną stronę przetwarzane przed wysłaniem jakiejkolwiek zawartości do żądającego klienta.  
  
 Pełny przykład można znaleźć w <xref:System.Web.HttpResponse> klasie.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Właściwość jest ustawiona na <see langword="null" />. <see cref="P:System.Web.HttpResponse.ContentType" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję plików cookie odpowiedzi.</summary>
        <value>Kolekcja plików cookie odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET obejmuje dwie wewnętrzne kolekcje plików cookie. Kolekcja dostępna za pomocą <xref:System.Web.HttpRequest.Cookies%2A> <xref:System.Web.HttpRequest> kolekcji zawiera pliki cookie przesłane przez klienta `Cookie` do serwera w nagłówku. Kolekcja dostępna za pomocą <xref:System.Web.HttpResponse.Cookies%2A> <xref:System.Web.HttpResponse> kolekcji zawiera nowe pliki cookie utworzone na serwerze i przesłane `Set-Cookie` do klienta w nagłówku programu.  
  
 Po dodaniu pliku cookie przy użyciu <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> kolekcji plik cookie jest natychmiast dostępny <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> w kolekcji, nawet jeśli odpowiedź nie została wysłana do klienta.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy plik cookie o nazwie `LastVisit`, ustawia wartość pliku cookie na bieżącą datę i godzinę i dodaje plik cookie do bieżącej kolekcji plików cookie. Wszystkie pliki cookie w kolekcji plików cookie są wysyłane do klienta w `Set-Cookie` nagłówku przy użyciu strumienia wyjściowego http.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyłącza buforowanie jądra dla bieżącej odpowiedzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli buforowanie jądra nie jest obsługiwane, ta metoda nie ma żadnego wpływu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyłącza buforowanie w trybie użytkownika usług IIS dla tej odpowiedzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli buforowanie w trybie użytkownika usług IIS nie jest obsługiwane, Metoda ta zwraca bez wykonania żadnej akcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wysyła wszystkie aktualnie buforowane dane wyjściowe do klienta, kończy wykonywanie strony i zgłasza <see cref="E:System.Web.HttpApplication.EndRequest" /> zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna tylko w celu zapewnienia zgodności z technologią ASP, czyli w celu zapewnienia zgodności z technologiami internetowymi opartymi na modelu COM, które poprzedzali ASP.NET. Jeśli chcesz przejść <xref:System.Web.HttpApplication.EndRequest> do zdarzenia i wysłać odpowiedź do klienta, zazwyczaj preferowane jest wywołanie metody <xref:System.Web.HttpApplication.CompleteRequest%2A> .  
  
 Aby naśladować zachowanie `End` metody w ASP, ta metoda próbuje <xref:System.Threading.ThreadAbortException> wywołać wyjątek. Jeśli ta próba zakończy się pomyślnie, wątek wywołujący zostanie przerwany, co jest niekorzystne dla wydajności lokacji. W takim przypadku kod po wywołaniu <xref:System.Web.HttpResponse.End%2A> metody nie jest wykonywany.  
  
 Jeśli metoda nie może podnieść, zamiast tego opróżnia bajty odpowiedzi do klienta. <xref:System.Threading.ThreadAbortException> <xref:System.Web.HttpResponse.End%2A> Wykonuje to synchronicznie, co może być również niekorzystne dla wydajności witryny.  
  
 W obu przypadkach (niezależnie od tego <xref:System.Threading.ThreadAbortException> , czy wyjątek został pomyślnie podniesiony) potok odpowiedzi przechodzi <xref:System.Web.HttpApplication.EndRequest> do zdarzenia.  
  
 Metoda nie wywołuje wyjątku i można wykonać kod po wywołaniu <xref:System.Web.HttpApplication.CompleteRequest%2A> metody. <xref:System.Web.HttpApplication.CompleteRequest%2A> Jeśli zamiarem jest uniknięcie wykonywania kolejnego kodu, a w przypadku akceptowalności <xref:System.Web.HttpResponse.End%2A> wydajności, można wywołać <xref:System.Web.HttpResponse.End%2A> zamiast <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">Wywołanie <see cref="M:System.Web.HttpResponse.End" /> zakończyło działanie bieżącego żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Asynchroniczny obiekt wyniku.</param>
        <summary>Kończy asynchroniczne operacje opróżniania.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Asynchroniczne opróżnianie nie jest obsługiwane, <paramref name="asyncResult" /> a parametr <see langword="null" />to.</exception>
        <exception cref="T:System.ArgumentException">Asynchroniczne opróżnianie nie jest obsługiwane i <paramref name="asyncResult" /> nie można rzutować parametru na obiekt <c>FlushAsyncResult</c> .</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę minut, po upływie której wygasa Strona w pamięci podręcznej w przeglądarce. Jeśli użytkownik powróci do tej samej strony przed wygaśnięciem, zostanie wyświetlona wersja z pamięci podręcznej. <see cref="P:System.Web.HttpResponse.Expires" />zapewnia zgodność z wcześniejszymi wersjami ASP.</summary>
        <value>Liczba minut przed wygaśnięciem strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Expires` <xref:System.Web.HttpCachePolicy> <xref:System.Web.HttpResponse.Cache%2A> Właściwości i zostały<xref:System.Web.HttpResponse.CacheControl%2A> przestarzałe na rzecz metod klasy dostępnej za pomocą obiektu wewnętrznego do kontrolowania wyjściowej pamięci podręcznej Internet Information Services (IIS) <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> i pamięci podręcznej klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bezwzględną datę i godzinę, o której ma zostać usunięte buforowane informacje z pamięci podręcznej. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" />zapewnia zgodność z wcześniejszymi wersjami ASP.</summary>
        <value>Data i godzina wygaśnięcia strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Cache%2A> <xref:System.Web.HttpCachePolicy> Właściwości `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A> i<xref:System.Web.HttpResponse.CacheControl%2A> zostały zaniechane na rzecz metod klasy dostępnej za pomocą obiektu wewnętrznego do kontrolowania wyjściowej pamięci podręcznej Internet Information Services (IIS) i pamięci podręcznej klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt filtru zawijania, który jest używany do modyfikacji treści jednostki HTTP przed przekazaniem.</summary>
        <value><see cref="T:System.IO.Stream" /> Obiekt, który działa jako filtr wyjściowy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia `Stream` obiektu i <xref:System.Web.HttpResponse.Filter%2A> ustawiania właściwości dla `Stream` obiektu, wszystkie dane wyjściowe http wysyłane przez <xref:System.Web.HttpResponse.Write%2A> przechodzą przez filtr.  
  
   
  
## Examples  
 Poniższy przykład jest stroną ASP.NET, która ustawia <xref:System.Web.HttpResponse.Filter%2A> właściwość na nowe wystąpienie `UpperCaseFilter` klasy, Klasa niestandardowa <xref:System.IO.Stream> , która konwertuje cały tekst, który przechodzi przez niego na wielkie litery. Informacje o żądaniu są zapisywane w pliku tekstowym, a następnie <xref:System.Web.HttpResponse.Filter%2A> ustawiona właściwość. Po zastosowaniu filtra odpowiedzi kod wywołuje <xref:System.Web.HttpRequest.MapPath%2A> metodę, aby uzyskać ścieżkę bezwzględną do `TestFile.txt` pliku tekstowego, który służy jako źródło zawartości odpowiedzi. Następnie kod tworzy nowy <xref:System.IO.StreamReader> obiekt, aby odczytać plik tekstowy z początku do końca, a następnie <xref:System.Web.HttpResponse.Write%2A> wywołuje metodę, aby wyświetlić zawartość pliku na stronie.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Filtrowanie nie jest dozwolone w przypadku jednostki.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wysyła do klienta wszystkie aktualnie buforowane dane wyjściowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wymusza wysłanie wszystkich buforowanych danych wyjściowych do klienta. <xref:System.Web.HttpResponse.Flush%2A> Metodę można wywołać wiele razy podczas przetwarzania żądania.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Drawing.Graphics.Save%2A> metodę w celu <xref:System.Drawing.Bitmap> zapisania obiektu do <xref:System.Web.HttpResponse.OutputStream%2A> właściwości i konwertuje obraz do formatu JPEG. Następnie kod wywołuje `Dispose` metodę <xref:System.Drawing.Bitmap> dla obiektu i <xref:System.Drawing.Graphics> obiektu, zwalniając zasoby, których używa. Następnie wywołuje <xref:System.Web.HttpResponse.Flush%2A> metodę w celu wysłania treści odpowiedzi do żądającego klienta.  
  
 Pełny przykład można znaleźć w <xref:System.Web.HttpResponse> klasie.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Pamięć podręczna jest opróżniana po wysłaniu odpowiedzi.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie wysyła wszystkie aktualnie buforowane dane wyjściowe do klienta.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> Reprezentuje operację asynchroniczną.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.Encoding" /> obiekt reprezentujący kodowanie dla bieżącego strumienia wyjściowego nagłówka.</summary>
        <value><see cref="T:System.Text.Encoding" /> Zawierający informacje o zestawie znaków dla bieżącego nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> <xref:System.Text.ASCIIEncoding> <xref:System.Text.UTF7Encoding> <xref:System.Text.UTF8Encoding> Właściwość daje możliwość wyłączenia lub <xref:System.Text.Encoding> zmiany obiektu w nagłówku odpowiedzi przy użyciu obiektu,,, lub. <xref:System.Web.HttpResponse.HeaderEncoding%2A> Domyślną wartością kodowania jest <xref:System.Text.UTF8Encoding> Klasa.  
  
 Zmiana typu <xref:System.Web.HttpResponse.HeaderEncoding%2A> właściwości może potencjalnie zwiększyć ryzyko pewnych złośliwych ataków lub spowodować wysłanie poufnych danych za pomocą nagłówka odpowiedzi. Ataki przed iniekcją nagłówka można uniknąć, w części, pozostawiając <xref:System.Web.HttpResponse.HeaderEncoding%2A> Właściwość odpowiedzi do ustawienia domyślnego. Atak w odniesieniu do zagrożonej aplikacji może spowodować, że dane zostały powierzone jako część nagłówka odpowiedzi. <xref:System.Web.HttpResponse.HeaderEncoding%2A> Jeśli jest wyłączone ze względu na wymaganie wierszy kontynuacji w nagłówku lub w przypadku skonstruowania dowolnego nagłówka w oparciu o wynik niezaufanych danych, należy sprawdzić poprawność danych nagłówka przed wysłaniem do strumienia odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość kodowania to <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Wartość kodowania to <see cref="P:System.Text.Encoding.Unicode" />.  
  
—lub— 
Nagłówki zostały już wysłane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję nagłówków odpowiedzi.</summary>
        <value>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> z nagłówków odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest obsługiwana tylko w [!INCLUDE[iisver](~/includes/iisver-md.md)] przypadku zintegrowanego trybu potokowego i co najmniej .NET Framework 3,0. <xref:System.Web.HttpResponse.Headers%2A> Gdy próbujesz uzyskać dostęp <xref:System.Web.HttpResponse.Headers%2A> do właściwości <xref:System.PlatformNotSupportedException> , a jeden z tych dwóch warunków nie jest spełniony, zostanie zgłoszony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Operacja wymaga zintegrowanego trybu potokowego w [!INCLUDE[iisver](~/includes/iisver-md.md)] i co najmniej .NET Framework w wersji 3,0.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=86952">Uaktualnianie aplikacji ASP.NET do usług IIS 7,0: Różnice między trybem zintegrowanym usług IIS 7,0 i trybem klasycznym</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy nagłówki odpowiedzi zostały zapisaniu.</summary>
        <value><see langword="true" />Jeśli nagłówki odpowiedzi zostały zapisaniu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy klient jest nadal połączony z serwerem.</summary>
        <value><see langword="true" />Jeśli klient jest aktualnie połączony; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość <xref:System.Web.HttpResponse.IsClientConnected%2A> zwraca`false` , gdy spełnione są następujące warunki:  
  
-   Połączenie z klientem zostało przerwane. Taka sytuacja może wystąpić, <xref:System.Web.HttpResponse.Close%2A> jeśli wywołana została metoda lub jeśli klient zatrzymał wykonywanie strony sieci Web lub przejdzie do przeglądania na innej stronie.  
  
-   Obiekt obsługujący żądanie jest `null` lub <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> zwraca `false`metodę. <xref:System.Web.HttpWorkerRequest> Jeśli obiekt niestandardowy <xref:System.Web.HttpWorkerRequest> obsługuje żądanie, <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> Metoda może być ustawiana na podstawie kryteriów niestandardowych. Na przykład żądanie niestandardowego procesu roboczego może wymusić przekroczenie limitu czasu po upływie określonego czasu.  
  
   
  
## Examples  
 Poniższy przykład używa właściwości, <xref:System.Web.HttpResponse.IsClientConnected%2A> aby sprawdzić, czy klient, który żąda strony, pozostaje połączony z serwerem. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> ma wartość true, kod <xref:System.Web.HttpResponse.Redirect%2A> wywołuje metodę, a klient zobaczy inną stronę. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> ma wartość false, kod <xref:System.Web.HttpResponse.End%2A> wywołuje metodę, a przetwarzanie wszystkich stron zostało zakończone.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość logiczną wskazującą, czy klient jest transferowany do nowej lokalizacji.</summary>
        <value><see langword="true" />Jeśli wartość nagłówka odpowiedzi lokalizacji jest inna niż bieżąca lokalizacja; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość z właściwością służy do testowania i ustalania, czy bezwzględny identyfikator URI, który jest przesyłany do `Location` klienta w nagłówku HTTP, jest inny niż bieżący identyfikator URI i jaki jest nowy zamierzony identyfikator URI <xref:System.Web.HttpResponse.RedirectLocation%2A> <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> przeniesiono do programu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Umożliwia wyjście tekstu do strumienia wychodzącej odpowiedzi HTTP.</summary>
        <value><see cref="T:System.IO.TextWriter" /> Obiekt, który umożliwia wykonywanie niestandardowych danych wyjściowych dla klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład to strona ASP.NET, która zawiera <xref:System.Web.UI.WebControls.TextBox> kontrolkę, która <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> ma ustawioną <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>właściwość. Kod strony przyjmuje tekst, który użytkownik wprowadza w programie <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, <xref:System.Web.HttpServerUtility.HtmlEncode%2A> używa metody do <xref:System.Web.HttpResponse.Output%2A> kodowania kodu HTML i właściwość do wyświetlania zakodowanego ciągu na stronie.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Włącza binarne dane wyjściowe do treści wychodzącej zawartości HTTP.</summary>
        <value>Operacja we <see cref="T:System.IO.Stream" /> /wy reprezentująca nieprzetworzoną zawartość wychodzącej treści http.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od .NET Framework w wersji 2,0, jeśli używasz <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody strumienia we/wy zwróconego <xref:System.Web.HttpResponse.OutputStream%2A> przez właściwość, mogą zostać zgłoszone następujące wyjątki:  
  
-   <xref:System.ArgumentOutOfRangeException>, jeśli `offset` `offset` lub `count` parametr`buffer` jest ujemny lub jeśli długość parametru minus parametr jest mniejsza lub równa zero.  
  
-   <xref:System.ArgumentNullException>, jeśli `buffer` parametr ma wartość `null`.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Drawing.Image.Save%2A> metodę w celu <xref:System.Drawing.Bitmap> zapisania obiektu do <xref:System.Web.HttpResponse.OutputStream%2A> właściwości i konwertuje obraz do formatu JPEG. Następnie kod wywołuje metodę Dispose dla <xref:System.Drawing.Bitmap> obiektu <xref:System.Drawing.Graphics> i obiektu, zwalniając zasoby, których używa. Na koniec kod wywołuje <xref:System.Web.HttpResponse.Flush%2A> metodę w celu wysłania treści odpowiedzi do żądającego klienta.  
  
 Pełny przykład można znaleźć w <xref:System.Web.HttpResponse> klasie.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="OutputStream" />jest niedostępny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg, który ma zostać dodany <see langword="PICS-Label" /> do nagłówka.</param>
        <summary>Dołącza nagłówek HTTP <see langword="PICS-Label" /> do strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Platforma do wyboru zawartości internetowej (PICS) to organizacja World Wide Web Consortium (W3C) standard dla etykietowania zawartości. PICS jest zasadniczo językiem do tworzenia systemu klasyfikacji.  
  
 Dowolną wartością może być etykieta PICS; ASP.NET nie weryfikuje etykiety. Maksymalna długość ciągu to 255 znaków. Aby uzyskać więcej informacji na temat standardów i składni PICS, zobacz witrynę sieci Web [organizacja World Wide Web Consortium](https://go.microsoft.com/fwlink/?LinkID=37125) .  
  
   
  
## Examples  
 Poniższy przykład to strona ASP.NET, która wyświetla obraz. Kod strony wywołuje metodę, <xref:System.Web.HttpResponse.Pics%2A> aby ustawić nagłówek HTTP `PICS-Label` dla odpowiedzi. Ciąg, który jest przesyłany jako parametr do <xref:System.Web.HttpResponse.Pics%2A> metody reprezentuje etykietę klasyfikacji wygenerowaną w witrynie sieci Web skojarzenia zawartości internetowej (ICRA).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Promuje obiekt przyrzeczonych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Adres URL żądania wypychania. Powinna to być ścieżka wirtualna względnych zasobów, którą serwer chce wypchnąć do klienta.</param>
        <summary>Ten interfejs API obsługuje aplikacje wysyłające wypychanie niesie obietnice zwiększenia do klientów HTTP 2,0. Więcej szczegółów dotyczących programu Http2 Server push można znaleźć w <see href="https://http2.github.io/http2-spec/#PushResources">sekcji specyfikacji protokołu HTTP/2 8,2: Wypychanie</see>serwera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise jest niedeterministyczny, a aplikacje nie powinny mieć logiki zależnej od niej. Jedynym celem jest wykorzystanie wydajności w niektórych przypadkach. Istnieje wiele warunków (protokołu i implementacji), które mogą spowodować całkowite zignorowanie żądań wypychania. Oczekiwana jest oparta na ogniu i zapomnieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="2" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Adres URL żądania wypychania. Powinna to być ścieżka wirtualna względnych zasobów, którą serwer chce wypchnąć do klienta.</param>
        <param name="method">Metoda żądania HTTP, która będzie używana przez żądanie push.</param>
        <param name="headers">Nagłówek żądania HTTP, który będzie używany przez żądanie wypychania.</param>
        <summary>Ten interfejs API obsługuje aplikacje wysyłające wypychanie niesie obietnice zwiększenia do klientów HTTP 2,0. Więcej szczegółów dotyczących programu Http2 Server push można znaleźć w <see href="https://http2.github.io/http2-spec/#PushResources">sekcji specyfikacji protokołu HTTP/2 8,2: Wypychanie</see>serwera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise jest niedeterministyczny, a aplikacje nie powinny mieć logiki zależnej od niej. Jedynym celem jest wykorzystanie wydajności w niektórych przypadkach. Istnieje wiele warunków (protokołu i implementacji), które mogą spowodować całkowite zignorowanie żądań wypychania. Oczekiwana jest oparta na ogniu i zapomnieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekierowuje klienta do nowego adresu URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacja docelowa. Może to być ścieżka wirtualna względna w stosunku do aplikacji.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL i określa nowy adres URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Web.HttpResponse.Redirect%2A> jest równoważne wywołaniu <xref:System.Web.HttpResponse.Redirect%2A> z drugim parametrem ustawionym na `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A>wywołania <xref:System.Web.HttpResponse.End%2A> , które <xref:System.Threading.ThreadAbortException> zgłaszają wyjątek po zakończeniu. Ten wyjątek ma szkodliwy wpływ na wydajność aplikacji sieci Web. W związku z tym zaleca się, aby zamiast tego przeciążenia użyć <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenia i przekazać `false` `endResponse` parametr, a następnie wywołać <xref:System.Web.HttpApplication.CompleteRequest%2A> metodę. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpResponse.End%2A> metodę.  
  
> [!NOTE]
>  Tylko w przypadku stron mobilnych, jeśli aplikacja korzysta z sesji bez plików cookie lub może odbierać żądania z urządzeń przenośnych, które wymagają sesji bez plików cookie, przy użyciu tyldy (\~) w ścieżce może spowodować utworzenie nowej sesji i potencjalnie utraty sesji Data. Aby ustawić właściwość dla kontrolki mobilnej z ścieżką, taką jak\~"/Path", należy rozwiązać ścieżkę <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> przy\~użyciu "/Path" przed przypisaniem jej do właściwości.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302. Alternatywnym sposobem przetransferowania kontroli na inną stronę jest <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda. Metoda <xref:System.Web.HttpServerUtility.Transfer%2A> jest zwykle bardziej wydajna, ponieważ nie powoduje przejazdu klientowi. Aby uzyskać więcej informacji, zobacz [jak: Przekieruj użytkowników na inną](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e)stronę.  
  
   
  
## Examples  
 W poniższym przykładzie wymuszane jest bezwarunkowe przekierowanie do innej witryny sieci Web.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacja docelowa.</param>
        <param name="endResponse">Wskazuje, czy wykonywanie bieżącej strony powinno kończyć się.</param>
        <summary>Przekierowuje klienta do nowego adresu URL. Określa nowy adres URL i wskazuje, czy wykonywanie bieżącej strony powinno kończyć się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezwzględny adres URL (na `http://www.contoso.com/default.aspx`przykład) lub względny adres URL (na przykład Default. aspx) można określić dla lokalizacji docelowej, ale niektóre przeglądarki mogą odrzucić względny adres URL.  
  
 W przypadku użycia tej metody w obsłudze strony do zakończenia żądania dla jednej strony i uruchomienia nowego żądania dla innej strony ustaw wartość `endResponse` `false` , a następnie Wywołaj <xref:System.Web.HttpApplication.CompleteRequest%2A> metodę. Jeśli określisz `true` `endResponse` dla parametru <xref:System.Web.HttpResponse.End%2A> , ta metoda wywoła metodę <xref:System.Threading.ThreadAbortException> dla oryginalnego żądania, która zgłasza wyjątek po zakończeniu. Ten wyjątek ma szkodliwy wpływ na wydajność aplikacji sieci Web, co oznacza, że `false` zaleca się `endResponse` przekazywanie parametrów. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpResponse.End%2A> metodę.  
  
> [!NOTE]
>  W przypadku stron mobilnych, jeśli aplikacja korzysta z sesji bez plików cookie lub mogą otrzymywać żądania z urządzeń przenośnych, które wymagają sesji bez plików cookie, przy użyciu tyldy (\~) w ścieżce można utworzyć nową sesję i potencjalnie utracić dane sesji. Aby ustawić właściwość dla kontrolki mobilnej z ścieżką, taką jak\~"/Path", należy rozwiązać ścieżkę <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> przy\~użyciu "/Path" przed przypisaniem jej do właściwości.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302. Alternatywnym sposobem przetransferowania kontroli na inną stronę jest <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda. Metoda <xref:System.Web.HttpServerUtility.Transfer%2A> jest zwykle bardziej wydajna, ponieważ nie powoduje przejazdu klientowi. Aby uzyskać więcej informacji, zobacz [jak: Przekieruj użytkowników na inną](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e)stronę.  
  
   
  
## Examples  
 Poniższy przykład używa właściwości, <xref:System.Web.HttpResponse.IsClientConnected%2A> aby sprawdzić, czy klient, który żąda strony, pozostaje połączony z serwerem. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> ma wartość true, kod <xref:System.Web.HttpResponse.Redirect%2A> wywołuje metodę, a klient zobaczy inną stronę. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> ma wartość false, kod <xref:System.Web.HttpResponse.End%2A> wywołuje metodę, a przetwarzanie wszystkich stron zostało zakończone.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" />zawiera znak nowego wiersza.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <exception cref="T:System.ApplicationException">Żądanie strony jest wynikiem wywołania zwrotnego.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość nagłówka HTTP <see langword="Location" /> .</summary>
        <value>Bezwzględny identyfikator URI, który jest przesyłany do klienta <see langword="Location" /> w nagłówku HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak używać tej właściwości, aby określić adres URL przekierowania podczas tworzenia kodu stałego przekierowania przy użyciu kodu odpowiedzi HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nagłówki HTTP zostały już zapisaniu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje stałe przekierowanie z żądanego adresu URL do określonego adresu URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacja, do której ma zostać przekierowany żądanie.</param>
        <summary>Wykonuje stałe przekierowanie z żądanego adresu URL do określonego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> metody zapewnia kod stanu HTTP 301 w odpowiedzi i zawiera adres URL do przekierowania żądania do. Kod stanu HTTP 301 jest standardowym kodem w odpowiedzi HTTP. Wskazuje, że istnieje stałe przekierowanie i zawiera lokalizację przekierowania.  
  
 Wywołanie przeciążenia <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> metody przerywa odpowiedź.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" />zawiera znak nowego wiersza (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="endResponse" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacja, do której ma zostać przekierowany żądanie.</param>
        <param name="endResponse"><see langword="true" />Aby przerwać odpowiedź; w <see langword="false" />przeciwnym razie. Wartość domyślna to <see langword="false" />.</param>
        <summary>Wykonuje stałe przekierowanie z żądanego adresu URL do określonego adresu URL i udostępnia opcję ukończenia odpowiedzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metody zapewnia kod stanu HTTP 301 w odpowiedzi i zawiera adres URL do przekierowania żądania do. To Przeciążenie metody zapewnia również opcję, aby określić, czy zakończyć czy zakończyć odpowiedź po przekierowaniu. Kod stanu HTTP 301 jest standardowym kodem w odpowiedzi HTTP. Wskazuje, że istnieje stałe przekierowanie i zawiera lokalizację przekierowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" />zawiera znak nowego wiersza (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametrów trasy, nazwy trasy lub obu tych elementów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL za pomocą wartości parametrów trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest równoważne wywołaniu <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda konwertuje obiekt, który jest przesyłany `routeValues` <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> do obiektu za pomocą <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Metoda jest następnie wywoływana w celu określenia adresu URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy mającej parametry o nazwach `productid` i `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa nie odpowiada określonym parametrom trasy.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest równoważne wywołaniu <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda konwertuje nazwę trasy, która jest przenoszona `routeName` do adresu URL przy <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> użyciu metody.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy o nazwie `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa nie odpowiada określonym parametrom trasy.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL za pomocą wartości parametrów trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest równoważne wywołaniu <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda wywołuje <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodę w celu określenia adresu URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy mającej parametry o nazwach `productid` i `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa nie odpowiada określonym parametrom trasy.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametrów trasy i nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest równoważne wywołaniu <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda konwertuje obiekt, który jest przesyłany `routeValues` <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> do obiektu za pomocą <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Metoda jest następnie wywoływana w celu określenia adresu URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy o nazwie `Product` i, która ma parametry o nazwach `productid` i. `category`  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa nie odpowiada określonym parametrom trasy.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametrów trasy i nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest równoważne wywołaniu <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Metoda jest wywoływana w celu określenia adresu URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy o nazwie `Product` i, która ma parametry o nazwach `productid` i. `category`  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa nie odpowiada określonym parametrom trasy.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje stałe przekierowanie z żądanego adresu URL do nowego adresu URL za pomocą wartości parametrów trasy, nazwy trasy lub obu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje stałe przekierowanie z żądanego adresu URL do nowego adresu URL za pomocą wartości parametrów trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest równoważne wywołaniu <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda konwertuje obiekt, który jest przesyłany `routeValues` <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> do obiektu za pomocą <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Metoda jest następnie wywoływana w celu określenia adresu URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy mającej parametry o nazwach `productid` i `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa nie odpowiada określonym parametrom trasy.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <summary>Wykonuje stałe przekierowanie z żądanego adresu URL do nowego adresu URL przy użyciu nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest równoważne wywołaniu <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda konwertuje nazwę trasy, która jest przenoszona `routeName` do adresu URL przy <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> użyciu metody.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy o nazwie `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa nie odpowiada określonym parametrom trasy.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje stałe przekierowanie z żądanego adresu URL do nowego adresu URL za pomocą wartości parametrów trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest równoważne wywołaniu <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda wywołuje <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodę w celu określenia adresu URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy mającej parametry o nazwach `productid` i `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa nie odpowiada określonym parametrom trasy.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje stałe przekierowanie z żądanego adresu URL do nowego adresu URL przy użyciu wartości parametrów trasy i nazwy trasy odpowiadającej nowemu adresowi URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest równoważne wywołaniu <xref:System.Web.HttpResponse.RedirectPermanent%2A> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda konwertuje obiekt, który jest przesyłany `routeValues` <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> do obiektu za pomocą <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Metoda jest następnie wywoływana w celu określenia adresu URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy o nazwie `Product` i, która ma parametry o nazwach `productid` i. `category`  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa nie odpowiada określonym parametrom trasy.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje stałe przekierowanie z żądanego adresu URL do nowego adresu URL przy użyciu wartości parametrów trasy i nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest równoważne wywołaniu <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawionym na `false`.  
  
 Ta metoda wywołuje <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodę w celu określenia adresu URL.  
  
 ASP.NET wykonuje przekierowanie, zwracając kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać tę metodę w celu przekierowania do trasy o nazwie `Product` i, która ma parametry o nazwach `productid` i. `category`  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa nie odpowiada określonym parametrom trasy.</exception>
        <exception cref="T:System.Web.HttpException">Podjęto próbę przekierowania po wysłaniu nagłówków HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa elementy buforowane z wyjściowej pamięci podręcznej przy użyciu domyślnego dostawcy wyjściowej pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Wirtualna ścieżka bezwzględna do elementów, które są usuwane z pamięci podręcznej.</param>
        <summary>Usuwa z pamięci podręcznej wszystkie elementy buforowane, które są skojarzone z domyślnym dostawcą wyjściowej pamięci podręcznej. Ta metoda jest statyczna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z domyślnym dostawcą wyjściowej pamięci podręcznej. Wywołaj <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> metodę, aby usunąć elementy pamięci podręcznej, które są skojarzone z niestandardowymi dostawcami pamięci podręcznej danych wyjściowych, które są określone w pliku konfiguracyjnym witryny sieci Web.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />nie jest bezwzględną ścieżką wirtualną.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="providerName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Wirtualna ścieżka bezwzględna elementów usuniętych z pamięci podręcznej.</param>
        <param name="providerName">Dostawca służący do usuwania artefaktów pamięci podręcznej danych wyjściowych, które są skojarzone z określoną ścieżką.</param>
        <summary>Używa określonego dostawcy wyjściowej pamięci podręcznej, aby usunąć wszystkie elementy pamięci podręcznej, które są skojarzone z określoną ścieżką.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z niestandardowymi dostawcami pamięci podręcznej, które są określone w pliku konfiguracyjnym witryny sieci Web. Aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z domyślnym dostawcą pamięci podręcznej danych wyjściowych, wywołaj <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> Przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />ma wartość null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest nieprawidłową ścieżką.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Plik cookie w kolekcji, który ma zostać zaktualizowany.</param>
        <summary>Ponieważ metoda <b>HttpResponse. setcooka</b> jest przeznaczona wyłącznie do użytku wewnętrznego, nie należy wywoływać jej w kodzie. Zamiast tego można wywołać metodę <b>HttpResponse. cookies. Set</b> , jak pokazano w poniższym przykładzie.<br /> Aktualizuje istniejący plik cookie w kolekcji plików cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład aktualizuje wartość istniejącego pliku cookie.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Podjęto próbę ustawienia pliku cookie po wysłaniu nagłówków HTTP.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="Status" /> Ustawia wiersz, który jest zwracany do klienta.</summary>
        <value>Ustawienie kodu stanu powoduje, że ciąg opisujący stan danych wyjściowych HTTP do zwrócenia do klienta. Wartość domyślna to 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A>został uznany za przestarzały <xref:System.Web.HttpResponse.StatusDescription%2A> i jest dostępny tylko w celu zapewnienia zgodności z wcześniejszymi wersjami ASP. Przy użyciu ASP.NET zamiast <xref:System.Web.HttpResponse.StatusDescription%2A> tego użyj.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Stan jest ustawiony na nieprawidłowy kod stanu.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod stanu HTTP danych wyjściowych zwracanych do klienta.</summary>
        <value>Liczba całkowita reprezentująca stan danych wyjściowych HTTP zwróconych do klienta. Wartość domyślna to 200 (OK). Aby uzyskać listę prawidłowych kodów stanu, zobacz <see href="/windows/win32/winhttp/http-status-codes">kody stanu HTTP</see>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza kod stanu strumienia wyjściowego. Jeśli kod stanu nie jest równy 200, zostanie wykonany dodatkowy kod.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.HttpResponse.StatusCode" />jest ustawiany po wysłaniu nagłówków HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg stanu HTTP zwróconych danych wyjściowych do klienta.</summary>
        <value>Ciąg opisujący stan danych wyjściowych HTTP zwróconych do klienta. Wartość domyślna to "OK". Aby uzyskać listę prawidłowych kodów stanu, zobacz [kody stanu HTTP](https://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza ciąg stanu strumienia wyjściowego. Jeśli stan nie jest równy "OK", zostanie wykonany dodatkowy kod.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="StatusDescription" />jest ustawiany po wysłaniu nagłówków HTTP.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wybrana wartość ma długość większą niż 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość kwalifikującą kod stanu odpowiedzi.</summary>
        <value>Wartość całkowita reprezentująca [!INCLUDE[iisver](~/includes/iisver-md.md)] kod stanu podrzędnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest obsługiwana tylko w trybie zintegrowanego potoku w [!INCLUDE[iisver](~/includes/iisver-md.md)] systemie i co najmniej .NET Framework w wersji 3,0. <xref:System.Web.HttpResponse.SubStatusCode%2A> Po ustawieniu <xref:System.Web.HttpResponse.SubStatusCode%2A> właściwości stan jest [!INCLUDE[iisver](~/includes/iisver-md.md)] zarejestrowana, jeśli skonfigurowano śledzenie żądań. Niezależnie od tego, czy śledzenie jest skonfigurowane, kod nigdy nie jest wysyłany jako część odpowiedzi końcowej do żądania. Aby uzyskać więcej informacji, zobacz Rozwiązywanie problemów z nieudanymi żądaniami [przy użyciu śledzenia nieudanych żądań w usługach IIS 7,0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Web.HttpResponse.SubStatusCode%2A> właściwość w programie obsługi zdarzeń <xref:System.Web.HttpApplication> dla wystąpienia <xref:System.Web.HttpApplication.PostAuthenticateRequest> zdarzenia. Umieść plik kodu w folderze App_Code aplikacji sieci Web i Skonfiguruj plik Web. config w celu zarejestrowania modułu. Aby uzyskać więcej informacji, [zobacz Przewodnik: Tworzenie i rejestrowanie niestandardowego modułu](https://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453)http.  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Operacja wymaga zintegrowanego trybu potokowego w [!INCLUDE[iisver](~/includes/iisver-md.md)] i co najmniej .NET Framework w wersji 3,0.</exception>
        <exception cref="T:System.Web.HttpException">Kod stanu jest ustawiany po wysłaniu wszystkich nagłówków HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy połączenie obsługuje asynchroniczne operacje opróżniania.</summary>
        <value><see langword="true" />Jeśli połączenie obsługuje asynchroniczne operacje opróżniania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do klienta ma być wysyłana zawartość protokołu HTTP.</summary>
        <value><see langword="true" />Aby pominąć dane wyjściowe; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza, czy <xref:System.Web.HttpRequest.IsSecureConnection%2A> właściwość jest ustawiona na false. Jeśli tak jest, <xref:System.Web.HttpResponse.SuppressContent%2A> właściwość jest ustawiona na wartość true, aby zatrzymać wysyłanie odpowiedzi.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy pominąć domyślną kontrolkę <c>pamięci podręcznej: nagłówek prywatny</c> dla bieżącej odpowiedzi HTTP.</summary>
        <value><see langword="true" />Aby pominąć domyślny <c>formant pamięci podręcznej: prywatny</c> nagłówek bieżącej odpowiedzi http; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ASP.NET wysyła `Cache-Control: private` nagłówek odpowiedzi, chyba że dla tej odpowiedzi określono jawne zasady pamięci podręcznej. Ta właściwość umożliwia pominięcie tego domyślnego nagłówka odpowiedzi dla poszczególnych żądań. Nagłówek można nadal pominąć dla całej aplikacji przez ustawienie <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> w [elemencie httpRuntime (Schemat ustawień ASP.NET)](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) lub [element OutputCache dla buforowania (Schemat ustawień ASP.NET)](https://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Należy zachować ostrożność podczas pomijania `Cache-Control: private` domyślnego nagłówka, ponieważ proxy i inne pośredników mogą traktować odpowiedzi bez tego nagłówka jako pamięci podręcznej. Takie podejście może prowadzić do przypadkowego buforowania poufnych informacji. Aby uzyskać więcej informacji [, zobacz RFC 2616, sek. 13,4](https://tools.ietf.org/html/rfc2616) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy przekierowywanie uwierzytelniania formularzy do strony logowania powinno być pomijane.</summary>
        <value><see langword="true" />Jeśli przekierowanie uwierzytelniania formularzy powinno być pomijane; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie uwierzytelnianie formularzy Konwertuje kody stanu HTTP 401 na 302 w celu przekierowania na stronę logowania. Nie jest to odpowiednie dla niektórych klas błędów, takich jak w przypadku pomyślnego uwierzytelnienia, ale autoryzacja nie powiedzie się lub gdy bieżące żądanie jest żądanie AJAX lub usługi sieci Web. Ta właściwość umożliwia pominięcie zachowania przekierowania i wysłanie oryginalnego kodu stanu do klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje określony plik bezpośrednio do strumienia wyjściowego odpowiedzi HTTP bez buforowania go w pamięci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w danych wyjściowych protokołu HTTP.</param>
        <summary>Zapisuje określony plik bezpośrednio do strumienia wyjściowego odpowiedzi HTTP, bez buforowania go w pamięci.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> Parametr jest<see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w danych wyjściowych protokołu HTTP.</param>
        <param name="offset">Pozycja w pliku, która rozpocznie zapisywanie w danych wyjściowych protokołu HTTP.</param>
        <param name="length">Liczba bajtów do przesłania.</param>
        <summary>Zapisuje określoną część pliku bezpośrednio do strumienia wyjściowego odpowiedzi HTTP bez buforowania go w pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku określenia wartości 0 jako `offset` parametru i-1 `length` jako parametru zostanie wysłany cały plik.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="offset" /> Parametr jest mniejszy od zera.  
  
—lub— 
<paramref name="length" /> Parametr jest mniejszy niż-1.  
  
—lub— 
<paramref name="length" /> Parametr określa liczbę bajtów, która jest większa niż liczba bajtów, które plik zawiera minus przesunięcia.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Pozaprocesowe żądanie procesu roboczego nie jest obsługiwane.  
  
—lub— 
Odpowiedź nie używa <see cref="T:System.Web.HttpWriter" /> obiektu.</exception>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="offset" /> parametru jest mniejsza od zera lub większa niż rozmiar pliku.  
  
—lub— 
Parametr jest mniejszy niż-1 lub większy niż wartość <paramref name="offset" /> parametru oraz rozmiar pliku. <paramref name="length" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy [!INCLUDE[iisver](~/includes/iisver-md.md)] błędy niestandardowe są wyłączone.</summary>
        <value><see langword="true" />Aby wyłączyć niestandardowe błędy usługi IIS; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> Właściwość jest używana tylko wtedy, gdy aplikacja jest hostowana w usługach IIS 7,0 i nowszych. W przypadku uruchamiania w trybie <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> klasycznym wartość domyślna właściwości to. `true` W przypadku uruchamiania w trybie <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> zintegrowanym wartość domyślna właściwości to. `false`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje informacje w strumieniu wyjściowym odpowiedzi HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Znak do zapisu w strumieniu wyjściowym protokołu HTTP.</param>
        <summary>Zapisuje znak w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy serię stałych, które są zapisywane na stronie ASP.NET przy użyciu metody Write. Kod wywołuje tę wersję metody zapisu w celu zapisywania pojedynczych znaków stałych na stronie.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Object" /> Do zapisu w strumieniu wyjściowym protokołu HTTP.</param>
        <summary><see cref="T:System.Object" /> Zapisuje w strumieniu odpowiedzi HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg do zapisu w strumieniu wyjściowym protokołu HTTP.</param>
        <summary>Zapisuje ciąg w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamicznie generowane strony HTML mogą wprowadzać zagrożenia bezpieczeństwa, jeśli dane wejściowe odebrane od klientów sieci Web nie są zweryfikowane po odebraniu od klienta lub po przesłaniu ich z powrotem do klienta. Złośliwy skrypt osadzony w danych wejściowych przesyłanych do witryny sieci Web i późniejszym zapisaniu go na komputerze klienckim może wydawać się pochodzi z zaufanego źródła. To zagrożenie bezpieczeństwa jest określane jako atak skryptowy między lokacjami. Należy zawsze sprawdzać poprawność danych odbieranych od klienta, gdy zostanie on przesłany z witryny do przeglądarki klienta.  
  
 Ponadto za każdym razem, gdy piszesz jako plik HTML wszystkie dane, które zostały odebrane jako dane wejściowe, należy zakodować <xref:System.Web.HttpServerUtility.HtmlEncode%2A> je <xref:System.Web.HttpServerUtility.UrlEncode%2A> przy użyciu techniki, takiej jak lub, aby zapobiec wykonywaniu złośliwego skryptu. Ta technika jest przydatna w przypadku danych, które nie zostały zweryfikowane po odebraniu.  
  
 Podczas kodowania lub filtrowania danych, należy określić zestaw znaków dla stron sieci Web, aby filtr mógł identyfikować i usuwać sekwencje bajtów, które nie należą do tego zestawu (na przykład sekwencje inne niż alfanumeryczne) i mogą potencjalnie mieć złośliwy skrypt osadzony w niego.  
  
 Aby uzyskać więcej informacji o atakach na skrypty między lokacjami, zobacz artykuł Q252985 "jak zapobiegać problemom z zabezpieczeniami skryptów między lokacjami" w witrynie sieci Web [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?LinkID=37115) .  
  
   
  
## Examples  
 Poniższy przykład zwraca nazwę klienta z powrotem do przeglądarki klienta. Metoda przypasa wszelkich złośliwych skryptów i nieprawidłowych znaków, które mogły zostać `UserName` przesłane w polu wejściowym. <xref:System.Web.HttpServerUtility.HtmlEncode%2A>  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków do zapisania.</param>
        <param name="index">Pozycja w tablicy znaków, w której rozpocznie się pisanie.</param>
        <param name="count">Liczba znaków do zapisu, rozpoczynając <paramref name="index" />od.</param>
        <summary>Zapisuje tablicę znaków w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy serię stałych, które są zapisywane na stronie ASP.NET przy użyciu metody Write. Kod wywołuje tę wersję metody zapisu w celu zapisywania pojedynczych znaków stałych na stronie.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje określony plik bezpośrednio do strumienia wyjściowego odpowiedzi HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w danych wyjściowych protokołu HTTP.</param>
        <summary>Zapisuje zawartość określonego pliku bezpośrednio do strumienia wyjściowego odpowiedzi HTTP jako blok pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany z tą metodą, zależy od konfiguracji sprzętowej serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406 "PRB: Odpowiedź. WriteFile nie może pobrać dużego pliku "w witrynie sieci Web [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) .  
  
   
  
## Examples  
 Poniższy przykład zapisuje całą zawartość pliku tekstowego o nazwie `Login.txt` (który może zawierać literał tekstu HTML i kontrolki wprowadzania) bezpośrednio do strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="filename" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w bloku pamięci.</param>
        <param name="readIntoMemory">Wskazuje, czy plik zostanie zapisany w bloku pamięci.</param>
        <summary>Zapisuje zawartość określonego pliku bezpośrednio do strumienia wyjściowego odpowiedzi HTTP jako blok pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany z tą metodą, zależy od konfiguracji sprzętowej serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406 "PRB: Odpowiedź. WriteFile nie może pobrać dużego pliku "w witrynie sieci Web [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) .  
  
   
  
## Examples  
 Poniższy przykład zapisuje plik w pamięci.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="filename" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Dojście do pliku do zapisu w strumieniu wyjściowym protokołu HTTP.</param>
        <param name="offset">Pozycja bajtu w pliku, w którym rozpocznie się zapisywanie.</param>
        <param name="size">Liczba bajtów do zapisu w strumieniu wyjściowym.</param>
        <summary>Zapisuje określony plik bezpośrednio do strumienia wyjściowego odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany z tą metodą, zależy od konfiguracji sprzętowej serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406 "PRB: Odpowiedź. WriteFile nie może pobrać dużego pliku "w witrynie sieci Web [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) .  
  
   
  
## Examples  
 Poniższy przykład zapisuje całą zawartość pliku tekstowego o nazwie `Login.txt` (który może zawierać literał tekstu HTML i kontrolki wprowadzania) bezpośrednio do strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileHandler" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większy niż rozmiar pliku minus <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w strumieniu wyjściowym protokołu HTTP.</param>
        <param name="offset">Pozycja bajtu w pliku, w którym rozpocznie się zapisywanie.</param>
        <param name="size">Liczba bajtów do zapisu w strumieniu wyjściowym.</param>
        <summary>Zapisuje określony plik bezpośrednio do strumienia wyjściowego odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany z tą metodą, zależy od konfiguracji sprzętowej serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406 "PRB: Odpowiedź. WriteFile nie może pobrać dużego pliku "w witrynie sieci Web [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) .  
  
   
  
## Examples  
 Poniższy przykład zapisuje całą zawartość pliku tekstowego o nazwie `Login.txt` (który może zawierać tekst literału i kontrolki wprowadzania html) bezpośrednio do strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większy niż rozmiar pliku minus <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="filename" /></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda, kontrolka użytkownika lub obiekt, który ma zostać zastąpiony.</param>
        <summary>Umożliwia wstawianie bloków podstawienia odpowiedzi do odpowiedzi, co umożliwia dynamiczną generację określonych regionów odpowiedzi dla wyjściowych odpowiedzi w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Web.HttpResponse.WriteSubstitution%2A> metody podstawiania po pamięci podręcznej na stronach ze zbuforowanym wyjściem. Przekazując <xref:System.Web.HttpContext> obiekt do metody wywołania zwrotnego z określonym <xref:System.Web.HttpResponseSubstitutionCallback> podpisem, można zamienić wyjściową zawartość z pamięci podręcznej w dowolnym miejscu na stronie cache. Aby zainicjować zastępowanie, wywołaj <xref:System.Web.HttpResponse.WriteSubstitution%2A> metodę, przekazując ją do metody wywołania zwrotnego, która musi być bezpieczna dla wątków i może być jedną z następujących wartości:  
  
-   Statyczna metoda na stronie kontenera lub kontrolce użytkownika.  
  
-   Statyczna lub metoda wystąpienia dla innego dowolnego obiektu.  
  
 Na pierwsze żądanie do strony <xref:System.Web.HttpResponse.WriteSubstitution%2A> <xref:System.Web.HttpResponseSubstitutionCallback> wywołuje delegata w celu wygenerowania danych wyjściowych. Następnie dodaje bufor podstawiania do odpowiedzi, który zachowuje delegata do wywoływania w przyszłych żądaniach. Na koniec obniża ona pamięć podręczną po stronie klienta wyłącznie do serwera, dzięki czemu w przyszłości żądania do strony ponownie wywołują delegata, nie buforowania na kliencie.  
  
> [!NOTE]
>  Podstawianie pamięci podręcznej nie jest obsługiwane w przypadku buforowanej kontrolki użytkownika, w której na poziomie kontroli użytkownika jest stosowane buforowanie danych wyjściowych. Jest to również nazywane buforowaniem fragmentów. Aby uzyskać więcej informacji, zobacz [buforowanie części strony ASP.NET](https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Obiekt docelowy <paramref name="callback" /> parametru jest typu <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://msdn.microsoft.com/library/d5fbd79f-972d-4557-9a39-f90684b3dcd3">Ustawianie buforowania strony</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e">Buforowanie części strony ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/09c9bd9a-0d68-4a5c-aa6f-1b461c208795">Dynamiczne aktualizowanie części buforowanej strony</related>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bc9053a9016410a8a9550724ce69fb24920f19d3" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36574655" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Hermetyzuje informacje o odpowiedzi HTTP z operacji programu ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody i właściwości <xref:System.Web.HttpResponse> klasy są dostępne za pośrednictwem <xref:System.Web.HttpApplication.Response%2A> właściwość <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, i <xref:System.Web.UI.UserControl> klasy.  
  
 Następujące metody <xref:System.Web.HttpResponse> klasy są obsługiwane tylko w scenariuszach post Wstecz i nie znajduje się w asynchronicznej post kopii scenariusze:  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Gdy używane są włączone aktualizacje stron częściowych <xref:System.Web.UI.UpdatePanel> formanty zaktualizować wybranych regionach strony zamiast aktualizowania ogłaszanie zwrotne całej strony. Aby uzyskać więcej informacji, zobacz [informacje o formancie UpdatePanel](http://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) i [omówienie renderowania stron częściowych](http://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 Poniższy przykład rysuje trzy prostokąty nakładające się, gdy strona zostanie wywołana. Kod, który rozpoczyna się przez ustawienie <xref:System.Web.HttpResponse.ContentType%2A> właściwości image/jpeg, dzięki czemu całej strony ma być odwzorowany jako obraz JPEG. Kod wywołuje <xref:System.Web.HttpResponse.Clear%2A> metody, aby upewnić się, że nadmiarowe zawartości nie są przesyłane z tej odpowiedzi. Następnie kod ustawia <xref:System.Web.HttpResponse.BufferOutput%2A> właściwości na wartość true, aby całkowicie przetwarzania strony przed wysłaniem do klienta. Następnie są tworzone dwa obiekty używany do rysowania prostokątów: <xref:System.Drawing.Bitmap> i <xref:System.Drawing.Graphics> obiektu. Zmienne utworzone na stronie są używane jako współrzędne Rysowanie prostokątów i ciąg, który pojawi się wewnątrz największy prostokąta.  
  
 Gdy są rysowane trzy prostokąty i ciąg, który pojawi się zawartych w nich <xref:System.Drawing.Bitmap> są zapisywane <xref:System.IO.Stream> obiektu, z którym skojarzony jest <xref:System.Web.HttpResponse.OutputStream%2A> właściwości i jego format jest ustawione na JPEG. Kod wywołuje <xref:System.Drawing.Image.Dispose%2A> i <xref:System.Drawing.Graphics.Dispose%2A> metody, aby zwolnić zasoby używane przez dwa obiekty rysowania. Ponadto kod wywołuje <xref:System.Web.HttpResponse.Flush%2A> do wysyłania buforowaną odpowiedź do klienta.  
  
> [!NOTE]
>  W kodzie <xref:System.Web.HttpResponse> obiekt odwołuje się do słowa kluczowego `Response`. Na przykład `Response.Clear()` odwołuje się do <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> metody. <xref:System.Web.UI.Page> Klasa ma właściwości o nazwie <xref:System.Web.UI.Page.Response%2A> który uwidacznia bieżące wystąpienie klasy <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.IO.TextWriter" /> obiekt, który umożliwia niestandardowych wyniku HTTP.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.HttpResponse" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski obsługuje infrastrukturę programu .NET Framework i nie jest przeznaczony do użycia bezpośrednio w kodzie.  
  
 Metody i właściwości <xref:System.Web.HttpResponse> klasy są dostępne za pośrednictwem wewnętrznego <xref:System.Web.HttpContext.Response%2A> obiektu w programie ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">Plik, klucz pamięci podręcznej lub <see cref="T:System.Web.Caching.CacheDependency" /> do dodania do listy zależności aplikacji.</param>
        <summary>Kojarzy zestaw zależności w pamięci podręcznej z odpowiedzią ułatwiające unieważniania odpowiedzi, jeśli jest ona przechowywana w wyjściowej pamięci podręcznej i zmienić określonej zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddCacheDependency%2A> Metoda pozwala zależności, które można utworzyć między buforowane odpowiedzi i <xref:System.Web.Caching.CacheDependency> obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć zależności pamięci podręcznej za pomocą <xref:System.Web.HttpResponse.AddCacheDependency%2A> — metoda i <xref:System.Web.Caching.CacheDependency> obiektu.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencies" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana za późno w potoku przetwarzania w pamięci podręcznej, po buforowanej odpowiedzi został już utworzony.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawia, że ważności buforowaną odpowiedź zależny od innych elementów w pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">
          <see cref="T:System.Collections.ArrayList" /> Zawierający klucze elementów, które jest zależne od bieżącej buforowanej odpowiedzi.</param>
        <summary>Sprawia, że ważności buforowaną odpowiedź zależny od innych elementów w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli elementy wymienione w `cacheKeys` parametru są usuwane z pamięci podręcznej, odpowiedź buforowana bieżącego elementu jest nieprawidłowy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia strony ASP.NET, która jest w pamięci podręcznej danych wyjściowych. Tworzy kod dla strony <xref:System.Collections.ArrayList> obiektu klucze, które są skojarzone z elementami, które są przechowywane w <xref:System.Web.Caching.Cache> obiektu. Następnie przekazuje kod <xref:System.Collections.ArrayList> jako parametr w wywołaniu <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> metody. Dzięki temu odpowiedzi danych wyjściowych w pamięci podręcznej nie jest prawidłowy, jeśli dowolny z plików, określonych w <xref:System.Collections.ArrayList> zmienić.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Tablica elementu kluczy, które jest zależny od buforowanej odpowiedzi.</param>
        <summary>Sprawia, że ważności elementu pamięci podręcznej zależny od innego elementu w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy `cacheKey`s są usuwane z pamięci podręcznej i odpowiedź buforowana bieżącego elementu jest nieprawidłowy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Klucz elementu, który jest zależny od buforowanej odpowiedzi.</param>
        <summary>Sprawia, że ważności buforowaną odpowiedź zależny od innego elementu w pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element odpowiadający `cacheKey` parametr zostanie usunięty z pamięci podręcznej, odpowiedź buforowana bieżącego elementu jest nieprawidłowy.  
  
   
  
## Examples  
 Poniższy przykład jest kontrolkę użytkownika platformy ASP.NET, która jest danych wyjściowych w pamięci podręcznej. Kod dla wywołań kontroli <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> metody z kluczem elementu przechowywane w <xref:System.Web.Caching.Cache> przekazano obiekt jako jego parametr. Jeśli element nie istnieje w pamięci podręcznej, jest unieważniona formantu odpowiedzi, które były przechowywane w wyjściowej pamięci podręcznej. Oznacza to, że na kolejne żądanie nowej wersji odpowiedzi formantu zostanie dodany do wyjściowej pamięci podręcznej.  
  
 Następnie kod sprawdza, czy element skojarzony z `bookData` klucz jest przechowywany w `Cache` obiektu i zawiera jedną z dwóch wierszy tekstu, które są zależne od wyniku. Następnie, ustawia kod <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> właściwość <xref:System.Web.UI.WebControls.DataGrid> formantu o nazwie `dgBooks`, przy użyciu wywołania do niestandardowego `DataHelper` udostępnionych klasy `GetBookData` metody i wypełnia <xref:System.Web.UI.WebControls.DataGrid> z <xref:System.Web.UI.Control.DataBind%2A> — metoda.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje grupę nazw plików do kolekcji nazw plików, na których jest zależna bieżąca odpowiedź.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Kolekcja plików do dodania.</param>
        <summary>Dodaje grupę nazw plików do kolekcji nazw plików, na których jest zależna bieżąca odpowiedź.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład to strona ASP.NET jest danych wyjściowych w pamięci podręcznej. Tworzy kod dla strony <xref:System.Collections.ArrayList> ścieżki do pliku, a następnie przekazuje <xref:System.Collections.ArrayList> jako parametr w wywołaniu <xref:System.Web.HttpResponse.AddFileDependencies%2A> metody. Sprawia to, że jeśli nieprawidłową odpowiedź buforowana danych wyjściowych plików określonych w <xref:System.Collections.ArrayList> zmiany.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">Tablica plików do dodania.</param>
        <summary>Dodaje tablicę nazw plików do kolekcji nazw plików, na których jest zależna bieżąca odpowiedź.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie dodano tablicę nazw plików do <xref:System.Web.HttpResponse.AddFileDependencies%2A> listy plików zależności. Jeśli pliki, unieważnienia buforowanej odpowiedzi.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do dodania.</param>
        <summary>Dodaje nazwę jednego pliku do kolekcji nazw plików, na których jest zależna bieżąca odpowiedź.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz <xref:System.Web.HttpResponse.AddFileDependency%2A> metody w celu dodania zależności pliku, należy także określić buforowanie danych wyjściowych programowo i deklaratywnie. Na przykład aby określić deklaratywnie buforowania danych wyjściowych, należy użyć dyrektywy. Aby uzyskać więcej informacji, zobacz [porady: pamięci podręcznej danych wyjściowych strony o zależnościach plików](http://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można dodać nazwę jednego pliku do <xref:System.Web.HttpResponse.AddFileDependency%2A> listy plików zależności. W przypadku zmiany pliku, unieważnienia buforowanej odpowiedzi.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa nagłówka HTTP, aby dodać <c>wartość</c> do.</param>
        <param name="value">Ciąg do dodania do nagłówka.</param>
        <summary>Dodaje nagłówek HTTP w strumieniu wyjściowym. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> to zapewnia zgodność z wcześniejszymi wersjami programu ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> jest taka sama jak <xref:System.Web.HttpResponse.AppendHeader%2A> i tylko w celu zachowania zgodności z wcześniejszymi wersjami programu ASP. ASP.NET, za pomocą <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda wywołania zwrotnego.</param>
        <summary>[Obsługiwane w programie .NET Framework 4.5.2 i nowszych wersjach]  Rejestruje wywołanie zwrotne środowiska uruchomieniowego ASP.NET wywoła bezpośrednio przed odpowiedzi wysłania nagłówki dla tego żądania.</summary>
        <returns>
          <see cref="T:System.Web.ISubscriptionToken" /> Obiekt, który reprezentuje subskrybowanie pseudo-zdarzeń OnSendingHeaders.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Metoda AddOnSendingHeaders nie jest wywoływana, jeśli moduł macierzysty opróżnia najpierw odpowiedzi.  
  
 OnSendingHeaders pseudo-zdarzeń różni się od zdarzeń potoku poziom IHttpModule w tym jest subskrypcji na żądanie, a nie w subskrypcji dla poszczególnych aplikacji. Celem nie może zmienić kod stanu odpowiedzi wywołania zwrotnego lub może ustawić nagłówka lub plik cookie odpowiedzi. Inne uwagi dotyczące użycia i ostrzeżenia:  
  
-   Ta metoda jest efektywne tylko wtedy, gdy usługi IIS są uruchamiane w potoku tryb zintegrowanego potoku i tylko wtedy, gdy nagłówki odpowiedzi nie zostały jeszcze wysłane dla bieżącego żądania.  
  
-   Środowisko uruchomieniowe programu ASP.NET nie gwarantuje niczego o wywołanie zwrotne wywoływane w wątku. Na przykład wywołania zwrotnego może wywołać synchronicznie w wątku w tle Jeśli opróżnienie tła jest wykonywana. <xref:System.Web.HttpContext.Current%2A> nie musi być dostępna w takich wątku.  
  
-   Wywołanie zwrotne nie mogą wywoływać dowolnej metody, które zmienia treść jednostki odpowiedzi lub który powoduje opróżnienie. Na przykład nie należy wywołać metodę wywołania zwrotnego <xref:System.Web.HttpResponse.Redirect%2A>, ponieważ ta metoda może manipulować treść jednostki odpowiedzi.  
  
-   Wywołanie zwrotne musi zawierać tylko wykonywania short synchroniczne kodu. Próba wywołania operacji asynchronicznej lub zaczekaj na taką operację może doprowadzić do zakleszczenia.  
  
-   Wywołanie zwrotne nie należy zgłosić wyjątek; w przeciwnym razie zachowanie jest niezdefiniowana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">
          <see cref="T:System.Web.HttpCookie" /> Do dodania do strumienia wyjściowego.</param>
        <summary>Dodaje plik cookie HTTP do kolekcji wewnętrznej pliku cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy nowy plik cookie o nazwie `LastVisit`, ustawia wartość pliku cookie do bieżącej daty i godziny i dołącza pliku cookie do bieżącej kolekcji plików cookie. Wszystkie pliki cookie w kolekcji cookie są wysyłane do klienta w `Set-Cookie` strumienia wyjściowego nagłówka HTTP.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Plik cookie jest dołączany po wysłaniu nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa nagłówka HTTP, aby dodać do strumienia wyjściowego.</param>
        <param name="value">Ciąg do dołączenia do nagłówka.</param>
        <summary>Dodaje nagłówek HTTP w strumieniu wyjściowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz <xref:System.Web.HttpResponse.AppendHeader%2A> metodę wysyłanie nagłówków specyficzne dla pamięci podręcznej i w tym samym czasie korzystania z modelu obiektu pamięci podręcznej (<xref:System.Web.HttpResponse.Cache%2A>) można ustawić zasady pamięci podręcznej, nagłówków odpowiedzi HTTP, które odnoszą się do buforowania (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, i `Vary`) mogą zostać usunięte, gdy jest używany model obiektu pamięci podręcznej. To zachowanie umożliwia platformę ASP.NET do obsługi najbardziej restrykcyjne ustawienia. Rozważmy na przykład strona, która zawiera kontrolki użytkownika. Jeśli te rozwiązania mają zasady powodujące konflikt pamięci podręcznej, najbardziej restrykcyjne zasady pamięci podręcznej będzie używany. Jeśli jeden formant użytkownika ustawia nagłówek "`Cache-Control: Public`"i inny formant użytkownika ustawia nagłówek bardziej restrykcyjne"`Cache-Control: Private`" za pośrednictwem wywołania <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, a następnie "`Cache-Control: Private`" nagłówka będą wysyłane z odpowiedzią.  
  
 Listę standardowych nagłówków HTTP/1.1, zobacz sekcję "Definicje pól nagłówka" 14 w [Hypertext Transfer Protocol — HTTP/1.1](http://go.microsoft.com/fwlink/?LinkID=73147) specyfikacji w witrynie sieci Web w sieci World Wide Web konsorcjum W3C.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Web.HttpResponse.AppendHeader%2A> metody w celu dodania niestandardowego nagłówka do <xref:System.Web.HttpResponse> obiektu wysyłanego do klienta.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nagłówek jest dołączany po wysłaniu nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Tekst, który chcesz dodać do pliku dziennika.</param>
        <summary>Dodaje informacje dziennika niestandardowego do pliku dziennika usług Internet Information Services (IIS).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zezwolić na określony ciąg znaków, które mają być rejestrowane w pliku dziennika, należy najpierw włączyć **zapytania identyfikatora URI** opcji **rozszerzone właściwości rejestrowania** okno dialogowe dla lokacji, które mają być rejestrowane działanie w usługach IIS .  
  
 Aby dostosować rozszerzonej rejestrowania w usługach IIS 6.0, wykonaj następujące kroki:  
  
1.  W Menedżerze usług IIS rozwiń węzeł komputera lokalnego, rozwiń folder w sieci Web lub witryny FTP, kliknij prawym przyciskiem myszy witrynę sieci Web i FTP, a następnie kliknij przycisk **właściwości**.  
  
2.  Kliknij przycisk **sieci Web lub witrynę FTP** , a następnie wybierz **włączyć rejestrowanie** pole wyboru (Jeśli nie została jeszcze wybrana).  
  
3.  W **format aktywnego dziennika** kliknij **rozszerzony Format W3C pliku dziennika**.  
  
4.  Kliknij przycisk **właściwości**.  
  
5.  Kliknij przycisk **zaawansowane** , a następnie wybierz właściwości, które mają być logowania, a następnie kliknij przycisk **OK**.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dołączyć ciąg w dzienniku.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna do zasobu.</param>
        <summary>Dodaje identyfikator sesji na ścieżkę wirtualną, jeśli używa sesji <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> stan sesji i zwraca połączone ścieżki. Jeśli <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> stan sesji nie jest używany, <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> zwraca oryginalnej ścieżki wirtualnej.</summary>
        <returns>
          <paramref name="virtualPath" /> z sesją dodaje identyfikator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> jest używana tylko z sesji bez plików cookie do utworzenia bezwzględnej odwołania HREF.  
  
   
  
## Examples  
 Poniższy przykład deklaruje zmienną ciągu o nazwie `urlConverted`i ustawia go do wyniku <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> wywołania metody. Kod następnie przekazuje wartość zmiennej do <xref:System.Web.UI.WebControls.HyperLink> formantu <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> właściwości.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Obiektu wywołania zwrotnego.</param>
        <param name="state">Stan odpowiedzi.</param>
        <summary>Wysyła obecnie buforowaną odpowiedź do klienta.</summary>
        <returns>Asynchroniczny obiekt wyniku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli podstawowa <xref:System.Web.HttpWorkerRequest> obiektu obsługuje asynchroniczne operacje opróżniania i ta metoda jest wywoływana z zdarzenie asynchronicznego modułu lub asynchronicznej obsługi, operacja opróżniania jest wykonywane asynchronicznie. W przeciwnym razie operacja opróżniania odbywa się synchronicznie. Asynchronicznego opróżniania jest obsługiwana dla usług IIS 6.0 i nowszych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Odpowiedź jest już ukończone.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Bajty zapisu do strumienia wyjściowego.</param>
        <summary>Zapisuje ciąg znaków binarnego do strumienia wyjściowego HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład odczytuje plik tekstowy do buforu i zapisuje bufor do strumienia wyjściowego HTTP.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do buforowania danych wyjściowych, a następnie wysłać je po pełnej odpowiedzi zakończyło się przetwarzanie.</summary>
        <value>
          <see langword="true" /> Jeśli dane wyjściowe do klienta jest buforowana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Buffer%2A> Właściwość jest przestarzała uzyskać <xref:System.Web.HttpResponse.BufferOutput%2A> właściwości i jest dostępne tylko w celu zapewnienia zgodności z wcześniejszymi wersjami programu ASP. ASP.NET, za pomocą <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do buforowania danych wyjściowych, a następnie wysłać je po stronie pełne przetwarzanie ukończone.</summary>
        <value>
          <see langword="true" /> Jeśli dane wyjściowe do klienta jest buforowana; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie <xref:System.Web.HttpResponse.ContentType%2A> wywołuje właściwość odpowiedź na image/jpeg, <xref:System.Web.HttpResponse.Clear%2A> metodę, aby usunąć inną zawartość, która może zostać dołączony do odpowiedzi, a następnie ustawia <xref:System.Web.HttpResponse.BufferOutput%2A> właściwości na wartość true, dzięki czemu będą całej strony przetworzone przed wysłaniem do klienta żadnej zawartości.  
  
 Pełny przykład, zobacz <xref:System.Web.HttpResponse> klasy.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zasady buforowania (takich jak wygaśnięcia czasu ustawienia prywatności i różnią się klauzule) strony sieci Web.</summary>
        <value>
          <see cref="T:System.Web.HttpCachePolicy" /> Obiekt, który zawiera informacje o zasadach buforowania bieżącej odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład zapisuje bieżące zasady pamięci podręcznej do strumienia wyjściowego HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see langword="Cache-Control" /> nagłówka HTTP, który jest zgodny z <see cref="T:System.Web.HttpCacheability" /> wartości wyliczenia.</summary>
        <value>Reprezentacja ciągu <see cref="T:System.Web.HttpCacheability" /> wartości wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości `Private`, `Public`, i `No-Cache` są ciągami i musi być ujęta w znaki cudzysłowu (""). Jeśli <xref:System.Web.HttpResponse.CacheControl%2A> właściwości ustawiono wartość, która nie pasuje do jednej z <xref:System.Web.HttpCacheability> wartości wyliczenia, a następnie <xref:System.ArgumentException> jest generowany. Jeśli <xref:System.Web.HttpResponse.CacheControl%2A> właściwość nie jest ustawiona, buforowanie odpowiedzi jest równa <xref:System.Web.HttpCacheability.NoCache>.  
  
 `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, I <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> właściwości są przestarzałe. Zamiast tego metody <xref:System.Web.HttpCachePolicy> klasy są dostępne za pośrednictwem <xref:System.Web.HttpResponse.Cache%2A> obiektu wewnętrznego, aby kontrolować Internet Information Services (IIS), dane wyjściowe pamięci podręcznej i pamięci podręcznej klienta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość ciągu jest niezgodny z <see cref="T:System.Web.HttpCacheability" /> wartości wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zestaw znaków HTTP w strumieniu wyjściowym.</summary>
        <value>Zestaw znaków HTTP w strumieniu wyjściowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Charset` Ustawioną właściwość `null` do pomijania HTTP `Content-Type` nagłówka.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy zestaw znaków strumień wyjściowy jest centralna Europejskiego (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see langword="Charset" /> Właściwość została ustawiona po nagłówki zostały wysłane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści całą zawartość dane wyjściowe ze strumienia buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Clear%2A> — Metoda nie czyści informacje nagłówka.  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Web.HttpResponse.ContentType%2A> wywołuje właściwość odpowiedź na image/jpeg, <xref:System.Web.HttpResponse.Clear%2A> metodę, aby usunąć inną zawartość, która może zostać dołączony do odpowiedzi, a następnie ustawia <xref:System.Web.HttpResponse.BufferOutput%2A> true tak, aby pełne strony właściwości przetworzone przed wysłaniem do klienta żadnej zawartości.  
  
 Pełny przykład, zobacz <xref:System.Web.HttpResponse> klasy.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści całą zawartość dane wyjściowe ze strumienia buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ClearContent%2A> — Metoda nie czyści informacje nagłówka.  
  
   
  
## Examples  
 Poniższy przykład Czyści całą zawartość strumienia buforu.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie nagłówki ze strumienia buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Web.HttpResponse.ClearHeaders%2A> metody, aby upewnić się, że nagłówki nie są wysyłane z bieżącej odpowiedzi. Ta technika może być szczególnie ważne, jeśli odpowiedź ASP.NET jest generowanie obrazu, takich jak plik JPEG. W tym przykładzie <xref:System.Web.HttpResponse.ContentType%2A> właściwość ma wartość image/jpeg.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nagłówki są czyszczone po wysłaniu nagłówków HTTP.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.CancellationToken" /> obiekt, który jest uruchomiony, gdy klient zakończy połączenie.</summary>
        <value>Token anulowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten interfejs API jest wątkowo. Istnieją pewne ograniczenia dotyczące używania token anulowania. Nieprawidłowe użycie może prowadzić do wyścigu, zakleszczenie lub inne nieoczekiwane zachowania. Należy przestrzegać następujących wytycznych:  
  
-   Upewnij się, nie wywołują ten interfejs API poza granicami pojedynczego żądania, ponieważ zlikwiduje token anulowania na końcu żądania ASP.NET. Nie ma żadnej gwarancji, która token nigdy spowoduje przejście do stanu anulowane przed jego usunięcia. Na przykład jeśli żądanie kończy się bez użycia klienta o odłączony, token zostanie usunięte bez konieczności najpierw anulować.  
  
-   Nie należy czekać <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, jak to pozbawia sensu asynchroniczne powiadomienia i może spowodować zakleszczenie.  
  
-   Nie wywołuj <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> przeciążenia, które wywołują wywołania zwrotnego w pierwotnej <xref:System.Threading.SynchronizationContext> obiektu.  
  
-   Nie używaj <xref:System.Web.HttpContext> obiektu lub innych niż wątkowo ASP.NET obiekty wewnętrzne z wewnątrz wywołania zwrotnego dostarczonego do <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> metody. Wywołanie zwrotne mogą być uruchomione jednocześnie z innymi ASP.NET lub kod aplikacji.  
  
-   Aktualizowanie wywołanie zwrotne metody wykonywania short i bez blokowania.  
  
-   Należy wszelkich starań, aby uniknąć generowania wyjątków z wewnątrz metody wywołania zwrotnego.  
  
 Ta właściwość jest obsługiwana tylko w Internet informacji Service (IIS) 7.5 lub nowszej w trybie zintegrowanym. Jeśli można wywołać bez prawa usług IIS w wersji lub potoku trybu, <xref:System.PlatformNotSupportedException> jest generowany. Aby określić wersji usług IIS, należy użyć <xref:System.Web.HttpRuntime.IISVersion%2A>. Aby określić tryb potokowy, użyj <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka połączenie gniazda do klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zakończy połączenie z klientem w nagłych sposób i nie jest przeznaczony do normalnego przetwarzania żądania HTTP. Metoda wysyła pakiet resetowania do klienta, co może powodować dane odpowiedzi, które są buforowane na serwerze, kliencie lub gdzieś między go porzucić.  
  
 Jednak zwykle należy wywołać <xref:System.Web.HttpApplication.CompleteRequest%2A> zamiast tego, aby przejść do <xref:System.Web.HttpApplication.EndRequest> zdarzeń i wysyłania odpowiedzi do klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zestaw znaków HTTP w strumieniu wyjściowym.</summary>
        <value>A <see cref="T:System.Text.Encoding" /> obiektu, który zawiera informacje o zestawie znaków bieżącej odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna `ContentEncoding` można określić w pliku konfiguracji platformy ASP.NET w [globalizacji — Element (schemat ustawień programu ASP.NET)](http://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) sekcji. Jeśli <xref:System.Web.HttpResponse.ContentEncoding%2A> jest określony przez klienta, domyślne ustawienia konfiguracji zostały zastąpione.  
  
   
  
## Examples  
 Poniższy przykład zapisuje zrozumiałą dla użytkownika opis kodowanie do strumienia wyjściowego zestawu znaków.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Podjęto próbę ustawienia <see cref="P:System.Web.HttpResponse.ContentEncoding" /> do <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ HTTP MIME w strumieniu wyjściowym.</summary>
        <value>Typ HTTP MIME w strumieniu wyjściowym. Wartość domyślna to "<see langword="text/html" />".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie <xref:System.Web.HttpResponse.ContentType%2A> wywołuje właściwość odpowiedź na image/jpeg, <xref:System.Web.HttpResponse.Clear%2A> metodę, aby usunąć inną zawartość, która może zostać dołączony do odpowiedzi, a następnie ustawia <xref:System.Web.HttpResponse.BufferOutput%2A> true tak, aby pełne strony właściwości przetworzone przed wysłaniem do klienta żadnej zawartości.  
  
 Pełny przykład, zobacz <xref:System.Web.HttpResponse> klasy.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.ContentType" /> Właściwość jest ustawiona na <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję plików cookie odpowiedzi.</summary>
        <value>Kolekcja plików cookie odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program ASP.NET zawiera dwie kolekcje wewnętrzne pliku cookie. Kolekcja dostępne za pośrednictwem <xref:System.Web.HttpRequest.Cookies%2A> Kolekcja <xref:System.Web.HttpRequest> zawiera pliki cookie wysłanych przez klienta do serwera w `Cookie` nagłówka. Kolekcja dostępne za pośrednictwem <xref:System.Web.HttpResponse.Cookies%2A> Kolekcja <xref:System.Web.HttpResponse> zawiera nowe pliki cookie utworzone na serwerze i przesyłane do klienta w `Set-Cookie` nagłówka.  
  
 Po dodaniu pliku cookie przy użyciu <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> kolekcji, plik cookie jest natychmiast dostępna w <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> kolekcji, nawet jeśli nie została wysłana odpowiedź do klienta.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy plik cookie o nazwie `LastVisit`, ustawia wartość pliku cookie do bieżącej daty i godziny i dodaje plik cookie do bieżącej kolekcji plików cookie. Wszystkie pliki cookie w kolekcji cookie są wysyłane do klienta w `Set-Cookie` strumienia wyjściowego nagłówka HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyłącza buforowanie jądra dla bieżącej odpowiedzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli buforowanie jądra nie jest obsługiwane, ta metoda nie ma znaczenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyłącza IIS buforowanie w trybie użytkownika dla tej odpowiedzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli buforowanie w trybie użytkownika usług IIS nie jest obsługiwana, ta metoda zwraca bez wykonywania żadnych czynności.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wysyła do klienta, wszystkie obecnie buforowanych wyników, zatrzymuje wykonywanie strony i zgłasza <see cref="E:System.Web.HttpApplication.EndRequest" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępne tylko w celu zgodności z ASP — to znaczy dla zgodności z technologii sieci Web — Programowanie oparte na modelu COM, która poprzedzone ASP.NET. Jeśli chcesz przejść do <xref:System.Web.HttpApplication.EndRequest> zdarzeń i wysyłania odpowiedzi do klienta, zaleca się zazwyczaj do wywołania <xref:System.Web.HttpApplication.CompleteRequest%2A> zamiast tego.  
  
 Aby naśladował zachowanie `End` metody w ASP, ta metoda próbuje podnieść <xref:System.Threading.ThreadAbortException> wyjątku. Jeśli ta próba zakończy się pomyślnie, wątek wywołujący zostanie przerwane, uniemożliwiających wydajności sieci Web. W takim przypadku żaden kod po wywołaniu <xref:System.Web.HttpResponse.End%2A> metoda jest wykonywana.  
  
 Jeśli <xref:System.Web.HttpResponse.End%2A> — metoda nie będzie mógł podnieść <xref:System.Threading.ThreadAbortException>, zamiast tego opróżnia bajtów odpowiedzi do klienta. Robi to synchronicznie, które również mogą być szkodliwe dla wydajności sieci Web.  
  
 W obu przypadkach (czy <xref:System.Threading.ThreadAbortException> pomyślnie wyjątek), potoku odpowiedzi przechodzi dalej do <xref:System.Web.HttpApplication.EndRequest> zdarzeń.  
  
 <xref:System.Web.HttpApplication.CompleteRequest%2A> — Metoda nie zgłaszał wyjątku i kod po wywołaniu <xref:System.Web.HttpApplication.CompleteRequest%2A> metody mogą być wykonywane. Jeśli masz zamiar jest uniknięcie wykonywanie kolejnych kodu i ograniczeń wydajności <xref:System.Web.HttpResponse.End%2A> jest dopuszczalne, można wywołać <xref:System.Web.HttpResponse.End%2A> zamiast <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">Wywołanie <see cref="M:System.Web.HttpResponse.End" /> zakończył bieżącego żądania.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Asynchroniczny obiekt wyniku.</param>
        <summary>Kończy operację asynchroniczną opróżniania.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Asynchronicznego opróżniania nie jest obsługiwana i <paramref name="asyncResult" /> parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Asynchronicznego opróżniania nie jest obsługiwana i <paramref name="asyncResult" /> nie można rzutować parametru <c>FlushAsyncResult</c> obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę minut przed wygaśnięciem strony buforowanej w przeglądarce. Po powrocie do tej samej strony przed jej wygaśnięciem, wyświetlana jest wersja buforowana. <see cref="P:System.Web.HttpResponse.Expires" /> to zapewnia zgodność z wcześniejszymi wersjami programu ASP.</summary>
        <value>Liczba minut przed wygaśnięciem strony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> i <xref:System.Web.HttpResponse.CacheControl%2A> właściwości została zastąpiona metody <xref:System.Web.HttpCachePolicy> dostępne za pośrednictwem klasy <xref:System.Web.HttpResponse.Cache%2A> obiektu wewnętrznego, aby kontrolować Internet Information Services (IIS) wyjściowej pamięci podręcznej i umieszcza w pamięci podręcznej klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bezwzględny Data i czas, w którym można usunąć informacji o pamięci podręcznej z pamięci podręcznej. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> to zapewnia zgodność z wcześniejszymi wersjami programu ASP.</summary>
        <value>Data i godzina, jaką strona wygasa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, I <xref:System.Web.HttpResponse.CacheControl%2A> właściwości została zastąpiona metody <xref:System.Web.HttpCachePolicy> dostępne za pośrednictwem klasy <xref:System.Web.HttpResponse.Cache%2A> obiektu wewnętrznego, aby kontrolować Internet Information Services (IIS) wyjściowej pamięci podręcznej i umieszcza w pamięci podręcznej klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt filtru zawijania używane do modyfikowania treści jednostki HTTP przed ich przesłaniem.</summary>
        <value>
          <see cref="T:System.IO.Stream" /> Obiektu, który działa jako filtr danych wyjściowych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu `Stream` obiektu i ustawić <xref:System.Web.HttpResponse.Filter%2A> właściwości `Stream` obiektów, wszystkie HTTP dane wyjściowe wysyłane przez <xref:System.Web.HttpResponse.Write%2A> przechodzi przez filtr.  
  
   
  
## Examples  
 Poniższy przykład jest strony platformy ASP.NET, która ustawia <xref:System.Web.HttpResponse.Filter%2A> właściwości nowe wystąpienie klasy `UpperCaseFilter` klasy niestandardowej <xref:System.IO.Stream> klasy, który konwertuje cały tekst, który przechodzi na wielkie litery. Informacje o żądaniu są zapisywane do pliku tekstowego, a następnie <xref:System.Web.HttpResponse.Filter%2A> właściwość jest ustawiona. Po filtr odpowiedzi jest spełnione, wywołuje kod <xref:System.Web.HttpRequest.MapPath%2A> metodę get ścieżka bezwzględna do pliku tekstowego o nazwie `TestFile.txt` służy jako źródła dla zawartości odpowiedzi. Następnie kod tworzy nową <xref:System.IO.StreamReader> obiektu do odczytania pliku tekstowego od początku do końca, a następnie wywołania <xref:System.Web.HttpResponse.Write%2A> metodę, aby wyświetlić zawartość pliku na stronie.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Filtrowanie nie jest dozwolone z jednostką.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wszystkie obecnie buforowanych wyników wysyła do klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wymusza wszystkie aktualnie buforowane dane wyjściowe do wysłania do klienta. <xref:System.Web.HttpResponse.Flush%2A> Metoda może być wywołana wiele razy podczas przetwarzania żądania.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Drawing.Graphics.Save%2A> metodę, aby zapisać <xref:System.Drawing.Bitmap> do obiektu <xref:System.Web.HttpResponse.OutputStream%2A> właściwości i konwertuje format obrazu JPEG. Kod wywołuje `Dispose` metoda <xref:System.Drawing.Bitmap> obiektu i <xref:System.Drawing.Graphics> obiektu udostępnia zasoby, które zostały przy użyciu. Następnie wywołuje <xref:System.Web.HttpResponse.Flush%2A> do wysyłania zawartości odpowiedzi do klienta.  
  
 Pełny przykład, zobacz <xref:System.Web.HttpResponse> klasy.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Pamięć podręczna jest opróżniany po wysłaniu odpowiedzi.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie wysyła wszystkie obecnie buforowane dane wyjściowe do klienta.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task" /> reprezentujący operację asynchroniczną.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.Encoding" /> obiekt, który reprezentuje kodowania dla bieżącego nagłówka wyjściowego strumienia.</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> Zawierający informacje o nagłówku bieżący zestaw znaków.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.HeaderEncoding%2A> Właściwości daje możliwość wyłączenia lub zmień <xref:System.Text.Encoding> obiektu nagłówka odpowiedzi przy użyciu <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, lub <xref:System.Text.UTF8Encoding> obiektu. Domyślnym kodowaniem wartość jest <xref:System.Text.UTF8Encoding> klasy.  
  
 Zmieniając typ <xref:System.Web.HttpResponse.HeaderEncoding%2A> właściwości, możesz potencjalnie zwiększyć ryzyko wystąpienia niektórych złośliwych ataków lub Przyczyna poufnych danych za pomocą nagłówka odpowiedzi. Nagłówek iniekcji ataków można uniknąć, w części pozostawić <xref:System.Web.HttpResponse.HeaderEncoding%2A> właściwości odpowiedzi na ustawienie domyślne. Atak wykorzystujący usterce aplikacji można echo ponownie powierzyć danych jako część nagłówka odpowiedzi. Jeśli <xref:System.Web.HttpResponse.HeaderEncoding%2A> jest wyłączona z powodu wymagane dla kontynuacji wiersze nagłówka lub jeśli nagłówek dowolnej jest tworzony na podstawie wyniku niezaufanych danych, powinny być weryfikowane danych nagłówka przed wysłaniem do strumienia odpowiedzi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość kodowania <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Wartość kodowania <see cref="P:System.Text.Encoding.Unicode" />.  \- lub - nagłówki zostały już wysłane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję nagłówków odpowiedzi.</summary>
        <value>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> nagłówków odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Headers%2A> Właściwość jest obsługiwana tylko z [!INCLUDE[iisver](~/includes/iisver-md.md)] tryb zintegrowanego potoku i co najmniej środowiska .NET Framework 3.0. Podczas próby uzyskania dostępu do <xref:System.Web.HttpResponse.Headers%2A> właściwości i jeden z tych dwóch warunków nie jest spełniony, <xref:System.PlatformNotSupportedException> jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Operacja wymaga trybu zintegrowanego potoku w [! INCLUDE[iisver](~/includes/iisver-MD.MD)] i co najmniej programu .NET Framework w wersji 3.0 lub nowszej.</exception>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Obsługiwane w programie .NET Framework 4.5.2 i nowszych wersjach]  Pobiera wartość wskazującą, czy nagłówki odpowiedzi zostały zapisane.</summary>
        <value>
          <see langword="true" /> Jeśli nagłówki odpowiedzi zostały zapisane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy klient jest nadal połączony z serwerem.</summary>
        <value>
          <see langword="true" /> Jeśli klient jest obecnie połączony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.IsClientConnected%2A> Zwraca `false` gdy są spełnione następujące warunki:  
  
-   Połączenie z klientem zostało przerwane. Taka sytuacja może wystąpić, jeśli <xref:System.Web.HttpResponse.Close%2A> wywołano metodę lub jeśli klient zatrzymał wykonywanie strony sieci Web lub przeglądać do innej strony.  
  
-   <xref:System.Web.HttpWorkerRequest> Obiekt, który obsługuje żądania jest `null` lub <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> metoda zwraca `false`. Jeśli niestandardowego <xref:System.Web.HttpWorkerRequest> obiektu obsługi żądania, a następnie <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> metoda może być ustawiona na podstawie kryteriów niestandardowych. Na przykład żądania niestandardowy proces roboczy może wymusić limit czasu po upływie określonego czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Web.HttpResponse.IsClientConnected%2A> właściwość do sprawdzenia, czy klient, który żąda strony pozostaje nawiązanie połączenia z serwerem. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> ma wartość true, wywołania kodu <xref:System.Web.HttpResponse.Redirect%2A> — metoda i klienta zostaną wyświetlone innej strony. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> wynosi false, a następnie kod wywołuje <xref:System.Web.HttpResponse.End%2A> — metoda i wszystkie przetwarzania strony zostało zakończone.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość logiczną wskazującą, czy klient jest przenoszona do nowej lokalizacji.</summary>
        <value>
          <see langword="true" /> Jeśli wartości nagłówka odpowiedzi lokalizacja jest inna niż bieżąca lokalizacja; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> właściwości o <xref:System.Web.HttpResponse.RedirectLocation%2A> właściwości do testowania i określić, czy bezwzględny identyfikator URI jest przesyłane do klientów w HTTP `Location` nagłówka jest inny niż bieżący identyfikator URI i nowy zamierzonego identyfikator URI, który jest zostaną przeniesione do.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dane wyjściowe umożliwia tekst w strumieniu wychodzące odpowiedzi HTTP.</summary>
        <value>A <see cref="T:System.IO.TextWriter" /> obiekt, który umożliwia niestandardowe dane wyjściowe do klienta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład jest strony ASP.NET, który zawiera <xref:System.Web.UI.WebControls.TextBox> formantu, który ma jego <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> ustawioną właściwość <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Strony kod przedstawia tekst, który użytkownik wprowadza <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, używa <xref:System.Web.HttpServerUtility.HtmlEncode%2A> metodę HTML kodowania i <xref:System.Web.HttpResponse.Output%2A> właściwości do wyświetlenia strony zaszyfrowanym ciągiem.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Umożliwia wyjście binarne do wychodzących treści HTTP.</summary>
        <value>We/Wy <see cref="T:System.IO.Stream" /> reprezentujący nieprzetworzona zawartość wychodzących treści HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 2.0, korzystając z <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> strumień we/wy zwrócony przez metodę <xref:System.Web.HttpResponse.OutputStream%2A> właściwości, może zostać zgłoszone następujące wyjątki:  
  
-   <xref:System.ArgumentOutOfRangeException>, jeśli `offset` lub `count` parametru jest ujemny lub, jeśli `buffer` długość parametru minus `offset` parametr jest mniejsza niż lub równa zero.  
  
-   <xref:System.ArgumentNullException>, jeśli `buffer` parametr jest `null`.  
  
   
  
## Examples  
 Poniższym przykładzie wywołuje <xref:System.Drawing.Image.Save%2A> metodę, aby zapisać <xref:System.Drawing.Bitmap> do obiektu <xref:System.Web.HttpResponse.OutputStream%2A> właściwości oraz konwertuje obraz w formacie JPEG. Następnie kod wywołuje metodę Dispose dla <xref:System.Drawing.Bitmap> obiektu i <xref:System.Drawing.Graphics> obiektu udostępnia zasoby, które zostały przy użyciu. Na koniec kod wywołuje <xref:System.Web.HttpResponse.Flush%2A> do wysyłania zawartości odpowiedzi do klienta.  
  
 Pełny przykład, zobacz <xref:System.Web.HttpResponse> klasy.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> nie jest dostępna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do dodania do <see langword="PICS-Label" /> nagłówka.</param>
        <summary>Dołącza HTTP <see langword="PICS-Label" /> nagłówka do strumienia wyjściowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Platforma dla zaznaczenia zawartości Internetu (PICS) to standard sieci World Wide Web konsorcjum W3C do oznaczania zawartości. PICS jest zasadniczo język do tworzenia system klasyfikacji.  
  
 Każda wartość może być etykietę PICS; Program ASP.NET nie sprawdza etykiety. Maksymalna długość ciągu to 255 znaków. Aby uzyskać więcej informacji na temat PICS standardów i składni, zobacz [sieci World Wide Web konsorcjum](http://go.microsoft.com/fwlink/?LinkID=37125) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład jest wyświetlany obraz strony ASP.NET. Strona kod wywołuje <xref:System.Web.HttpResponse.Pics%2A> metodę, aby ustawić HTTP `PICS-Label` nagłówka odpowiedzi. Ciąg, który jest przekazywany jako parametr do <xref:System.Web.HttpResponse.Pics%2A> metody reprezentuje etykietę klasyfikacji wygenerowane z witryny sieci Web internetowych skojarzenia klasyfikacji zawartości (ICRA).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamienia uzgodnionej obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Adres URL żądania wypychania. Należy go ścieżkę wirtualną względną zasób, który serwer będzie chciał push do klienta.</param>
        <summary>Ten interfejs API jest do obsługi aplikacji wysyłania wypychania zobowiązuje się do klientów HTTP 2.0. Więcej szczegółów można znaleźć w odniesieniu do wypychania serwera Http2 w [8.2 sekcji specyfikacji HTTP/2: wypychane serwera] (https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise jest deterministyczna, a aplikacje nie powinny mieć logikę, która zależy od niego. Jej jedynym celem jest zalet wydajności w niektórych przypadkach. Istnieje wiele warunków (protokół i wykonania), mogą powodować całkowicie ignorowanie żądań wypychania. Oczekiwania jest oparta na fire i zapomnij.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">Adres URL żądania wypychania. Należy go ścieżkę wirtualną względną zasób, który serwer będzie chciał push do klienta.</param>
        <param name="method">Metoda żądania HTTP, który będzie używany przez żądanie wypychania.</param>
        <param name="headers">Nagłówek żądania HTTP, który będzie używany przez żądanie wypychania.</param>
        <summary>Ten interfejs API jest do obsługi aplikacji wysyłania wypychania zobowiązuje się do klientów HTTP 2.0. Więcej szczegółów można znaleźć w odniesieniu do wypychania serwera Http2 w [8.2 sekcji specyfikacji HTTP/2: wypychane serwera] (https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise jest deterministyczna, a aplikacje nie powinny mieć logikę, która zależy od niego. Jej jedynym celem jest zalet wydajności w niektórych przypadkach. Istnieje wiele warunków (protokół i wykonania), mogą powodować całkowicie ignorowanie żądań wypychania. Oczekiwania jest oparta na fire i zapomnij.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekierowuje klienta do nowego adresu URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacja docelowa. Może to być ścieżka wirtualna aplikacji z wątkiem.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL i umożliwia określenie nowego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Web.HttpResponse.Redirect%2A> jest odpowiednikiem wywołania <xref:System.Web.HttpResponse.Redirect%2A> z drugim parametrem ustawioną `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> wywołania <xref:System.Web.HttpResponse.End%2A> które zgłasza <xref:System.Threading.ThreadAbortException> wyjątek po zakończeniu. Ten wyjątek ma niekorzystny wpływ na wydajność aplikacji sieci Web. Dlatego zaleca się zamiast tego przeciążenia użycie <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenia, a następnie przekaż `false` dla `endResponse` parametr, a następnie wywołania <xref:System.Web.HttpApplication.CompleteRequest%2A> metody. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpResponse.End%2A> metody.  
  
> [!NOTE]
>  Dla stron tylko dla urządzeń przenośnych Jeśli aplikacja zależy od sesji bez plików cookie lub może odbierać żądania z urządzeń przenośnych, które wymagają sesje bez plików cookie, przy użyciu tyldy (~) w ścieżce może spowodować utworzenie nowej sesji i potencjalnie utraty danych sesji. Można ustawić właściwości w formancie przenośnych ze ścieżką takich jak "~ / path", rozwiązania przy użyciu ścieżki <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / ścieżki" przed przypisaniem go do właściwości.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 302. To alternatywny sposób transfer kontroli do innej strony <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda jest zazwyczaj bardziej wydajne, ponieważ nie powoduje podróż do klienta. Aby uzyskać więcej informacji, zobacz [porady: przekierować użytkowników do innej strony](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 Poniższy przykład powoduje bezwarunkowe przekierowania do innej witryny sieci Web.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Przekierowanie nastąpiła po wysłaniu nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacji obiektu docelowego.</param>
        <param name="endResponse">Wskazuje, czy należy zakończyć wykonywanie bieżącej strony.</param>
        <summary>Przekierowuje klienta do nowego adresu URL. Określa nowy adres URL i określa, czy należy zakończyć wykonywanie bieżącej strony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezwzględny adres URL (na przykład http://www.contoso.com/default.aspx) lub względny adres URL (na przykład Default.aspx) można określić dla lokalizacji docelowej, ale niektóre przeglądarki mogą odrzucić względnym adresem URL.  
  
 Jeśli używasz tej metody w obsłudze strony zakończenie żądania dla jednej strony, a następnie rozpocznij nowe żądanie dla innej strony, należy ustawić `endResponse` do `false` , a następnie wywołać <xref:System.Web.HttpApplication.CompleteRequest%2A> metody. Jeśli określisz `true` dla `endResponse` parametru, ta metoda wywołuje <xref:System.Web.HttpResponse.End%2A> metody oryginalnego żądania, która zgłasza <xref:System.Threading.ThreadAbortException> wyjątek po jego ukończeniu. Ten wyjątek ma niekorzystny wpływ na wydajność aplikacji sieci Web, dlatego przekazywanie `false` dla `endResponse` parametru jest zalecane. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpResponse.End%2A> metody.  
  
> [!NOTE]
>  Dla stron dla urządzeń przenośnych Jeśli aplikacja zależy od sesji bez plików cookie lub może odbierać żądania z urządzeń przenośnych, które wymagają sesje bez plików cookie, przy użyciu tyldy (~) w ścieżce można utworzyć nowej sesji i może spowodować utratę danych sesji. Można ustawić właściwości w formancie przenośnych ze ścieżką takich jak "~ / path", rozwiązania przy użyciu ścieżki <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / ścieżki" przed przypisaniem go do właściwości.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 302. To alternatywny sposób transfer kontroli do innej strony <xref:System.Web.HttpServerUtility.Transfer%2A> metody. <xref:System.Web.HttpServerUtility.Transfer%2A> Metoda jest zazwyczaj bardziej wydajne, ponieważ nie powoduje podróż do klienta. Aby uzyskać więcej informacji, zobacz [porady: przekierować użytkowników do innej strony](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Web.HttpResponse.IsClientConnected%2A> właściwość do sprawdzenia, czy klient, który żąda strony pozostaje nawiązanie połączenia z serwerem. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> ma wartość true, wywołania kodu <xref:System.Web.HttpResponse.Redirect%2A> — metoda i klienta zostaną wyświetlone innej strony. Jeśli <xref:System.Web.HttpResponse.IsClientConnected%2A> wynosi false, a następnie kod wywołuje <xref:System.Web.HttpResponse.End%2A> — metoda i wszystkie przetwarzania strony zostało zakończone.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> zawiera znak nowego wiersza.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie nastąpiła po wysłaniu nagłówków HTTP.</exception>
        <exception cref="T:System.ApplicationException">Żądanie dostępu do strony jest wynikiem wywołania zwrotnego.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość http <see langword="Location" /> nagłówka.</summary>
        <value>Bezwzględny identyfikator URI, który są przesyłane do klientów w HTTP <see langword="Location" /> nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia użycie tej właściwości można określić adres URL przekierowania w przypadku kodu stałe przekierowanie przy użyciu kodu odpowiedzi HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Nagłówki HTTP zostały już zapisane.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje przekierowanie trwałe z żądany adres URL określony adres URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacja, aby przekierować żądania do.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL, pod określony adres URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> Przeciążenie metody zawiera kod stanu HTTP 301 w odpowiedzi oraz adres URL przekierowania żądania. Kod stanu HTTP 301 to standardowy kod odpowiedzi HTTP. Wskazuje on, że istnieje stałe przekierowanie i zapewnia lokalizacji przekierowania.  
  
 Wywoływanie <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> przeciążenie metody kończy odpowiedź.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> zawiera znak nowego wiersza (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Lokalizacja, aby przekierować żądania do.</param>
        <param name="endResponse">
          <see langword="true" /> Aby zakończyć odpowiedzi; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL, pod określony adres URL i udostępnia opcję, aby ukończyć odpowiedzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> Przeciążenie metody zawiera kod stanu HTTP 301 w odpowiedzi oraz adres URL przekierowania żądania. To przeciążenie metody udostępnia opcję, aby określić, czy Zakończenie lub przeprowadzenie odpowiedzi po wykonał przekierowanie. Kod stanu HTTP 301 to standardowy kod odpowiedzi HTTP. Wskazuje on, że istnieje stałe przekierowanie i zapewnia lokalizacji przekierowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> zawiera znak nowego wiersza (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametru trasy i nazwy trasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawioną `false`.  
  
 Ta metoda Konwertuje obiekt, który jest przekazywany w `routeValues` do <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> obiektu przy użyciu <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Wywoływana jest metoda następnie ustalić adresu URL.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania tej metody do przekierowania do trasy, który ma parametry, które są nazywane `productid` i `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie podjęto próbę po wysłał nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawioną `false`.  
  
 Ta metoda konwertuje nazwę trasy, który jest przekazywany w `routeName` do adresu URL za pomocą <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metody.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania tej metody do przekierowania do trasy, o nazwie `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie podjęto próbę po wysłał nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawioną `false`.  
  
 Ta metoda wywołuje <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodę, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania tej metody do przekierowania do trasy, który ma parametry, które są nazywane `productid` i `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie podjęto próbę po wysłał nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametru trasy i nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawioną `false`.  
  
 Ta metoda Konwertuje obiekt, który jest przekazywany w `routeValues` do <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> obiektu przy użyciu <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Wywoływana jest metoda następnie ustalić adresu URL.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania tej metody do przekierowania do trasy, o nazwie `Product` i ma parametry, które są nazywane `productid` i `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie podjęto próbę po wysłał nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Przekierowuje żądanie do nowego adresu URL przy użyciu wartości parametru trasy i nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawioną `false`.  
  
 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Metoda jest wywoływana w celu określenia adresu URL.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 302.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania tej metody do przekierowania do trasy, o nazwie `Product` i ma parametry, które są nazywane `productid` i `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie podjęto próbę po wysłał nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przeprowadza Stałe przekierowanie z żądanego adresu URL do nowego adresu URL przy użyciu wartości parametru trasy i nazwy trasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL do nowego adresu URL przy użyciu wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawioną `false`.  
  
 Ta metoda Konwertuje obiekt, który jest przekazywany w `routeValues` do <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> obiektu przy użyciu <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Wywoływana jest metoda następnie ustalić adresu URL.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania tej metody do przekierowania do trasy, który ma parametry, które są nazywane `productid` i `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie podjęto próbę po wysłał nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL do nowego adresu URL przy użyciu nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawioną `false`.  
  
 Ta metoda konwertuje nazwę trasy, który jest przekazywany w `routeName` do adresu URL za pomocą <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metody.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania tej metody do przekierowania do trasy, o nazwie `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie podjęto próbę po wysłał nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL do nowego adresu URL przy użyciu wartości parametru trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawioną `false`.  
  
 Ta metoda wywołuje <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodę, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania tej metody do przekierowania do trasy, który ma parametry, które są nazywane `productid` i `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie podjęto próbę po wysłał nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL do nowego adresu URL przy użyciu wartości parametru trasy i nazwy trasy, który odpowiada nowego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.HttpResponse.RedirectPermanent%2A> metody z drugim parametrem ustawioną `false`.  
  
 Ta metoda Konwertuje obiekt, który jest przekazywany w `routeValues` do <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> obiektu przy użyciu <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> konstruktora. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Wywoływana jest metoda następnie ustalić adresu URL.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania tej metody do przekierowania do trasy, o nazwie `Product` i ma parametry, które są nazywane `productid` i `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie podjęto próbę po wysłał nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeValues">Wartości parametrów trasy.</param>
        <summary>Wykonuje przekierowanie trwałe z żądanego adresu URL do nowego adresu URL przy użyciu wartości parametru trasy i nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metody z drugim parametrem ustawioną `false`.  
  
 Ta metoda wywołuje <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodę, aby określić adres URL.  
  
 ASP.NET wykonuje przekierowanie zwróciła kod stanu HTTP 301.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania tej metody do przekierowania do trasy, o nazwie `Product` i ma parametry, które są nazywane `productid` i `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Żadna trasa odpowiada określone parametry trasy.</exception>
        <exception cref="T:System.Web.HttpException">Przekierowanie podjęto próbę po wysłał nagłówków HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa buforowane elementy z wyjściowej pamięci podręcznej przy użyciu domyślnego dostawcy pamięci podręcznej danych wyjściowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Bezwzględna ścieżka wirtualna do elementów, które są usuwane z pamięci podręcznej.</param>
        <summary>Usuwa z pamięci podręcznej wszystkie buforowane elementy, które są skojarzone z domyślnego dostawcy pamięci podręcznej danych wyjściowych. Ta metoda jest statyczna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z domyślnego dostawcy pamięci podręcznej danych wyjściowych. Wywołanie <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> metodę, aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z niestandardowych dostawców pamięci podręcznej danych wyjściowych, które są określone w pliku konfiguracji witryny sieci Web.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> nie jest bezwzględną ścieżką wirtualną.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Bezwzględna ścieżka wirtualna elementów, które są usuwane z pamięci podręcznej.</param>
        <param name="providerName">Dostawcy, który służy do usuwania artefakty pamięci podręcznej danych wyjściowych, które są skojarzone z określoną ścieżką.</param>
        <summary>Używa określonego dostawcy pamięci podręcznej danych wyjściowych, aby usunąć wszystkie elementy pamięci podręcznej danych wyjściowych, które są skojarzone z określoną ścieżką.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z niestandardowych dostawców pamięci podręcznej danych wyjściowych, które są określone w pliku konfiguracji witryny sieci Web. Aby usunąć elementy pamięci podręcznej danych wyjściowych, które są skojarzone z pamięci podręcznej danych wyjściowych domyślnego dostawcę, należy wywołać <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest nieprawidłową ścieżkę.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Plik cookie w kolekcji do zaktualizowania.</param>
        <summary>Ponieważ <b>HttpResponse.SetCookie</b> metoda jest przeznaczona tylko do użytku wewnętrznego, nie należy wywołać ją w kodzie. Zamiast tego można wywołać <b>HttpResponse.Cookies.Set</b> metody, jak przedstawiono na poniższym przykładzie.<br /> Aktualizuje istniejący plik cookie w kolekcji plików cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład aktualizuje wartość istniejący plik cookie.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Próbowano ustawić plik cookie po nagłówków HTTP zostały wysłane.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia <see langword="Status" /> wiersza, która jest zwracana do klienta.</summary>
        <value>Kod stanu ustawienie powoduje, że ciąg opisujący stan wyniku HTTP, która ma zostać zwrócona do klienta. Wartość domyślna to 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> przestarzała uzyskać <xref:System.Web.HttpResponse.StatusDescription%2A> i tylko w celu zachowania zgodności z wcześniejszymi wersjami programu ASP. ASP.NET, za pomocą <xref:System.Web.HttpResponse.StatusDescription%2A> zamiast tego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Stan jest ustawiony na kod nieprawidłowy stan.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod stanu HTTP wyjścia zwróconego do klienta.</summary>
        <value>Liczba całkowita reprezentująca stan HTTP wyjścia zwróconego do klienta. Wartość domyślna to 200 (OK). Zawiera listę kodów stanu prawidłowe, zobacz [kody stanu Http] (http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza kod stanu strumienia wyjściowego. Jeśli kod stanu nie jest równy 200, dodatkowy kod jest wykonywany.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.StatusCode" /> ustawiono po wysłaniu nagłówków HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg stanu HTTP wyjścia zwróconego do klienta.</summary>
        <value>Ciąg opisujący stan HTTP wyjścia zwróconego do klienta. Wartość domyślna to "OK". Zawiera listę kodów stanu prawidłowe, zobacz [kody stanu Http] (http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza ciąg stanu strumienia wyjściowego. Jeśli stan nie jest równa "OK", dodatkowe kod jest wykonywany.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="StatusDescription" /> ustawiono po wysłaniu nagłówków HTTP.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wybrana wartość ma długość większą niż 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość kwalifikowanie kod stanu odpowiedzi.</summary>
        <value>Wartość całkowitą, która reprezentuje [! Kod stanu podrzędnego include[iisver](~/includes/iisver-MD.MD)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.SubStatusCode%2A> Właściwość jest obsługiwana tylko w trybie zintegrowanym potoku [!INCLUDE[iisver](~/includes/iisver-md.md)] i co najmniej programu .NET Framework w wersji 3.0 lub nowszej. Podczas ustawiania <xref:System.Web.HttpResponse.SubStatusCode%2A> właściwości, stan jest zalogowany [!INCLUDE[iisver](~/includes/iisver-md.md)] Jeśli skonfigurowane jest śledzenie żądanie nie powiodło się. Niezależnie od tego, czy skonfigurowane jest śledzenie, kod nigdy nie są wysyłane jako część ostatecznej odpowiedzi na żądanie. Aby uzyskać więcej informacji, zobacz [rozwiązywania problemów nie powiodło się żądania za pomocą śledzenia nieudanych żądań w usługach IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Web.HttpResponse.SubStatusCode%2A> właściwości w obsłudze zdarzeń dla <xref:System.Web.HttpApplication> wystąpienie <xref:System.Web.HttpApplication.PostAuthenticateRequest> zdarzeń. Umieść plik kodu w folderze App_Code aplikacji sieci Web i konfigurowanie pliku Web.config można zarejestrować modułu. Aby uzyskać więcej informacji, zobacz [wskazówki: tworzenie i Rejestrowanie modułu HTTP niestandardowe](http://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Operacja wymaga trybu zintegrowanego potoku w [! INCLUDE[iisver](~/includes/iisver-MD.MD)] i co najmniej programu .NET Framework w wersji 3.0 lub nowszej.</exception>
        <exception cref="T:System.Web.HttpException">Kod stanu jest ustawiana po wysłaniu wszystkich nagłówków HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy połączenie obsługuje opróżniania operacji asynchronicznych.</summary>
        <value>
          <see langword="true" /> Jeśli połączenie obsługuje asynchroniczne operacje opróżniania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do wysłania zawartości HTTP klienta.</summary>
        <value>
          <see langword="true" /> Aby pominąć dane wyjściowe; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Następujące testy przykład czy <xref:System.Web.HttpRequest.IsSecureConnection%2A> właściwość jest ustawiona na wartość false. Jeśli tak jest, <xref:System.Web.HttpResponse.SuppressContent%2A> właściwość jest ustawiona na true, aby zatrzymać wysłanie odpowiedzi.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Obsługiwane w programie .NET Framework 4.5.2 i nowszych wersjach]  Pobiera lub ustawia wartość wskazującą, czy pominąć domyślna <c>kontroli pamięci podręcznej: prywatnej</c> nagłówek dla bieżącej odpowiedzi HTTP.</summary>
        <value>
          <see langword="true" /> Aby pominąć domyślne <c>kontroli pamięci podręcznej: prywatnej</c> nagłówek dla bieżącej odpowiedzi HTTP; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie wysyła ASP.NET `Cache-Control: private` nagłówka odpowiedzi, chyba że zasady jawne pamięci podręcznej został określony dla tej odpowiedzi. Ta właściwość umożliwia pomijanie ten nagłówek odpowiedzi domyślne na podstawie danego żądania. Nadal można pominąć nagłówek na całej aplikacji przez ustawienie <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> w [httpRuntime — Element (schemat ustawień programu ASP.NET)](http://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) lub [outputCache Element do buforowania (schemat ustawień ASP.NET)](http://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Należy zachować ostrożność podczas pomijanie domyślnie `Cache-Control: private` nagłówka jako serwery proxy i innych pośredników mogą traktować odpowiedzi bez tego nagłówka jako buforowalnej domyślnie. Takie podejście może prowadzić do niepotrzebnemu buforowaniu poufne informacje. Zobacz [RFC 2616, 13.4 s.](http://tools.ietf.org/html/rfc2616) Aby uzyskać więcej informacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy ma być pomijana przekierowania uwierzytelniania formularzy do strony logowania.</summary>
        <value>
          <see langword="true" /> Jeśli ma być pomijana przekierowania uwierzytelniania formularzy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie uwierzytelnianie formularzy konwertuje kodów stanu HTTP 401 na 302 w celu przekierowania do strony logowania. To nie jest odpowiednia dla niektórych klas błędów, na przykład gdy uwierzytelnienie zakończy się pomyślnie, ale autoryzacji nie powiedzie się lub gdy bieżące żądanie dotyczy żądanie obsługi AJAX lub sieci web. Ta właściwość umożliwia pomijanie zachowanie przekierowania i wysłać do klienta oryginalnym kod stanu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje określony plik bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP bez buforowania go w pamięci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w wyniku HTTP.</param>
        <summary>Zapisuje określony plik bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP, bez buforowania go w pamięci.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> Parametr jest <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w wyniku HTTP.</param>
        <param name="offset">Pozycja w pliku do zapisu w wyniku HTTP.</param>
        <param name="length">Liczba bajtów, które mają być przekazywane.</param>
        <summary>Zapisuje określoną część pliku bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP bez buforowania go w pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określisz 0 jako `offset` parametr i wartość -1 jako `length` parametru wysyłane cały plik.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="offset" /> Parametru jest mniejszy od zera.  \- lub - <paramref name="length" /> parametr jest mniejsza niż -1.  \- lub - <paramref name="length" /> parametr określa liczbę bajtów jest większa niż liczba bajtów, plik zawiera minus przesunięcie.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Żądanie poza procesem proces roboczy nie jest obsługiwane.  \- lub — w odpowiedzi nie używa <see cref="T:System.Web.HttpWriter" /> obiektu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> Parametr jest mniejsza niż zero lub większy niż rozmiar pliku.  \- lub - <paramref name="length" /> parametrów jest mniejsza niż -1 lub większa niż wartość <paramref name="offset" /> parametru powiększony o rozmiar pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą czy [! INCLUDE[iisver](~/includes/iisver-MD.MD)] błędy niestandardowe są wyłączone.</summary>
        <value>
          <see langword="true" /> Aby wyłączyć błędów niestandardowych usług IIS; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> Właściwość jest używana tylko wtedy, gdy aplikacja jest hostowana w usługach IIS 7.0. Podczas uruchamiania w trybie klasycznym w usługach IIS 7.0 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> jest wartość domyślna właściwości `true`. Podczas uruchamiania w trybie zintegrowanym <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> jest wartość domyślna właściwości `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje informacje w strumieniu wyjściowym odpowiedzi HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Znak do zapisu HTTP output strumienia.</param>
        <summary>Zapisuje znak w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy serię stałe, które są zapisywane do strony ASP.NET przy użyciu metody zapisu. Kod wywołuje metody zapisu do zapisu stałe znakowe poszczególnych strony tej wersji.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Object" /> Można zapisać do strumienia wyjściowego HTTP.</param>
        <summary>Zapisuje <see cref="T:System.Object" /> do strumienia odpowiedzi HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg do zapisu HTTP output strumienia.</param>
        <summary>Zapisuje ciąg w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamicznie generowanym stron HTML można wprowadzać zagrożenia bezpieczeństwa, jeśli dane wejściowe otrzymane z klientów sieci Web nie jest sprawdzana poprawność po odebraniu przez klienta lub są przesyłane do klienta. Złośliwy skrypt, który jest osadzony w danych wejściowych przesłane do witryny sieci Web i później zapisywane klient może się pojawić pochodzącym z zaufanego źródła. To zagrożenie bezpieczeństwa jest określana jako atak skryptowy między witrynami. Zawsze należy sprawdzić, czy dane odebrane od klienta, gdy zostanie on przekazywane z lokacji do przeglądarki klienta.  
  
 Ponadto, gdy można zapisać jako plik HTML żadnych danych, która została odebrana jako dane wejściowe, powinien kodowania go przy użyciu technik, takich jak <xref:System.Web.HttpServerUtility.HtmlEncode%2A> lub <xref:System.Web.HttpServerUtility.UrlEncode%2A> aby zapobiec wykonywania przez złośliwy skrypt. Ta technika jest przydatne w przypadku danych, która nie została zweryfikowana, gdy zostało przesłane.  
  
 Zakoduj lub filtrowanie danych, należy określić zestaw znaków dla stron sieci Web, aby filtru można zidentyfikować i usuwać żadnych bajtów sekwencje, które nie należą do ustaw (na przykład sekwencji innych niż alfanumeryczne), które może potencjalnie złośliwy skrypt osadzony w je.  
  
 Aby uzyskać więcej informacji dotyczących ataków skryptów między witrynami, zobacz artykuł Q252985, "Sposób można zapobiec Cross-Site skryptów problemy z zabezpieczeniami" w [bazy wiedzy Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?LinkID=37115) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład zwraca nazwę klienta do przeglądarki klienta. <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Metoda usuwa wszelkie złośliwy skrypt i nieprawidłowe znaki, które mogą przesłać w `UserName` pola wejściowego.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków do zapisu.</param>
        <param name="index">Pozycja w tablicy znaków, w której rozpoczyna się zapisu.</param>
        <param name="count">Liczba znaków do zapisu, rozpoczynając od <c>indeksu</c>.</param>
        <summary>Zapisuje tablicę znaków w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy serię stałe, które są zapisywane do strony ASP.NET przy użyciu metody zapisu. Kod wywołuje metody zapisu do zapisu stałe znakowe poszczególnych strony tej wersji.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje określony plik bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu w wyniku HTTP.</param>
        <summary>Zapisuje zawartość określonego pliku bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP jako blokowania plików.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany z tej metody zależy od konfiguracji sprzętu serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406, "PRB: Response.WriteFile nie można pobrać plików o dużym" w [bazy wiedzy Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład zapisuje zawartość pliku tekstowego o nazwie `Login.txt` (który może zawierać literału kontrolek HTML tekstu i dane wejściowe) bezpośrednio do strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu do bloku pamięci.</param>
        <param name="readIntoMemory">Wskazuje, czy plik zostanie zapisany w bloku pamięci.</param>
        <summary>Zapisuje zawartość określonego pliku bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP jako bloku pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany z tej metody zależy od konfiguracji sprzętu serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406, "PRB: Response.WriteFile nie można pobrać plików o dużym" w [bazy wiedzy Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład zapisuje plik w pamięci.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Dojście do pliku pliku do zapisu do strumienia wyjściowego HTTP.</param>
        <param name="offset">Pozycja bajtów w pliku, gdy rozpocznie się zapisu.</param>
        <param name="size">Liczba bajtów do zapisania w strumieniu wyjściowym.</param>
        <summary>Zapisuje określony plik bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany z tej metody zależy od konfiguracji sprzętu serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406, "PRB: Response.WriteFile nie można pobrać plików o dużym" w [bazy wiedzy Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład zapisuje zawartość pliku tekstowego o nazwie `Login.txt` (który może zawierać literału kontrolek HTML tekstu i dane wejściowe) bezpośrednio do strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileHandler" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> jest mniejsza niż 0.  \- lub - <paramref name="size" /> jest większy niż rozmiar pliku minus <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nazwa pliku do zapisu HTTP output strumienia.</param>
        <param name="offset">Pozycja bajtów w pliku, gdy rozpocznie się zapisu.</param>
        <param name="size">Liczba bajtów do zapisania w strumieniu wyjściowym.</param>
        <summary>Zapisuje określony plik bezpośrednio w strumieniu wyjściowym odpowiedzi HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest używana z dużymi plikami, wywołanie metody może zgłosić wyjątek. Rozmiar pliku, który może być używany z tej metody zależy od konfiguracji sprzętu serwera sieci Web. Aby uzyskać więcej informacji, zobacz artykuł 812406, "PRB: Response.WriteFile nie można pobrać plików o dużym" w [bazy wiedzy Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) witryny sieci Web.  
  
   
  
## Examples  
 Poniższy przykład zapisuje zawartość pliku tekstowego o nazwie `Login.txt` (który może zawierać literału tekst i HTML wejściowych kontrolek) bezpośrednio do strumienia wyjściowego.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> jest mniejsza niż 0.  \- lub - <paramref name="size" /> jest większy niż rozmiar pliku minus <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda, kontrolki użytkownika lub obiektu do zastąpienia.</param>
        <summary>Umożliwia wstawienie bloków podstawienia odpowiedzi do odpowiedzi, która umożliwia dynamiczne generowanie kodu odpowiedzi określonych regionów dla odpowiedzi w pamięci podręcznej danych wyjściowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Web.HttpResponse.WriteSubstitution%2A> metody podstawiania po pamięci podręcznej w pamięci podręcznej danych wyjściowych strony. Przez przekazanie <xref:System.Web.HttpContext> obiektu do metody wywołania zwrotnego z wyznaczonych <xref:System.Web.HttpResponseSubstitutionCallback> podpisu, można zastąpić danych wyjściowych w pamięci podręcznej zawartości w dowolnym miejscu podanego w pamięci podręcznej stron. Aby zainicjować zastąpienia, należy wywołać <xref:System.Web.HttpResponse.WriteSubstitution%2A> metody przekazanie jej przez metodę wywołania zwrotnego, która musi zapewniać bezpieczeństwo wątkowe i może być jedną z następujących czynności:  
  
-   Metoda statyczna formantu kontenera strony lub użytkownika.  
  
-   Statycznych lub metoda obiektu dowolnego innego wystąpienia.  
  
 Na pierwsze żądanie do strony <xref:System.Web.HttpResponse.WriteSubstitution%2A> wywołania <xref:System.Web.HttpResponseSubstitutionCallback> delegata do generowania danych wyjściowych. Następnie dodaje bufor podstawienia do odpowiedzi, która zachowuje delegata, który ma zostać wywołany w przyszłych żądań. Na koniec powoduje spadek buforowanie po stronie klienta z publicznej tylko do serwera, do zapewnienia przyszłych żądań do wywołania ponownie strony delegat przez nie pamięci podręcznej na kliencie.  
  
> [!NOTE]
>  Podstawianie po pamięci podręcznej nie jest obsługiwana dla kontrolkę użytkownika pamięci podręcznej, w którym buforowanie danych wyjściowych jest stosowana na poziomie formantu użytkownika. Jest to również nazywane buforowanie fragmentu. Aby uzyskać więcej informacji, zobacz [buforowanie części strony ASP.NET](http://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element docelowy <paramref name="callback" /> parametr jest typu <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
      </Docs>
    </Member>
  </Members>
</Type>
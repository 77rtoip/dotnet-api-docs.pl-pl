<Type Name="Image" FullName="System.Drawing.Image">
  <Metadata><Meta Name="ms.openlocfilehash" Value="016a5da1cb2c9c23eae9e8b7af4bfdab20df177f" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56778982" /></Metadata><TypeSignature Language="C#" Value="public abstract class Image : MarshalByRefObject, ICloneable, IDisposable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Image extends System.MarshalByRefObject implements class System.ICloneable, class System.IDisposable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Image" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Image&#xA;Inherits MarshalByRefObject&#xA;Implements ICloneable, IDisposable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Image abstract : MarshalByRefObject, ICloneable, IDisposable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Image = class&#xA;    inherit MarshalByRefObject&#xA;    interface ISerializable&#xA;    interface ICloneable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Drawing.Common</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.1</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.ImageEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
      <AttributeName>System.ComponentModel.ImmutableObject(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Drawing.ImageConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.ImageEditor, System.Drawing.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.ImageEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="dotnet-plat-ext-3.0">
      <AttributeName>System.ComponentModel.TypeConverter("System.Drawing.ImageConverter, System.Windows.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Abstrakcyjna klasa bazowa dostarczająca funkcje dla <see cref="T:System.Drawing.Bitmap" /> i <see cref="T:System.Drawing.Imaging.Metafile" /> wywodzi się klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby narysować <xref:System.Drawing.Image> w formularzu Windows, należy użyć jednej z <xref:System.Drawing.Graphics.DrawImage%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms. Program obsługi jest <xref:System.Windows.Forms.Control.Paint> zdarzeń. A <xref:System.Drawing.Graphics> obiekt jest przekazywany do zdarzenia, a używany do rysowania obrazu w formularzu. Kod wykonuje następujące czynności:  
  
-   Tworzy obraz z pliku o nazwie SampImag.jpg. Ten plik musi znajdować się w tym samym folderze co plik wykonywalny aplikacji.  
  
-   Tworzy punkt, w którym należy narysować w lewym górnym rogu obrazu.  
  
-   Rysuje nieskalowanego obrazu w formularzu.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#55](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#55)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#55)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#55)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Obrazy, mapy bitowe i metapliki</related>
    <related type="Article" href="https://msdn.microsoft.com/library/a626d701-bd99-4fd8-b92f-7b8f794e042b">Praca z obrazami, mapami bitowymi, ikonami i metaplikami</related>
  </Docs>
  <Members>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="image.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy dokładną kopię tego <see cref="T:System.Drawing.Image" />.</summary>
        <returns><see cref="T:System.Drawing.Image" /> Ta metoda tworzy, rzutowany jako obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez to <see cref="T:System.Drawing.Image" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Drawing.Image.Dispose%2A> przed publikacją swoje ostatnie odwołanie do <xref:System.Drawing.Image>. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.Drawing.Image> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="image.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez to <see cref="T:System.Drawing.Image" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Drawing.Image.Dispose%2A> metoda umożliwia zasoby używane przez to <xref:System.Drawing.Image> zostają przeniesione do innych celów.  
  
 Wywołaj <xref:System.Drawing.Image.Dispose%2A> po zakończeniu przy użyciu <xref:System.Drawing.Image>. <xref:System.Drawing.Image.Dispose%2A> Pozostawia metoda <xref:System.Drawing.Image> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Drawing.Image.Dispose%2A>, trzeba zwolnić wszystkie odwołania do <xref:System.Drawing.Image> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.Drawing.Image> zajmowaną przez wystąpienie. Aby uzyskać więcej informacji, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Drawing.Image.Dispose%2A> przed publikacją swoje ostatnie odwołanie do <xref:System.Drawing.Image>. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.Drawing.Image> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="image.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Drawing.Image" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Drawing.Image.Dispose%2A> przed publikacją swoje ostatnie odwołanie do <xref:System.Drawing.Image>. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.Drawing.Image> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Image ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Image ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="image.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektu spróbuj zwolnić zasoby i wykonywać inne operacje oczyszczania, zanim go jest odzyskiwane przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public int Flags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Flags" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.Flags" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Flags As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Flags { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Flags : int" Usage="System.Drawing.Image.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybut Flagi dla danych pikseli <see cref="T:System.Drawing.Image" />.</summary>
        <value>Liczbę całkowitą przedstawiającą bitowa kombinacja <see cref="T:System.Drawing.Imaging.ImageFlags" /> tego <see cref="T:System.Drawing.Image" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość całkowitą zwracane z tej metody odpowiadają sumę <xref:System.Drawing.Imaging.ImageFlags>, zgodnie z opisem w poniższej tabeli.  
  
|Wartość ImageFlag|Reprezentacja liczby całkowitej|  
|---------------------|----------------------------|  
|`ImageFlagsNone`|0|  
|`ImageFlagsScalable`|1|  
|`ImageFlagsHasAlpha`|2|  
|`ImageFlagsHasTranslucent`|4|  
|`ImageFlagsPartiallyScalable`|8|  
|`ImageFlagsColorSpaceRGB`|16|  
|`ImageFlagsColorSpaceCMYK`|32|  
|`ImageFlagsColorSpaceGRAY`|64|  
|`ImageFlagsColorSpaceYCBCR`|128|  
|`ImageFlagsColorSpaceYCCK`|256|  
|`ImageFlagsHasRealDPI`|4096|  
|`ImageFlagsHasRealPixelSize`|8192|  
|`ImageFlagsReadOnly`|65536|  
|`ImageFlagsCaching`|131072|  
  
 Na przykład jeśli <xref:System.Drawing.Image.Flags%2A> właściwość obrazu zwróciła 77960, <xref:System.Drawing.Imaging.ImageFlags> obraz, który może być <xref:System.Drawing.Imaging.ImageFlags.ReadOnly>, <xref:System.Drawing.Imaging.ImageFlags.HasRealDpi>, <xref:System.Drawing.Imaging.ImageFlags.HasRealPixelSize>, <xref:System.Drawing.Imaging.ImageFlags.ColorSpaceYcbcr>, i <xref:System.Drawing.Imaging.ImageFlags.PartiallyScalable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameDimensionsList">
      <MemberSignature Language="C#" Value="public Guid[] FrameDimensionsList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid[] FrameDimensionsList" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.FrameDimensionsList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FrameDimensionsList As Guid()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Guid&gt; ^ FrameDimensionsList { cli::array &lt;Guid&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FrameDimensionsList : Guid[]" Usage="System.Drawing.Image.FrameDimensionsList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tablicę identyfikatorów GUID, które reprezentują wymiary ramki w ramach tej <see cref="T:System.Drawing.Image" />.</summary>
        <value>Tablica identyfikatorów GUID, które określają wymiary ramki w ramach tej <see cref="T:System.Drawing.Image" /> od najbardziej do najmniej znaczących.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca informacje na temat ramki wiele obrazów, które są oferowane w dwóch style: wiele stron i wielu rozdzielczości.  
  
 Obraz wielu stron jest obraz, który zawiera więcej niż jeden obraz. Każda strona zawiera pojedynczy obraz (lub ramki). Te strony (lub obrazów lub ramek) zazwyczaj są wyświetlane w odstępie czasu, aby utworzyć animację, takich jak animowanych plików GIF.  
  
 Obraz wielu rozdzielczości jest obraz, który zawiera więcej niż jedną kopię obrazu w różnych rozdzielczościach. To jest powszechnie używanych przez mapowanie MIP gdzie rozmiar obrazu wyświetlanego Określa rozdzielczość obrazu użytego do rysowania. [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] może obsługiwać dowolną liczbę stron (lub obrazów lub ramek), a także dowolną liczbę rozwiązania. Zdefiniowane wymiary są właściwości <xref:System.Drawing.Imaging.FrameDimension>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromFile">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Drawing.Image" /> z określonego pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromFile">
      <MemberSignature Language="C#" Value="public static System.Drawing.Image FromFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Image FromFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.FromFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFile (filename As String) As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Image ^ FromFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="static member FromFile : string -&gt; System.Drawing.Image" Usage="System.Drawing.Image.FromFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Ciąg, który zawiera nazwę pliku, z której ma zostać utworzona <see cref="T:System.Drawing.Image" />.</param>
        <summary>Tworzy <see cref="T:System.Drawing.Image" /> z określonego pliku.</summary>
        <returns><see cref="T:System.Drawing.Image" /> Ta metoda tworzy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarządzanym GDI + ma wbudowane kodeków, które obsługują następujące typy plików:  
  
-   BMP  
  
-   GIF  
  
-   JPEG  
  
-   PNG  
  
-   TIFF  
  
 Plik jest zablokowany do momentu <xref:System.Drawing.Image> zostanie usunięty.  
  
 Jeśli plik nie ma prawidłowego formatu obrazu lub [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] nie obsługuje format pikseli pliku, ta metoda wyrzuca <xref:System.OutOfMemoryException> wyjątku.  
  
> [!NOTE]
>  <xref:System.Drawing.Image> Klasa nie obsługuje alfa przezroczystości map bitowych. Aby włączyć alfa przezroczystości, należy użyć obrazów PNG z 32 bity na piksel.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Drawing.Image.FromFile%2A> <xref:System.Drawing.Image.GetPropertyItem%2A> i <xref:System.Drawing.Image.SetPropertyItem%2A> metody. W tym przykładzie jest przeznaczona do użycia za pomocą interfejsu Windows Forms. Aby uruchomić ten przykład, wkleić go do formularza i obsługiwać formularza <xref:System.Windows.Forms.Control.Paint> zdarzeń przez wywołanie metody `DemonstratePropertyItem` jest metoda `e` jako <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.ImageExample#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ImageExample/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.ImageExample#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ImageExample/CS/form1.cs#7)]
 [!code-vb[System.Drawing.ImageExample#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ImageExample/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Plik nie ma prawidłowego formatu obrazu.  
  
—lub— 
 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] nie obsługuje format pikseli pliku.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Określony plik nie istnieje.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="filename" /> jest <see cref="T:System.Uri" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/6be085a2-2c13-47c8-b80a-c18b32777d8d">Typy map bitowych</related>
      </Docs>
    </Member>
    <Member MemberName="FromFile">
      <MemberSignature Language="C#" Value="public static System.Drawing.Image FromFile (string filename, bool useEmbeddedColorManagement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Image FromFile(string filename, bool useEmbeddedColorManagement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.FromFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFile (filename As String, useEmbeddedColorManagement As Boolean) As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Image ^ FromFile(System::String ^ filename, bool useEmbeddedColorManagement);" />
      <MemberSignature Language="F#" Value="static member FromFile : string * bool -&gt; System.Drawing.Image" Usage="System.Drawing.Image.FromFile (filename, useEmbeddedColorManagement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="useEmbeddedColorManagement" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Ciąg, który zawiera nazwę pliku, z której ma zostać utworzona <see cref="T:System.Drawing.Image" />.</param>
        <param name="useEmbeddedColorManagement">Ustaw <see langword="true" /> do użycia informacje o zarządzaniu kolor osadzone w pliku obrazu; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy <see cref="T:System.Drawing.Image" /> z określonego pliku przy użyciu osadzonych informacji o zarządzaniu kolorów w tym pliku.</summary>
        <returns><see cref="T:System.Drawing.Image" /> Ta metoda tworzy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarządzanym GDI + ma wbudowane kodeków, które obsługują następujące typy plików:  
  
-   BMP  
  
-   GIF  
  
-   JPEG  
  
-   PNG  
  
-   TIFF  
  
 Jeśli plik nie ma prawidłowego formatu obrazu lub [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] nie obsługuje format pikseli pliku, ta metoda wyrzuca <xref:System.OutOfMemoryException> wyjątku.  
  
 Plik jest zablokowany do momentu <xref:System.Drawing.Image> zostanie usunięty.  
  
 `useEmbeddedColorManagement` Parametr określa, czy nowy <xref:System.Drawing.Image> stosuje się korekcji kolorów zgodnie z informacji dotyczących zarządzania kolorami, który jest osadzony w pliku obrazu. Osadzony informacje mogą obejmować profile konsorcjum kolor międzynarodowy (ICC), wartości gamma i trójchromatyczna informacji.  
  
> [!NOTE]
>  <xref:System.Drawing.Image> Klasa nie obsługuje alfa przezroczystości map bitowych. Aby włączyć alfa przezroczystości, należy użyć obrazów PNG z 32 bity na piksel.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób uzyskiwania nowej mapy bitowej, używając <xref:System.Drawing.Image.FromFile%2A> metody. Ilustruje też <xref:System.Drawing.TextureBrush>.  
  
 W tym przykładzie jest przeznaczona do użycia za pomocą interfejsu Windows Forms. Tworzenie formularza zawierającego przycisk o nazwie `Button2`. Wklej kod do formularza i skojarz `Button2_Click` metody przy użyciu przycisku <xref:System.Windows.Forms.Control.Click> zdarzeń.  
  
 [!code-cpp[System.Drawing.ImageExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ImageExample/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.ImageExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ImageExample/CS/form1.cs#2)]
 [!code-vb[System.Drawing.ImageExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ImageExample/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Plik nie ma prawidłowego formatu obrazu.  
  
—lub— 
 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] nie obsługuje format pikseli pliku.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Określony plik nie istnieje.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="filename" /> jest <see cref="T:System.Uri" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/6be085a2-2c13-47c8-b80a-c18b32777d8d">Typy map bitowych</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHbitmap">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Drawing.Bitmap" /> dojścia Windows.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHbitmap">
      <MemberSignature Language="C#" Value="public static System.Drawing.Bitmap FromHbitmap (IntPtr hbitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Bitmap FromHbitmap(native int hbitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.FromHbitmap(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHbitmap (hbitmap As IntPtr) As Bitmap" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Bitmap ^ FromHbitmap(IntPtr hbitmap);" />
      <MemberSignature Language="F#" Value="static member FromHbitmap : nativeint -&gt; System.Drawing.Bitmap" Usage="System.Drawing.Image.FromHbitmap hbitmap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Bitmap</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hbitmap" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hbitmap">[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Dojścia mapy bitowej, z której ma zostać utworzona <see cref="T:System.Drawing.Bitmap" />.</param>
        <summary>Tworzy <see cref="T:System.Drawing.Bitmap" /> dojścia do mapy bitowej GDI.</summary>
        <returns><see cref="T:System.Drawing.Bitmap" /> Ta metoda tworzy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image.FromHbitmap%2A> Metoda tworzy kopię [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] mapę bitową; dlatego można zwolnić przychodzącego [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] mapy bitowej przy użyciu [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] `DeleteObject` metoda natychmiast po utworzeniu nowego <xref:System.Drawing.Image>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHbitmap">
      <MemberSignature Language="C#" Value="public static System.Drawing.Bitmap FromHbitmap (IntPtr hbitmap, IntPtr hpalette);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Bitmap FromHbitmap(native int hbitmap, native int hpalette) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.FromHbitmap(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHbitmap (hbitmap As IntPtr, hpalette As IntPtr) As Bitmap" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Bitmap ^ FromHbitmap(IntPtr hbitmap, IntPtr hpalette);" />
      <MemberSignature Language="F#" Value="static member FromHbitmap : nativeint * nativeint -&gt; System.Drawing.Bitmap" Usage="System.Drawing.Image.FromHbitmap (hbitmap, hpalette)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Bitmap</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hbitmap" Type="System.IntPtr" />
        <Parameter Name="hpalette" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hbitmap">[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Dojścia mapy bitowej, z której ma zostać utworzona <see cref="T:System.Drawing.Bitmap" />.</param>
        <param name="hpalette">Dojście do [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] palety używane do definiowania kolorów mapy bitowej, jeśli mapa bitowa określona w <paramref name="hbitmap" /> parametr nie jest mapa bitowa niezależna od urządzenia (DIB).</param>
        <summary>Tworzy <see cref="T:System.Drawing.Bitmap" /> dojścia do mapy bitowej GDI i dojścia do palety GDI.</summary>
        <returns><see cref="T:System.Drawing.Bitmap" /> Ta metoda tworzy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image.FromHbitmap%2A> Metoda tworzy kopię [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] mapę bitową; dlatego można zwolnić przychodzącego [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] mapy bitowej przy użyciu [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] `DeleteObject` metoda natychmiast po utworzeniu nowego <xref:System.Drawing.Image>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromStream">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Drawing.Image" /> ze strumienia określone dane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromStream">
      <MemberSignature Language="C#" Value="public static System.Drawing.Image FromStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Image FromStream(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.FromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Image ^ FromStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member FromStream : System.IO.Stream -&gt; System.Drawing.Image" Usage="System.Drawing.Image.FromStream stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> zawierający dane, w tym <see cref="T:System.Drawing.Image" />.</param>
        <summary>Tworzy <see cref="T:System.Drawing.Image" /> ze strumienia określone dane.</summary>
        <returns><see cref="T:System.Drawing.Image" /> Ta metoda tworzy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pozostawić strumienia otwarte przez okres istnienia <xref:System.Drawing.Image>.  
  
 Strumień jest resetowany do zera, jeśli ta metoda jest wywoływana kolejno przy użyciu tego samego strumienia.  
  
> [!NOTE]
>  <xref:System.Drawing.Image> Klasa nie obsługuje alfa przezroczystości map bitowych. Aby włączyć alfa przezroczystości, należy użyć obrazów PNG z 32 bity na piksel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Strumień nie ma prawidłowego formatu obrazu 
—lub— 
 <paramref name="stream" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromStream">
      <MemberSignature Language="C#" Value="public static System.Drawing.Image FromStream (System.IO.Stream stream, bool useEmbeddedColorManagement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Image FromStream(class System.IO.Stream stream, bool useEmbeddedColorManagement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.FromStream(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Image ^ FromStream(System::IO::Stream ^ stream, bool useEmbeddedColorManagement);" />
      <MemberSignature Language="F#" Value="static member FromStream : System.IO.Stream * bool -&gt; System.Drawing.Image" Usage="System.Drawing.Image.FromStream (stream, useEmbeddedColorManagement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="useEmbeddedColorManagement" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> zawierający dane, w tym <see cref="T:System.Drawing.Image" />.</param>
        <param name="useEmbeddedColorManagement"><see langword="true" /> Aby użyć informacji zarządzania kolor osadzone w strumieniu danych; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy <see cref="T:System.Drawing.Image" /> ze strumienia określone dane, opcjonalnie za pomocą osadzonych informacji o zarządzaniu kolorów w strumieniu.</summary>
        <returns><see cref="T:System.Drawing.Image" /> Ta metoda tworzy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pozostawić strumienia otwarte przez okres istnienia <xref:System.Drawing.Image>.  
  
 `useEmbeddedColorManagement` Parametr określa, czy nowy <xref:System.Drawing.Image> stosuje się korekcji kolorów zgodnie z informacji dotyczących zarządzania kolorami, który jest osadzony w strumieniu danych. Osadzony informacje mogą obejmować profile konsorcjum kolor międzynarodowy (ICC), wartości gamma i trójchromatyczna informacji.  
  
 Strumień jest resetowany do zera, jeśli ta metoda jest wywoływana kolejno przy użyciu tego samego strumienia.  
  
> [!NOTE]
>  <xref:System.Drawing.Image> Klasa nie obsługuje alfa przezroczystości map bitowych. Aby włączyć alfa przezroczystości, należy użyć obrazów PNG z 32 bity na piksel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Strumień nie ma prawidłowego formatu obrazu 
—lub— 
 <paramref name="stream" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromStream">
      <MemberSignature Language="C#" Value="public static System.Drawing.Image FromStream (System.IO.Stream stream, bool useEmbeddedColorManagement, bool validateImageData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Image FromStream(class System.IO.Stream stream, bool useEmbeddedColorManagement, bool validateImageData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.FromStream(System.IO.Stream,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Image ^ FromStream(System::IO::Stream ^ stream, bool useEmbeddedColorManagement, bool validateImageData);" />
      <MemberSignature Language="F#" Value="static member FromStream : System.IO.Stream * bool * bool -&gt; System.Drawing.Image" Usage="System.Drawing.Image.FromStream (stream, useEmbeddedColorManagement, validateImageData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="useEmbeddedColorManagement" Type="System.Boolean" />
        <Parameter Name="validateImageData" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> zawierający dane, w tym <see cref="T:System.Drawing.Image" />.</param>
        <param name="useEmbeddedColorManagement"><see langword="true" /> Aby użyć informacji zarządzania kolor osadzone w strumieniu danych; w przeciwnym razie <see langword="false" />.</param>
        <param name="validateImageData"><see langword="true" /> Aby sprawdzić poprawność danych obrazu; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy <see cref="T:System.Drawing.Image" /> ze strumienia określone dane, opcjonalnie przy użyciu osadzonych informacji o zarządzaniu kolorów i sprawdzanie poprawności danych obrazu.</summary>
        <returns><see cref="T:System.Drawing.Image" /> Ta metoda tworzy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `useEmbeddedColorManagement` Parametr określa, czy nowy <xref:System.Drawing.Image> stosuje się korekcji kolorów zgodnie z informacji dotyczących zarządzania kolorami, który jest osadzony w strumieniu danych. Osadzony informacje mogą obejmować profile konsorcjum kolor międzynarodowy (ICC), wartości gamma i trójchromatyczna informacji.  
  
> [!NOTE]
>  <xref:System.Drawing.Image> Klasa nie obsługuje alfa przezroczystości map bitowych. Aby włączyć alfa przezroczystości, należy użyć obrazów PNG z 32 bity na piksel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Strumień nie ma prawidłowego formatu obrazu.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (ref System.Drawing.GraphicsUnit pageUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(valuetype System.Drawing.GraphicsUnit&amp; pageUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.GetBounds(System.Drawing.GraphicsUnit@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBounds (ByRef pageUnit As GraphicsUnit) As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::GraphicsUnit % pageUnit);" />
      <MemberSignature Language="F#" Value="member this.GetBounds :  -&gt; System.Drawing.RectangleF" Usage="image.GetBounds pageUnit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pageUnit" Type="System.Drawing.GraphicsUnit" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pageUnit">Jedną z <see cref="T:System.Drawing.GraphicsUnit" /> wartości oznaczają jednostkę miary prostokąt otaczający.</param>
        <summary>Pobiera granicami obrazu w określonej jednostce.</summary>
        <returns><see cref="T:System.Drawing.RectangleF" /> Reprezentujący granicami obrazu, w określonej jednostce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób ładowania mapę bitową z <xref:System.Drawing.Icon> obsługi, za pomocą <xref:System.Drawing.GraphicsUnit> wyliczenie i sposobu użycia <xref:System.Drawing.Rectangle.Round%2A> metodę, aby narysować prostokąt granice mapy bitowej.  
  
 W tym przykładzie jest przeznaczona do użycia za pomocą interfejsu Windows Forms. Tworzenie formularza, która zawiera przycisk o nazwie `Button2`. Wklej kod do formularza i skojarzyć tę metodę, przy użyciu przycisku <xref:System.Windows.Forms.Control.Click> zdarzeń.  
  
 [!code-cpp[System.Drawing.BitmapMembers#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.BitmapMembers/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.BitmapMembers#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.BitmapMembers/CS/form1.cs#1)]
 [!code-vb[System.Drawing.BitmapMembers#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.BitmapMembers/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEncoderParameterList">
      <MemberSignature Language="C#" Value="public System.Drawing.Imaging.EncoderParameters GetEncoderParameterList (Guid encoder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Imaging.EncoderParameters GetEncoderParameterList(valuetype System.Guid encoder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.GetEncoderParameterList(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEncoderParameterList (encoder As Guid) As EncoderParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Imaging::EncoderParameters ^ GetEncoderParameterList(Guid encoder);" />
      <MemberSignature Language="F#" Value="member this.GetEncoderParameterList : Guid -&gt; System.Drawing.Imaging.EncoderParameters" Usage="image.GetEncoderParameterList encoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Imaging.EncoderParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoder" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="encoder">Identyfikator GUID, który określa kodeka obrazu.</param>
        <summary>Zwraca informacje na temat parametrów obsługiwanych przez koder określonego obrazu.</summary>
        <returns><see cref="T:System.Drawing.Imaging.EncoderParameters" /> Zawierający tablicę <see cref="T:System.Drawing.Imaging.EncoderParameter" /> obiektów. Każdy <see cref="T:System.Drawing.Imaging.EncoderParameter" /> zawiera informacje o jeden z parametrów obsługiwanych przez koder określonego obrazu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFrameCount">
      <MemberSignature Language="C#" Value="public int GetFrameCount (System.Drawing.Imaging.FrameDimension dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetFrameCount(class System.Drawing.Imaging.FrameDimension dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.GetFrameCount(System.Drawing.Imaging.FrameDimension)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFrameCount (dimension As FrameDimension) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetFrameCount(System::Drawing::Imaging::FrameDimension ^ dimension);" />
      <MemberSignature Language="F#" Value="member this.GetFrameCount : System.Drawing.Imaging.FrameDimension -&gt; int" Usage="image.GetFrameCount dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Drawing.Imaging.FrameDimension" />
      </Parameters>
      <Docs>
        <param name="dimension">Element <see cref="T:System.Drawing.Imaging.FrameDimension" /> , który określa tożsamości do typu wymiaru.</param>
        <summary>Zwraca liczbę ramek określonego wymiaru.</summary>
        <returns>Liczba ramek w określonym wymiarze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca informacje na temat ramki wiele obrazów, które są oferowane w dwóch style: wiele stron i wielu rozdzielczości.  
  
 Obraz wielu stron jest obraz, który zawiera więcej niż jeden obraz. Każda strona zawiera pojedynczy obraz (lub ramki). Te strony (lub obrazów lub ramek) zazwyczaj są wyświetlane w odstępie czasu, aby utworzyć animację, takich jak animowanych plików GIF.  
  
 Obraz wielu rozdzielczości jest obraz, który zawiera więcej niż jedną kopię obrazu w różnych rozdzielczościach. To jest powszechnie używanych przez mapowanie MIP gdzie rozmiar obrazu wyświetlanego Określa rozdzielczość obrazu użytego do rysowania. [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] może obsługiwać dowolną liczbę stron (lub obrazów lub ramek), a także dowolną liczbę rozwiązania. Zdefiniowane wymiary są właściwości <xref:System.Drawing.Imaging.FrameDimension>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPixelFormatSize">
      <MemberSignature Language="C#" Value="public static int GetPixelFormatSize (System.Drawing.Imaging.PixelFormat pixfmt);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetPixelFormatSize(valuetype System.Drawing.Imaging.PixelFormat pixfmt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.GetPixelFormatSize(System.Drawing.Imaging.PixelFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPixelFormatSize (pixfmt As PixelFormat) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetPixelFormatSize(System::Drawing::Imaging::PixelFormat pixfmt);" />
      <MemberSignature Language="F#" Value="static member GetPixelFormatSize : System.Drawing.Imaging.PixelFormat -&gt; int" Usage="System.Drawing.Image.GetPixelFormatSize pixfmt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pixfmt" Type="System.Drawing.Imaging.PixelFormat" />
      </Parameters>
      <Docs>
        <param name="pixfmt"><see cref="T:System.Drawing.Imaging.PixelFormat" /> Elementu członkowskiego, który określa format dla której wyszukiwany jest rozmiar.</param>
        <summary>Zwraca liczbę bitów na piksel, podanym formacie pikseli głębi kolorów.</summary>
        <returns>Głębi kolorów w podanym formacie pikseli.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyItem">
      <MemberSignature Language="C#" Value="public System.Drawing.Imaging.PropertyItem GetPropertyItem (int propid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Imaging.PropertyItem GetPropertyItem(int32 propid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.GetPropertyItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyItem (propid As Integer) As PropertyItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Imaging::PropertyItem ^ GetPropertyItem(int propid);" />
      <MemberSignature Language="F#" Value="member this.GetPropertyItem : int -&gt; System.Drawing.Imaging.PropertyItem" Usage="image.GetPropertyItem propid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Imaging.PropertyItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propid" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="propid">Identyfikator elementu właściwości do pobrania.</param>
        <summary>Pobiera element określonej właściwości z tego <see cref="T:System.Drawing.Image" />.</summary>
        <returns><see cref="T:System.Drawing.Imaging.PropertyItem" /> Pobiera tę metodę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę identyfikatorów elementu właściwości i linki do szczegółowych informacji, zobacz <xref:System.Drawing.Imaging.PropertyItem.Id%2A>.  
  
 Trudno jest ustawianie właściwości elementów, ponieważ <xref:System.Drawing.Imaging.PropertyItem> klasa nie ma publicznych konstruktorów. Jednym ze sposobów, aby obejść to ograniczenie jest uzyskanie <xref:System.Drawing.Imaging.PropertyItem> pobierając <xref:System.Drawing.Image.PropertyItems%2A> wartości właściwości lub wywoływania <xref:System.Drawing.Image.GetPropertyItem%2A> metody <xref:System.Drawing.Image> zawierający elementy właściwości. Następnie można ustawić pola <xref:System.Drawing.Imaging.PropertyItem> i przekazać ją do <xref:System.Drawing.Image.SetPropertyItem%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Drawing.Image.GetPropertyItem%2A> i <xref:System.Drawing.Image.SetPropertyItem%2A> metody. Ten przykład wywołuje <xref:System.Drawing.Image.GetPropertyItem%2A> przekazywanie wartości Identyfikatora. Dla listy identyfikator wartości, zobacz <xref:System.Drawing.Imaging.PropertyItem.Id%2A>. W tym przykładzie jest przeznaczona do użycia za pomocą interfejsu Windows Forms. Aby uruchomić ten przykład, wkleić go do formularza i obsługiwać formularza <xref:System.Windows.Forms.Control.Paint> zdarzeń przez wywołanie metody `DemonstratePropertyItem` jest metoda `e` jako <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.ImageExample#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ImageExample/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.ImageExample#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ImageExample/CS/form1.cs#7)]
 [!code-vb[System.Drawing.ImageExample#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ImageExample/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Format obrazu tego obrazu nie obsługuje elementy właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetThumbnailImage">
      <MemberSignature Language="C#" Value="public System.Drawing.Image GetThumbnailImage (int thumbWidth, int thumbHeight, System.Drawing.Image.GetThumbnailImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Image GetThumbnailImage(int32 thumbWidth, int32 thumbHeight, class System.Drawing.Image/GetThumbnailImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.GetThumbnailImage(System.Int32,System.Int32,System.Drawing.Image.GetThumbnailImageAbort,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetThumbnailImage (thumbWidth As Integer, thumbHeight As Integer, callback As Image.GetThumbnailImageAbort, callbackData As IntPtr) As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Image ^ GetThumbnailImage(int thumbWidth, int thumbHeight, System::Drawing::Image::GetThumbnailImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.GetThumbnailImage : int * int * System.Drawing.Image.GetThumbnailImageAbort * nativeint -&gt; System.Drawing.Image" Usage="image.GetThumbnailImage (thumbWidth, thumbHeight, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thumbWidth" Type="System.Int32" />
        <Parameter Name="thumbHeight" Type="System.Int32" />
        <Parameter Name="callback" Type="System.Drawing.Image+GetThumbnailImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="thumbWidth">Szerokość w pikselach, żądany obraz miniatury.</param>
        <param name="thumbHeight">Wysokość w pikselach, żądany obraz miniatury.</param>
        <param name="callback">A <see cref="T:System.Drawing.Image.GetThumbnailImageAbort" /> delegować.  
  
 **Uwaga** musi utworzyć delegata i przekazać odwołanie do obiektu delegowanego jako <paramref name="callback" /> parametru, ale delegata nie jest używany.</param>
        <param name="callbackData">Musi być <see cref="F:System.IntPtr.Zero" />.</param>
        <summary>Zwraca miniatury dla tej klasy <see cref="T:System.Drawing.Image" />.</summary>
        <returns><see cref="T:System.Drawing.Image" /> Reprezentujący miniatury.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Drawing.Image> zawiera osadzony obraz miniatury, ta metoda pobiera osadzone miniatury i którą można skalować do żądanego rozmiaru. Jeśli <xref:System.Drawing.Image> nie zawiera osadzony obraz miniatury, ta metoda tworzy obraz miniatury, skalując w głównym obrazu.  
  
 <xref:System.Drawing.Image.GetThumbnailImage%2A> Metoda działa dobrze, jeśli żądany obraz miniatury ma rozmiar około 120 x 120 pikseli. Jeśli żądanie duży obraz miniatury (na przykład 300 x 300) z <xref:System.Drawing.Image> zawierającego osadzony miniatury, może to być utracie jakości miniaturę. Może być lepszym rozwiązaniem skaluje obraz głównego (zamiast skalowania miniaturę embedded) przez wywołanie metody <xref:System.Drawing.Graphics.DrawImage%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i wyświetla obraz miniatury. Ten delegat nigdy nie jest wywoływana.  
  
 [!code-csharp[System.Drawing.Misc3#GetThumbnail](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Misc3/CS/Form1.cs#getthumbnail)]
 [!code-vb[System.Drawing.Misc3#GetThumbnail](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Misc3/VB/Form1.vb#getthumbnail)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.Height" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Height As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Height { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Height : int" Usage="System.Drawing.Image.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wysokość w pikselach to <see cref="T:System.Drawing.Image" />.</summary>
        <value>Wysokość w pikselach to <see cref="T:System.Drawing.Image" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób tworzenia nowej mapy bitowej z pliku, przy użyciu <xref:System.Drawing.Bitmap.GetPixel%2A> i <xref:System.Drawing.Bitmap.SetPixel%2A> metody, aby zmienić kolory na obrazie. Korzysta również <xref:System.Drawing.Image.PixelFormat%2A> i <xref:System.Drawing.Image.Height%2A> właściwości.  
  
 W tym przykładzie jest przeznaczony do użycia za pomocą interfejsu Windows Forms, który zawiera <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.PictureBox>, i <xref:System.Windows.Forms.Button> o nazwie `Label1`, `PictureBox1`, i `Button1`, odpowiednio. Wklej kod do formularza i skojarz `Button1_Click` metody przy użyciu przycisku <xref:System.Windows.Forms.Control.Click> zdarzeń.  
  
 [!code-cpp[System.Drawing.ImageExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ImageExample/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.ImageExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ImageExample/CS/form1.cs#1)]
 [!code-vb[System.Drawing.ImageExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ImageExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalResolution">
      <MemberSignature Language="C#" Value="public float HorizontalResolution { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 HorizontalResolution" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.HorizontalResolution" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HorizontalResolution As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float HorizontalResolution { float get(); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalResolution : single" Usage="System.Drawing.Image.HorizontalResolution" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozdzielczość w poziomie w pikseli na cal to <see cref="T:System.Drawing.Image" />.</summary>
        <value>Rozdzielczość w poziomie w pikseli na cal to <see cref="T:System.Drawing.Image" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAlphaPixelFormat">
      <MemberSignature Language="C#" Value="public static bool IsAlphaPixelFormat (System.Drawing.Imaging.PixelFormat pixfmt);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAlphaPixelFormat(valuetype System.Drawing.Imaging.PixelFormat pixfmt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.IsAlphaPixelFormat(System.Drawing.Imaging.PixelFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAlphaPixelFormat (pixfmt As PixelFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsAlphaPixelFormat(System::Drawing::Imaging::PixelFormat pixfmt);" />
      <MemberSignature Language="F#" Value="static member IsAlphaPixelFormat : System.Drawing.Imaging.PixelFormat -&gt; bool" Usage="System.Drawing.Image.IsAlphaPixelFormat pixfmt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pixfmt" Type="System.Drawing.Imaging.PixelFormat" />
      </Parameters>
      <Docs>
        <param name="pixfmt"><see cref="T:System.Drawing.Imaging.PixelFormat" /> Do testowania.</param>
        <summary>Zwraca wartość wskazującą, czy pixel format to <see cref="T:System.Drawing.Image" /> informacjami alfa.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="pixfmt" /> informacjami alfa; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCanonicalPixelFormat">
      <MemberSignature Language="C#" Value="public static bool IsCanonicalPixelFormat (System.Drawing.Imaging.PixelFormat pixfmt);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsCanonicalPixelFormat(valuetype System.Drawing.Imaging.PixelFormat pixfmt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.IsCanonicalPixelFormat(System.Drawing.Imaging.PixelFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsCanonicalPixelFormat (pixfmt As PixelFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsCanonicalPixelFormat(System::Drawing::Imaging::PixelFormat pixfmt);" />
      <MemberSignature Language="F#" Value="static member IsCanonicalPixelFormat : System.Drawing.Imaging.PixelFormat -&gt; bool" Usage="System.Drawing.Image.IsCanonicalPixelFormat pixfmt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pixfmt" Type="System.Drawing.Imaging.PixelFormat" />
      </Parameters>
      <Docs>
        <param name="pixfmt"><see cref="T:System.Drawing.Imaging.PixelFormat" /> Do testowania.</param>
        <summary>Zwraca wartość wskazującą, czy format pikseli jest 32 bity na piksel.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="pixfmt" /> jest canonical; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Format pikseli canonical wskazuje format pikseli 32 bity na piksel. Ten format Określa 24-bitowej głębi kolorów i kanał alfa 8-bitowych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExtendedPixelFormat">
      <MemberSignature Language="C#" Value="public static bool IsExtendedPixelFormat (System.Drawing.Imaging.PixelFormat pixfmt);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsExtendedPixelFormat(valuetype System.Drawing.Imaging.PixelFormat pixfmt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.IsExtendedPixelFormat(System.Drawing.Imaging.PixelFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsExtendedPixelFormat (pixfmt As PixelFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsExtendedPixelFormat(System::Drawing::Imaging::PixelFormat pixfmt);" />
      <MemberSignature Language="F#" Value="static member IsExtendedPixelFormat : System.Drawing.Imaging.PixelFormat -&gt; bool" Usage="System.Drawing.Image.IsExtendedPixelFormat pixfmt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pixfmt" Type="System.Drawing.Imaging.PixelFormat" />
      </Parameters>
      <Docs>
        <param name="pixfmt"><see cref="T:System.Drawing.Imaging.PixelFormat" /> Wyliczenia do testowania.</param>
        <summary>Zwraca wartość wskazującą, czy format pikseli jest 64 bity na piksel.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="pixfmt" /> jest rozszerzona; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Palette">
      <MemberSignature Language="C#" Value="public System.Drawing.Imaging.ColorPalette Palette { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Imaging.ColorPalette Palette" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.Palette" />
      <MemberSignature Language="VB.NET" Value="Public Property Palette As ColorPalette" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Imaging::ColorPalette ^ Palette { System::Drawing::Imaging::ColorPalette ^ get(); void set(System::Drawing::Imaging::ColorPalette ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Palette : System.Drawing.Imaging.ColorPalette with get, set" Usage="System.Drawing.Image.Palette" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Imaging.ColorPalette</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia paletę kolorów używaną w tym <see cref="T:System.Drawing.Image" />.</summary>
        <value>A <see cref="T:System.Drawing.Imaging.ColorPalette" /> reprezentujący paletę kolorów używaną w tym <see cref="T:System.Drawing.Image" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca kopię obiektu <xref:System.Drawing.Imaging.ColorPalette> używana przez ten obiekt <xref:System.Drawing.Image>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalDimension">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF PhysicalDimension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF PhysicalDimension" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.PhysicalDimension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalDimension As SizeF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::SizeF PhysicalDimension { System::Drawing::SizeF get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalDimension : System.Drawing.SizeF" Usage="System.Drawing.Image.PhysicalDimension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szerokość i wysokość tego obrazu.</summary>
        <value>A <see cref="T:System.Drawing.SizeF" /> strukturę, która reprezentuje szerokość i wysokość tego <see cref="T:System.Drawing.Image" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli obraz jest mapą bitową, zwracane są szerokość i wysokość w pikselach. Jeśli obraz jest metaplik, szerokość i wysokość są zwracane w jednostkach 0,01 milimetra.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PixelFormat">
      <MemberSignature Language="C#" Value="public System.Drawing.Imaging.PixelFormat PixelFormat { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Imaging.PixelFormat PixelFormat" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.PixelFormat" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelFormat As PixelFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Imaging::PixelFormat PixelFormat { System::Drawing::Imaging::PixelFormat get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelFormat : System.Drawing.Imaging.PixelFormat" Usage="System.Drawing.Image.PixelFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Imaging.PixelFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera format pikseli dla tego <see cref="T:System.Drawing.Image" />.</summary>
        <value>A <see cref="T:System.Drawing.Imaging.PixelFormat" /> reprezentujący format pikseli dla tego <see cref="T:System.Drawing.Image" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób tworzenia nowej mapy bitowej z pliku, przy użyciu <xref:System.Drawing.Bitmap.GetPixel%2A> i <xref:System.Drawing.Bitmap.SetPixel%2A> metody, aby zmienić kolory na obrazie. Korzysta również <xref:System.Drawing.Image.PixelFormat%2A> właściwości.  
  
 W tym przykładzie jest przeznaczony do użycia z formularzem Windows, który zawiera <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.PictureBox> i <xref:System.Windows.Forms.Button> o nazwie `Label1`, `PictureBox1`, i `Button1`, odpowiednio. Wklej kod do formularza i skojarz `Button1_Click` metody przy użyciu przycisku <xref:System.Windows.Forms.Control.Click> zdarzeń.  
  
 [!code-cpp[System.Drawing.ImageExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ImageExample/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.ImageExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ImageExample/CS/form1.cs#1)]
 [!code-vb[System.Drawing.ImageExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ImageExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyIdList">
      <MemberSignature Language="C#" Value="public int[] PropertyIdList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] PropertyIdList" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.PropertyIdList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyIdList As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ PropertyIdList { cli::array &lt;int&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyIdList : int[]" Usage="System.Drawing.Image.PropertyIdList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikatory elementów właściwości przechowywane w tym <see cref="T:System.Drawing.Image" />.</summary>
        <value>Tablica właściwości identyfikatorów, jeden dla każdego elementu właściwości przechowywane na tej ilustracji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli obraz nie ma żadnych elementów właściwości lub format obrazu nie obsługuje elementy właściwości <xref:System.Drawing.Image.PropertyIdList%2A> właściwość zwraca pustą tablicę (czyli tablicę o zerowej długości).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/72ec0b31-0be7-444a-9575-1dbcb864e0be">Instrukcje: Odczytaj metadane obrazu</related>
      </Docs>
    </Member>
    <Member MemberName="PropertyItems">
      <MemberSignature Language="C#" Value="public System.Drawing.Imaging.PropertyItem[] PropertyItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Imaging.PropertyItem[] PropertyItems" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.PropertyItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyItems As PropertyItem()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Drawing::Imaging::PropertyItem ^&gt; ^ PropertyItems { cli::array &lt;System::Drawing::Imaging::PropertyItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyItems : System.Drawing.Imaging.PropertyItem[]" Usage="System.Drawing.Image.PropertyItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Imaging.PropertyItem[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie właściwości elementy (elementy metadanych) przechowywanego w tym <see cref="T:System.Drawing.Image" />.</summary>
        <value>Tablica <see cref="T:System.Drawing.Imaging.PropertyItem" /> obiektów, po jednym dla każdej właściwości elementu są przechowywane na obrazie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli obraz nie ma żadnych elementów właściwości lub format obrazu nie obsługuje elementy właściwości <xref:System.Drawing.Image.PropertyItems%2A> zwraca pustą tablicę (czyli tablicę o zerowej długości).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak odczytywać i wyświetlić metadane w pliku obrazu przy użyciu <xref:System.Drawing.Imaging.PropertyItem?displayProperty=nameWithType> klasy i <xref:System.Drawing.Image.PropertyItems%2A> właściwości.  
  
 W tym przykładzie została zaprojektowana jako używany formularz Windows, który importuje <xref:System.Drawing.Imaging?displayProperty=nameWithType> przestrzeni nazw. Wklej kod do formularza i zmień ścieżkę, tak aby `fakePhoto.jpg` wskaż plik obrazu, w tym systemie. Wywołaj `ExtractMetaData` metody obsługi danych formularza <xref:System.Windows.Forms.Control.Paint> zdarzenie, przekazując `e` jako <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.ImageExample#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ImageExample/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.ImageExample#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ImageExample/CS/form1.cs#6)]
 [!code-vb[System.Drawing.ImageExample#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ImageExample/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/72ec0b31-0be7-444a-9575-1dbcb864e0be">Instrukcje: Odczytaj metadane obrazu</related>
      </Docs>
    </Member>
    <Member MemberName="RawFormat">
      <MemberSignature Language="C#" Value="public System.Drawing.Imaging.ImageFormat RawFormat { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Imaging.ImageFormat RawFormat" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.RawFormat" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawFormat As ImageFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Imaging::ImageFormat ^ RawFormat { System::Drawing::Imaging::ImageFormat ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawFormat : System.Drawing.Imaging.ImageFormat" Usage="System.Drawing.Image.RawFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Imaging.ImageFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera format pliku to <see cref="T:System.Drawing.Image" />.</summary>
        <value><see cref="T:System.Drawing.Imaging.ImageFormat" /> Reprezentujący format pliku to <see cref="T:System.Drawing.Image" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePropertyItem">
      <MemberSignature Language="C#" Value="public void RemovePropertyItem (int propid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemovePropertyItem(int32 propid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.RemovePropertyItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemovePropertyItem (propid As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemovePropertyItem(int propid);" />
      <MemberSignature Language="F#" Value="member this.RemovePropertyItem : int -&gt; unit" Usage="image.RemovePropertyItem propid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propid" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="propid">Identyfikator elementu właściwości do usunięcia.</param>
        <summary>Usuwa element określonej właściwości z tego <see cref="T:System.Drawing.Image" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trudno jest ustawianie właściwości elementów, ponieważ <xref:System.Drawing.Imaging.PropertyItem> klasa nie ma publicznych konstruktorów. Jednym ze sposobów, aby obejść to ograniczenie jest uzyskanie <xref:System.Drawing.Imaging.PropertyItem> pobierając <xref:System.Drawing.Image.PropertyItems%2A> wartości właściwości lub wywoływania <xref:System.Drawing.Image.GetPropertyItem%2A> metody <xref:System.Drawing.Image> zawierający elementy właściwości. Następnie można ustawić pola <xref:System.Drawing.Imaging.PropertyItem> i przekazać ją do <xref:System.Drawing.Image.SetPropertyItem%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Obraz, który nie zawiera elementu żądanej właściwości.  
  
—lub— 
Format obrazu dla tego obrazu nie obsługuje elementy właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="RotateFlip">
      <MemberSignature Language="C#" Value="public void RotateFlip (System.Drawing.RotateFlipType rotateFlipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateFlip(valuetype System.Drawing.RotateFlipType rotateFlipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.RotateFlip(System.Drawing.RotateFlipType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateFlip(System::Drawing::RotateFlipType rotateFlipType);" />
      <MemberSignature Language="F#" Value="member this.RotateFlip : System.Drawing.RotateFlipType -&gt; unit" Usage="image.RotateFlip rotateFlipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rotateFlipType" Type="System.Drawing.RotateFlipType" />
      </Parameters>
      <Docs>
        <param name="rotateFlipType">Element <see cref="T:System.Drawing.RotateFlipType" /> elementu członkowskiego, który określa typ rotacji i przerzucanie do zastosowania do obrazu.</param>
        <summary>Obraca się Przerzuca, lub obraca się i Przerzuca <see cref="T:System.Drawing.Image" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image.RotateFlip%2A> Metoda obraca obraz z ruchem wskazówek zegara.  
  
 Jeśli chcesz rysować na obraz, gdy został obrócony, należy zawsze pobierać nowy obiekt grafiki z obrazu, w przeciwnym razie może wystąpić wyjątek pustej.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób wywołania <xref:System.Drawing.Image.RotateFlip%2A> metody <xref:System.Drawing.Image> i <xref:System.Drawing.RotateFlipType> wyliczenia.  
  
 W tym przykładzie jest przeznaczony do użycia z formularzem Windows, który zawiera <xref:System.Windows.Forms.PictureBox> o nazwie `PictureBox1` i przycisk o nazwie `Button1`. Wklej kod do formularza, wywołanie `InitializeBitmap` z konstruktora formularza i skojarz `Button1_Click` przy użyciu przycisku <xref:System.Windows.Forms.Control.Click> zdarzeń. Upewnij się, że ścieżka pliku do mapy bitowej jest prawidłowa w tym systemie.  
  
 [!code-cpp[System.Drawing.BitmapMembers#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.BitmapMembers/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.BitmapMembers#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.BitmapMembers/CS/form1.cs#3)]
 [!code-vb[System.Drawing.BitmapMembers#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.BitmapMembers/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje ten obraz do określonego strumienia w określonym formacie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="image.Save filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Ciąg, który zawiera nazwę pliku, do której chcesz zapisać to <see cref="T:System.Drawing.Image" />.</param>
        <summary>Zapisuje to <see cref="T:System.Drawing.Image" /> do określonego pliku lub strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kodera nie istnieje dla formatu pliku obrazu, koder Portable Network Graphics (PNG) jest używany. Kiedy używasz <xref:System.Drawing.Image.Save%2A> metodę, aby zapisać obraz jako plik formatu metaplik Windows (WMF) lub Format rozszerzony metaplik (EMF), wynikowy plik jest zapisywany jako plik Portable Network Graphics (PNG). Ten problem występuje, ponieważ [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] składnika [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] nie ma koder, który służy do zapisywania plików jako pliki WMF lub EMF.  
  
 Zapisywanie obrazu do tego samego pliku, który został zbudowany z nie jest dozwolona i zgłasza wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób wywołania <xref:System.Drawing.Image.Save%2A> metody. W tym przykładzie jest przeznaczona do użycia za pomocą interfejsu Windows Forms. Tworzenie formularza, która zawiera przycisk o nazwie `Button5`. Wklej kod do formularza i skojarzyć metody przy użyciu przycisku <xref:System.Windows.Forms.Control.Click> zdarzeń.  
  
 [!code-cpp[System.Drawing.ImageExample#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ImageExample/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.ImageExample#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ImageExample/CS/form1.cs#5)]
 [!code-vb[System.Drawing.ImageExample#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ImageExample/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> jest <see langword="null." /></exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Obraz, który został zapisany w formacie niewłaściwy obraz.  
  
—lub— 
Obraz, który został zapisany w tym samym pliku, który został utworzony.</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Drawing.Imaging.ImageFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, class System.Drawing.Imaging.ImageFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.Save(System.IO.Stream,System.Drawing.Imaging.ImageFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Drawing::Imaging::ImageFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * System.Drawing.Imaging.ImageFormat -&gt; unit" Usage="image.Save (stream, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="format" Type="System.Drawing.Imaging.ImageFormat" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" /> Którym obraz zostanie zapisany.</param>
        <param name="format"><see cref="T:System.Drawing.Imaging.ImageFormat" /> , Który określa format obrazu zapisane.</param>
        <summary>Zapisuje ten obraz do określonego strumienia w określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy unikać Zapisywanie obrazu do tego samego strumienia, który został użyty do utworzenia go. Ten sposób może spowodować uszkodzenie strumienia.  
  
 Obraz, który musi zostać zapisany do strumienia przesunięciem o wartości zero. Jeśli dodatkowych danych został zapisany do strumienia przed zapisaniem na ilustracji, dane obrazu w strumieniu zostanie uszkodzony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> lub <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Obraz, który został zapisany w formacie nieprawidłowy obraz</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string filename, System.Drawing.Imaging.ImageFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string filename, class System.Drawing.Imaging.ImageFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.Save(System.String,System.Drawing.Imaging.ImageFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (filename As String, format As ImageFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ filename, System::Drawing::Imaging::ImageFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Drawing.Imaging.ImageFormat -&gt; unit" Usage="image.Save (filename, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="format" Type="System.Drawing.Imaging.ImageFormat" />
      </Parameters>
      <Docs>
        <param name="filename">Ciąg, który zawiera nazwę pliku, do której chcesz zapisać to <see cref="T:System.Drawing.Image" />.</param>
        <param name="format"><see cref="T:System.Drawing.Imaging.ImageFormat" /> Tego <see cref="T:System.Drawing.Image" />.</param>
        <summary>Zapisuje to <see cref="T:System.Drawing.Image" /> do określonego pliku w określonym formacie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje, jak utworzyć mapę bitową z typu i jak używać <xref:System.Drawing.Image.Save%2A> metody. Aby uruchomić ten przykład, Wklej kod do formularza Windows. Obsługa formularzy <xref:System.Windows.Forms.Control.Paint> zdarzenia i wywołania `ConstructFromResourceSaveAsGif` jest metoda `e` jako <xref:System.Windows.Forms.PaintEventArgs>  
  
 [!code-cpp[System.Drawing.BmpCtorAndSave#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.BmpCtorAndSave/cpp/form1.cpp#1)]
 [!code-csharp[System.Drawing.BmpCtorAndSave#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.BmpCtorAndSave/CS/form1.cs#1)]
 [!code-vb[System.Drawing.BmpCtorAndSave#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.BmpCtorAndSave/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> lub <paramref name="format" /> jest <see langword="null." /></exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Obraz, który został zapisany w formacie niewłaściwy obraz.  
  
—lub— 
Obraz, który został zapisany w tym samym pliku, który został utworzony.</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Drawing.Imaging.ImageCodecInfo encoder, System.Drawing.Imaging.EncoderParameters encoderParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, class System.Drawing.Imaging.ImageCodecInfo encoder, class System.Drawing.Imaging.EncoderParameters encoderParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.Save(System.IO.Stream,System.Drawing.Imaging.ImageCodecInfo,System.Drawing.Imaging.EncoderParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Drawing::Imaging::ImageCodecInfo ^ encoder, System::Drawing::Imaging::EncoderParameters ^ encoderParams);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * System.Drawing.Imaging.ImageCodecInfo * System.Drawing.Imaging.EncoderParameters -&gt; unit" Usage="image.Save (stream, encoder, encoderParams)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoder" Type="System.Drawing.Imaging.ImageCodecInfo" />
        <Parameter Name="encoderParams" Type="System.Drawing.Imaging.EncoderParameters" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" /> Którym obraz zostanie zapisany.</param>
        <param name="encoder"><see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> Tego <see cref="T:System.Drawing.Image" />.</param>
        <param name="encoderParams"><see cref="T:System.Drawing.Imaging.EncoderParameters" /> , Który określa parametry używane przez kodeka obrazu.</param>
        <summary>Zapisuje ten obraz do określonego strumienia, za pomocą określonego encoder i parametry kodera obrazu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie zapisuj obrazu do tego samego strumienia, który został użyty do utworzenia obrazu. Ten sposób może spowodować uszkodzenie strumienia.  
  
 Obraz, który musi zostać zapisany do strumienia przesunięciem o wartości zero. Jeśli dodatkowych danych został zapisany do strumienia przed zapisaniem na ilustracji, dane obrazu w strumieniu zostanie uszkodzony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Obraz, który został zapisany w formacie niewłaściwy obraz.</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string filename, System.Drawing.Imaging.ImageCodecInfo encoder, System.Drawing.Imaging.EncoderParameters encoderParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string filename, class System.Drawing.Imaging.ImageCodecInfo encoder, class System.Drawing.Imaging.EncoderParameters encoderParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.Save(System.String,System.Drawing.Imaging.ImageCodecInfo,System.Drawing.Imaging.EncoderParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (filename As String, encoder As ImageCodecInfo, encoderParams As EncoderParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ filename, System::Drawing::Imaging::ImageCodecInfo ^ encoder, System::Drawing::Imaging::EncoderParameters ^ encoderParams);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Drawing.Imaging.ImageCodecInfo * System.Drawing.Imaging.EncoderParameters -&gt; unit" Usage="image.Save (filename, encoder, encoderParams)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="encoder" Type="System.Drawing.Imaging.ImageCodecInfo" />
        <Parameter Name="encoderParams" Type="System.Drawing.Imaging.EncoderParameters" />
      </Parameters>
      <Docs>
        <param name="filename">Ciąg, który zawiera nazwę pliku, do której chcesz zapisać to <see cref="T:System.Drawing.Image" />.</param>
        <param name="encoder"><see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> Tego <see cref="T:System.Drawing.Image" />.</param>
        <param name="encoderParams"><see cref="T:System.Drawing.Imaging.EncoderParameters" /> Do użycia w tym <see cref="T:System.Drawing.Image" />.</param>
        <summary>Zapisuje to <see cref="T:System.Drawing.Image" /> do określonego pliku, przy użyciu określonych parametrów kodera i kodeka obrazu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zapisywanie obrazu do tego samego pliku, który został zbudowany z nie jest dozwolona i zgłasza wyjątek.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Drawing.Bitmap> obiekt z pliku BMP. Kod zapisuje mapy bitowej trzy pliki JPEG, każdy z poziomu różnych jakości.  
  
 [!code-cpp[System.Drawing.ClassicImagingEndcoder3#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicImagingEndcoder3/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.ClassicImagingEndcoder3#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicImagingEndcoder3/CS/form1.cs#3)]
 [!code-vb[System.Drawing.ClassicImagingEndcoder3#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicImagingEndcoder3/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> lub <paramref name="encoder" /> jest <see langword="null." /></exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Obraz, który został zapisany w formacie niewłaściwy obraz.  
  
—lub— 
Obraz, który został zapisany w tym samym pliku, który został utworzony.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/4b9a74e3-9504-43c1-9f28-ace651d0772e">Instrukcje: Ustawianie poziomu dekompresji JPEG</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveAdd">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje informacje w określonym <see cref="T:System.Drawing.Image" /> tej <see cref="T:System.Drawing.Image" />. Określony <see cref="T:System.Drawing.Imaging.EncoderParameters" /> określić, jak nowe informacje jest włączona do istniejącego obrazu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveAdd">
      <MemberSignature Language="C#" Value="public void SaveAdd (System.Drawing.Imaging.EncoderParameters encoderParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAdd(class System.Drawing.Imaging.EncoderParameters encoderParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.SaveAdd(System.Drawing.Imaging.EncoderParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveAdd (encoderParams As EncoderParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAdd(System::Drawing::Imaging::EncoderParameters ^ encoderParams);" />
      <MemberSignature Language="F#" Value="member this.SaveAdd : System.Drawing.Imaging.EncoderParameters -&gt; unit" Usage="image.SaveAdd encoderParams" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoderParams" Type="System.Drawing.Imaging.EncoderParameters" />
      </Parameters>
      <Docs>
        <param name="encoderParams"><see cref="T:System.Drawing.Imaging.EncoderParameters" /> Przechowuje parametrów wymaganych przez koder obrazu, który jest używany przez zapisywanie dodanie operacji.</param>
        <summary>Dodaje ramki do pliku lub strumienia określone w poprzednie wywołanie <see cref="Overload:System.Drawing.Image.Save" /> metody. Użyj tej metody, aby zapisać wybrane ramki za pomocą obrazu ramki wielu do innej ramki wielu obrazu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAdd">
      <MemberSignature Language="C#" Value="public void SaveAdd (System.Drawing.Image image, System.Drawing.Imaging.EncoderParameters encoderParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAdd(class System.Drawing.Image image, class System.Drawing.Imaging.EncoderParameters encoderParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.SaveAdd(System.Drawing.Image,System.Drawing.Imaging.EncoderParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAdd(System::Drawing::Image ^ image, System::Drawing::Imaging::EncoderParameters ^ encoderParams);" />
      <MemberSignature Language="F#" Value="member this.SaveAdd : System.Drawing.Image * System.Drawing.Imaging.EncoderParameters -&gt; unit" Usage="image.SaveAdd (image, encoderParams)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="encoderParams" Type="System.Drawing.Imaging.EncoderParameters" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> Zawierający ramkę do dodania.</param>
        <param name="encoderParams"><see cref="T:System.Drawing.Imaging.EncoderParameters" /> Przechowuje parametrów wymaganych przez koder obrazu, który jest używany przez zapisywanie dodanie operacji.</param>
        <summary>Dodaje ramki do pliku lub strumienia określone w poprzednie wywołanie <see cref="Overload:System.Drawing.Image.Save" /> metody.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectActiveFrame">
      <MemberSignature Language="C#" Value="public int SelectActiveFrame (System.Drawing.Imaging.FrameDimension dimension, int frameIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SelectActiveFrame(class System.Drawing.Imaging.FrameDimension dimension, int32 frameIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.SelectActiveFrame(System.Drawing.Imaging.FrameDimension,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectActiveFrame (dimension As FrameDimension, frameIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SelectActiveFrame(System::Drawing::Imaging::FrameDimension ^ dimension, int frameIndex);" />
      <MemberSignature Language="F#" Value="member this.SelectActiveFrame : System.Drawing.Imaging.FrameDimension * int -&gt; int" Usage="image.SelectActiveFrame (dimension, frameIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Drawing.Imaging.FrameDimension" />
        <Parameter Name="frameIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Element <see cref="T:System.Drawing.Imaging.FrameDimension" /> , który określa tożsamości do typu wymiaru.</param>
        <param name="frameIndex">Indeks aktywną ramkę.</param>
        <summary>Wybiera ramki określonego przez wymiaru i indeksu.</summary>
        <returns>Zawsze zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwe wartości `dimensionID` parametru są właściwości <xref:System.Drawing.Imaging.FrameDimension>. Mogą one służyć do identyfikowania obraz przez jego czas, rozwiązania lub numer strony.  
  
 Wywołanie tej metody powoduje, że wszystkie zmiany wprowadzone do poprzedniej ramki do usunięcia. Przed wybraniem innej ramki, Zapisz wszystkie zmiany wprowadzone do bieżącej ramki, łącznie ze zmianami właściwości i wartości pikseli. Jeśli wywołanie <xref:System.Drawing.Image.SelectActiveFrame%2A> metoda zakończy się pomyślnie (wyjątek nie wystąpi), metoda zwróci wartość 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPropertyItem">
      <MemberSignature Language="C#" Value="public void SetPropertyItem (System.Drawing.Imaging.PropertyItem propitem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPropertyItem(class System.Drawing.Imaging.PropertyItem propitem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.SetPropertyItem(System.Drawing.Imaging.PropertyItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPropertyItem (propitem As PropertyItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPropertyItem(System::Drawing::Imaging::PropertyItem ^ propitem);" />
      <MemberSignature Language="F#" Value="member this.SetPropertyItem : System.Drawing.Imaging.PropertyItem -&gt; unit" Usage="image.SetPropertyItem propitem" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propitem" Type="System.Drawing.Imaging.PropertyItem" />
      </Parameters>
      <Docs>
        <param name="propitem"><see cref="T:System.Drawing.Imaging.PropertyItem" /> Ma być przechowywany.</param>
        <summary>Element właściwości (fragmentem metadanych) są przechowywane w tym <see cref="T:System.Drawing.Image" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli format obrazu nie obsługuje właściwości elementów, ta metoda wyrzuca <xref:System.ArgumentException> z komunikatem "Właściwość nie jest obsługiwana." Jeśli format obrazu obsługuje elementy właściwości, ale nie obsługuje określonej właściwości, którą próbujesz ustawić, ta metoda ignoruje próba, ale nie zgłasza wyjątku.  
  
 Trudno jest ustawianie właściwości elementów, ponieważ <xref:System.Drawing.Imaging.PropertyItem> klasa nie ma publicznych konstruktorów. Jednym ze sposobów, aby obejść to ograniczenie jest uzyskanie <xref:System.Drawing.Imaging.PropertyItem> pobierając <xref:System.Drawing.Image.PropertyItems%2A> wartości właściwości lub wywoływania <xref:System.Drawing.Image.GetPropertyItem%2A> metody <xref:System.Drawing.Image> zawierający elementy właściwości. Następnie można ustawić pola <xref:System.Drawing.Imaging.PropertyItem> i przekazać ją do <xref:System.Drawing.Image.SetPropertyItem%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Drawing.Image.GetPropertyItem%2A> i <xref:System.Drawing.Image.SetPropertyItem%2A> metody. W tym przykładzie jest przeznaczona do użycia za pomocą interfejsu Windows Forms. Aby uruchomić ten przykład, wkleić go do formularza i obsługiwać formularza <xref:System.Windows.Forms.Control.Paint> zdarzeń przez wywołanie metody `DemonstratePropertyItem` jest metoda `e` jako <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.ImageExample#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ImageExample/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.ImageExample#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ImageExample/CS/form1.cs#7)]
 [!code-vb[System.Drawing.ImageExample#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ImageExample/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Format obrazu tego obrazu nie obsługuje elementy właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size" Usage="System.Drawing.Image.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szerokość i wysokość w pikselach, ten obraz.</summary>
        <value>A <see cref="T:System.Drawing.Size" /> strukturę, która reprezentuje szerokość i wysokość w pikselach, ten obraz.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Image.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Obiektu do wypełniania danymi.</param>
        <param name="si">To be added.</param>
        <param name="context">Miejsce docelowe (zobacz <see cref="T:System.Runtime.Serialization.StreamingContext" />) tej serializacji.</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> z dane potrzebne do zserializowania obiektu docelowego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Drawing.Image.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który udostępnia dodatkowe dane dotyczące obrazu.</summary>
        <value><see cref="T:System.Object" /> Udostępniające dodatkowe dane dotyczące obrazu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalResolution">
      <MemberSignature Language="C#" Value="public float VerticalResolution { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 VerticalResolution" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.VerticalResolution" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VerticalResolution As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float VerticalResolution { float get(); };" />
      <MemberSignature Language="F#" Value="member this.VerticalResolution : single" Usage="System.Drawing.Image.VerticalResolution" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozdzielczość w pionie w pikseli na cal to <see cref="T:System.Drawing.Image" />.</summary>
        <value>Rozdzielczość w pionie w pikseli na cal to <see cref="T:System.Drawing.Image" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Image.Width" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Width As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Width { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Width : int" Usage="System.Drawing.Image.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szerokość w pikselach to <see cref="T:System.Drawing.Image" />.</summary>
        <value>Szerokość w pikselach to <see cref="T:System.Drawing.Image" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć nową <xref:System.Drawing.Bitmap> z pliku, przy użyciu <xref:System.Drawing.Bitmap.GetPixel%2A> i <xref:System.Drawing.Bitmap.SetPixel%2A> metody, aby zmienić kolory na obrazie. Korzysta również <xref:System.Drawing.Image.PixelFormat%2A>, <xref:System.Drawing.Image.Width%2A>, i <xref:System.Drawing.Image.Height%2A> właściwości.  
  
 W tym przykładzie jest przeznaczony do użycia za pomocą interfejsu Windows Forms, który zawiera <xref:System.Windows.Forms.Label> ,<xref:System.Windows.Forms.PictureBox> i <xref:System.Windows.Forms.Button> o nazwie `Label1`, `PictureBox1` i `Button1`, odpowiednio. Wklej kod do formularza i skojarz `Button1_Click` metody przy użyciu przycisku <xref:System.Windows.Forms.Control.Click> zdarzeń.  
  
 [!code-cpp[System.Drawing.ImageExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ImageExample/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.ImageExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ImageExample/CS/form1.cs#1)]
 [!code-vb[System.Drawing.ImageExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ImageExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
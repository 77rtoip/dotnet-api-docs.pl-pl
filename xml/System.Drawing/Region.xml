<Type Name="Region" FullName="System.Drawing.Region">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9162261d1421c28daca51b5ecef11dbb60185db6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36489676" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Region : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Region extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Region" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Region&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Region sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Region = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>W tym artykule opisano wewnątrz kształtu grafiki prostokąty i ścieżki. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Region jest skalowalna, ponieważ określono współrzędnych we współrzędnych świata. Na powierzchni do rysowania jednak jego wnętrza jest zależna od wielkość i kształt pikseli reprezentujący go. Aplikacja może używać regionów należy przyciąć dane wyjściowe operacje rysowania. Te regiony są nazywane regionów wycinka. Aby uzyskać więcej informacji na temat używania regiony dla wycinka, zobacz [porady: użycie wycinka za pomocą obszaru](~/docs/framework/winforms/advanced/how-to-use-clipping-with-a-region.md).  
  
 Aplikację można również użyć regionach w ramach testowania trafień operacji, takich jak sprawdzanie, czy punkt lub prostokąt przecina regionu. Aby uzyskać więcej informacji o do testowania trafień za pomocą regionów, zobacz [porady: użycie testowania trafień za pomocą obszaru](~/docs/framework/winforms/advanced/how-to-use-hit-testing-with-a-region.md).  
  
 Aplikacja wpisać region przy użyciu <xref:System.Drawing.Graphics.FillRegion%2A?displayProperty=nameWithType> — metoda i <xref:System.Drawing.Brush> obiektu.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń.  Przykład kodu pokazuje sposób użycia <xref:System.Drawing.Drawing2D.RegionData.Data%2A> z jednego <xref:System.Drawing.Drawing2D.RegionData> obiekt, aby ustawić <xref:System.Drawing.Drawing2D.RegionData.Data%2A> dla innej <xref:System.Drawing.Drawing2D.RegionData>.  
  
 [!code-cpp[System.Drawing.MiscExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.MiscExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.MiscExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#13)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Drawing.Rectangle" />
    <altmember cref="T:System.Drawing.Drawing2D.GraphicsPath" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowy <see cref="T:System.Drawing.Region" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Region ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Region();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowy <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.Drawing.Region> z wnętrza nieskończoną.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Region (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.#ctor(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Region(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Region : System.Drawing.Drawing2D.GraphicsPath -&gt; System.Drawing.Region" Usage="new System.Drawing.Region path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> definiuje nowy <see cref="T:System.Drawing.Region" />.</param>
        <summary>Inicjuje nowy <see cref="T:System.Drawing.Region" /> z określonym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowy <xref:System.Drawing.Region> z <xref:System.Drawing.Drawing2D.GraphicsPath>. Nowy region jest zdefiniowany jako wnętrza <xref:System.Drawing.Drawing2D.GraphicsPath> określonego przez `path` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Region (System.Drawing.Drawing2D.RegionData rgnData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Drawing.Drawing2D.RegionData rgnData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.#ctor(System.Drawing.Drawing2D.RegionData)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rgnData As RegionData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Region(System::Drawing::Drawing2D::RegionData ^ rgnData);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Region : System.Drawing.Drawing2D.RegionData -&gt; System.Drawing.Region" Usage="new System.Drawing.Region rgnData" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rgnData" Type="System.Drawing.Drawing2D.RegionData" />
      </Parameters>
      <Docs>
        <param name="rgnData">A <see cref="T:System.Drawing.Drawing2D.RegionData" /> definiuje wewnętrznych nowej <see cref="T:System.Drawing.Region" />.</param>
        <summary>Inicjuje nowy <see cref="T:System.Drawing.Region" /> z określonych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowy <xref:System.Drawing.Region> z wnętrza zdefiniowane przez istniejące <xref:System.Drawing.Region>. `rgnData` Parametr jest tablicą, który zawiera definicję istniejącego <xref:System.Drawing.Region>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rgnData" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Region (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.#ctor(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Region(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Region : System.Drawing.Rectangle -&gt; System.Drawing.Region" Usage="new System.Drawing.Region rect" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> strukturę, która definiuje wewnętrznych nowej <see cref="T:System.Drawing.Region" />.</param>
        <summary>Inicjuje nowy <see cref="T:System.Drawing.Region" /> z określonego <see cref="T:System.Drawing.Rectangle" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowy <xref:System.Drawing.Region> z wnętrza prostokątny. Wewnętrzny jest definiowana za pomocą `rect` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Drawing.Region.%23ctor%2A> Konstruktor i <xref:System.Drawing.Region.MakeEmpty%2A> metody. W tym przykładzie jest przeznaczony do użycia z formularzy systemu Windows. Tworzenie formularza i wklej następujący kod do niego. Wywołanie `FillEmptyRegion` metody w postaci <xref:System.Windows.Forms.Control.Paint> jest metoda obsługi zdarzeń `e` jako <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.MiscExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.MiscExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.MiscExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Region (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.#ctor(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Region(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Region : System.Drawing.RectangleF -&gt; System.Drawing.Region" Usage="new System.Drawing.Region rect" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> strukturę, która definiuje wewnętrznych nowej <see cref="T:System.Drawing.Region" />.</param>
        <summary>Inicjuje nowy <see cref="T:System.Drawing.Region" /> z określonego <see cref="T:System.Drawing.RectangleF" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowy <xref:System.Drawing.Region> z wnętrza prostokątny. Wewnętrzny jest definiowana za pomocą `rect` parametru.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Region Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Region ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Drawing.Region" Usage="region.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy dokładną kopię to <see cref="T:System.Drawing.Region" />.</summary>
        <returns>
          <see cref="T:System.Drawing.Region" /> Tworzącą tę metodę.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Complement">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> części określonego <see cref="T:System.Drawing.RectangleF" /> strukturę, która nie intersect z tym <see cref="T:System.Drawing.Region" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Complement">
      <MemberSignature Language="C#" Value="public void Complement (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Complement(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Complement(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complement (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Complement(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.Complement : System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="region.Complement path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> To uzupełnienie <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> zawiera część określonego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> nie który intersect z tym <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt i go rysuje do ekranu w kolorze czarnym.  
  
-   Tworzy drugi prostokąt przecina przy pierwszym, który go rysuje ekran kolorem czerwonym.  
  
-   Tworzy obszar przy użyciu pierwszego prostokąta.  
  
-   Tworzy <xref:System.Drawing.Drawing2D.GraphicsPath>i dodaje drugi prostokąta.  
  
-   Pobiera dopełnienia regionu w połączeniu z <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
-   Wypełnia obszaru dopełnienia niebieska i go rysuje do ekranu.  
  
 Zwróć uwagę, że obszar <xref:System.Drawing.Drawing2D.GraphicsPath> nie który intersect z regionu to kolor niebieski.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.ClassicRegionExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Complement">
      <MemberSignature Language="C#" Value="public void Complement (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Complement(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Complement(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complement (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Complement(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.Complement : System.Drawing.Rectangle -&gt; unit" Usage="region.Complement rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> Struktury uzupełnienie to <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> zawiera część określonego <see cref="T:System.Drawing.Rectangle" /> strukturę, która nie intersect z tym <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Region.Complement%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Complement">
      <MemberSignature Language="C#" Value="public void Complement (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Complement(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Complement(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complement (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Complement(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.Complement : System.Drawing.RectangleF -&gt; unit" Usage="region.Complement rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> Struktury uzupełnienie to <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> zawiera część określonego <see cref="T:System.Drawing.RectangleF" /> strukturę, która nie intersect z tym <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt i go rysuje do ekranu w kolorze czarnym.  
  
-   Tworzy drugi prostokąt przecina przy pierwszym, który go rysuje ekran kolorem czerwonym.  
  
-   Tworzy obszar przy użyciu pierwszego prostokąta.  
  
-   Pobiera uzupełnienie tego regionu, w połączeniu z innego prostokąta.  
  
-   Wypełnia obszaru dopełnienia niebieska i go rysuje do ekranu.  
  
 Zwróć uwagę, że obszar prostokąt drugiej, który nie intersect z regionu to kolor niebieski.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.ClassicRegionExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Complement">
      <MemberSignature Language="C#" Value="public void Complement (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Complement(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Complement(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Complement(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Complement : System.Drawing.Region -&gt; unit" Usage="region.Complement region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" /> Obiektu to uzupełnienie <see cref="T:System.Drawing.Region" /> obiektu.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> zawiera część określonego <see cref="T:System.Drawing.Region" /> nie który intersect z tym <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt i go rysuje do ekranu w kolorze czarnym  
  
-   Tworzy drugi prostokąt przecina przy pierwszym, który go rysuje ekran kolorem czerwonym.  
  
-   Tworzy jeden region, za pomocą pierwszego prostokąta oraz drugi region przy użyciu innego prostokąta.  
  
-   Pobiera uzupełnienie tego regionu pierwszy w połączeniu z drugiego regionu.  
  
-   Wypełnia obszaru dopełnienia niebieska i go rysuje do ekranu.  
  
 Zwróć uwagę, że obszar nie intersect region drugi z pierwszego region to kolor niebieski.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.ClassicRegionExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="region" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="region.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez to <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Drawing.Region.Dispose%2A> umożliwia zasoby używane przez to <xref:System.Drawing.Region> odbiorczego do innych celów.  
  
 Wywołanie <xref:System.Drawing.Region.Dispose%2A> po zakończeniu przy użyciu <xref:System.Drawing.Region>. <xref:System.Drawing.Region.Dispose%2A> Pozostawia metody <xref:System.Drawing.Region> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Drawing.Region.Dispose%2A>, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Drawing.Region> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.Drawing.Region> klasy. Aby uzyskać więcej informacji, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.Drawing.Region.Dispose%2A> przed zwolnieniem ostatniego odwołania do <xref:System.Drawing.Region>. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.Drawing.Region> obiektu `Finalize` metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Drawing.Region.%23ctor%2A> Konstruktor i <xref:System.Drawing.Region.Exclude%2A> i <xref:System.Drawing.Region.Dispose%2A> metody.  
  
 W tym przykładzie jest przeznaczony do użycia z formularzy systemu Windows. Wklej kod do formularza i wywołanie `FillRegionExcludingPath` metody podczas obsługi formularza <xref:System.Windows.Forms.Control.Paint> przekazywania zdarzeń `e` jako <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.GraphicsProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#1)]
 [!code-vb[System.Drawing.GraphicsProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Drawing.Region region, System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Drawing.Region region, class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Equals(System.Drawing.Region,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Drawing::Region ^ region, System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Drawing.Region * System.Drawing.Graphics -&gt; bool" Usage="region.Equals (region, g)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" /> Do testowania.</param>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący powierzchni do rysowania.</param>
        <summary>Testy czy określonego <see cref="T:System.Drawing.Region" /> jest taki sam jak to <see cref="T:System.Drawing.Region" /> na określonym rysowania powierzchni.</summary>
        <returns>
          <see langword="true" /> Jeśli podczas transformacja skojarzone z wewnątrz obszaru jest taki sam jak wewnątrz tego regionu <paramref name="g" /> parametr jest stosowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki `g` jest używana do obliczania wnętrza region na powierzchni do rysowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="g" /> lub <paramref name="region" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exclude">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> części jej wewnętrznych, które nie intersect z określonym <see cref="T:System.Drawing.Rectangle" /> struktury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exclude">
      <MemberSignature Language="C#" Value="public void Exclude (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exclude(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Exclude(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exclude (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exclude(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.Exclude : System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="region.Exclude path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Do wykluczenia z tej <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> zawiera tylko część jej wewnętrznych, które nie intersect z określonym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Drawing.Region.%23ctor%2A> Konstruktor i <xref:System.Drawing.Region.Exclude%2A> i <xref:System.Drawing.Region.Dispose%2A> metody.  
  
 W tym przykładzie jest przeznaczony do użycia z formularzy systemu Windows. Wklej kod do formularza i wywołanie `FillRegionExcludingPath` metody podczas obsługi formularza <xref:System.Windows.Forms.Control.Paint> przekazywania zdarzeń `e` jako <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.GraphicsProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#1)]
 [!code-vb[System.Drawing.GraphicsProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exclude">
      <MemberSignature Language="C#" Value="public void Exclude (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exclude(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Exclude(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exclude (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exclude(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.Exclude : System.Drawing.Rectangle -&gt; unit" Usage="region.Exclude rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> Struktury do wykluczenia z tej <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> zawiera tylko część jej wewnętrznych, które nie intersect z określonym <see cref="T:System.Drawing.Rectangle" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.Exclude%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exclude">
      <MemberSignature Language="C#" Value="public void Exclude (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exclude(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Exclude(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exclude (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exclude(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.Exclude : System.Drawing.RectangleF -&gt; unit" Usage="region.Exclude rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> Struktury do wykluczenia z tej <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> zawiera tylko część jej wewnętrznych, które nie intersect z określonym <see cref="T:System.Drawing.RectangleF" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt i go rysuje do ekranu w kolorze czarnym  
  
-   Tworzy drugi prostokąt przecina przy pierwszym, który go rysuje ekran kolorem czerwonym.  
  
-   Tworzy obszar przy użyciu pierwszego prostokąta.  
  
-   Pobiera obszar nonexcluded regionu w połączeniu z innego prostokąta.  
  
-   Wypełnia obszaru nonexcluded niebieska i go rysuje do ekranu.  
  
 Zwróć uwagę, że obszar obszaru obszaru nie intersect prostokąt to kolor niebieski.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.ClassicRegionExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exclude">
      <MemberSignature Language="C#" Value="public void Exclude (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exclude(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Exclude(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exclude(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Exclude : System.Drawing.Region -&gt; unit" Usage="region.Exclude region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" /> Do wykluczenia z tej <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> zawiera tylko część jej wewnętrznych, które nie intersect z określonym <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykłady kodu, zobacz <xref:System.Drawing.Region.Exclude%28System.Drawing.RectangleF%29> i <xref:System.Drawing.Region.Complement%28System.Drawing.Region%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="region" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Region ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Region ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="region.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektu, próby zwolnienia zasobów i wykonywać inne operacje oczyszczania, przed jego jest odzyskana przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHrgn">
      <MemberSignature Language="C#" Value="public static System.Drawing.Region FromHrgn (IntPtr hrgn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Region FromHrgn(native int hrgn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.FromHrgn(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHrgn (hrgn As IntPtr) As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Region ^ FromHrgn(IntPtr hrgn);" />
      <MemberSignature Language="F#" Value="static member FromHrgn : nativeint -&gt; System.Drawing.Region" Usage="System.Drawing.Region.FromHrgn hrgn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hrgn" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hrgn">Dojście do istniejącej <see cref="T:System.Drawing.Region" />.</param>
        <summary>Inicjuje nowy <see cref="T:System.Drawing.Region" /> dojścia do określonego istniejących [! Region include[ndptecgdi](~/includes/ndptecgdi-MD.MD)].</summary>
        <returns>Nowe <see cref="T:System.Drawing.Region" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowy <xref:System.Drawing.Region> z wnętrza zdefiniowane przez istniejące <xref:System.Drawing.Region> określonego przez dojście w `hrgn` parametru.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Związane z wyliczenia <see cref="T:System.Security.Permissions.SecurityPermissionFlag" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.GetBounds(System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBounds (g As Graphics) As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.GetBounds : System.Drawing.Graphics -&gt; System.Drawing.RectangleF" Usage="region.GetBounds g" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="g">
          <see cref="T:System.Drawing.Graphics" /> Na którym znajduje się ten <see cref="T:System.Drawing.Region" /> jest rysowane.</param>
        <summary>Pobiera <see cref="T:System.Drawing.RectangleF" /> strukturę, która reprezentuje prostokąt zakresem to <see cref="T:System.Drawing.Region" /> na powierzchni rysowania <see cref="T:System.Drawing.Graphics" /> obiektu.</summary>
        <returns>A <see cref="T:System.Drawing.RectangleF" /> strukturę, która reprezentuje prostokąt ograniczający tego <see cref="T:System.Drawing.Region" /> na określonym rysowania powierzchni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki jest używana do obliczania wewnątrz obszaru na powierzchni do rysowania. Prostokąt ograniczający nie zawsze jest najmniejsza prostokąt ograniczający w zależności od bieżącej transformacji.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy <xref:System.Drawing.Drawing2D.GraphicsPath> i dodaje elipsy do niej.  
  
-   Wypełnia ścieżka niebieska i go rysuje do ekranu.  
  
-   Tworzy region, który używa <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
-   Pobiera obszar nonexcluded regionu w połączeniu z innego prostokąta.  
  
-   Pobiera prostokąt ograniczający dla regionu i go rysuje ekran kolorem czerwonym.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.ClassicRegionExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="g" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHrgn">
      <MemberSignature Language="C#" Value="public IntPtr GetHrgn (System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int GetHrgn(class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.GetHrgn(System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHrgn (g As Graphics) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr GetHrgn(System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.GetHrgn : System.Drawing.Graphics -&gt; nativeint" Usage="region.GetHrgn g" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="g">
          <see cref="T:System.Drawing.Graphics" /> Na którym znajduje się ten <see cref="T:System.Drawing.Region" /> jest rysowane.</param>
        <summary>Zwraca dojście systemu Windows do tego <see cref="T:System.Drawing.Region" /> w kontekście określonego grafiki.</summary>
        <returns>Dojście systemu Windows do to <see cref="T:System.Drawing.Region" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="g" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRegionData">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.RegionData GetRegionData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.RegionData GetRegionData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.GetRegionData" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegionData () As RegionData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::RegionData ^ GetRegionData();" />
      <MemberSignature Language="F#" Value="member this.GetRegionData : unit -&gt; System.Drawing.Drawing2D.RegionData" Usage="region.GetRegionData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.RegionData</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Drawing.Drawing2D.RegionData" /> reprezentujący informacje opisujące to <see cref="T:System.Drawing.Region" />.</summary>
        <returns>A <see cref="T:System.Drawing.Drawing2D.RegionData" /> reprezentujący informacje opisujące to <see cref="T:System.Drawing.Region" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Region> Klasa umożliwia zdefiniowanie niestandardowego kształtu. Kształt może składać się z linii, wielokątów i krzywych. <xref:System.Drawing.Region.GetRegionData%2A> Zawiera opis kształtu zawarte w tym <xref:System.Drawing.Region>.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń.  Przykład kodu pokazuje sposób użycia <xref:System.Drawing.Drawing2D.RegionData.Data%2A> z jednego <xref:System.Drawing.Drawing2D.RegionData> obiekt, aby ustawić <xref:System.Drawing.Drawing2D.RegionData.Data%2A> dla innej <xref:System.Drawing.Drawing2D.RegionData>.  
  
 [!code-cpp[System.Drawing.MiscExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.MiscExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.MiscExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegionScans">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF[] GetRegionScans (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF[] GetRegionScans(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.GetRegionScans(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Drawing::RectangleF&gt; ^ GetRegionScans(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.GetRegionScans : System.Drawing.Drawing2D.Matrix -&gt; System.Drawing.RectangleF[]" Usage="region.GetRegionScans matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> reprezentujący geometrycznych przekształcenie do zastosowania do tego regionu.</param>
        <summary>Zwraca tablicę <see cref="T:System.Drawing.RectangleF" /> struktur, które to przybliżona <see cref="T:System.Drawing.Region" /> po zastosowaniu przekształcenia wskazana macierz matrix.</summary>
        <returns>Tablica <see cref="T:System.Drawing.RectangleF" /> struktur, które to przybliżona <see cref="T:System.Drawing.Region" /> po zastosowaniu przekształcenia wskazana macierz matrix.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="matrix" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> do przecięcia się z określonym <see cref="T:System.Drawing.Region" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public void Intersect (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Intersect(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Intersect(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Intersect (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Intersect(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.Intersect : System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="region.Intersect path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Do intersect z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> do przecięcia się z określonym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykłady kodu, zobacz <xref:System.Drawing.RectangleF.Intersect%28System.Drawing.RectangleF%29?displayProperty=nameWithType> i <xref:System.Drawing.Region.Complement%28System.Drawing.Drawing2D.GraphicsPath%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public void Intersect (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Intersect(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Intersect(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Intersect (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Intersect(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.Intersect : System.Drawing.Rectangle -&gt; unit" Usage="region.Intersect rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> Struktury, intersect z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> do przecięcia się z określonym <see cref="T:System.Drawing.Rectangle" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.Intersect%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public void Intersect (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Intersect(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Intersect(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Intersect (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Intersect(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.Intersect : System.Drawing.RectangleF -&gt; unit" Usage="region.Intersect rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> Struktury, intersect z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> do przecięcia się z określonym <see cref="T:System.Drawing.RectangleF" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt pierwszy i go rysuje do ekranu w kolorze czarnym.  
  
-   Tworzy drugi prostokąt i go rysuje ekran kolorem czerwonym.  
  
-   Tworzy obszar pierwszy prostokąta.  
  
-   Pobiera obszar przecięcia dla regionu w połączeniu z innego prostokąta.  
  
-   Wypełnia obszar przecina niebieska i go rysuje do ekranu.  
  
 Zauważ, że obszar nakładających się dla regionu i prostokąt jest niebieski.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.ClassicRegionExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public void Intersect (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Intersect(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Intersect(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Intersect(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Intersect : System.Drawing.Region -&gt; unit" Usage="region.Intersect region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" /> Do intersect z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> do przecięcia się z określonym <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykłady kodu, zobacz <xref:System.Drawing.Region.Intersect%28System.Drawing.RectangleF%29> i <xref:System.Drawing.Region.Complement%28System.Drawing.Drawing2D.GraphicsPath%29> — metoda`.`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty (System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEmpty(class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsEmpty(System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEmpty (g As Graphics) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEmpty(System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : System.Drawing.Graphics -&gt; bool" Usage="region.IsEmpty g" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący powierzchni do rysowania.</param>
        <summary>Testy czy to <see cref="T:System.Drawing.Region" /> ma pusty wnętrze na powierzchni do rysowania określony.</summary>
        <returns>
          <see langword="true" /> Jeśli wewnątrz tego <see cref="T:System.Drawing.Region" /> jest pusta, gdy transformacja skojarzone z <paramref name="g" /> zastosowane, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki `g` jest używana do obliczania wewnątrz obszaru na powierzchni do rysowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="g" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInfinite">
      <MemberSignature Language="C#" Value="public bool IsInfinite (System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInfinite(class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsInfinite(System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInfinite (g As Graphics) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInfinite(System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.IsInfinite : System.Drawing.Graphics -&gt; bool" Usage="region.IsInfinite g" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący powierzchni do rysowania.</param>
        <summary>Testy czy to <see cref="T:System.Drawing.Region" /> ma nieograniczony wnętrze na powierzchni do rysowania określony.</summary>
        <returns>
          <see langword="true" /> Jeśli wewnątrz tego <see cref="T:System.Drawing.Region" /> to nieskończoność, transformacja powiązanych z <paramref name="g" /> zastosowane, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki `g` jest używana do obliczania wewnątrz obszaru na powierzchni do rysowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="g" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza, czy określony prostokąta znajduje się w ramach tego <see cref="T:System.Drawing.Region" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point -&gt; bool" Usage="region.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Drawing.Point" /> Struktury do testowania.</param>
        <summary>Testy czy określonego <see cref="T:System.Drawing.Point" /> struktury jest zawarty w tym <see cref="T:System.Drawing.Region" />.</summary>
        <returns>
          <see langword="true" /> gdy <paramref name="point" /> jest zawarty w tym <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF -&gt; bool" Usage="region.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Drawing.PointF" /> Struktury do testowania.</param>
        <summary>Testy czy określonego <see cref="T:System.Drawing.PointF" /> struktury jest zawarty w tym <see cref="T:System.Drawing.Region" />.</summary>
        <returns>
          <see langword="true" /> gdy <paramref name="point" /> jest zawarty w tym <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As Rectangle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Rectangle -&gt; bool" Usage="region.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> Struktury do testowania.</param>
        <summary>Sprawdza, czy dowolne część określonego <see cref="T:System.Drawing.Rectangle" /> struktury jest zawarty w tym <see cref="T:System.Drawing.Region" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> po jakiejkolwiek jego części <paramref name="rect" /> jest zawarty w tym <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As RectangleF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.RectangleF -&gt; bool" Usage="region.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> Struktury do testowania.</param>
        <summary>Sprawdza, czy dowolne część określonego <see cref="T:System.Drawing.RectangleF" /> struktury jest zawarty w tym <see cref="T:System.Drawing.Region" />.</summary>
        <returns>
          <see langword="true" /> gdy jakiejkolwiek jego części <paramref name="rect" /> jest zawarty w tym <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt pierwszy i go rysuje ekran kolorem niebieskim.  
  
-   Tworzy drugi prostokąt i go rysuje ekran kolorem czerwonym.  
  
-   Tworzy obszar pierwszy prostokąta.  
  
-   Określa, czy jakiejkolwiek jego części prostokąt przecina z regionu.  
  
-   Wyświetla `true` lub `false` wyników na ekranie.  
  
 Powiadomienie, że prostokąt przecina regionu, więc w rezultacie `true`.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.ClassicRegionExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point, System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point, class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Drawing.Point,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point, System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point * System.Drawing.Graphics -&gt; bool" Usage="region.IsVisible (point, g)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Drawing.Point" /> Struktury do testowania.</param>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący kontekstu grafiki.</param>
        <summary>Testy czy określonego <see cref="T:System.Drawing.Point" /> struktury jest zawarty w tym <see cref="T:System.Drawing.Region" /> podczas rysowania przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>
          <see langword="true" /> gdy <paramref name="point" /> jest zawarty w tym <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki jest używana do obliczania wewnątrz regionu i współrzędne punktu na powierzchni do rysowania.  
  
   
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point, System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point, class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Drawing.PointF,System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF, g As Graphics) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point, System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF * System.Drawing.Graphics -&gt; bool" Usage="region.IsVisible (point, g)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Drawing.PointF" /> Struktury do testowania.</param>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący kontekstu grafiki.</param>
        <summary>Testy czy określonego <see cref="T:System.Drawing.PointF" /> struktury jest zawarty w tym <see cref="T:System.Drawing.Region" /> podczas rysowania przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>
          <see langword="true" /> gdy <paramref name="point" /> jest zawarty w tym <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki jest używana do obliczania wewnątrz regionu i współrzędne punktu na powierzchni do rysowania.  
  
   
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Rectangle rect, System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Rectangle rect, class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Drawing.Rectangle,System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As Rectangle, g As Graphics) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Rectangle rect, System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Rectangle * System.Drawing.Graphics -&gt; bool" Usage="region.IsVisible (rect, g)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> Struktury do testowania.</param>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący kontekstu grafiki.</param>
        <summary>Sprawdza, czy dowolne część określonego <see cref="T:System.Drawing.Rectangle" /> struktury jest zawarty w tym <see cref="T:System.Drawing.Region" /> podczas rysowania przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>
          <see langword="true" /> gdy jakiejkolwiek jego części <paramref name="rect" /> jest zawarty w tym <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki jest używana do obliczania wewnątrz regionu i współrzędne prostokąt na powierzchni do rysowania.  
  
   
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.RectangleF rect, System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.RectangleF rect, class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Drawing.RectangleF,System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As RectangleF, g As Graphics) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::RectangleF rect, System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.RectangleF * System.Drawing.Graphics -&gt; bool" Usage="region.IsVisible (rect, g)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> Struktury do testowania.</param>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący kontekstu grafiki.</param>
        <summary>Sprawdza, czy dowolne część określonego <see cref="T:System.Drawing.RectangleF" /> struktury jest zawarty w tym <see cref="T:System.Drawing.Region" /> podczas rysowania przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>
          <see langword="true" /> gdy <paramref name="rect" /> jest zawarty w tym <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki jest używana do obliczania wewnątrz regionu i współrzędne prostokąt na powierzchni do rysowania.  
  
   
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single -&gt; bool" Usage="region.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <summary>Sprawdza, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Region" />.</summary>
        <returns>
          <see langword="true" /> Jeśli określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Int32,System.Int32,System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer, g As Graphics) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * System.Drawing.Graphics -&gt; bool" Usage="region.IsVisible (x, y, g)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący kontekstu grafiki.</param>
        <summary>Sprawdza, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Region" /> obiektu, gdy rysowane przy użyciu określonego <see cref="T:System.Drawing.Graphics" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki jest używana do obliczania wewnątrz regionu i współrzędne punktu na powierzchni do rysowania.  
  
   
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Single,System.Single,System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single, g As Graphics) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * System.Drawing.Graphics -&gt; bool" Usage="region.IsVisible (x, y, g)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący kontekstu grafiki.</param>
        <summary>Sprawdza, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Region" /> podczas rysowania przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>
          <see langword="true" /> Jeśli określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki jest używana do obliczania wewnątrz regionu i współrzędne punktu na powierzchni do rysowania.  
  
   
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer, width As Integer, height As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * int * int -&gt; bool" Usage="region.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x górnego lewego rogu prostokąta do testowania.</param>
        <param name="y">Współrzędna y górnego lewego rogu prostokąta do testowania.</param>
        <param name="width">Szerokość prostokąta do testowania.</param>
        <param name="height">Wysokość prostokąta do testowania.</param>
        <summary>Sprawdza, czy jakiejkolwiek jego części określonego prostokąta znajduje się w ramach tego <see cref="T:System.Drawing.Region" />.</summary>
        <returns>
          <see langword="true" /> po jakiejkolwiek jego części określonego prostokąta znajduje się w ramach tego <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single, width As Single, height As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * single * single -&gt; bool" Usage="region.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x górnego lewego rogu prostokąta do testowania.</param>
        <param name="y">Współrzędna y górnego lewego rogu prostokąta do testowania.</param>
        <param name="width">Szerokość prostokąta do testowania.</param>
        <param name="height">Wysokość prostokąta do testowania.</param>
        <summary>Sprawdza, czy jakiejkolwiek jego części określonego prostokąta znajduje się w ramach tego <see cref="T:System.Drawing.Region" />.</summary>
        <returns>
          <see langword="true" /> po jakiejkolwiek jego części określonego prostokąta znajduje się w ramach tego <see cref="T:System.Drawing.Region" /> obiektu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, int width, int height, System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, int32 width, int32 height, class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer, width As Integer, height As Integer, g As Graphics) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, int width, int height, System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * int * int * System.Drawing.Graphics -&gt; bool" Usage="region.IsVisible (x, y, width, height, g)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x górnego lewego rogu prostokąta do testowania.</param>
        <param name="y">Współrzędna y górnego lewego rogu prostokąta do testowania.</param>
        <param name="width">Szerokość prostokąta do testowania.</param>
        <param name="height">Wysokość prostokąta do testowania.</param>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący kontekstu grafiki.</param>
        <summary>Sprawdza, czy jakiejkolwiek jego części określonego prostokąta znajduje się w ramach tego <see cref="T:System.Drawing.Region" /> podczas rysowania przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>
          <see langword="true" /> po jakiejkolwiek jego części określonego prostokąta znajduje się w ramach tego <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki jest używana do obliczania wewnątrz regionu i współrzędne prostokąt na powierzchni do rysowania.  
  
   
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, float width, float height, System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, float32 width, float32 height, class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.IsVisible(System.Single,System.Single,System.Single,System.Single,System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single, width As Single, height As Single, g As Graphics) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, float width, float height, System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * single * single * System.Drawing.Graphics -&gt; bool" Usage="region.IsVisible (x, y, width, height, g)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x górnego lewego rogu prostokąta do testowania.</param>
        <param name="y">Współrzędna y górnego lewego rogu prostokąta do testowania.</param>
        <param name="width">Szerokość prostokąta do testowania.</param>
        <param name="height">Wysokość prostokąta do testowania.</param>
        <param name="g">A <see cref="T:System.Drawing.Graphics" /> reprezentujący kontekstu grafiki.</param>
        <summary>Sprawdza, czy jakiejkolwiek jego części określonego prostokąta znajduje się w ramach tego <see cref="T:System.Drawing.Region" /> podczas rysowania przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>
          <see langword="true" /> po jakiejkolwiek jego części określonego prostokąta znajduje się w ramach tego <see cref="T:System.Drawing.Region" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja bieżącego kontekstu grafiki jest używana do obliczania wewnątrz regionu i współrzędne prostokąt na powierzchni do rysowania.  
  
   
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.IsVisible%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeEmpty">
      <MemberSignature Language="C#" Value="public void MakeEmpty ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MakeEmpty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.MakeEmpty" />
      <MemberSignature Language="VB.NET" Value="Public Sub MakeEmpty ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MakeEmpty();" />
      <MemberSignature Language="F#" Value="member this.MakeEmpty : unit -&gt; unit" Usage="region.MakeEmpty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje to <see cref="T:System.Drawing.Region" /> do pustego wewnętrzne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Drawing.Region.%23ctor%2A> Konstruktor i <xref:System.Drawing.Region.MakeEmpty%2A> metody. W tym przykładzie jest przeznaczony do użycia z formularzy systemu Windows. Tworzenie formularza i wklej następujący kod do niego. Wywołanie `FillEmptyRegion` metody w postaci <xref:System.Windows.Forms.Control.Paint> jest metoda obsługi zdarzeń `e` jako <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.MiscExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.MiscExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.MiscExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeInfinite">
      <MemberSignature Language="C#" Value="public void MakeInfinite ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MakeInfinite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.MakeInfinite" />
      <MemberSignature Language="VB.NET" Value="Public Sub MakeInfinite ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MakeInfinite();" />
      <MemberSignature Language="F#" Value="member this.MakeInfinite : unit -&gt; unit" Usage="region.MakeInfinite " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje to <see cref="T:System.Drawing.Region" /> obiektu nieskończone wewnętrzne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Drawing.Region.MakeInfinite%2A> metody. W tym przykładzie jest przeznaczony do użycia z formularzy systemu Windows. Tworzenie formularza i wklej następujący kod do niego. Wywołanie `FillEmptyRegion` metody w postaci <xref:System.Windows.Forms.Control.Paint> jest metoda obsługi zdarzeń `e` jako <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.MiscExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.MiscExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.MiscExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHrgn">
      <MemberSignature Language="C#" Value="public void ReleaseHrgn (IntPtr regionHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHrgn(native int regionHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.ReleaseHrgn(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHrgn (regionHandle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHrgn(IntPtr regionHandle);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHrgn : nativeint -&gt; unit" Usage="region.ReleaseHrgn regionHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="regionHandle">Dojście do <see cref="T:System.Drawing.Region" />.</param>
        <summary>Zwalnia dojście <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="regionHandle" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Związane z wyliczenia <see cref="T:System.Security.Permissions.SecurityPermissionFlag" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Transform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="region.Transform matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> Za pomocą której do przekształcenia to <see cref="T:System.Drawing.Region" />.</param>
        <summary>Przekształca to <see cref="T:System.Drawing.Region" /> przez określony <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt i go rysuje ekran kolorem niebieskim.  
  
-   Tworzy obszarem prostokąta.  
  
-   Tworzy macierzy transformacji i ustawia ją na 45 stopni.  
  
-   Stosuje przekształcenia do regionu.  
  
-   Wypełnia obszaru przekształcone przy użyciu czerwony i rysuje przekształcone region ekran kolorem czerwonym.  
  
 Zauważ, że czerwonym prostokątem jest obracany 45 stopni z oryginalnego prostokąta w kolorze niebieskim.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.ClassicRegionExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="matrix" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przesuwa współrzędne to <see cref="T:System.Drawing.Region" /> o określonej szerokości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public void Translate (int dx, int dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Translate(int32 dx, int32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Translate(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Translate (dx As Integer, dy As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Translate(int dx, int dy);" />
      <MemberSignature Language="F#" Value="member this.Translate : int * int -&gt; unit" Usage="region.Translate (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Int32" />
        <Parameter Name="dy" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dx">Wielkość przesunięcia to <see cref="T:System.Drawing.Region" /> poziomo.</param>
        <param name="dy">Wielkość przesunięcia to <see cref="T:System.Drawing.Region" /> pionowo.</param>
        <summary>Przesuwa współrzędne to <see cref="T:System.Drawing.Region" /> o określonej szerokości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt i go rysuje ekran kolorem niebieskim.  
  
-   Tworzy obszarem prostokąta.  
  
-   Stosuje tłumaczenia do regionu.  
  
-   Wypełnia obszaru przetłumaczonego czerwonym i rysuje przetłumaczonego region ekran kolorem czerwonym.  
  
 Zwróć uwagę, że czerwonym prostokątem zostanie przesunięty w dół i w prawo z oryginalnego prostokąt zaznaczone na niebiesko.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.ClassicRegionExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public void Translate (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Translate(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Translate(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Translate (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Translate(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.Translate : single * single -&gt; unit" Usage="region.Translate (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Wielkość przesunięcia to <see cref="T:System.Drawing.Region" /> poziomo.</param>
        <param name="dy">Wielkość przesunięcia to <see cref="T:System.Drawing.Region" /> pionowo.</param>
        <summary>Przesuwa współrzędne to <see cref="T:System.Drawing.Region" /> o określonej szerokości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.Translate%28System.Single%2CSystem.Single%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> Unii sam i określonego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public void Union (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Union(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Union(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Union (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Union(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.Union : System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="region.Union path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Łączenie z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> Unii sam i określonego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.Union%28System.Drawing.RectangleF%29> i <xref:System.Drawing.Region.Complement%28System.Drawing.Drawing2D.GraphicsPath%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public void Union (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Union(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Union(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Union (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Union(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.Union : System.Drawing.Rectangle -&gt; unit" Usage="region.Union rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> Struktury łączenia z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> Unii sam i określonego <see cref="T:System.Drawing.Rectangle" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.Union%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public void Union (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Union(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Union(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Union (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Union(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.Union : System.Drawing.RectangleF -&gt; unit" Usage="region.Union rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> Struktury łączenia z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> Unii sam i określonego <see cref="T:System.Drawing.RectangleF" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt pierwszy i go rysuje do ekranu w kolorze czarnym.  
  
-   Tworzy drugi prostokąt i go rysuje ekran kolorem czerwonym.  
  
-   Tworzy obszar przy użyciu pierwszego prostokąta.  
  
-   Pobiera obszar Unii na `myRegion` w połączeniu z `complementRect`.  
  
-   Wypełnia wypełnienia obszaru Unii niebieska i go rysuje do ekranu.  
  
 Zwróć uwagę, zarówno prostokąty są wypełniane niebieski, w tym obszarze nakładają się na siebie.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.ClassicRegionExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public void Union (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Union(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Union(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Union(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Union : System.Drawing.Region -&gt; unit" Usage="region.Union region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" /> Łączenie z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> Unii sam i określonego <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.Union%28System.Drawing.RectangleF%29> i <xref:System.Drawing.Region.Complement%28System.Drawing.Drawing2D.GraphicsPath%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="region" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Xor">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> obiektu Unii minus przecięcia własnym z określonym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public void Xor (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Xor(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Xor(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Xor (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Xor(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.Xor : System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="region.Xor path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Do <see cref="Overload:System.Drawing.Region.Xor" /> z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> Unii minus przecięcia własnym z określonym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.Xor%28System.Drawing.RectangleF%29> i <xref:System.Drawing.Region.Complement%28System.Drawing.Drawing2D.GraphicsPath%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public void Xor (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Xor(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Xor(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Xor (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Xor(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.Xor : System.Drawing.Rectangle -&gt; unit" Usage="region.Xor rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> Struktury do <see cref="Overload:System.Drawing.Region.Xor" /> z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> Unii minus przecięcia własnym z określonym <see cref="T:System.Drawing.Rectangle" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.Xor%28System.Drawing.RectangleF%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public void Xor (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Xor(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Xor(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Xor (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Xor(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.Xor : System.Drawing.RectangleF -&gt; unit" Usage="region.Xor rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> Struktury do <see cref="M:System.Drawing.Region.Xor(System.Drawing.Drawing2D.GraphicsPath)" /> z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> Unii minus przecięcia własnym z określonym <see cref="T:System.Drawing.RectangleF" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, który jest parametrem <xref:System.Windows.Forms.Control.Paint> obsługi zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt pierwszy i go rysuje do ekranu w kolorze czarnym.  
  
-   Tworzy drugi prostokąt i go rysuje ekran kolorem czerwonym.  
  
-   Tworzy obszar przy użyciu pierwszego prostokąta.  
  
-   Pobiera <xref:System.Drawing.Region.Xor%2A> obszar `myRegion` w połączeniu z `complementRect`.  
  
-   Wypełnia <xref:System.Drawing.Region.Xor%2A> obszar o niebieska i go rysuje do ekranu.  
  
 Zwróć uwagę, zarówno prostokąty są wypełniane niebieski, z wyjątkiem obszaru nakładają się na siebie.  
  
 [!code-cpp[System.Drawing.ClassicRegionExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.ClassicRegionExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.ClassicRegionExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicRegionExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public void Xor (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Xor(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Region.Xor(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Xor(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Xor : System.Drawing.Region -&gt; unit" Usage="region.Xor region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" /> Do <see cref="Overload:System.Drawing.Region.Xor" /> z tym <see cref="T:System.Drawing.Region" />.</param>
        <summary>Aktualizuje to <see cref="T:System.Drawing.Region" /> Unii minus przecięcia własnym z określonym <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład kod, zobacz <xref:System.Drawing.Region.Xor%28System.Drawing.RectangleF%29> i <xref:System.Drawing.Region.Complement%28System.Drawing.Drawing2D.GraphicsPath%29> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="region" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="BlockingCollection&lt;T&gt;" FullName="System.Collections.Concurrent.BlockingCollection&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="46aa402488d2939504c19c19c4d366454b6e940a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36646199" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BlockingCollection&lt;T&gt; : IDisposable, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BlockingCollection`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.BlockingCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public Class BlockingCollection(Of T)&#xA;Implements ICollection, IDisposable, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class BlockingCollection : IDisposable, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BlockingCollection&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IDisposable&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}, Type = {m_collection}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Typ elementów w kolekcji.</typeparam>
    <summary>Umożliwia blokowanie i ograniczenia możliwości kolekcje bezpieczne wątkowo, które implementują <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Concurrent.BlockingCollection%601> to klasa wątkowo kolekcji, która zapewnia następujące korzyści:  
  
-   Implementacja wzorca producent/konsument; <xref:System.Collections.Concurrent.BlockingCollection%601> jest otoki dla <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interfejsu.  
  
-   Współbieżne Dodawanie i usuwanie elementów z wielu wątków z <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> i <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> metody.  
  
-   Ograniczone kolekcji, która blokuje <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> i <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> operacji, gdy kolekcja jest pełny lub jest pusty.  
  
-   Anulowanie <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> lub <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> operacji za pomocą <xref:System.Threading.CancellationToken> obiektu w <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> lub <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> metody.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu. Ponadto należy pamiętać, że <xref:System.Collections.Concurrent.BlockingCollection%601.Dispose> metoda nie jest bezpieczne wątkowo. Wszystkie inne publiczne i chronione elementy członkowskie <xref:System.Collections.Concurrent.BlockingCollection%601> są wątkowo i mogą być używane jednocześnie wiele wątków.  
  
 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> reprezentuje kolekcję, która umożliwia bezpieczne wątkowo, dodawania i usuwania danych. <xref:System.Collections.Concurrent.BlockingCollection%601> Służy jako otoka dla <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> wystąpienia oraz umożliwia próby usunięcia z kolekcji do blokowania dopóki dane są dostępne do usunięcia. Podobnie można utworzyć <xref:System.Collections.Concurrent.BlockingCollection%601> górnej granicy liczby elementów danych może wymusić <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>; próby dodania do kolekcji może następnie zablokować, dopóki nie jest dostępna do przechowywania elementów dodanych miejsca. W ten sposób <xref:System.Collections.Concurrent.BlockingCollection%601> jest podobny do tradycyjnych blokowania kolejki struktury danych, z wyjątkiem, że podstawowy mechanizm magazynu danych jest niedostępny pobieranej jako <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601> obsługuje blokujących i ograniczających. Ograniczenia oznacza, że można skonfigurować maksymalną pojemność kolekcji. Ograniczenia jest ważne w niektórych scenariuszach, ponieważ pozwala kontrolować maksymalny rozmiar kolekcji w pamięci, i uniemożliwia tworzenie wątków przenoszenie zbyt daleko wcześniejsze odbierającą wątków. Wiele wątków lub zadań można dodać elementy do kolekcji jednocześnie, a jeśli kolekcji osiągnie określony maksymalną pojemność, Tworzenie wątków zablokuje do momentu usunięcia elementu. Wielu klientów może jednocześnie usunąć elementy, a jeśli kolekcja jest pusta, odbierającą wątków zablokuje dopóki producent dodaje element. Tworzenie wątków można wywołać <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> metody, aby wskazać, że ma więcej elementów zostaną dodane. Monitor konsumentów <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> właściwość, aby dowiedzieć się, gdy kolekcja jest pusta i ma więcej elementów zostanie dodany.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> i <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> zazwyczaj wykonywane są operacje w pętli. Możesz anulować pętlę przez przekazywanie <xref:System.Threading.CancellationToken> do obiektu <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> lub <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> metody, a następnie zaznaczając wartość tokenu <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> właściwości w każdej iteracji. Jeśli wartość jest `true`, jest Twoją odpowiedź na żądanie anulowania przez wyczyszczenie wszystkich zasobów i wyjścia z pętli.  
  
 Po utworzeniu <xref:System.Collections.Concurrent.BlockingCollection%601> obiektu, można określić nie tylko ograniczonej pojemności, ale również typem kolekcji do użycia. Na przykład można określić <xref:System.Collections.Concurrent.ConcurrentQueue%601> obiektu pierwszym w pierwszym FIFO zachowanie lub <xref:System.Collections.Concurrent.ConcurrentStack%601> obiektu ostatnie w pierwszym LIFO zachowanie. Można użyć dowolnej klasy kolekcji, który implementuje <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interfejsu. Domyślny typ kolekcji dla <xref:System.Collections.Concurrent.BlockingCollection%601> jest <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 Nie należy modyfikować kolekcji źródłowej bezpośrednio. Użyj <xref:System.Collections.Concurrent.BlockingCollection%601> metod, aby dodać lub usunąć elementy. <xref:System.Collections.Concurrent.BlockingCollection%601> Obiektu mogą ulec uszkodzeniu bezpośrednio po zmianie kolekcji źródłowej.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dodawania i pobieranie elementów jednocześnie z blokowaniem kolekcji:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#1)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Metoda Dispose nie jest bezpieczne wątkowo. Wszystkie inne publiczne i chronione elementy członkowskie <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> są wątkowo i mogą być używane jednocześnie wiele wątków.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> klasy bez górną granicę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> klasy bez górną granicę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie podstawowy kolekcji <xref:System.Collections.Concurrent.ConcurrentQueue%601> obiektu, który udostępnia najpierw w pierwszym FIFO zachowanie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, która ma być używana jako magazyn danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> klasy bez górna granica i przy użyciu dostarczonego <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> jako magazyn danych.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; boundedCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="boundedCapacity">Ograniczone rozmiar kolekcji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> klasy z określonym górną granicę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie podstawowy kolekcji <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="boundedCapacity" /> Nie jest wartością dodatnią.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection, int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection, int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T), boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection, int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; * int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; (collection, boundedCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, która ma być używana jako magazyn danych.</param>
        <param name="boundedCapacity">Ograniczone rozmiar kolekcji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> klasy z określonym górna granica i przy użyciu dostarczonego <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> jako magazyn danych.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="boundedCapacity" /> Nie jest wartością dodatnią.</exception>
        <exception cref="T:System.ArgumentException">Podana <paramref name="collection" /> zawiera więcej wartości niż jest dozwolone przez <paramref name="boundedCapacity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje element do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T -&gt; unit" Usage="blockingCollection.Add item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma zostać dodany do kolekcji. Wartość może być odwołaniem o wartości zerowej.</param>
        <summary>Dodaje element do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określono ograniczonej pojemności podczas tego wystąpienia <xref:System.Collections.Concurrent.BlockingCollection%601> został zainicjowany, wywołania do Add może blokować do czasu miejsca do przechowywania dostarczonego elementu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Została oznaczona jako zakończona w odniesieniu do dodatków.  - lub - kolekcja źródłowa nie zaakceptowała elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T * System.Threading.CancellationToken -&gt; unit" Usage="blockingCollection.Add (item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma zostać dodany do kolekcji. Wartość może być odwołaniem o wartości zerowej.</param>
        <param name="cancellationToken">Token anulowania, aby przyjrzeć się.</param>
        <summary>Dodaje element do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określono ograniczonej pojemności podczas tego wystąpienia <xref:System.Collections.Concurrent.BlockingCollection%601> został zainicjowany, wywołanie <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> można zablokować, dopóki nie jest dostępna do przechowywania podanego elementu miejsca.  
  
 Ta metoda może zwracać wcześniej z <xref:System.OperationCanceledException> Jeśli `cancellationToken` została anulowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Jeśli <see cref="T:System.Threading.CancellationToken" /> została anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty lub <see cref="T:System.Threading.CancellationTokenSource" /> , który jest właścicielem <paramref name="cancellationToken" /> został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Została oznaczona jako zakończona w odniesieniu do dodatków.  - lub - kolekcja źródłowa nie zaakceptowała elementu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje określony element do jednej z określonym <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element, który ma zostać dodany do jednej z kolekcji.</param>
        <summary>Dodaje określony element do jednej z określonym <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> tablicy do chwili dodania elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określono ograniczonej pojemności podczas wszystkich <xref:System.Collections.Concurrent.BlockingCollection%601> wystąpienia zostały zainicjowane, wywołanie AddToAny można zablokować, dopóki nie jest dostępna w jednej z kolekcji do przechowywania podanego elementu miejsca.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element lub co najmniej jednej z kolekcji została oznaczona jako zakończone w celu dodania.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden kolekcja źródłowa nie zaakceptowała elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element, który ma zostać dodany do jednej z kolekcji.</param>
        <param name="cancellationToken">Token anulowania, aby przyjrzeć się.</param>
        <summary>Dodaje określony element do jednej z określonym <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> tablicy do chwili dodania elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określono ograniczonej pojemności podczas wszystkich <xref:System.Collections.Concurrent.BlockingCollection%601> wystąpienia zostały zainicjowane, wywołanie AddToAny można zablokować, dopóki nie jest dostępna w jednej z kolekcji do przechowywania podanego elementu miejsca. Ta metoda może zwracać przed dodania elementu do kolekcji, jeśli `cancellationToken` została anulowana, zanim jest wystarczająca ilość miejsca.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Jeśli <see cref="T:System.Threading.CancellationToken" /> została anulowana.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden kolekcja źródłowa nie zaakceptowała elementu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element lub co najmniej jednej z kolekcji została oznaczona jako zakończone w celu dodania.</exception>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty, lub <see cref="T:System.Threading.CancellationTokenSource" /> utworzony <paramref name="cancellationToken" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BoundedCapacity">
      <MemberSignature Language="C#" Value="public int BoundedCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BoundedCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BoundedCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BoundedCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BoundedCapacity : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.BoundedCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pojemność ograniczona <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</summary>
        <value>Pojemność ograniczona tej kolekcji lub int. MaxValue, jeśli nie został dostarczony Brak granicy.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompleteAdding">
      <MemberSignature Language="C#" Value="public void CompleteAdding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CompleteAdding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" />
      <MemberSignature Language="VB.NET" Value="Public Sub CompleteAdding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CompleteAdding();" />
      <MemberSignature Language="F#" Value="member this.CompleteAdding : unit -&gt; unit" Usage="blockingCollection.CompleteAdding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Znaczniki <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia jako nie akceptuje żadnych więcej dodatków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po Kolekcja została oznaczona jako zakończona w celu dodania, dodanie do kolekcji nie jest dozwolone, a próby usunięcia z kolekcji nie będzie czekać, gdy kolekcja jest pusta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="blockingCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia. Tablica musi mieć indeksowane zaczynające od zera.</param>
        <param name="index">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje wszystkie elementy w <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia zgodne jednowymiarowej tablicy, zaczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 CopyTo reprezentuje migawki kolekcji w określonym punkcie w czasie. Jeśli inne wątki dodawania lub usuwania elementów podczas wykonywania operacji CopyTo, elementów zwróconych przez CopyTo może być nieprawidłowy stan kolekcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> Argumentu jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> Argument jest równa lub większa niż długość <paramref name="array" />.  Tablica docelowa jest zbyt mała do przechowywania wszystkich elementów BlockingCcollection.  Ranga tablicy nie jest zgodny.  Typ tablicy jest niezgodny z typem elementów kolekcji BlockingCollection.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów zawartych w <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <value>Liczba elementów zawartych w <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dowolnej metody w kolekcji BlockingCollection jest wykonywany, gdy właściwość Count jest accessd, wartość zwracana jest przybliżona. Liczba mogą uwzględniać liczby, która jest większa lub mniejsza niż rzeczywista liczba elementów w kolekcji BlockingCollection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="blockingCollection.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dispose` Metoda nie jest bezpieczne wątkowo.  
  
 Wywołanie `Dispose` po zakończeniu przy użyciu <xref:System.Collections.Concurrent.BlockingCollection%601>. `Dispose` Pozostawia metody <xref:System.Collections.Concurrent.BlockingCollection%601> w stanie uniemożliwiającym jego używanie. Po wywołaniu `Dispose`, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Collections.Concurrent.BlockingCollection%601> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.Collections.Concurrent.BlockingCollection%601> klasy.  
  
 Aby uzyskać więcej informacji, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Wywoływanie zawsze `Dispose` przed zwolnieniem ostatniego odwołania do <xref:System.Collections.Concurrent.BlockingCollection%601>. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.Collections.Concurrent.BlockingCollection%601> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="blockingCollection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Czy jest jawnie zlikwidowany (true) lub z powodu finalizator (false).</param>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConsumingEnumerable">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umożliwia korzystanie z <see cref="T:System.Collections.Generic.IEnumerator`1" /> dla elementów w kolekcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConsumingEnumerable () As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable();" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : unit -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia korzystanie z <see cref="T:System.Collections.Generic.IEnumerator`1" /> dla elementów w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Usuwa i zwraca elementy z kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> metody:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#4)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : System.Threading.CancellationToken -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token anulowania, aby przyjrzeć się.</param>
        <summary>Umożliwia korzystanie z <see cref="T:System.Collections.Generic.IEnumerable`1" /> dla elementów w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Usuwa i zwraca elementy z kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę kodu klienta usunąć elementy z kolekcji przy użyciu pętli foreach (dla każdej w języku Visual Basic) lub <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> lub zapytań PLINQ. Moduł wyliczający będzie dostarczać elementów (jeśli istnieją) do momentu <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> zwraca wartość true i w razie <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> ma wartość false bloki Pętla do momentu element staje się dostępny, lub do czasu <xref:System.Threading.CancellationToken> zostało anulowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Jeśli <see cref="T:System.Threading.CancellationToken" /> została anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty lub <see cref="T:System.Threading.CancellationTokenSource" /> utworzony <paramref name="cancellationToken" /> został usunięty</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAddingCompleted">
      <MemberSignature Language="C#" Value="public bool IsAddingCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAddingCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAddingCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAddingCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAddingCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsAddingCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy to <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> została oznaczona jako zakończone w celu dodania.</summary>
        <value>Określa, czy ta kolekcja została oznaczona jako zakończone w celu dodania.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy to <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> zostało oznaczone jako zakończone w celu dodania i jest pusta.</summary>
        <value>Określa, czy ta kolekcja została oznaczona jako zakończone w celu dodania i jest pusta.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Udostępnia <see cref="T:System.Collections.Generic.IEnumerator`1" /> dla elementów w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> Dla elementów w kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A>, <xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType> zwraca standardowy moduł wyliczający, który nie modyfikuje odpowiednia kolekcja. Jeśli inne wątki dodawania lub usuwania elementów jednocześnie, gdy jest wywoływana GetEnumerator, elementów zwróconych przez moduł wyliczający może reprezentuje bieżący stan kolekcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia. Tablica musi mieć indeksowane zaczynające od zera.</param>
        <param name="index">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje wszystkie elementy w <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia zgodne jednowymiarowej tablicy, zaczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> Argumentu jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> Argument jest równa lub większa niż długość <paramref name="array" />, tablica jest wielowymiarowa lub parametr typu dla kolekcji nie można automatycznie rzutować na typ tablicy docelowej.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy uzyskują dostęp do <see cref="T:System.Collections.ICollection" /> jest zsynchronizowany.</summary>
        <value>zawsze zwraca wartość false.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.ICollection" />. Ta właściwość nie jest obsługiwana.</summary>
        <value>Zwraca wartość null.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Właściwości SyncRoot nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Udostępnia <see cref="T:System.Collections.IEnumerator" /> dla elementów w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Dla elementów w kolekcji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Take">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa element z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take" />
      <MemberSignature Language="VB.NET" Value="Public Function Take () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take();" />
      <MemberSignature Language="F#" Value="member this.Take : unit -&gt; 'T" Usage="blockingCollection.Take " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa element z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Element usunięty z kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> można zablokować, dopóki element jest dostępny do usunięcia.  
  
 Kolejność, w którym element został usunięty zależy od typu kolekcji pozwala utworzyć <xref:System.Collections.Concurrent.BlockingCollection%601> wystąpienia. Po utworzeniu <xref:System.Collections.Concurrent.BlockingCollection%601> obiektu, można określić typ kolekcji do użycia. Na przykład można określić <xref:System.Collections.Concurrent.ConcurrentQueue%601> obiektu pierwszym w pierwszym FIFO zachowanie lub <xref:System.Collections.Concurrent.ConcurrentStack%601> obiektu ostatnie w pierwszym LIFO zachowanie. Można użyć dowolnej klasy kolekcji, który implementuje <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interfejsu. Domyślny typ kolekcji dla <xref:System.Collections.Concurrent.BlockingCollection%601> jest <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Kolekcja podstawowa została zmodyfikowana poza to <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia, lub <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> jest pusty i kolekcji został oznaczony jako zakończone w celu dodania.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Take : System.Threading.CancellationToken -&gt; 'T" Usage="blockingCollection.Take cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Obiekt, który może służyć do anulowania operacji odbioru.</param>
        <summary>Usuwa element z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Element usunięty z kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> można zablokować, dopóki element jest dostępny do usunięcia lub token jest anulowane.  
  
 Kolejność, w którym element został usunięty zależy od typu kolekcji pozwala utworzyć <xref:System.Collections.Concurrent.BlockingCollection%601> wystąpienia. Po utworzeniu <xref:System.Collections.Concurrent.BlockingCollection%601> obiektu, można określić typ kolekcji do użycia. Na przykład można określić <xref:System.Collections.Concurrent.ConcurrentQueue%601> obiektu pierwszym w pierwszym FIFO zachowanie lub <xref:System.Collections.Concurrent.ConcurrentStack%601> obiektu ostatnie w pierwszym LIFO zachowanie. Można użyć dowolnej klasy kolekcji, który implementuje <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interfejsu. Domyślny typ kolekcji dla <xref:System.Collections.Concurrent.BlockingCollection%601> jest <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> Zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty lub <see cref="T:System.Threading.CancellationTokenSource" /> utworzony token anulowania.</exception>
        <exception cref="T:System.InvalidOperationException">Kolekcja podstawowa została zmodyfikowana poza to <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> kolekcji BlockingCollection lub wystąpienia jest oznaczony jako ukończonych, dodawania, lub <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> jest pusta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera element z jednego określonego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element usunięty z jednej z kolekcji.</param>
        <summary>Pobiera element z jednego określonego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> array, z którym element został usunięty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie TakeFromAny można zablokować, dopóki element jest dostępny do usunięcia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element lub <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> została wywołana dla kolekcji.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden z podstawowych kolekcji został zmodyfikowany poza jego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T&amp;" RefType="out" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element usunięty z jednej z kolekcji.</param>
        <param name="cancellationToken">Token anulowania, aby przyjrzeć się.</param>
        <summary>Pobiera element z jednego określonego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień podczas obserwowania token anulowania określony.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> array, z którym element został usunięty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie TakeFromAny można zablokować, dopóki element jest dostępny do usunięcia. Metoda zwróci wcześniej z operationcanceledexception — Jeśli token jest anulowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Jeśli <see cref="T:System.Threading.CancellationToken" /> została anulowana.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden z podstawowych kolekcji został zmodyfikowany poza jego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element lub <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> została wywołana dla kolekcji.</exception>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="blockingCollection.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje elementy z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienie do nowej tablicy.</summary>
        <returns>Tablica zawierająca kopiuje elementy kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skopiowane elementy nie zostaną usunięte z kolekcji.  
  
 Jeśli wszystkie metody w kolekcji BlockingCollection jest wykonywany podczas wykonywania metody ToArray, zwracana wartość jest przybliżona. ToArray może zawierać takie elementy, które zostały już usunięte lub Wyklucz elementy, które już zostały wstawione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAdd">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje dodać określony element do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T -&gt; bool" Usage="blockingCollection.TryAdd item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma zostać dodany do kolekcji.</param>
        <summary>Próbuje dodać określony element do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>wartość true, jeśli <paramref name="item" /> może być dodany; w przeciwnym razie wartość false. Jeśli element jest zduplikowany, a kolekcja źródłowa nie akceptuje duplikatów, a następnie <see cref="T:System.InvalidOperationException" /> jest generowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kolekcja jest ograniczona kolekcji i jest pełna, ta metoda natychmiast zwraca wartość false bez dodawania elementu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Została oznaczona jako zakończona w odniesieniu do dodatków.  - lub - kolekcja źródłowa nie zaakceptowała elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma zostać dodany do kolekcji.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <summary>Próbuje dodać określony element do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> w określonym przedziale czasu.</summary>
        <returns>wartość true, jeśli <paramref name="item" /> może być dodany do kolekcji w określonym czasie, a w przeciwnym razie wartość false. Jeśli element jest zduplikowany, a kolekcja źródłowa nie akceptuje duplikatów, a następnie <see cref="T:System.InvalidOperationException" /> jest generowany.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Została oznaczona jako zakończona w odniesieniu do dodatków.  - lub - kolekcja źródłowa nie zaakceptowała elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * TimeSpan -&gt; bool" Usage="blockingCollection.TryAdd (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma zostać dodany do kolekcji.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Próbuje dodać określony element do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>wartość true, jeśli <paramref name="item" /> może być dodany do kolekcji w określonym okresie; w przeciwnym razie wartość false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna niż-1 milisekund, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Została oznaczona jako zakończona w odniesieniu do dodatków.  - lub - kolekcja źródłowa nie zaakceptowała elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma zostać dodany do kolekcji.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <param name="cancellationToken">Token anulowania, aby przyjrzeć się.</param>
        <summary>Próbuje dodać określony element do <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> w określonym przedziale czasu, podczas obserwowania token anulowania.</summary>
        <returns>wartość true, jeśli <paramref name="item" /> może być dodany do kolekcji w określonym czasie, a w przeciwnym razie wartość false. Jeśli element jest zduplikowany, a kolekcja źródłowa nie akceptuje duplikatów, a następnie <see cref="T:System.InvalidOperationException" /> jest generowany.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Jeśli <see cref="T:System.Threading.CancellationToken" /> została anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty lub odpowiadającego <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Została oznaczona jako zakończona w odniesieniu do dodatków.  - lub - kolekcja źródłowa nie zaakceptowała elementu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje dodać określony element do jednej z określonym <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element, który ma zostać dodany do jednej z kolekcji.</param>
        <summary>Próbuje dodać określony element do jednej z określonym <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> tablicy, do której dodano element lub wartość -1, jeśli nie można dodać elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element lub co najmniej jednej z kolekcji została oznaczona jako zakończone w celu dodania.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden kolekcja źródłowa nie zaakceptowała elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element, który ma zostać dodany do jednej z kolekcji.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <summary>Próbuje dodać określony element do jednej z określonym <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> tablicy, do której dodano element lub wartość -1, jeśli nie można dodać elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.  - lub - liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element lub co najmniej jednej z kolekcji została oznaczona jako zakończone w celu dodania.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden kolekcja źródłowa nie zaakceptowała elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element, który ma zostać dodany do jednej z kolekcji.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Próbuje dodać określony element do jednej z określonym <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień podczas obserwowania token anulowania określony.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> tablicy, do której dodano element lub wartość -1, jeśli nie można dodać elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może zwracać wczesne Jeśli cancellationToken zostanie anulowany przed miejsca jest dostępna dla operacji dodawania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień lub <see cref="T:System.Threading.CancellationTokenSource" /> utworzony <paramref name="cancellationToken" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna niż-1 milisekund, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.  - lub - liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element lub co najmniej jednej z kolekcji została oznaczona jako zakończone w celu dodania.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden kolekcja źródłowa nie zaakceptowała elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element, który ma zostać dodany do jednej z kolekcji.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <param name="cancellationToken">Token anulowania, aby przyjrzeć się.</param>
        <summary>Próbuje dodać określony element do jednej z określonym <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> tablicy, do której dodano element lub wartość -1, jeśli nie można dodać elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Jeśli <see cref="T:System.Threading.CancellationToken" /> została anulowana.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden kolekcja źródłowa nie zaakceptowała elementu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.  - lub - liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element lub co najmniej jednej z kolekcji została oznaczona jako zakończone w celu dodania.</exception>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTake">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje usunąć element z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> metody.  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#2)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  -&gt; bool" Usage="blockingCollection.TryTake item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma zostać usunięty z kolekcji.</param>
        <summary>Próbuje usunąć element z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>
          <see langword="true" /> Jeśli można usunąć elementu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kolekcja jest pusta, ta metoda natychmiast zwraca wartość false.  
  
 Kolejność, w którym element został usunięty zależy od typu kolekcji pozwala utworzyć <xref:System.Collections.Concurrent.BlockingCollection%601> wystąpienia. Po utworzeniu <xref:System.Collections.Concurrent.BlockingCollection%601> obiektu, można określić typ kolekcji do użycia. Na przykład można określić <xref:System.Collections.Concurrent.ConcurrentQueue%601> obiektu pierwszym w pierwszym FIFO zachowanie lub <xref:System.Collections.Concurrent.ConcurrentStack%601> obiektu ostatnie w pierwszym LIFO zachowanie. Można użyć dowolnej klasy kolekcji, który implementuje <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interfejsu. Domyślny typ kolekcji dla <xref:System.Collections.Concurrent.BlockingCollection%601> jest <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Kolekcja podstawowa została zmodyfikowana poza to <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T&amp;" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma zostać usunięty z kolekcji.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <summary>Próbuje usunąć element z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> w określonym przedziale czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli można usunąć elementu z kolekcji w określonym czasie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność, w którym element został usunięty zależy od typu kolekcji pozwala utworzyć <xref:System.Collections.Concurrent.BlockingCollection%601> wystąpienia. Po utworzeniu <xref:System.Collections.Concurrent.BlockingCollection%601>, można określić typ kolekcji do użycia. Na przykład można określić <xref:System.Collections.Concurrent.ConcurrentQueue%601> obiektu pierwszym w pierwszym FIFO zachowanie lub <xref:System.Collections.Concurrent.ConcurrentStack%601> obiektu ostatnie w pierwszym LIFO zachowanie. Można użyć dowolnej klasy kolekcji, który implementuje <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interfejsu. Domyślny typ kolekcji dla <xref:System.Collections.Concurrent.BlockingCollection%601> jest <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.InvalidOperationException">Kolekcja podstawowa została zmodyfikowana poza to <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * TimeSpan -&gt; bool" Usage="blockingCollection.TryTake (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T&amp;" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma zostać usunięty z kolekcji.</param>
        <param name="timeout">Obiekt reprezentujący wyrażony w milisekundach czas oczekiwania, lub obiekt, który reprezentuje-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Próbuje usunąć element z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> w określonym przedziale czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli można usunąć elementu z kolekcji w określonym czasie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność, w którym element został usunięty zależy od typu kolekcji pozwala utworzyć <xref:System.Collections.Concurrent.BlockingCollection%601> wystąpienia. Po utworzeniu <xref:System.Collections.Concurrent.BlockingCollection%601> obiektu, można określić typ kolekcji do użycia. Na przykład można określić <xref:System.Collections.Concurrent.ConcurrentQueue%601> obiektu pierwszym w pierwszym FIFO zachowanie lub <xref:System.Collections.Concurrent.ConcurrentStack%601> obiektu ostatnie w pierwszym LIFO zachowanie. Można użyć dowolnej klasy kolekcji, który implementuje <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interfejsu. Domyślny typ kolekcji dla <xref:System.Collections.Concurrent.BlockingCollection%601> jest <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kolekcja podstawowa została zmodyfikowana poza to <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T&amp;" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma zostać usunięty z kolekcji.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <param name="cancellationToken">Token anulowania, aby przyjrzeć się.</param>
        <summary>Próbuje usunąć element z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> w określonym przedziale czasu podczas obserwowania token anulowania.</summary>
        <returns>
          <see langword="true" /> Jeśli można usunąć elementu z kolekcji w określonym czasie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność, w którym element został usunięty zależy od typu kolekcji pozwala utworzyć <xref:System.Collections.Concurrent.BlockingCollection%601> wystąpienia. Po utworzeniu <xref:System.Collections.Concurrent.BlockingCollection%601> obiektu, można określić typ kolekcji do użycia. Na przykład można określić <xref:System.Collections.Concurrent.ConcurrentQueue%601> obiektu pierwszym w pierwszym FIFO zachowanie lub <xref:System.Collections.Concurrent.ConcurrentStack%601> obiektu ostatnie w pierwszym LIFO zachowanie. Można użyć dowolnej klasy kolekcji, który implementuje <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interfejsu. Domyślny typ kolekcji dla <xref:System.Collections.Concurrent.BlockingCollection%601> jest <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> Zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> Został usunięty lub odpowiadającego <see cref="T:System.Threading.CancellationTokenSource" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.InvalidOperationException">Kolekcja podstawowa została zmodyfikowana poza to <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje usunąć element z jednego określonego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element usunięty z jednej z kolekcji.</param>
        <summary>Próbuje usunąć element z jednego określonego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> tablicy, w którym element został usunięty lub -1, jeśli nie można usunąć elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie TryTakeFromAny można zablokować, dopóki element jest dostępny do usunięcia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType> metody:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#3)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden z podstawowych kolekcji został zmodyfikowany poza jego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T&amp;" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element usunięty z jednej z kolekcji.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <summary>Próbuje usunąć element z jednego określonego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> tablicy, w którym element został usunięty lub -1, jeśli nie można usunąć elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie TryTakeFromAny można zablokować, dopóki element jest dostępny do usunięcia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.  - lub - liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden z podstawowych kolekcji został zmodyfikowany poza jego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T&amp;" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element usunięty z jednej z kolekcji.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Próbuje usunąć element z jednego określonego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> tablicy, w którym element został usunięty lub -1, jeśli nie można usunąć elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie TryTakeFromAny można zablokować, dopóki element jest dostępny do usunięcia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna niż-1 milisekund, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.  - lub - liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden z podstawowych kolekcji został zmodyfikowany poza jego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T&amp;" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Tablica kolekcji.</param>
        <param name="item">Element usunięty z jednej z kolekcji.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <param name="cancellationToken">Token anulowania, aby przyjrzeć się.</param>
        <summary>Próbuje usunąć element z jednego określonego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień.</summary>
        <returns>Indeks kolekcji w <paramref name="collections" /> tablicy, w którym element został usunięty lub -1, jeśli nie można usunąć elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie TryTakeFromAny można zablokować, dopóki element jest dostępny do usunięcia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Jeśli <see cref="T:System.Threading.CancellationToken" /> została anulowana.</exception>
        <exception cref="T:System.InvalidOperationException">Co najmniej jeden z podstawowych kolekcji został zmodyfikowany poza jego <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpienia.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collections" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.  - lub - liczba <paramref name="collections" /> jest większy niż maksymalny rozmiar 62 dla STA i 63 dla MTA.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collections" /> Argument jest tablicą o długości 0 lub zawiera null element.</exception>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wystąpień został usunięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="HwndSource" FullName="System.Windows.Interop.HwndSource">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cb193ef5001ee559ae6946c3a72d951aa18a2599" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36504073" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HwndSource : System.Windows.PresentationSource, IDisposable, System.Windows.Interop.IKeyboardInputSink, System.Windows.Interop.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi HwndSource extends System.Windows.PresentationSource implements class System.IDisposable, class System.Windows.Interop.IKeyboardInputSink, class System.Windows.Interop.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Interop.HwndSource" />
  <TypeSignature Language="VB.NET" Value="Public Class HwndSource&#xA;Inherits PresentationSource&#xA;Implements IDisposable, IKeyboardInputSink, IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class HwndSource : System::Windows::PresentationSource, IDisposable, System::Windows::Interop::IKeyboardInputSink, System::Windows::Interop::IWin32Window" />
  <TypeSignature Language="F#" Value="type HwndSource = class&#xA;    inherit PresentationSource&#xA;    interface IDisposable&#xA;    interface IWin32Window&#xA;    interface IKeyboardInputSink" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.PresentationSource</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Interop.IKeyboardInputSink</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Interop.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Przedstawia informacje o zawartości Windows Presentation Foundation (WPF) w oknie Win32.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Wiele elementów członkowskich tej klasy są niedostępne w strefie Internet.  
  
 <xref:System.Windows.Interop.HwndSource> Implementuje [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] okna, które mogą zawierać [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] zawartości. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Rozmieszczenia zawartości w oknie mierzony i renderowane; i jest interaktywny jako danych wejściowych. Ponieważ <xref:System.Windows.Interop.HwndSource> zaprojektowane specjalnie na potrzeby współdziałania z [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)], ta klasa udostępnia kilka niskiego poziomu [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] funkcji. Ta klasa służy do wykonaj następujące czynności:  
  
-   Określ style okien, style klasy okna, a rozszerzone Style okna.  
  
-   Utworzenie punktu zaczepienia procedurę okna.  
  
-   Zapewnia dostęp do uchwyt okna (HWND).  
  
-   Zniszczenie okna.  
  
 <xref:System.Windows.Interop.HwndSource> Klasy zaprojektowano pod kątem współdziałania ogólne i nie został zaprojektowany jako zarządzany otok HWND. Ogólnie rzecz biorąc nie udostępnia metody zarządzanych okna lub właściwości do sprawdzania stanu. Zamiast tego <xref:System.Windows.Interop.HwndSource> klasy zapewnia dostęp do [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] uchwyt okna (HWND) za pośrednictwem <xref:System.Windows.Interop.HwndSource.Handle%2A> właściwości, które mogą zostać przekazane za pomocą funkcji PInvoke technik w celu [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] celu manipulowania okna.  
  
 **Konstrukcji**  
  
 Wiele aspektów <xref:System.Windows.Interop.HwndSource> można określić tylko w czasie tworzenia. Aby utworzyć <xref:System.Windows.Interop.HwndSource>, najpierw utwórz <xref:System.Windows.Interop.HwndSourceParameters> struktury i wypełnić ją odpowiednie parametry. Te parametry są następujące:  
  
-   Klasa, okno i rozszerzone Style okna. Aby zmienić style po utworzeniu okna należy użyć funkcji PInvoke. Nie wszystkie style można zmienić po utworzeniu okna. Zapoznaj się [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] dokumentacji przed Zmienianie stylów okna.  
  
-   Początkowe położenie okna.  
  
-   Początkowy rozmiar okna, w tym, czy rozmiar została określona lub należy określić na podstawie ustalonego rozmiaru [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] zawartości.  
  
-   Okno nadrzędne.  
  
-   <xref:System.Windows.Interop.HwndSourceHook> Do uwzględnienia w łańcuchu procedurę okna. Jeśli określisz haku podczas konstruowania odbiera wszystkie komunikaty okna. Można użyć <xref:System.Windows.Interop.HwndSource.AddHook%2A> można dodać punktu zaczepienia po utworzeniu okna.  
  
-   Ustawienia przezroczystości. Okno najwyższego poziomu można skonfigurować w celu przejścia z innych okien na pulpicie zgodnie z każdego piksela przezroczystość [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] zawartości. Aby włączyć tę opcję, należy ustawić <xref:System.Windows.Interop.HwndSourceParameters.UsesPerPixelOpacity%2A> właściwości w <xref:System.Windows.Interop.HwndSourceParameters> do `true`. Ta właściwość może być określony tylko podczas konstruowania i tylko za pomocą <xref:System.Windows.Interop.HwndSource.%23ctor%28System.Windows.Interop.HwndSourceParameters%29> sygnatury konstruktora który nakłada kilku ograniczeń.  
  
 Po wypełnieniu <xref:System.Windows.Interop.HwndSourceParameters> struktury, przekaż go do <xref:System.Windows.Interop.HwndSource.%23ctor%28System.Windows.Interop.HwndSourceParameters%29> Konstruktor <xref:System.Windows.Interop.HwndSource>.  
  
 **Okres istnienia obiektu**  
  
 <xref:System.Windows.Interop.HwndSource> To standardowa [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] obiekt i jego okres istnienia jest zarządzany przez moduł garbage collector. Ponieważ <xref:System.Windows.Interop.HwndSource> reprezentuje zasób niezarządzany <xref:System.Windows.Interop.HwndSource> implementuje <xref:System.IDisposable>. Synchronicznego wywoływania <xref:System.Windows.Interop.HwndSource.Dispose%2A> natychmiast niszczy [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] okna, jeśli wywołać z wątku właściciela. Jeśli wywołany z innego wątku [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] okno zostanie zniszczone asynchronicznie. Wywoływanie <xref:System.Windows.Interop.HwndSource.Dispose%2A> jawnie z interoperating kodu może być konieczne w niektórych scenariuszach współdziałanie.  
  
 **Procedury okna**  
  
 <xref:System.Windows.Interop.HwndSource> Klasa implementuje własną procedurę okna. Tę procedurę okna jest używane do przetwarzania komunikatów okien ważne, takich jak powiązane z układu renderowania i wejściowego. Można jednak również Podłącz procedurę okna na własny użytek. Można określić własne haku podczas konstruowania przez ustawienie <xref:System.Windows.Interop.HwndSourceParameters.HwndSourceHook%2A?displayProperty=nameWithType> właściwości lub też użyć <xref:System.Windows.Interop.HwndSource.AddHook%2A> i <xref:System.Windows.Interop.HwndSource.RemoveHook%2A> do dodawania i usuwania punkty zaczepienia po utworzeniu okna. Punkty zaczepienia są nazywane według kolejności FIFO w ostatniej, co umożliwia Twojej punkty zaczepienia do wykonania przed rozpoczęciem przetwarzania wbudowanych. Rzeczywiste punkty zaczepienia są przechowywane przez słabe odwołanie. W związku z tym upewnij się, że zarządzanie okresem istnienia pełnomocnika punktu zaczepienia.  
  
 Aby uzyskać więcej informacji na temat <xref:System.Windows.Interop.HwndSource> i innych klas współdziałanie, zobacz [WPF i współdziałanie Win32](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md).  
  
 Powiadomienie jak konstruktorów dla <xref:System.Windows.Interop.HwndSource> przyjmować parametrów, które przypominają parametry [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] funkcje takie jak [CreateWindowEx](http://go.microsoft.com/fwlink/?LinkID=98462).  
  
 Przekształcenia skalowania nie powinny być stosowane do <xref:System.Windows.Interop.HwndSource.RootVisual%2A> z <xref:System.Windows.Interop.HwndSource>. Zobacz uwagi dla <xref:System.Windows.Interop.HwndSource.RootVisual%2A>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Interop.HwndHost" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Interop.HwndSource" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ta metoda nie jest dostępna w strefie Internet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (System.Windows.Interop.HwndSourceParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Interop.HwndSourceParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Windows.Interop.HwndSourceParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parameters As HwndSourceParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HwndSource(System::Windows::Interop::HwndSourceParameters parameters);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.HwndSource : System.Windows.Interop.HwndSourceParameters -&gt; System.Windows.Interop.HwndSource" Usage="new System.Windows.Interop.HwndSource parameters" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="parameters" Type="System.Windows.Interop.HwndSourceParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">Struktura, która zawiera parametry, które są wymagane do utworzenia okna.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Interop.HwndSource" /> przy użyciu struktury, który zawiera ustawienia początkowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ta metoda nie jest dostępna w strefie Internet.  
  
 Ta sygnatura konstruktora może być wygodniejsze w niektórych sytuacjach domyślnej struktury zawiera niektóre odpowiednich początkowej wartości domyślnych.  
  
> [!IMPORTANT]
>  Jeśli używasz tego podpisu, nie używaj domyślnie <xref:System.Windows.Interop.HwndSourceParameters> konstruktora, aby utworzyć <xref:System.Windows.Interop.HwndSourceParameters> struktury `parameters` wartość. Należy użyć <xref:System.Windows.Interop.HwndSourceParameters> Konstruktor, który umożliwia określenie nazwy okna. Jeśli użytkownik korzysta z domyślnych <xref:System.Windows.Interop.HwndSourceParameters> Konstruktor i Utwórz <xref:System.Windows.Interop.HwndSource> , który <xref:System.Windows.Interop.HwndSource> nie są wyświetlane nazwa okna jest konstrukcji potrzeby reprezentowanego HWND.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu utworzenia wystąpienia tej klasy. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (int classStyle, int style, int exStyle, int x, int y, string name, IntPtr parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 classStyle, int32 style, int32 exStyle, int32 x, int32 y, string name, native int parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (classStyle As Integer, style As Integer, exStyle As Integer, x As Integer, y As Integer, name As String, parent As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HwndSource(int classStyle, int style, int exStyle, int x, int y, System::String ^ name, IntPtr parent);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.HwndSource : int * int * int * int * int * string * nativeint -&gt; System.Windows.Interop.HwndSource" Usage="new System.Windows.Interop.HwndSource (classStyle, style, exStyle, x, y, name, parent)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classStyle" Type="System.Int32" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="exStyle" Type="System.Int32" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parent" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="classStyle">[! Style klasy include[TLA#tla_win32](~/includes/tlasharptla-Win32-MD.MD)] w oknie.</param>
        <param name="style">[! Style include[TLA2#tla_win32](~/includes/tla2sharptla-Win32-MD.MD)] w oknie.</param>
        <param name="exStyle">Rozszerzony [! Style include[TLA2#tla_win32](~/includes/tla2sharptla-Win32-MD.MD)] w oknie.</param>
        <param name="x">Położenie okna lewej krawędzi.</param>
        <param name="y">Pozycja górnej krawędzi okna.</param>
        <param name="name">Nazwa okna.</param>
        <param name="parent">Uchwyt okna nadrzędnego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Interop.HwndSource" /> klasy stylu określonej klasy, style, rozszerzone styl, pozycja x i y, nazwy i okno nadrzędne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ta metoda nie jest dostępna w strefie Internet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu utworzenia wystąpienia tej klasy. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 classStyle, int32 style, int32 exStyle, int32 x, int32 y, int32 width, int32 height, string name, native int parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (classStyle As Integer, style As Integer, exStyle As Integer, x As Integer, y As Integer, width As Integer, height As Integer, name As String, parent As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, System::String ^ name, IntPtr parent);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.HwndSource : int * int * int * int * int * int * int * string * nativeint -&gt; System.Windows.Interop.HwndSource" Usage="new System.Windows.Interop.HwndSource (classStyle, style, exStyle, x, y, width, height, name, parent)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classStyle" Type="System.Int32" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="exStyle" Type="System.Int32" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parent" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="classStyle">[! Style klasy include[TLA#tla_win32](~/includes/tlasharptla-Win32-MD.MD)] w oknie.</param>
        <param name="style">[! Style include[TLA2#tla_win32](~/includes/tla2sharptla-Win32-MD.MD)] w oknie.</param>
        <param name="exStyle">Rozszerzony [! Style include[TLA2#tla_win32](~/includes/tla2sharptla-Win32-MD.MD)] w oknie.</param>
        <param name="x">Położenie okna lewej krawędzi.</param>
        <param name="y">Pozycja górnej krawędzi okna.</param>
        <param name="width">Szerokość okna.</param>
        <param name="height">Wysokość okna.</param>
        <param name="name">Nazwa okna.</param>
        <param name="parent">Uchwyt okna nadrzędnego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Interop.HwndSource" /> klasy stylu określonej klasy, style, rozszerzone style, pozycji x i y, szerokość, wysokość, nazwy i okno nadrzędne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ta metoda nie jest dostępna w strefie Internet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu utworzenia wystąpienia tej klasy. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent, bool adjustSizingForNonClientArea);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 classStyle, int32 style, int32 exStyle, int32 x, int32 y, int32 width, int32 height, string name, native int parent, bool adjustSizingForNonClientArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (classStyle As Integer, style As Integer, exStyle As Integer, x As Integer, y As Integer, width As Integer, height As Integer, name As String, parent As IntPtr, adjustSizingForNonClientArea As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, System::String ^ name, IntPtr parent, bool adjustSizingForNonClientArea);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.HwndSource : int * int * int * int * int * int * int * string * nativeint * bool -&gt; System.Windows.Interop.HwndSource" Usage="new System.Windows.Interop.HwndSource (classStyle, style, exStyle, x, y, width, height, name, parent, adjustSizingForNonClientArea)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classStyle" Type="System.Int32" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="exStyle" Type="System.Int32" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parent" Type="System.IntPtr" />
        <Parameter Name="adjustSizingForNonClientArea" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="classStyle">[! Style klasy include[TLA#tla_win32](~/includes/tlasharptla-Win32-MD.MD)] w oknie.</param>
        <param name="style">[! Style include[TLA2#tla_win32](~/includes/tla2sharptla-Win32-MD.MD)] w oknie.</param>
        <param name="exStyle">Rozszerzony [! Style include[TLA2#tla_win32](~/includes/tla2sharptla-Win32-MD.MD)] w oknie.</param>
        <param name="x">Położenie okna lewej krawędzi.</param>
        <param name="y">Pozycja górnej krawędzi okna.</param>
        <param name="width">Szerokość okna.</param>
        <param name="height">Wysokość okna.</param>
        <param name="name">Nazwa okna.</param>
        <param name="parent">Uchwyt okna nadrzędnego.</param>
        <param name="adjustSizingForNonClientArea">
          <see langword="true" /> Aby manager układu obejmują obszaru nieklienckiego dla rozmiaru; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Interop.HwndSource" /> klasy stylu określonej klasy, style, rozszerzone style, pozycji x i y, szerokość, wysokość, nazwy i okno nadrzędne i określenie, czy okno jest autosized.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ta metoda nie jest dostępna w strefie Internet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">w celu utworzenia wystąpienia tej klasy. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AcquireHwndFocusInMenuMode">
      <MemberSignature Language="C#" Value="public bool AcquireHwndFocusInMenuMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcquireHwndFocusInMenuMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcquireHwndFocusInMenuMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AcquireHwndFocusInMenuMode { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AcquireHwndFocusInMenuMode : bool" Usage="System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która określa, czy można uzyskać fokusu Win32 dla WPF zawierającą okno tego <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <value>
          <see langword="true" /> można uzyskać fokusu Win32 dla WPF zawierającą okno, gdy użytkownik użyje menu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest ustawiana podczas tworzenia <xref:System.Windows.Interop.HwndSource> przez ustawienie <xref:System.Windows.Interop.HwndSourceParameters.AcquireHwndFocusInMenuMode%2A> parametru.  
  
 Wartość domyślna jest określana przez <xref:System.Windows.Interop.HwndSource.DefaultAcquireHwndFocusInMenuMode%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHook">
      <MemberSignature Language="C#" Value="public void AddHook (System.Windows.Interop.HwndSourceHook hook);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHook(class System.Windows.Interop.HwndSourceHook hook) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.AddHook(System.Windows.Interop.HwndSourceHook)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHook (hook As HwndSourceHook)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHook(System::Windows::Interop::HwndSourceHook ^ hook);" />
      <MemberSignature Language="F#" Value="member this.AddHook : System.Windows.Interop.HwndSourceHook -&gt; unit" Usage="hwndSource.AddHook hook" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hook" Type="System.Windows.Interop.HwndSourceHook" />
      </Parameters>
      <Docs>
        <param name="hook">Implementacja programu obsługi (na podstawie <see cref="T:System.Windows.Interop.HwndSourceHook" /> delegować) odbierająca komunikaty okna.</param>
        <summary>Dodaje program obsługi zdarzeń, który odbiera wszystkie komunikaty okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ta metoda nie jest dostępna w strefie Internet.  
  
 Większość [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] wiadomości, które dotarły do <xref:System.Windows.Interop.HwndSource> ma przybliżonej [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] równoważne. Możesz użyć <xref:System.Windows.Interop.HwndSource.AddHook%2A> do obsługi przypadków, w którym nie ma wiadomości [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] równoważne.  
  
 <xref:System.Windows.Interop.HwndSourceHook> Delegata podobny profil parametru [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] procedurę okna głównego. Wszystkie okna wiadomości, które procedury okna głównego <xref:System.Windows.Interop.HwndSource> odbiera okno nadrzędne zostają przekazane <xref:System.Windows.Interop.HwndSourceHook> delegatów.  
  
 Punkty zaczepienia są wywoływane w kolejności, że zostały one dodane. Jeśli dowolne utworzenie punktu zaczepienia zwraca `handled` = `true` wiadomości, punkty zaczepienia po nim, w kolejności wywołania nie są nazywane dla tej wiadomości.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby dodać obsługę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Interop.HwndSourceHook" />
        <altmember cref="M:System.Windows.Interop.HwndSource.RemoveHook(System.Windows.Interop.HwndSourceHook)" />
      </Docs>
    </Member>
    <Member MemberName="AutoResized">
      <MemberSignature Language="C#" Value="public event System.Windows.AutoResizedEventHandler AutoResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.AutoResizedEventHandler AutoResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.AutoResized" />
      <MemberSignature Language="VB.NET" Value="Public Event AutoResized As AutoResizedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::AutoResizedEventHandler ^ AutoResized;" />
      <MemberSignature Language="F#" Value="member this.AutoResized : System.Windows.AutoResizedEventHandler " Usage="member this.AutoResized : System.Windows.AutoResizedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.AutoResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy układ powoduje <see cref="T:System.Windows.Interop.HwndSource" /> automatycznie zmiany rozmiaru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie natywnego <xref:System.Windows.Interop.HwndSource> jest automatycznie Zmień rozmiar zawartości i regionu okna na podstawie zmian zgłoszone za pośrednictwem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] układu systemu. Okno nie zmienia rozmiaru, jeśli jest on obecnie zminimalizowany lub <xref:System.Windows.Interop.HwndSource.SizeToContent%2A> ma ustawioną wartość <xref:System.Windows.SizeToContent.Manual>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildKeyboardInputSinks">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Interop.IKeyboardInputSink&gt; ChildKeyboardInputSinks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Interop.IKeyboardInputSink&gt; ChildKeyboardInputSinks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.ChildKeyboardInputSinks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildKeyboardInputSinks As IEnumerable(Of IKeyboardInputSink)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Interop::IKeyboardInputSink ^&gt; ^ ChildKeyboardInputSinks { System::Collections::Generic::IEnumerable&lt;System::Windows::Interop::IKeyboardInputSink ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildKeyboardInputSinks : seq&lt;System.Windows.Interop.IKeyboardInputSink&gt;" Usage="System.Windows.Interop.HwndSource.ChildKeyboardInputSinks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Windows.Interop.HwndSource/&lt;get_ChildKeyboardInputSinks&gt;d__29))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Interop.IKeyboardInputSink&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera sekwencję zarejestrowanych wychwytywanie wejściowego.</summary>
        <value>Wychwytywanie wyliczenie przy użyciu klawiatury.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositionTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.HwndTarget CompositionTarget { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Interop.HwndTarget CompositionTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.CompositionTarget" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositionTarget As HwndTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Interop::HwndTarget ^ CompositionTarget { System::Windows::Interop::HwndTarget ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompositionTarget : System.Windows.Interop.HwndTarget" Usage="System.Windows.Interop.HwndSource.CompositionTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.HwndTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Menedżera visual hostowanej okna.</summary>
        <value>Menedżer visual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąpienie <xref:System.Windows.Interop.HwndSource.GetCompositionTargetCore%2A> Aby przesłonić wartość która <xref:System.Windows.Interop.HwndSource.CompositionTarget%2A> zwraca.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHandleRef">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.HandleRef CreateHandleRef ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.InteropServices.HandleRef CreateHandleRef() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.CreateHandleRef" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateHandleRef () As HandleRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::InteropServices::HandleRef CreateHandleRef();" />
      <MemberSignature Language="F#" Value="member this.CreateHandleRef : unit -&gt; System.Runtime.InteropServices.HandleRef" Usage="hwndSource.CreateHandleRef " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.HandleRef</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera uchwytu okna dla <see cref="T:System.Windows.Interop.HwndSource" />. Uchwyt okna jest dostarczana jako część <see cref="T:System.Runtime.InteropServices.HandleRef" /> struktury.</summary>
        <returns>Struktura, która zawiera uchwytu okna dla tego <see cref="T:System.Windows.Interop.HwndSource" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć uchwytu, które są uzyskiwane z <xref:System.Windows.Interop.HwndSource.CreateHandleRef%2A> do odwołania <xref:System.Windows.Interop.HwndSource> z [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] kodu. Użyj uchwytu dla operacji, takich jak zachowanie i okna obsługi komunikatów.  
  
 Aby pobrać tylko uchwytu, należy użyć <xref:System.Windows.Interop.HwndSource.Handle%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.HwndSource.Handle" />
      </Docs>
    </Member>
    <Member MemberName="DefaultAcquireHwndFocusInMenuMode">
      <MemberSignature Language="C#" Value="public static bool DefaultAcquireHwndFocusInMenuMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool DefaultAcquireHwndFocusInMenuMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.DefaultAcquireHwndFocusInMenuMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultAcquireHwndFocusInMenuMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool DefaultAcquireHwndFocusInMenuMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultAcquireHwndFocusInMenuMode : bool with get, set" Usage="System.Windows.Interop.HwndSource.DefaultAcquireHwndFocusInMenuMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślny <see cref="P:System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode" /> wartość dla nowych wystąpień <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <value>
          <see langword="true" /> można uzyskać fokusu Win32 dla WPF zawierającą okno, gdy użytkownik użyje menu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nowe wystąpienia klasy <xref:System.Windows.Interop.HwndSource> ma <xref:System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode%2A> ustawioną wartość domyślną, chyba że inną wartość jest przekazywana jako parametr <xref:System.Windows.Interop.HwndSource> konstruktora dla określonego wystąpienia przy użyciu <xref:System.Windows.Interop.HwndSourceParameters.AcquireHwndFocusInMenuMode%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Aby uzyskać tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="P:System.Windows.Interop.HwndSourceParameters.AcquireHwndFocusInMenuMode" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="hwndSource.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zarządzane zasoby, które są używane przez <see cref="T:System.Windows.Interop.HwndSource" />i zgłasza <see cref="E:System.Windows.Interop.HwndSource.Disposed" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ta metoda nie jest dostępna w strefie Internet.  
  
 <xref:System.Windows.Interop.HwndSource.Dispose%2A> Inicjuje powiązanych oczyszczania pracy HWND. Jeśli <xref:System.Windows.Interop.HwndSource.Dispose%2A> jest wywoływana przez wątek, który różni się od głównego wątku interfejsu użytkownika, może zostać odroczona pracy oczyszczania dopóki nie mogą być publikowane na główny wątek interfejsu użytkownika.  
  
 Wywoływanie <xref:System.Windows.Interop.HwndSource.Dispose%2A> jawnie z interoperating kodu może być konieczne w przypadku niektórych scenariuszy współdziałanie ponieważ <xref:System.Windows.Interop.HwndSource> w niektórych scenariuszach współdziałanie można wygenerować kilku odwołania do niego w granicach współdziałanie który może uniemożliwiać odpowiednim wyrzucanie elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.HwndSource.IsDisposed" />
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="M:System.Windows.Interop.HwndSource.Dispose" /> metoda jest wywoływana w tym obiekcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Interop.HwndSource.Disposed> Zdarzenie jest wywoływane przed wszystkie zasoby są wydawane przez <xref:System.Windows.Interop.HwndSource>. <xref:System.Windows.Interop.HwndSource.Disposed> Zdarzeń wskazuje obiekt, który wywołuje zdarzenie o zbliżającym się ma wszystkie odwołania do niego usunięte.  
  
 Użyj <xref:System.Windows.Interop.HwndSource.Disposed> i <xref:System.Windows.Interop.HwndSource.IsDisposed%2A> właściwości, aby uniknąć wywołania <xref:System.Windows.Interop.HwndSource.Dispose%2A> dwukrotnie (która zgłasza wyjątek).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.HwndSource.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.HwndDpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.HwndDpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event DpiChanged As HwndDpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::HwndDpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.HwndDpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.HwndDpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HwndDpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy rozdzielczości monitora tego Hwnd został zmieniony lub Hwnd jest przenoszony do monitora z różnych DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHwnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Interop.HwndSource FromHwnd (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Interop.HwndSource FromHwnd(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.FromHwnd(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwnd (hwnd As IntPtr) As HwndSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Interop::HwndSource ^ FromHwnd(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwnd : nativeint -&gt; System.Windows.Interop.HwndSource" Usage="System.Windows.Interop.HwndSource.FromHwnd hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.HwndSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">Uchwyt okna podana.</param>
        <summary>Zwraca <see cref="T:System.Windows.Interop.HwndSource" /> obiektu określone okno.</summary>
        <returns>
          <see cref="T:System.Windows.Interop.HwndSource" /> Obiektu okna, określony przez <paramref name="hwnd" /> uchwytu okna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ta metoda nie jest dostępne w strefie Internet security lub dla częściowej relacji zaufania w zasadzie.  
  
 Ta metoda służy do zwracania <xref:System.Windows.Interop.HwndSource> dla elementu typu window, który nie jest jawnie współdziałanie okna. Ta procedura jest:  
  
1.  Utwórz <xref:System.Windows.Interop.WindowInteropHelper> wystąpienia (zapewnianie głównym <xref:System.Windows.Window> jako parametru konstruktora).  
  
2.  Pobierz wartość <xref:System.Windows.Interop.WindowInteropHelper.Handle%2A> właściwości niż <xref:System.Windows.Interop.WindowInteropHelper> wystąpienia.  
  
3.  Przekaż wartość tego parametru HWND jako parametr <xref:System.Windows.Interop.HwndSource.FromHwnd%2A>.  
  
 Ta technika może być przydatna, jeśli chcesz dodać ogólne następnie <xref:System.Windows.Interop.HwndSource.AddHook%2A> przetwarzania w oknie komunikatu. Jednak gdy utworzysz <xref:System.Windows.Interop.HwndSource>, są również odpowiedzialne za niszczenie go. Dotyczy to nawet wtedy, gdy <xref:System.Windows.Application> obiektu aplikacji <xref:System.Windows.Interop.HwndSource> został usunięty. Aby uzyskać więcej informacji, zobacz uwagi na <xref:System.Windows.Interop.HwndSource>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Interop.WindowInteropHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetCompositionTargetCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.CompositionTarget GetCompositionTargetCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.CompositionTarget GetCompositionTargetCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.GetCompositionTargetCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetCompositionTargetCore () As CompositionTarget" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::CompositionTarget ^ GetCompositionTargetCore();" />
      <MemberSignature Language="F#" Value="override this.GetCompositionTargetCore : unit -&gt; System.Windows.Media.CompositionTarget" Usage="hwndSource.GetCompositionTargetCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CompositionTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera element docelowy visual okna.</summary>
        <returns>Zwraca element docelowy visual okna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca takiego samego wyniku jako <xref:System.Windows.Interop.HwndSource.CompositionTarget%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zaimplementuj tę metodę, aby przywrócić docelowy visual określonego typu. <see cref="T:System.Windows.Interop.HwndSource" /> implementuje tę metodę, aby zwrócić <see cref="T:System.Windows.Interop.HwndTarget" />.</para>
        </block>
        <altmember cref="T:System.Windows.Media.CompositionTarget" />
        <altmember cref="P:System.Windows.Interop.HwndSource.CompositionTarget" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Interop.HwndSource.Handle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Interop.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwytu okna dla <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <value>Uchwyt okna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ta właściwość nie jest dostępna w strefie Internet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dostępu do ten wskaźnik. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasFocusWithinCore">
      <MemberSignature Language="C#" Value="protected virtual bool HasFocusWithinCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasFocusWithinCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.HasFocusWithinCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HasFocusWithinCore () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool HasFocusWithinCore();" />
      <MemberSignature Language="F#" Value="abstract member HasFocusWithinCore : unit -&gt; bool&#xA;override this.HasFocusWithinCore : unit -&gt; bool" Usage="hwndSource.HasFocusWithinCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt sink lub jednego z jego składników zawartych w niej ma fokus.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt sink lub jednego z jego składników zawartych w niej ma fokus; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Interop.IKeyboardInputSink.HasFocusWithin" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public override bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.Interop.HwndSource.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="M:System.Windows.Interop.HwndSource.Dispose" /> została wywołana dla tego <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <value>
          <see langword="true" /> Jeśli obiekt ma <see cref="M:System.Windows.Interop.HwndSource.Dispose" /> wywołana na nim; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Interop.HwndSource.Dispose%2A> Inicjuje powiązanych oczyszczania pracy HWND. Jeśli <xref:System.Windows.Interop.HwndSource.Dispose%2A> jest wywoływana przez wątek, który różni się od głównego wątku interfejsu użytkownika, może zostać odroczona pracy oczyszczania dopóki nie mogą być publikowane na główny wątek interfejsu użytkownika. <xref:System.Windows.Interop.HwndSource.Disposed> Zdarzenia i wartość <xref:System.Windows.Interop.HwndSource.IsDisposed%2A> staje się `false` natychmiast <xref:System.Windows.Interop.HwndSource.Dispose%2A> jest wywoływana. W tym czasie, jeśli wywołujesz <xref:System.Windows.Interop.HwndSource.Dispose%2A> ponownie <xref:System.Windows.Interop.HwndSource.Dispose%2A> zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.HwndSource.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="KeyboardInputSiteCore">
      <MemberSignature Language="C#" Value="protected System.Windows.Interop.IKeyboardInputSite KeyboardInputSiteCore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Interop.IKeyboardInputSite KeyboardInputSiteCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.KeyboardInputSiteCore" />
      <MemberSignature Language="VB.NET" Value="Protected Property KeyboardInputSiteCore As IKeyboardInputSite" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Interop::IKeyboardInputSite ^ KeyboardInputSiteCore { System::Windows::Interop::IKeyboardInputSite ^ get(); void set(System::Windows::Interop::IKeyboardInputSite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.KeyboardInputSiteCore : System.Windows.Interop.IKeyboardInputSite with get, set" Usage="System.Windows.Interop.HwndSource.KeyboardInputSiteCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie do kontenera składnika <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> interfejsu.</summary>
        <value>Odwołanie do kontenera <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> interfejsu; lub <see langword="null" /> Jeśli nie przypisano żadnych lokacji. Wartość domyślna to <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.HwndDpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.HwndDpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.OnDpiChanged(System.Windows.HwndDpiChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (e As HwndDpiChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::HwndDpiChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.HwndDpiChangedEventArgs -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.HwndDpiChangedEventArgs -&gt; unit" Usage="hwndSource.OnDpiChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.HwndDpiChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Argumenty zdarzenia</param>
        <summary>Wywoływane, gdy będzie to wartość DPI można zmienić w oknie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli użytkownik obsługuje to zdarzenie, WPF nie obsługuje żadnych elementów wizualnych.  
  
> [!IMPORTANT]
>  Ta metoda uzyskuje dostęp do danych o kluczowym znaczeniu <xref:System.Windows.Interop.HwndTarget>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMnemonicCore">
      <MemberSignature Language="C#" Value="protected virtual bool OnMnemonicCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnMnemonicCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.OnMnemonicCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnMnemonicCore (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnMnemonicCore(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers);" />
      <MemberSignature Language="F#" Value="abstract member OnMnemonicCore :  * System.Windows.Input.ModifierKeys -&gt; bool&#xA;override this.OnMnemonicCore :  * System.Windows.Input.ModifierKeys -&gt; bool" Usage="hwndSource.OnMnemonicCore (msg, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat dla skrótu i skojarzone dane.</param>
        <param name="modifiers">Klawisze modyfikujące.</param>
        <summary>Wywoływane, gdy jeden z mnemonik (klucze dostępu) dla tego obiektu sink jest wywoływany.</summary>
        <returns>
          <see langword="true" /> Jeśli komunikat został obsłużony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="msg" /> nie jest WM_KEYDOWN, WM_SYSKEYDOWN, używając funkcji lub WM_DEADCHAR.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterKeyboardInputSinkCore">
      <MemberSignature Language="C#" Value="protected System.Windows.Interop.IKeyboardInputSite RegisterKeyboardInputSinkCore (System.Windows.Interop.IKeyboardInputSink sink);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Interop.IKeyboardInputSite RegisterKeyboardInputSinkCore(class System.Windows.Interop.IKeyboardInputSink sink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.RegisterKeyboardInputSinkCore(System.Windows.Interop.IKeyboardInputSink)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RegisterKeyboardInputSinkCore (sink As IKeyboardInputSink) As IKeyboardInputSite" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Interop::IKeyboardInputSite ^ RegisterKeyboardInputSinkCore(System::Windows::Interop::IKeyboardInputSink ^ sink);" />
      <MemberSignature Language="F#" Value="member this.RegisterKeyboardInputSinkCore : System.Windows.Interop.IKeyboardInputSink -&gt; System.Windows.Interop.IKeyboardInputSite" Usage="hwndSource.RegisterKeyboardInputSinkCore sink" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sink" Type="System.Windows.Interop.IKeyboardInputSink" />
      </Parameters>
      <Docs>
        <param name="sink">
          <see cref="T:System.Windows.Interop.IKeyboardInputSink" /> Zbiornika zawartych części.</param>
        <summary>Rejestruje <see cref="T:System.Windows.Interop.IKeyboardInputSink" /> interfejsu zawartych części.</summary>
        <returns>
          <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> Lokacji zawartych części.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(System.Windows.Interop.IKeyboardInputSink)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveHook">
      <MemberSignature Language="C#" Value="public void RemoveHook (System.Windows.Interop.HwndSourceHook hook);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveHook(class System.Windows.Interop.HwndSourceHook hook) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.RemoveHook(System.Windows.Interop.HwndSourceHook)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveHook (hook As HwndSourceHook)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveHook(System::Windows::Interop::HwndSourceHook ^ hook);" />
      <MemberSignature Language="F#" Value="member this.RemoveHook : System.Windows.Interop.HwndSourceHook -&gt; unit" Usage="hwndSource.RemoveHook hook" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hook" Type="System.Windows.Interop.HwndSourceHook" />
      </Parameters>
      <Docs>
        <param name="hook">Obsługa zdarzenia do usunięcia.</param>
        <summary>Usuwa obsługi zdarzeń, które zostały dodane przez <see cref="M:System.Windows.Interop.HwndSource.AddHook(System.Windows.Interop.HwndSourceHook)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ta metoda nie jest dostępna w strefie Internet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby usunąć programów obsługi. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Interop.HwndSource.AddHook(System.Windows.Interop.HwndSourceHook)" />
        <altmember cref="T:System.Windows.Interop.HwndSourceHook" />
      </Docs>
    </Member>
    <Member MemberName="RestoreFocusMode">
      <MemberSignature Language="C#" Value="public System.Windows.Input.RestoreFocusMode RestoreFocusMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Input.RestoreFocusMode RestoreFocusMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.RestoreFocusMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreFocusMode As RestoreFocusMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::RestoreFocusMode RestoreFocusMode { System::Windows::Input::RestoreFocusMode get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreFocusMode : System.Windows.Input.RestoreFocusMode" Usage="System.Windows.Interop.HwndSource.RestoreFocusMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RestoreFocusMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Input.RestoreFocusMode" /> okna.</summary>
        <value>
          <see cref="T:System.Windows.Input.RestoreFocusMode" /> Okna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości można ustawić tylko w <xref:System.Windows.Interop.HwndSource.%23ctor%28System.Windows.Interop.HwndSourceParameters%29?displayProperty=nameWithType> konstruktora przy użyciu <xref:System.Windows.Interop.HwndSourceParameters.RestoreFocusMode%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootVisual">
      <MemberSignature Language="C#" Value="public override System.Windows.Media.Visual RootVisual { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Visual RootVisual" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.RootVisual" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property RootVisual As Visual" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Media::Visual ^ RootVisual { System::Windows::Media::Visual ^ get(); void set(System::Windows::Media::Visual ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RootVisual : System.Windows.Media.Visual with get, set" Usage="System.Windows.Interop.HwndSource.RootVisual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="P:System.Windows.Media.CompositionTarget.RootVisual" /> okna.</summary>
        <value>Obiekt visual głównego okna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do połączenia <xref:System.Windows.Controls.Page> lub innego głównego visual do <xref:System.Windows.Interop.HwndSource>.  
  
 Przekształcenia skalowania nie powinny być stosowane do <xref:System.Windows.Interop.HwndSource.RootVisual%2A> z <xref:System.Windows.Interop.HwndSource> ponieważ to można wyłączyć <xref:System.Windows.Interop.HwndSource.SizeToContent%2A> zachowanie. Zawartość będzie skalowana, lecz nie będzie otaczającego okna. Zamiast stosowania przekształcenia do obiektu, który jest <xref:System.Windows.Interop.HwndSource.RootVisual%2A>, zastosowanie transformacji do obiektu, który jest elementem podrzędnym <xref:System.Windows.Interop.HwndSource.RootVisual%2A>. Konieczne może być bardzo otaczający element, aby dodać [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] zawartości, takich jak panelu, aby określić obiekt skalowalnych.  
  
 Możesz dodać <xref:System.Windows.Window> jako element wizualny głównego, ale tylko jako okno najwyższego poziomu (z ws_overlapped —), a nie jako okna podrzędnego.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Interop.HwndTarget.RootVisual" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Interop.HwndSource.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, czy i jak okna jest dopasowywany do jego zawartości.</summary>
        <value>Jedna z wartości wyliczenia. Wartość domyślna to <see cref="F:System.Windows.SizeToContent.Manual" />, który określa, że okno nie jest dopasowywany do jego zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownicy końcowi mogą pośrednio ustawić tej właściwości przy użyciu aplikacji interfejsu użytkownika, jeśli które funkcji jest udostępniany przez aplikację.  
  
 Przekształcenia skalowania nie powinny być stosowane do <xref:System.Windows.Interop.HwndSource.RootVisual%2A> z <xref:System.Windows.Interop.HwndSource>, ponieważ to można wyłączyć <xref:System.Windows.Interop.HwndSource.SizeToContent%2A> zachowanie. Zobacz uwagi dla <xref:System.Windows.Interop.HwndSource.RootVisual%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.SizeToContent" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeToContentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeToContentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.SizeToContentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event SizeToContentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SizeToContentChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeToContentChanged : EventHandler " Usage="member this.SizeToContentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość <see cref="P:System.Windows.Interop.HwndSource.SizeToContent" /> zmiany właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Interop.HwndSource.SizeToContentChanged> Zdarzenie jest wywoływane tylko, gdy zmiana powoduje interakcji z użytkownikiem. Jeśli ustawisz <xref:System.Windows.Window.SizeToContent%2A> w kodzie, <xref:System.Windows.Interop.HwndSource.SizeToContentChanged> nie zdarzenia.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Interop.HwndSource.AutoResized" />
        <altmember cref="P:System.Windows.Interop.HwndSource.SizeToContent" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.HasFocusWithin">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.HasFocusWithin ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#HasFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Function HasFocusWithin () As Boolean Implements IKeyboardInputSink.HasFocusWithin" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin() = System::Windows::Interop::IKeyboardInputSink::HasFocusWithin;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Media.FamilyTypefaceCollection.System#Collections#IList#Remove(System.Object)" />.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt sink lub jednego z jego składników zawartych w niej ma fokus; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Interop.HwndSource> wystąpienia jest rzutowane na <xref:System.Windows.Interop.IKeyboardInputSink> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite">
      <MemberSignature Language="C#" Value="System.Windows.Interop.IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Interop.IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#KeyboardInputSite" />
      <MemberSignature Language="VB.NET" Value=" Property KeyboardInputSite As IKeyboardInputSite Implements IKeyboardInputSink.KeyboardInputSite" />
      <MemberSignature Language="C++ CLI" Value="property System::Windows::Interop::IKeyboardInputSite ^ System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite { System::Windows::Interop::IKeyboardInputSite ^ get(); void set(System::Windows::Interop::IKeyboardInputSite ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Interop.HwndSource.System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite" />.</summary>
        <value>Odwołanie do kontenera <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> interfejsu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Interop.HwndSource> wystąpienia jest rzutowane na <xref:System.Windows.Interop.IKeyboardInputSink> interfejsu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.OnMnemonic">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.OnMnemonic (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Function OnMnemonic (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean Implements IKeyboardInputSink.OnMnemonic" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers) = System::Windows::Interop::IKeyboardInputSink::OnMnemonic;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat dla skrótu i skojarzone dane. Nie należy modyfikować tej struktury wiadomości. Jego jest przekazywana przez odwołanie tylko ze względu na wydajność.</param>
        <param name="modifiers">Klawisze modyfikujące.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />.</summary>
        <returns>
          <see langword="true" /> Jeśli komunikat został obsłużony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Interop.HwndSource> wystąpienia jest rzutowane na <xref:System.Windows.Interop.IKeyboardInputSink> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink">
      <MemberSignature Language="C#" Value="System.Windows.Interop.IKeyboardInputSite IKeyboardInputSink.RegisterKeyboardInputSink (System.Windows.Interop.IKeyboardInputSink sink);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Windows.Interop.IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(class System.Windows.Interop.IKeyboardInputSink sink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#RegisterKeyboardInputSink(System.Windows.Interop.IKeyboardInputSink)" />
      <MemberSignature Language="VB.NET" Value="Function RegisterKeyboardInputSink (sink As IKeyboardInputSink) As IKeyboardInputSite Implements IKeyboardInputSink.RegisterKeyboardInputSink" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Windows::Interop::IKeyboardInputSite ^ System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(System::Windows::Interop::IKeyboardInputSink ^ sink) = System::Windows::Interop::IKeyboardInputSink::RegisterKeyboardInputSink;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sink" Type="System.Windows.Interop.IKeyboardInputSink" />
      </Parameters>
      <Docs>
        <param name="sink">
          <see cref="T:System.Windows.Interop.IKeyboardInputSink" /> Zbiornika zawartych części.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(System.Windows.Interop.IKeyboardInputSink)" />.</summary>
        <returns>
          <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> Lokacji zawartych części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Interop.HwndSource> wystąpienia jest rzutowane na <xref:System.Windows.Interop.IKeyboardInputSink> interfejsu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TabInto">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TabInto (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TabInto(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#TabInto(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Function TabInto (request As TraversalRequest) As Boolean Implements IKeyboardInputSink.TabInto" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TabInto(System::Windows::Input::TraversalRequest ^ request) = System::Windows::Interop::IKeyboardInputSink::TabInto;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Określa, czy fokus powinien być ustawiony na pierwszym lub ostatnim tabulatora.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)" />.</summary>
        <returns>
          <see langword="true" /> Jeśli ustawiono fokus, zgodnie z wymaganiami; <see langword="false" />, jeśli nie ma żadnych tabulatorów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Interop.HwndSource> wystąpienia jest rzutowane na <xref:System.Windows.Interop.IKeyboardInputSink> interfejsu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TranslateAccelerator (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Function TranslateAccelerator (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean Implements IKeyboardInputSink.TranslateAccelerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers) = System::Windows::Interop::IKeyboardInputSink::TranslateAccelerator;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat i skojarzone dane. Nie należy modyfikować tej struktury. Jego jest przekazywana przez odwołanie tylko ze względu na wydajność.</param>
        <param name="modifiers">Klawisze modyfikujące.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />.</summary>
        <returns>
          <see langword="true" /> Jeśli wiadomość była obsługiwana przez implementację metody; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Interop.HwndSource> wystąpienia jest rzutowane na <xref:System.Windows.Interop.IKeyboardInputSink> interfejsu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TranslateChar">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TranslateChar (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#TranslateChar(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Function TranslateChar (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean Implements IKeyboardInputSink.TranslateChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers) = System::Windows::Interop::IKeyboardInputSink::TranslateChar;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat i skojarzone dane. Nie należy modyfikować tej struktury. Jego jest przekazywana przez odwołanie tylko ze względu na wydajność.</param>
        <param name="modifiers">Klawisze modyfikujące.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateChar(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />.</summary>
        <returns>
          <see langword="true" /> Jeśli komunikat został przetworzony i <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" /> nie powinien być wywołany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Interop.HwndSource> wystąpienia jest rzutowane na <xref:System.Windows.Interop.IKeyboardInputSink> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIntoCore">
      <MemberSignature Language="C#" Value="protected virtual bool TabIntoCore (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TabIntoCore(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.TabIntoCore(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TabIntoCore (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TabIntoCore(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member TabIntoCore : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.TabIntoCore : System.Windows.Input.TraversalRequest -&gt; bool" Usage="hwndSource.TabIntoCore request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Określa, czy fokus powinien być ustawiony na pierwszym lub ostatnim tabulatora.</param>
        <summary>Ustawia skupić się na tabulator pierwszego lub ostatniego tabulatora dla obiekt sink.</summary>
        <returns>
          <see langword="true" /> Jeśli ustawiono fokus, zgodnie z wymaganiami; <see langword="false" />, jeśli nie ma żadnych tabulatorów.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="TranslateAcceleratorCore">
      <MemberSignature Language="C#" Value="protected virtual bool TranslateAcceleratorCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TranslateAcceleratorCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.TranslateAcceleratorCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TranslateAcceleratorCore (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TranslateAcceleratorCore(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers);" />
      <MemberSignature Language="F#" Value="abstract member TranslateAcceleratorCore :  * System.Windows.Input.ModifierKeys -&gt; bool&#xA;override this.TranslateAcceleratorCore :  * System.Windows.Input.ModifierKeys -&gt; bool" Usage="hwndSource.TranslateAcceleratorCore (msg, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat i skojarzone dane. Nie należy modyfikować tej struktury. Jego jest przekazywana przez odwołanie tylko ze względu na wydajność.</param>
        <param name="modifiers">Klawisze modyfikujące.</param>
        <summary>Przetwarza wprowadzanie z klawiatury na poziomie komunikatu klucza w dół.</summary>
        <returns>
          <see langword="true" /> Jeśli wiadomość była obsługiwana przez implementację metody; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      </Docs>
    </Member>
    <Member MemberName="TranslateCharCore">
      <MemberSignature Language="C#" Value="protected virtual bool TranslateCharCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TranslateCharCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.TranslateCharCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TranslateCharCore (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TranslateCharCore(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers);" />
      <MemberSignature Language="F#" Value="abstract member TranslateCharCore :  * System.Windows.Input.ModifierKeys -&gt; bool&#xA;override this.TranslateCharCore :  * System.Windows.Input.ModifierKeys -&gt; bool" Usage="hwndSource.TranslateCharCore (msg, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat i skojarzone dane. Nie należy modyfikować tej struktury. Jego jest przekazywana przez odwołanie tylko ze względu na wydajność.</param>
        <param name="modifiers">Klawisze modyfikujące.</param>
        <summary>Przetwarza WM_CHAR, WM_SYSCHAR WM_DEADCHAR i WM_SYSDEADCHAR komunikaty wejściowe przed <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" /> metoda jest wywoływana.</summary>
        <returns>
          <see langword="true" /> Jeśli komunikat został przetworzony i <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" /> nie powinien być wywołany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="UsesPerPixelOpacity">
      <MemberSignature Language="C#" Value="public bool UsesPerPixelOpacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UsesPerPixelOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.UsesPerPixelOpacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UsesPerPixelOpacity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UsesPerPixelOpacity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UsesPerPixelOpacity : bool" Usage="System.Windows.Interop.HwndSource.UsesPerPixelOpacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która deklaruje czy nieprzezroczystość każdego piksela źródła zawartości okna jest przestrzegana.</summary>
        <value>
          <see langword="true" /> Jeśli system używa nieprzezroczystość każdego piksela; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po włączeniu nieprzezroczystość każdego piksela system już rysuje obszaru nieklienckiego. Jest to spowodowane przeznaczenie <xref:System.Windows.Interop.HwndSource.UsesPerPixelOpacity%2A> jest można wyświetlić nieregularnych najwyższego poziomu interfejsu użytkownika, która działa w scenariuszach współdziałanie. W związku z tym są wyświetlane stanowi zaprzeczenie prostokątny obszar klienta z systemem innym niż tego celu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
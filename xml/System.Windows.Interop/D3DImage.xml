<Type Name="D3DImage" FullName="System.Windows.Interop.D3DImage">
  <Metadata><Meta Name="ms.openlocfilehash" Value="567efaf4215fbce1c4cbe8f4e48b7b00f9bdfe91" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69168509" /></Metadata><TypeSignature Language="C#" Value="public class D3DImage : System.Windows.Media.ImageSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi D3DImage extends System.Windows.Media.ImageSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Interop.D3DImage" />
  <TypeSignature Language="VB.NET" Value="Public Class D3DImage&#xA;Inherits ImageSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class D3DImage : System::Windows::Media::ImageSource" />
  <TypeSignature Language="F#" Value="type D3DImage = class&#xA;    inherit ImageSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.ImageSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zostanie <see cref="T:System.Windows.Media.ImageSource" /> wyświetlona powierzchnia modułu Direct3D utworzona przez użytkownika.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Interop.D3DImage> Użyj klasy do hostowania zawartości Direct3D w aplikacji Windows Presentation Foundation (WPF).  
  
 Wywołaj <xref:System.Windows.Interop.D3DImage>metodę, aby zmienić zawartość Direct3D wyświetlaną przez. <xref:System.Windows.Interop.D3DImage.Lock%2A> Wywołaj <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodę, aby przypisać powierzchnię Direct3D do elementu <xref:System.Windows.Interop.D3DImage>. Wywołaj <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> metodę, aby śledzić aktualizacje na powierzchnię Direct3D. Wywołaj <xref:System.Windows.Interop.D3DImage.Unlock%2A> metodę, aby wyświetlić zmienione obszary.  
  
 Klasa zarządza dwoma buforami wyświetlania, które są nazywane buforem zapasowym i *buforem przednim*. ** <xref:System.Windows.Interop.D3DImage> Bufor zapasowy jest powierzchnią Direct3D.  Zmiany buforu zapasowego są kopiowane do przodu do buforu przedniego podczas wywoływania <xref:System.Windows.Interop.D3DImage.Unlock%2A> metody, gdzie jest wyświetlana na sprzęcie. Czasami bufor przedni jest niedostępny. Brak dostępności może być spowodowany blokowaniem ekranu, wyłącznym aplikacjom Direct3D w trybie pełnoekranowym, przełączaniem użytkownika lub innymi działaniami systemowymi. W takim przypadku aplikacja WPF zostanie powiadomiona o obsłudze <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> zdarzenia.  Sposób, w jaki aplikacja reaguje na przedni bufor staje się niedostępny, zależy od tego, czy WPF jest włączona, aby wrócić do renderowania oprogramowania. <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Metoda ma Przeciążenie, które przyjmuje parametr, który określa, czy WPF powraca do renderowania oprogramowania.  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-does-not-fall-back-to-software-rendering"></a>Reagowanie na niedostępny bufor przedni, gdy WPF nie powraca do renderowania oprogramowania  
 Po wywołaniu <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> przeciążenia lub <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> wywołaniu przeciążenia z `enableSoftwareFallback` parametrem ustawionym na `false`, system renderowania zwalnia jego odwołanie do buforu zapasowego, gdy bufor przedni jest niedostępny i nic nie jest stawia. Po ponownym udostępnieniu buforu przedniego system renderowania zgłasza zdarzenie, <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> aby powiadomić aplikację WPF.  Można utworzyć procedurę obsługi zdarzeń w celu ponownego <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> uruchomienia renderowania dla zdarzenia z prawidłową powierzchnią Direct3D. Aby ponownie uruchomić Render, należy wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodę.  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-falls-back-to-software-rendering"></a>Reagowanie na niedostępny bufor przedni, gdy WPF wraca do renderowania oprogramowania  
 Gdy wywołujesz <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Przeciążenie `enableSoftwareFallback` z parametrem ustawionym na `true`, system renderowania zachowuje swoje odwołanie do buforu zapasowego, gdy bufor przedni jest niedostępny, więc nie ma potrzeby wywoływania <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> , gdy przód bufor jest ponownie dostępny.  Mogą wystąpić sytuacje, w których urządzenie użytkownika staną się niedostępne.  Gdy to nastąpi <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> , wywołaj odwołanie do wersji WPF do buforu zapasowego.  Jeśli musisz zresetować urządzenie, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Wywołaj `backBuffer` z parametrem ustawionym na `null`, a następnie ponownie wywołaj <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> polecenie `backBuffer` z ustawioną prawidłową powierzchnią Direct3D.  
  
> [!NOTE]
>  Wydajność zależy znacznie od ustawień powierzchni Direct3D. Aby uzyskać więcej informacji, zobacz Zagadnienia dotyczące [wydajności dla współdziałania Direct3D9 i WPF](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  
  
> [!NOTE]
>  Klasa nie wyświetla zawartości Direct3D, gdy program WPF renderuje w oprogramowaniu, na przykład za pośrednictwem połączenia pulpit zdalny, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> chyba że `true` wywołasz `enableSoftwareFallback` i określisz dla parametru. <xref:System.Windows.Interop.D3DImage>  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Interop.D3DImage> jak zadeklarować w języku XAML. Należy zmapować <xref:System.Windows.Interop> przestrzeń nazw, ponieważ nie jest ona uwzględniona w domyślnych przestrzeniach nazw XAML. Aby uzyskać więcej informacji, [zobacz Przewodnik: Hostowanie zawartości Direct3D9 w](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-xaml[System.Windows.Interop.D3DImage#10](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania dostępu do zasobów niezarządzanych. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Interop.D3DImage" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Interop.D3DImage" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna rozdzielczość ekranu to 1/1/96 cala.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania dostępu do zasobów niezarządzanych. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage (double dpiX, double dpiY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 dpiX, float64 dpiY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dpiX As Double, dpiY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage(double dpiX, double dpiY);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.D3DImage : double * double -&gt; System.Windows.Interop.D3DImage" Usage="new System.Windows.Interop.D3DImage (dpiX, dpiY)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dpiX">Rozdzielczość ekranu na osi x.</param>
        <param name="dpiY">Rozdzielczość ekranu na osi y.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Interop.D3DImage" /> klasy z określoną rozdzielczością wyświetlania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna rozdzielczość ekranu to 1/1/96 cala.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dpiX" />lub <paramref name="dpiY" /> jest mniejsza od zera.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania dostępu do zasobów niezarządzanych. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberSignature Language="F#" Value="member this.AddDirtyRect : System.Windows.Int32Rect -&gt; unit" Usage="d3DImage.AddDirtyRect dirtyRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect"><see cref="T:System.Windows.Int32Rect" /> Reprezentuje obszar, który uległ zmianie.</param>
        <summary>Określa obszar buforu zaplecza, który został zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> metodę, aby wskazać zmiany wprowadzone w buforze zapasowym. Aby można było renderować zmieniony obszar w buforze zaplecza, musi on mieć odpowiednio zmieniony obszar w <xref:System.Windows.Interop.D3DImage>.  
  
 Przed wywołaniem <xref:System.Windows.Interop.D3DImage.Lock%2A> metody<xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> wywołaj metody i. <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  
  
 Wywołaj <xref:System.Windows.Interop.D3DImage.Unlock%2A> metodę, aby skopiować zmienione obszary do buforu przedniego.  
  
> [!NOTE]
>  Po kilku wywołaniach do <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> metody, zmienione obszary są scalane w jeden obszar. Oznacza to, że musisz mieć prawidłowe dane poza zmienionymi obszarami.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wywołać metodę, <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> aby określić zmieniony region w buforze zaplecza. Aby uzyskać więcej informacji, [zobacz Przewodnik: Hostowanie zawartości Direct3D9 w](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Mapa bitowa nie została zablokowana przez wywołanie <see cref="M:System.Windows.Interop.D3DImage.Lock" /> metody lub. <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />  
  
—lub— 
Bufor do <see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" /> tyłu nie został przypisany przez wywołanie metody.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Co najmniej jeden z poniższych warunków ma wartość true.  
  
 <paramref name="dirtyRect.X" /> &lt; 0 
 <paramref name="dirtyRect.Y" /> &lt; 0 
 <paramref name="dirtyRect.Width" />&lt; 0 lub <paramref name="dirtyRect.Width" /> 0<paramref name="dirtyRect.Height" /> lub &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /> <paramref name="dirtyRect.Height" /> &lt; &gt;<see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania dostępu do zasobów niezarządzanych. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Interop.D3DImage" Usage="d3DImage.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy modyfikowalny klon tego <see cref="T:System.Windows.Interop.D3DImage" /> obiektu, tworząc głębokie kopie wartości tego obiektu. Podczas kopiowania właściwości zależności ta metoda kopiuje odwołania do zasobów i powiązania danych (które mogą nie być już rozpoznawane), ale nie ma animacji ani ich bieżących wartości.</summary>
        <returns>Modyfikowalny klon bieżącego obiektu. <see cref="P:System.Windows.Freezable.IsFrozen" /> Właściwość sklonowanego obiektu <see langword="false" /> będzie <see cref="P:System.Windows.Freezable.IsFrozen" /> nawet wtedy, gdy właściwość źródła była<see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia modyfikowalnych kopii obiektów zamrożonych <xref:System.Windows.Freezable> (lub dowolnego <xref:System.Windows.Freezable> obiektu). Dla wygody ta metoda zaciemnienia dziedziczonej wersji z silnie wpisaną implementacją.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt, który ma zostać sklonowany.</param>
        <summary>Sprawia, że wystąpienie jest klonem (głębokiej kopii) <see cref="T:System.Windows.Freezable" /> określonej przy użyciu wartości właściwości Base (Nieanimowane).</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.Interop.D3DImage" Usage="d3DImage.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy modyfikowalny klon tego <see cref="T:System.Windows.Interop.D3DImage" /> obiektu, tworząc głębokie kopie bieżących wartości tego obiektu. Odwołania do zasobów, powiązania danych i animacje nie są kopiowane, ale ich bieżące wartości są kopiowane.</summary>
        <returns>Modyfikowalny klon bieżącego obiektu. <see cref="P:System.Windows.Freezable.IsFrozen" /> Właściwość sklonowanego obiektu <see langword="false" /> będzie <see cref="P:System.Windows.Freezable.IsFrozen" /> nawet wtedy, gdy właściwość źródła była <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia modyfikowalnych kopii obiektów zamrożonych <xref:System.Windows.Freezable> (lub dowolnego <xref:System.Windows.Freezable> obiektu). Dla wygody ta metoda zaciemnienia dziedziczonej wersji z silnie wpisaną implementacją.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><see cref="T:System.Windows.Freezable" /> Do klonowania.</param>
        <summary>Sprawia, że wystąpienie jest modyfikowalne klonowania (głębokiej kopii <see cref="T:System.Windows.Freezable" /> ) określonej przy użyciu bieżących wartości właściwości.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CopyBackBuffer">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.Media.Imaging.BitmapSource CopyBackBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CopyBackBuffer" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CopyBackBuffer () As BitmapSource" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::Media::Imaging::BitmapSource ^ CopyBackBuffer();" />
      <MemberSignature Language="F#" Value="abstract member CopyBackBuffer : unit -&gt; System.Windows.Media.Imaging.BitmapSource&#xA;override this.CopyBackBuffer : unit -&gt; System.Windows.Media.Imaging.BitmapSource" Usage="d3DImage.CopyBackBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.BitmapSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię <see cref="T:System.Windows.Interop.D3DImage" />oprogramowania.</summary>
        <returns>To jest kopia oprogramowania bieżącego stanu buforu zapasowego; w przeciwnym razie, <see langword="null" /> Jeśli nie można odczytać buforu zapasowego. <see cref="T:System.Windows.Media.Imaging.BitmapSource" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wywoływana przez klientów, takich jak system drukowania <xref:System.Windows.Media.Imaging.RenderTargetBitmap> i Klasa. <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A>  
  
 Opcjonalnie Zastąp <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> metodę, aby zaimplementować logikę niestandardową <xref:System.Windows.Media.Imaging.BitmapSource>i zwrócić inną. Na przykład, można zwrócić symbol zastępczy <xref:System.Windows.Media.Imaging.BitmapSource> , jeśli domyślna <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> implementacja zwróci `null`wartość.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania dostępu do zasobów niezarządzanych. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="d3DImage.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej tworzy nowe wystąpienie <see cref="T:System.Windows.Interop.D3DImage" /> klasy pochodnej.</summary>
        <returns>Nowe wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pochodzi od <xref:System.Windows.Interop.D3DImage> klasy, należy <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> zastąpić metodę, aby włączyć poprawne klonowanie. Implementacja domyślna wykonuje `return new D3DImage()`, która nie będzie poprawna, jeśli wystąpienie jest inną klasą.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!D3DImage ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="d3DImage.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby i wykonuje inne operacje czyszczenia przed <see cref="T:System.Windows.Interop.D3DImage" /> odzyskiwaniem przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.Object.Finalize%2A>. Kod aplikacji nie powinien wywoływać tej metody; `Finalize` metoda obiektu jest automatycznie wywoływana podczas wyrzucania elementów bezużytecznych, chyba że finalizacja przez moduł wyrzucania elementów bezużytecznych została wyłączona przez wywołanie <xref:System.GC.SuppressFinalize%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [finalizowanie metod i destruktorów](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), Oczyszczanie zasobów niezarządzanych i zastępowanie [metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)). [](~/docs/standard/garbage-collection/unmanaged.md)  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania dostępu do zasobów niezarządzanych. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override sealed bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="override this.FreezeCore : bool -&gt; bool" Usage="d3DImage.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">Nie ma żadnego wpływu.</param>
        <summary>Sprawia, <see cref="T:System.Windows.Interop.D3DImage" /> że nie można zmodyfikować lub określić, czy może być niemodyfikowalny.</summary>
        <returns><see langword="false" />we wszystkich przypadkach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa <xref:System.Windows.Interop.D3DImage> nie zezwala na zamrażanie, ponieważ zmiany są zawsze możliwe z powodu uzyskania dostępu do buforu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Wystąpienie, które ma zostać skopiowane.</param>
        <summary>Sprawia, że wystąpienie jest zablokowanym klonem <see cref="T:System.Windows.Freezable" /> określonego przy użyciu wartości właściwości Base (Nieanimowane).</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><see cref="T:System.Windows.Freezable" /> Do kopiowania i zablokowania.</param>
        <summary>Sprawia, że bieżące wystąpienie jest zablokowanym klonem <see cref="T:System.Windows.Freezable" />określonego. Jeśli obiekt ma animowane właściwości zależności, ich bieżące wartości animowane są kopiowane.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public override sealed double Height { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Height" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Height : double" Usage="System.Windows.Interop.D3DImage.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wysokość <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <value>Wysokość <see cref="T:System.Windows.Interop.D3DImage" />, w jednostkach miary. Jednostka miary to 1/1/96 cala.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Interop.D3DImage.Height%2A> może ulec zmianie, gdy nowy bufor zapasowy jest przypisywany przez wywołanie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailable">
      <MemberSignature Language="C#" Value="public bool IsFrontBufferAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrontBufferAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrontBufferAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrontBufferAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrontBufferAvailable : bool" Usage="System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy istnieje bufor przedni.</summary>
        <value><see langword="true" />Jeśli istnieje bufor przedni; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czasami bufor przedni jest niedostępny. Brak dostępności może być spowodowany blokowaniem ekranu, wyłącznym aplikacjom Direct3D w trybie pełnoekranowym, przełączaniem użytkownika lub innymi działaniami systemowymi. W takim przypadku aplikacja WPF zostanie powiadomiona o obsłudze <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> zdarzenia.  Sposób, w jaki aplikacja reaguje na przedni bufor staje się niedostępny, zależy od tego, czy WPF jest włączona, aby wrócić do renderowania oprogramowania. <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Metoda ma Przeciążenie, które przyjmuje parametr, który określa, czy WPF powraca do renderowania oprogramowania. Aby uzyskać więcej informacji, zobacz uwagi w <xref:System.Windows.Interop.D3DImage> klasie.  
  
<a name="dependencyPropertyInfo_IsFrontBufferAvailable"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A> jak sprawdzić właściwość podczas renderowania celu kompozycji. Aby uzyskać więcej informacji, [zobacz Przewodnik: Hostowanie zawartości Direct3D9 w](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#2](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
        <altmember cref="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsFrontBufferAvailableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="F#" Value="member this.IsFrontBufferAvailableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsFrontBufferAvailableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /> właściwość zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługuj powiadomienie <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> , gdy zmieni się stan buforu przedniego. Sposób, w jaki aplikacja reaguje na przedni bufor staje się niedostępny, zależy od tego, czy WPF jest włączona, aby wrócić do renderowania oprogramowania. <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Metoda ma Przeciążenie, które przyjmuje parametr, który określa, czy WPF powraca do renderowania oprogramowania. Aby uzyskać więcej informacji, zobacz uwagi w <xref:System.Windows.Interop.D3DImage> klasie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFrontBufferAvailableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFrontBufferAvailableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFrontBufferAvailableProperty : System.Windows.DependencyProperty" Usage="System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberSignature Language="F#" Value="member this.Lock : unit -&gt; unit" Usage="d3DImage.Lock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blokuje operacje <see cref="T:System.Windows.Interop.D3DImage" /> i włącza w buforze zapasowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Wywołaj <xref:System.Windows.Interop.D3DImage.Lock%2A> metodę, aby zmienić bufor zapasowy, wywołując metody i. <xref:System.Windows.Interop.D3DImage> Gdy jest zablokowany, aplikacja może również renderować do powierzchni Direct3D przypisanej do buforu zapasowego.  
  
> [!NOTE]
>  <xref:System.Windows.Interop.D3DImage.Lock%2A> Metoda blokuje, gdy system renderowania odczytuje bufor zapasowy w celu zaktualizowania buforu przedniego. Użyj metody <xref:System.Windows.Interop.D3DImage.TryLock%2A> , aby zapobiec blokowaniu w nieskończoność.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Interop.D3DImage.Lock%2A> jak wywołać metodę w celu włączenia aktualizacji buforu zapasowego. Aby uzyskać więcej informacji, [zobacz Przewodnik: Hostowanie zawartości Direct3D9 w](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Liczba blokad równa <see cref="F:System.UInt32.MaxValue" />się.</exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.Media.ImageMetadata Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageMetadata Metadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Metadata" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Metadata As ImageMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageMetadata ^ Metadata { System::Windows::Media::ImageMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Metadata : System.Windows.Media.ImageMetadata" Usage="System.Windows.Interop.D3DImage.Metadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metadane skojarzone ze źródłem obrazu.</summary>
        <value><see langword="null" />we wszystkich przypadkach.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PixelHeight">
      <MemberSignature Language="C#" Value="public int PixelHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelHeight : int" Usage="System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wysokość <see cref="T:System.Windows.Interop.D3DImage" />(w pikselach).</summary>
        <value>Wysokość <see cref="T:System.Windows.Interop.D3DImage" />(w pikselach).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> może ulec zmianie, gdy nowy bufor zapasowy jest przypisywany przez wywołanie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak użyć właściwości, <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> aby określić zmieniony region w buforze zapasowym. Aby uzyskać więcej informacji, [zobacz Przewodnik: Hostowanie zawartości Direct3D9 w](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelWidth" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PixelWidth">
      <MemberSignature Language="C#" Value="public int PixelWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelWidth : int" Usage="System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szerokość <see cref="T:System.Windows.Interop.D3DImage" />(w pikselach).</summary>
        <value>Szerokość <see cref="T:System.Windows.Interop.D3DImage" />(w pikselach).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> może ulec zmianie, gdy nowy bufor zapasowy jest przypisywany przez wywołanie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak użyć właściwości, <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> aby określić zmieniony region w buforze zapasowym. Aby uzyskać więcej informacji, [zobacz Przewodnik: Hostowanie zawartości Direct3D9 w](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelHeight" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBackBuffer">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przypisuje powierzchnię Direct3D jako źródło buforu zapasowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="F#" Value="member this.SetBackBuffer : System.Windows.Interop.D3DResourceType * nativeint -&gt; unit" Usage="d3DImage.SetBackBuffer (backBufferType, backBuffer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="backBufferType">Typ powierzchni Direct3D. Musi być prawidłowy <see cref="T:System.Windows.Interop.D3DResourceType" />.</param>
        <param name="backBuffer">Powierzchnia Direct3D, która ma zostać przypisana jako bufor zapasowy.</param>
        <summary>Przypisuje powierzchnię Direct3D jako źródło buforu zapasowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodę, aby przypisać powierzchnię Direct3D do buforu zaplecza.  
  
> [!NOTE]
>  Wydajność zależy znacznie od ustawień powierzchni Direct3D. Aby uzyskać więcej informacji, zobacz Zagadnienia dotyczące [wydajności dla współdziałania Direct3D9 i WPF](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  
  
 Wywołanie przeciążenia jest identyczne z <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> wywołaniem przeciążenia z `enableSoftwareFallback` parametrem ustawionym na `false`. <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> W przypadku wywołania <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> lub wywołania <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> `enableSoftwareFallback` parametru`false`z ustawioną opcją, system renderowania zwalnia jego odwołanie do buforu zapasowego, gdy przedni bufor przestanie być dostępny i nic nie zostanie wyświetlone. Po ponownym udostępnieniu buforu przedniego system renderowania zgłasza zdarzenie, <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> aby powiadomić aplikację WPF.  Można utworzyć procedurę obsługi zdarzeń w celu ponownego <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> uruchomienia renderowania dla zdarzenia z prawidłową powierzchnią Direct3D. Aby ponownie uruchomić Render, należy wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodę.  
  
 Na poniższej liście przedstawiono wymagane ustawienia buforu wstecznego dla tego `IDirect3DSurface9` typu.  
  
-   `D3DFMT_A8R8G8B8` lub `D3DFMT_X8R8G8B8`  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 Wielokrotne próbkowanie jest `IDirect3DSurface9Ex` dozwolone tylko na powierzchniach.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wywołać metodę, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> aby przypisać powierzchnię Direct3D. Aby uzyskać więcej informacji, [zobacz Przewodnik: Hostowanie zawartości Direct3D9 w](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została zablokowana przez wywołanie <see cref="M:System.Windows.Interop.D3DImage.Lock" /> metody lub <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />. <see cref="T:System.Windows.Interop.D3DImage" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="backBufferType" />jest nieprawidłowy <see cref="T:System.Windows.Interop.D3DResourceType" />.</exception>
        <exception cref="T:System.ArgumentException">Parametry tworzenia dla programu <paramref name="backBuffer" /> nie spełniają wymagań <paramref name="backBufferType" />dla-lub- <paramref name="backBuffer" /> urządzenia są nieprawidłowe.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania dostępu do zasobów niezarządzanych. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer, bool enableSoftwareFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr, enableSoftwareFallback As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="F#" Value="member this.SetBackBuffer : System.Windows.Interop.D3DResourceType * nativeint * bool -&gt; unit" Usage="d3DImage.SetBackBuffer (backBufferType, backBuffer, enableSoftwareFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="backBuffer" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableSoftwareFallback" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="backBufferType">Typ powierzchni Direct3D. Musi być prawidłowy <see cref="T:System.Windows.Interop.D3DResourceType" />.</param>
        <param name="backBuffer">Powierzchnia Direct3D, która ma zostać przypisana jako bufor zapasowy.</param>
        <param name="enableSoftwareFallback"><see langword="true" />Aby wrócić do renderowania oprogramowania; w przeciwnym razie. <see langword="false" /></param>
        <summary>Przypisuje powierzchnię Direct3D jako źródło buforu zapasowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> przeciążenia lub <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> wywołaniu przeciążenia z `enableSoftwareFallback` parametrem ustawionym na `false`, system renderowania zwalnia jego odwołanie do buforu zapasowego, gdy bufor przedni jest niedostępny i nic nie jest stawia. Po ponownym udostępnieniu buforu przedniego system renderowania zgłasza zdarzenie, <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> aby powiadomić aplikację WPF.  Można utworzyć procedurę obsługi zdarzeń w celu ponownego <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> uruchomienia renderowania dla zdarzenia z prawidłową powierzchnią Direct3D. Aby ponownie uruchomić Render, należy wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodę.  
  
 W przypadku wywołania <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> `enableSoftwareFallback` z parametrem ustawionym `true`na, system renderowania zachowuje odwołanie do buforu zapasowego, gdy bufor przedni jest niedostępny, więc nie ma potrzeby wywoływania <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> , gdy bufor przedni jest ponownie dostępne.  Mogą wystąpić sytuacje, w których urządzenie użytkownika staną się niedostępne.  Gdy to nastąpi <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> , wywołaj odwołanie do wersji WPF do buforu zapasowego.  Jeśli musisz zresetować <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> urządzenie, wywołaj polecenie z `backBuffer` ustawionym na `null`, a następnie Wywołaj <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> ponownie `backBuffer` z ustawioną prawidłową powierzchnią Direct3D.  
  
 Na poniższej liście przedstawiono wymagane ustawienia buforu wstecznego dla tego `IDirect3DSurface9` typu.  
  
-   `D3DFMT_A8R8G8B8` lub `D3DFMT_X8R8G8B8`  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 Wielokrotne próbkowanie jest `IDirect3DSurface9Ex` dozwolone tylko na powierzchniach.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberSignature Language="F#" Value="member this.TryLock : System.Windows.Duration -&gt; bool" Usage="d3DImage.TryLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout">Czas oczekiwania na pozyskanie blokady.</param>
        <summary>Próbuje zablokować <see cref="T:System.Windows.Interop.D3DImage" /> i czekać przez określony czas.</summary>
        <returns><see langword="true" />Jeśli blokada została pobrana; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest ustawiony na <see cref="P:System.Windows.Duration.Automatic" />.</exception>
        <exception cref="T:System.InvalidOperationException">Liczba blokad równa <see cref="F:System.UInt32.MaxValue" />się.</exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberSignature Language="F#" Value="member this.Unlock : unit -&gt; unit" Usage="d3DImage.Unlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę blokad dla <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy liczba blokad dla <xref:System.Windows.Interop.D3DImage> osiągnie wartość zero <xref:System.Windows.Interop.D3DImage> , jest całkowicie odblokowany. Jest <xref:System.Windows.Interop.D3DImage> oznaczona do renderowania, jeśli obraz zmienił obszary, które zostały określone przez poprzednie wywołania <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> metody.  
  
 Gdy zmiany zostaną zatwierdzone i wyrenderowanie, dodatkowe wywołania do <xref:System.Windows.Interop.D3DImage.Lock%2A> bloku metody do momentu, gdy wątek renderowania skopiował zawartość buforu zapasowego do buforu z przodu. Ta synchronizacja pozwala uniknąć wyświetlania artefaktów, takich jak rozerwanie.  
  
> [!NOTE]
>  Nie Aktualizuj powierzchni Direct3D podczas gdy <xref:System.Windows.Interop.D3DImage> jest odblokowany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wywołać metodę, <xref:System.Windows.Interop.D3DImage.Unlock%2A> aby skopiować zaktualizowany bufor do buforu z przodu. Aby uzyskać więcej informacji, [zobacz Przewodnik: Hostowanie zawartości Direct3D9 w](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public override sealed double Width { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Width" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Width : double" Usage="System.Windows.Interop.D3DImage.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szerokość <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <value>Szerokość <see cref="T:System.Windows.Interop.D3DImage" />w jednostkach miary. Jednostka miary to 1/1/96 cala.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Interop.D3DImage.Width%2A> może ulec zmianie, gdy nowy bufor zapasowy jest przypisywany przez wywołanie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
  </Members>
</Type>

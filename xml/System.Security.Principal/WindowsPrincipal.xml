<Type Name="WindowsPrincipal" FullName="System.Security.Principal.WindowsPrincipal">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="557e738279013f54ed693289355a9cba4b121a55" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30570898" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WindowsPrincipal : System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WindowsPrincipal extends System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="DocId" Value="T:System.Security.Principal.WindowsPrincipal" />
  <TypeSignature Language="VB.NET" Value="Public Class WindowsPrincipal&#xA;Inherits ClaimsPrincipal" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsPrincipal : System::Security::Claims::ClaimsPrincipal" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Principal.Windows</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Claims.ClaimsPrincipal</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia kod, aby sprawdzić członkostwa w grupie systemu Windows użytkownika systemu Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Principal.WindowsPrincipal> Klasy głównie służy do sprawdzania ról użytkownika systemu Windows. <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> Przeciążenia metody umożliwiają sprawdzanie roli użytkownika przy użyciu różnych kontekstach.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> przeciążenia metody. <xref:System.Security.Principal.WindowsBuiltInRole> Wyliczenie jest używany jako źródło dla identyfikatorów względnych (RID), które identyfikują wbudowane role. Identyfikatorów RID są używane do określania role bieżący podmiot zabezpieczeń.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsPrincipal (System.Security.Principal.WindowsIdentity ntIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.WindowsIdentity ntIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.#ctor(System.Security.Principal.WindowsIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ntIdentity As WindowsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsPrincipal(System::Security::Principal::WindowsIdentity ^ ntIdentity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ntIdentity" Type="System.Security.Principal.WindowsIdentity" />
      </Parameters>
      <Docs>
        <param name="ntIdentity">Obiekt, z którego można utworzyć nowe wystąpienie klasy <see cref="T:System.Security.Principal.WindowsPrincipal" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Principal.WindowsPrincipal" /> przy użyciu określonego <see cref="T:System.Security.Principal.WindowsIdentity" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Security.Principal.WindowsPrincipal> obiektu z bieżącego <xref:System.Security.Principal.WindowsIdentity> obiektu.  
  
 [!code-cpp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ntIdentity" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeviceClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; DeviceClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; DeviceClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeviceClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ DeviceClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__13))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie oświadczenia urządzeń z systemem Windows z tego podmiotu zabezpieczeń.</summary>
        <value>Kolekcja wszystkich oświadczeń urządzenia z systemem Windows z tego podmiotu zabezpieczeń.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public override System.Security.Principal.IIdentity Identity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity Identity" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Identity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ Identity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tożsamość bieżący podmiot zabezpieczeń.</summary>
        <value>
          <see cref="T:System.Security.Principal.WindowsIdentity" /> Obiektu bieżący podmiot zabezpieczeń.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera nazwę użytkownika przy użyciu <xref:System.Security.Principal.WindowsPrincipal.Identity%2A> właściwość <xref:System.Security.Principal.WindowsPrincipal> obiektu.  
  
 [!code-cpp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsInRole">
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy bieżący podmiot zabezpieczeń należy do określonej grupy użytkowników systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieją cztery przeciążenia dla tej metody. Ze względu na wydajność <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> zdecydowanie zalecane jest użycie przeładowania.  
  
> [!IMPORTANT]
>  <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> Metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (int rid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(int32 rid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (rid As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(int rid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rid" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rid">Identyfikator RID grupy użytkowników systemu Windows, w którym można sprawdzić stan członkostwa podmiotu.</param>
        <summary>Określa, czy bieżący podmiot zabezpieczeń należy do grupy użytkowników systemu Windows z określonego identyfikatora względnego (RID).</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący podmiot zabezpieczeń jest członkiem określonej grupy użytkowników systemu Windows, czyli w określonej roli; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas testowania dla nowo utworzona rola informacje, takie jak nowego użytkownika lub nowej grupy, należy się wylogować i zalogować się do wymusić propagacji informacje o rolach w ramach domeny. Nie może to spowodować <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test, aby zwrócić `false`. Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.  
  
 Ze względu na wydajność <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> zalecane jest użycie przeładowania jako preferowane przeciążenia określania roli użytkownika.  
  
> [!NOTE]
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Podczas próby wykonania zadania, która wymaga uprawnień administracyjnych, można ustawić za pomocą okna dialogowego zgody dynamicznie roli użytkownika. Kod, który wykonuje <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> — metoda nie wyświetla okno dialogowe zgody. Kod zwraca wartość false, jeśli są w roli użytkownika standardowego, nawet jeśli znajdują się w grupie Administratorzy wbudowanych. Twoje uprawnienia można ustawić przed wykonaniem kodu przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 Identyfikatorów względnych (RID) są składniki identyfikator zabezpieczeń grupy użytkowników systemu Windows (SID) i są obsługiwane w celu zapobiegania lokalizacji i platform. Wiele kont użytkowników, grup lokalnych i globalnych grup ma wartość domyślną identyfikatorów RID, który jest stały we wszystkich wersjach systemu Windows.  
  
 Na przykład identyfikatorów RID dla roli BUILTIN\Administratorzy jest 0x220. Przy użyciu 0x220 jako parametru wejściowego dla <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> wynikiem metody `true` jest zwracany, jeśli bieżący podmiot zabezpieczeń jest administratorem.  
  
 W poniższych tabelach przedstawiono wartości domyślne identyfikatorów RID.  
  
|Wbudowane użytkowników|IDENTYFIKATOR RID|  
|---------------------|---------|  
|DOMAINNAME\Administrator|0x1F4|  
|DOMAINNAME\Guest|0x1F5|  
  
|Wbudowane grupy globalne|IDENTYFIKATOR RID|  
|-----------------------------|---------|  
|Administratorzy DOMAINNAME\Domain|0x200|  
|Użytkownicy DOMAINNAME\Domain|0x201|  
|Goście DOMAINNAME\Domain|0x202|  
  
|Wbudowane grupy lokalne|IDENTYFIKATOR RID|  
|----------------------------|---------|  
|BUILTIN\Administratorzy|0x220|  
|BUILTIN\Użytkownicy|0x221|  
|BUILTIN\Guests|0x222|  
|Operatory wbudowanego operatora\operatora konta|0x224|  
|Operatory BUILTIN\Server|0x225|  
|Operatory BUILTIN\Print|0x226|  
|Operatory BUILTIN\Backup|0x227|  
|BUILTIN\Replicator|0x228|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metody. <xref:System.Security.Principal.WindowsBuiltInRole> Wyliczenie jest używany jako źródło dla identyfikatorów RID, które identyfikują wbudowane role. Identyfikatorów RID są używane do określania role bieżący podmiot zabezpieczeń.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.SecurityIdentifier sid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(class System.Security.Principal.SecurityIdentifier sid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.SecurityIdentifier)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (sid As SecurityIdentifier) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::SecurityIdentifier ^ sid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sid" Type="System.Security.Principal.SecurityIdentifier" />
      </Parameters>
      <Docs>
        <param name="sid">A <see cref="T:System.Security.Principal.SecurityIdentifier" /> który unikatowo identyfikuje grupę użytkowników systemu Windows.</param>
        <summary>Określa, czy bieżący podmiot zabezpieczeń należy do grupy użytkowników systemu Windows z identyfikatorem określonym zabezpieczeń (SID).</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący podmiot zabezpieczeń jest członkiem określonej grupy użytkowników systemu Windows; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Principal.SecurityIdentifier> Unikatowo identyfikuje użytkownika lub grupy w implementacjach systemu Windows 2000, Windows Server i Windows XP. Podczas testowania dla nowo utworzona rola informacje, takie jak nowego użytkownika lub nowej grupy, należy się wylogować i zalogować się do wymusić propagacji informacje o rolach w ramach domeny. Nie może to spowodować <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test, aby zwrócić `false`. Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.  
  
> [!NOTE]
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Podczas próby wykonania zadania, która wymaga uprawnień administracyjnych, można ustawić za pomocą okna dialogowego zgody dynamicznie roli użytkownika. Kod, który wykonuje <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> — metoda nie wyświetla okno dialogowe zgody. Kod zwraca wartość false, jeśli są w roli użytkownika standardowego, nawet jeśli znajdują się w grupie Administratorzy wbudowanych. Twoje uprawnienia można ustawić przed wykonaniem kodu przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 Ze względu na wydajność jest to preferowane przeciążenia, aby określić rolę użytkownika.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29?displayProperty=nameWithType> metody. <xref:System.Security.Principal.WellKnownSidType.BuiltinAdministratorsSid> Wartość wyliczenia służy do określenia, czy bieżący podmiot zabezpieczeń jest administratorem. Na przykład pełny kod, zobacz <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#5)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sid" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">System Windows zwrócił błąd Win32.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.WindowsBuiltInRole role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(valuetype System.Security.Principal.WindowsBuiltInRole role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.WindowsBuiltInRole)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (role As WindowsBuiltInRole) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::WindowsBuiltInRole role);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.Security.Principal.WindowsBuiltInRole" />
      </Parameters>
      <Docs>
        <param name="role">Jeden z <see cref="T:System.Security.Principal.WindowsBuiltInRole" /> wartości.</param>
        <summary>Określa, czy bieżący podmiot zabezpieczeń należy do grupy użytkowników systemu Windows z określonym <see cref="T:System.Security.Principal.WindowsBuiltInRole" />.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący podmiot zabezpieczeń jest członkiem określonej grupy użytkowników systemu Windows; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas testowania dla nowo utworzona rola informacje, takie jak nowego użytkownika lub nowej grupy, należy się wylogować i zalogować się do wymusić propagacji informacje o rolach w ramach domeny. Nie może to spowodować <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test, aby zwrócić `false`. Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.  
  
 Ze względu na wydajność <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> zalecane jest użycie przeładowania jako preferowane przeciążenia określania roli użytkownika.  
  
> [!NOTE]
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Podczas próby wykonania zadania, która wymaga uprawnień administracyjnych, można ustawić za pomocą okna dialogowego zgody dynamicznie roli użytkownika. Kod, który wykonuje <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> — metoda nie wyświetla okno dialogowe zgody. Kod zwraca wartość false, jeśli są w roli użytkownika standardowego, nawet jeśli znajdują się w grupie Administratorzy wbudowanych. Twoje uprawnienia można ustawić przed wykonaniem kodu przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Security.Principal.WindowsBuiltInRole> wyliczenie jest używana do określenia, czy bieżący podmiot zabezpieczeń jest <xref:System.Security.Principal.WindowsBuiltInRole.Administrator>. Na przykład pełny kod, zobacz <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#4)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="role" /> nie jest prawidłową <see cref="T:System.Security.Principal.WindowsBuiltInRole" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public override bool IsInRole (string role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsInRole(string role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsInRole (role As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsInRole(System::String ^ role);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="role">Nazwa grupy użytkowników systemu Windows, do których chcesz sprawdzić członkostwa.</param>
        <summary>Określa, czy bieżący podmiot zabezpieczeń należy do grupy użytkowników systemu Windows przy użyciu określonej nazwy.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący podmiot zabezpieczeń jest członkiem określonej grupy użytkowników systemu Windows; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas testowania dla nowo utworzona rola informacje, takie jak nowego użytkownika lub nowej grupy, należy się wylogować i zalogować się do wymusić propagacji informacje o rolach w ramach domeny. Nie może to spowodować <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test, aby zwrócić `false`. Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.  
  
 Ze względu na wydajność <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> zalecane jest użycie przeładowania jako preferowane przeciążenia określania roli użytkownika.  
  
> [!NOTE]
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Podczas próby wykonania zadania, która wymaga uprawnień administracyjnych, można ustawić za pomocą okna dialogowego zgody dynamicznie roli użytkownika. Kod, który wykonuje <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> — metoda nie wyświetla okno dialogowe zgody. Kod zwraca wartość false, jeśli są w roli użytkownika standardowego, nawet jeśli znajdują się w grupie Administratorzy wbudowanych. Twoje uprawnienia można ustawić przed wykonaniem kodu przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 Dla wbudowanych ról `role` ciągu powinna mieć postać "WBUDOWANE\\*RoleNameHere*". Na przykład aby sprawdzić członkostwa w roli administratora systemu Windows, ciąg reprezentujący rolę powinien być "BUILTIN\Administratorzy". Należy pamiętać, że może należy wstawić ukośnik odwrotny. W poniższej tabeli wymieniono role wbudowane.  
  
> [!NOTE]
>  Pisownię role WBUDOWANE w formacie ciągu różni się od pisowni używane w <xref:System.Security.Principal.WindowsBuiltInRole> wyliczenia. Pisownia administrator w wyliczeniu jest na przykład "Administrator", nie "Administratorzy". Korzystając z tego przeciążenia, należy użyć pisownię roli z poniższej tabeli.  
  
|Wbudowane grupy lokalne|  
|----------------------------|  
|BUILTIN\Administratorzy|  
|BUILTIN\Użytkownicy|  
|BUILTIN\Guests|  
|Operatory wbudowanego operatora\operatora konta|  
|Operatory BUILTIN\Server|  
|Operatory BUILTIN\Print|  
|Operatory BUILTIN\Backup|  
|BUILTIN\Replicator|  
  
 Dla ról komputera `role` ciągu powinna mieć postać "MachineName\\*RoleNameHere*".  
  
 Dla ról specyficznego dla domeny `role` ciągu powinna być w formie "nazwa_domeny\\*RoleNameHere*", na przykład `"SomeDomain\Domain Users`".  
  
> [!NOTE]
>  W programie .NET Framework w wersji 1.0 `role` parametru jest rozróżniana wielkość liter. W programie .NET Framework w wersji 1.1 lub nowszej `role` parametr jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> metody.  
  
 Ciągi `BUILTIN\Administrators` i `BUILTIN\Users` są używane do ustalenia, czy bieżący podmiot zabezpieczeń administratora lub użytkownika. Na przykład pełny kod, zobacz <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#3)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość manipulowania obiekt główny. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
        <altmember cref="T:System.Security.Principal.WindowsBuiltInRole" />
      </Docs>
    </Member>
    <Member MemberName="UserClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; UserClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; UserClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UserClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ UserClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__11))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie oświadczenia użytkownika systemu Windows z tego podmiotu zabezpieczeń.</summary>
        <value>Kolekcja wszystkich oświadczeń użytkownika systemu Windows z tego podmiotu zabezpieczeń.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
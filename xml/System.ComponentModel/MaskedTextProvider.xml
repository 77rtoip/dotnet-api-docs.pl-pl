<Type Name="MaskedTextProvider" FullName="System.ComponentModel.MaskedTextProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="08e04e06dcec92c59b9060542e5a7a8b7c355107" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37691558" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MaskedTextProvider : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MaskedTextProvider extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.MaskedTextProvider" />
  <TypeSignature Language="VB.NET" Value="Public Class MaskedTextProvider&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MaskedTextProvider : ICloneable" />
  <TypeSignature Language="F#" Value="type MaskedTextProvider = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje mogą być używane przez dowolną liczbę elementów sterujących, które obsługują maskowanie, takich jak usługa analizy maski <see cref="T:System.Windows.Forms.MaskedTextBox" /> kontroli.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MaskedTextBox> Maskę składa się ze znaków literałowych i formatowanie elementów, które sprawdza wszystkie dane wejściowe użytkownika przed zawiera formant. Zamiast trwale skojarzyć z konkretnego aparatu analizy maski przy użyciu <xref:System.Windows.Forms.MaskedTextBox>, Windows Forms zapewnia go jako osobną usługę, reprezentowane przez <xref:System.ComponentModel.MaskedTextProvider> klasy, która definiuje składni języka maskowania omówione w dokumentacji <xref:System.Windows.Forms.MaskedTextBox.Mask%2A> właściwości.  
  
 Wiele elementów członkowskich <xref:System.Windows.Forms.MaskedTextBox> klasy można znaleźć ich implementacji członków o podobnej nazwie skojarzonego <xref:System.ComponentModel.MaskedTextProvider>. Na przykład <xref:System.Windows.Forms.MaskedTextBox.PromptChar%2A?displayProperty=nameWithType> właściwość <xref:System.Windows.Forms.MaskedTextBox> klasy odwołuje się dostęp do wszystkich <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> z <xref:System.ComponentModel.MaskedTextProvider> klasy.  
  
 Aparat analizy maska posługują się <xref:System.ComponentModel.MaskedTextProvider> jest modelowane maskowana kontrolka edycji zawarte w programie Microsoft Visual Basic version 6. Opisano w dokumentacji dotyczącej języka maskowania <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwości.  
  
 Następujące trzy różne ciągi są związane z <xref:System.ComponentModel.MaskedTextProvider> klasy.  
  
|Nazwa ciągu|Opis|  
|-----------------|-----------------|  
|Znak wejściowy lub ciągu|Reprezentuje znaków używany jako dane wejściowe, że maska jest stosowany. W rzeczywistości ciągu wejściowego może się składać z wielu danych wejściowych operacji, w tym <xref:System.ComponentModel.MaskedTextProvider.Add%2A>, <xref:System.ComponentModel.MaskedTextProvider.Replace%2A>, <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A>, i <xref:System.ComponentModel.MaskedTextProvider.Remove%2A>. W związku z tym ciąg wejściowy nie jest bezpośrednio dostępny. Aspektów Obsługa ciąg wejściowy są jednak dostępne jednak <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> i <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>, <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>, i <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> właściwości.|  
|Maska|Reprezentuje dane wejściowe maska używana do przekształcania danych wejściowych ciąg sformatowany ciąg formatowania. Ten ciąg jest ustawiana w <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> i dostępne przede wszystkim, mimo że <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwości. Właściwości maski dostępne są także inne elementy członkowskie, takie jak <xref:System.ComponentModel.MaskedTextProvider.Length%2A>, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>, i <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> właściwości.|  
|Sformatowany ciąg|Określa ciąg, który występuje, gdy pełna jest stosowana do ciągu wejściowego. Sformatowany ciąg może być odpytywany za pomocą wiele elementów członkowskich klasy, łącznie z <xref:System.ComponentModel.MaskedTextProvider.Item%2A>, <xref:System.ComponentModel.MaskedTextProvider.Length%2A>, <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>, <xref:System.ComponentModel.MaskedTextProvider.MaskFull%2A>, <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A>, <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A>i tak dalej. Pełna wartość sformatowanego ciągu jest dostępna z <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody.|  
  
> [!NOTE]
>  Ciąg wejściowy może reprezentować danych wejściowych użytkownika bezpośrednie, tak jak w przypadku <xref:System.Windows.Forms.MaskedTextBox>, lub mogą być generowane przez inne procesy, które nie są bezpośrednio związane z operacji wejścia/wyjścia użytkownika.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MaskedTextBox" />
    <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskedTextProvider" />
    <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider mask" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określonej maski.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystanie z tego konstruktora jest równoznaczny z następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , null, true, '_', '\0', false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="restrictToAscii">
          <see langword="true" /> Aby ograniczyć dane wejściowe do znaków ASCII zgodnego. w przeciwnym razie <see langword="false" /> Aby zezwolić na cały zestaw Unicode.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy przy użyciu określonej maski i wartość ograniczenia ASCII.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystanie z tego konstruktora jest równoznaczny z następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , null, true, '_', '\0', restrictToASCII)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="culture">Element <see cref="T:System.Globalization.CultureInfo" /> używany do zestawu znaków separatora zależne od regionu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określonej maski i kultury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystanie z tego konstruktora jest równoznaczny z następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , culture, true, '_', '\0', false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, char passwordChar, bool allowPromptAsInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, passwordChar As Char, allowPromptAsInput As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, passwordChar, allowPromptAsInput)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="passwordChar">A <see cref="T:System.Char" /> , będzie on wyświetlany dla znaków wprowadzonych w ciąg hasła.</param>
        <param name="allowPromptAsInput">
          <see langword="true" /> Aby umożliwić monitu znak jako dane wejściowe w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określonej maski znaków hasła i wartość opcji użycie monitu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystanie z tego konstruktora jest równoznaczny z następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , null, allowPromptAsInput, '_', passwordChar, false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="culture">Element <see cref="T:System.Globalization.CultureInfo" /> używany do zestawu znaków separatora zależne od regionu.</param>
        <param name="restrictToAscii">
          <see langword="true" /> Aby ograniczyć dane wejściowe do znaków ASCII zgodnego. w przeciwnym razie <see langword="false" /> Aby zezwolić na cały zestaw Unicode.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określonej maski, kultury i wartość ograniczenia ASCII.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystanie z tego konstruktora jest równoznaczny z następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , culture, true, '_', '\0', restrictToAscii)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, char passwordChar, bool allowPromptAsInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, passwordChar As Char, allowPromptAsInput As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, passwordChar, allowPromptAsInput)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="culture">Element <see cref="T:System.Globalization.CultureInfo" /> używany do zestawu znaków separatora zależne od regionu.</param>
        <param name="passwordChar">A <see cref="T:System.Char" /> , będzie on wyświetlany dla znaków wprowadzonych w ciąg hasła.</param>
        <param name="allowPromptAsInput">
          <see langword="true" /> Aby umożliwić monitu znak jako dane wejściowe w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określonej maski, kultury, znaku hasła i wartość opcji użycie monitu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystanie z tego konstruktora jest równoznaczny z następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , culture, allowPromptAsInput, '_', passwordChar, false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean,System.Char,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, allowPromptAsInput As Boolean, promptChar As Char, passwordChar As Char, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * bool * char * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, allowPromptAsInput, promptChar, passwordChar, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
        <Parameter Name="promptChar" Type="System.Char" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="culture">Element <see cref="T:System.Globalization.CultureInfo" /> używany do zestawu znaków separatora zależne od regionu.</param>
        <param name="allowPromptAsInput">A <see cref="T:System.Boolean" /> wartość, która określa, czy znak monitu powinien być dozwolony jako prawidłowy znak danych wejściowych.</param>
        <param name="promptChar">A <see cref="T:System.Char" /> , będą wyświetlane jako symbol zastępczy dla danych wejściowych użytkownika.</param>
        <param name="passwordChar">A <see cref="T:System.Char" /> , będzie on wyświetlany dla znaków wprowadzonych w ciąg hasła.</param>
        <param name="restrictToAscii">
          <see langword="true" /> Aby ograniczyć dane wejściowe do znaków ASCII zgodnego. w przeciwnym razie <see langword="false" /> Aby zezwolić na cały zestaw Unicode.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określonej maski, kultury, wartość prompt użycia znaku zgłoszenia, znaku hasła i wartość ograniczenia ASCII.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor reprezentuje najbardziej powszechną formą przeciążona. `mask` Parametr musi być zgodny z językiem maskowania zdefiniowane przez <xref:System.ComponentModel.MaskedTextProvider> klasy, która została szczegółowo opisana w <xref:System.Windows.Forms.MaskedTextBox.Mask%2A?displayProperty=nameWithType> właściwość <xref:System.Windows.Forms.MaskedTextBox> klasy.  
  
 Ponieważ nie można zbadać kultury neutralnej, aby uzyskać informacje specyficzne dla kultury, <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> użyje Konstruktor <xref:System.Globalization.CultureInfo.GetCultures%2A> metodę wyszukiwania dla pierwszego kultury bez neutral służące do określenia odpowiednie separatory.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr maski jest <see langword="null" /> lub <see cref="F:System.String.Empty" />.  - lub - maska zawiera co najmniej jeden niedrukowalne znaki.</exception>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clone" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje do sformatowany ciąg wejściowy znak lub ciąg wejściowy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (char input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(char input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(char input);" />
      <MemberSignature Language="F#" Value="member this.Add : char -&gt; bool" Usage="maskedTextProvider.Add input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="input">A <see cref="T:System.Char" /> wartość do dołączenia do sformatowanego ciągu.</param>
        <summary>Dodaje określony znak danych wejściowych do końca sformatowany ciąg.</summary>
        <returns>
          <see langword="true" /> Jeśli znak wejściowy został dodany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%29> Metoda dodaje `input` znak wartości do pierwszej pozycji dostępnych w sformatowanym ciągu po ostatniej została przypisana, która jest reprezentowana przez pozycji <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> właściwości. Ta metoda zakończy się niepowodzeniem dla każdego z następujących powodów:  
  
-   Wartość wejściowa `input`, nie jest druku, lub nie jest zgodny odpowiadającego mu elementu maski.  
  
-   Zero pozycji Edytuj dostępne w sformatowanym ciągu lub, brak żadnych pozycji Edytuj dostępne po ostatniej pozycji.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Add : string -&gt; bool" Usage="maskedTextProvider.Add input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A <see cref="T:System.String" /> zawierające wartości znaków do dołączenia do sformatowanego ciągu.</param>
        <summary>Dodaje znaki do określonego ciągu wejściowego na końcu sformatowany ciąg.</summary>
        <returns>
          <see langword="true" /> w przypadku wszystkich znaków z ciągu wejściowego zostały dodane pomyślnie; w przeciwnym razie <see langword="false" /> do wskazania, że żadne znaki nie zostały dodane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%29> Metoda dodaje znaki z `input` ciąg sformatowany ciąg, rozpoczynając od pierwszego pozycji dostępne po <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>. Ta metoda zakończy się niepowodzeniem dla każdego z następujących powodów:  
  
-   Znaków w wartości wejściowej `input`, czy nie drukowalnych lub wartość wejściowa jest niezgodna odpowiadającego mu elementu maski.  
  
-   Brak wystarczającej liczby stanowisk edycji dostępna w sformatowanym ciągu po ostatniej pozycji.  
  
 Jeśli ta metoda nie powiedzie się, nie dodawane są, a metoda zwraca `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (char input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(char input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.Char,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As Char, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(char input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Add : char *  *  -&gt; bool" Usage="maskedTextProvider.Add (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">A <see cref="T:System.Char" /> wartość do dołączenia do sformatowanego ciągu.</param>
        <param name="testPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie próbowano dodać znak. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Dodaje określony znak danych wejściowych do końca sformatowany ciąg, a następnie generuje pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli znak wejściowy został dodany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metoda próbuje dodać `input` znak wartości do pierwszej pozycji dostępnych w sformatowanym ciągu po ostatniej została przypisana, która jest reprezentowana przez pozycji <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> właściwości. Ta metoda zakończy się niepowodzeniem, jeśli wszystkie dostępne stanowiska przed ostatnia pozycja przypisane. Ta metoda zakończy się niepowodzeniem dla każdego z następujących powodów:  
  
-   Wartość wejściowa `input`, nie jest druku, lub nie jest zgodny odpowiadającego mu elementu maski.  
  
-   Zero pozycji Edytuj dostępne w sformatowanym ciągu lub, brak żadnych pozycji Edytuj dostępne po ostatniej pozycji.  
  
 Ta metoda działa tak samo, co wersja zgodnym z przesłoniętą wykonanie jednej <xref:System.Char> parametru <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%29>, z tą różnicą, że Wyświetla dodatkowe informacje.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Add : string *  *  -&gt; bool" Usage="maskedTextProvider.Add (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">A <see cref="T:System.String" /> zawierające wartości znaków do dołączenia do sformatowanego ciągu.</param>
        <param name="testPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie próbowano dodać znak. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Dodaje znaki w określonym ciągu wejściowego na końcu sformatowany ciąg, a następnie generuje pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> w przypadku wszystkich znaków z ciągu wejściowego zostały dodane pomyślnie; w przeciwnym razie <see langword="false" /> do wskazania, że żadne znaki nie zostały dodane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metoda dodaje znaki z `input` ciąg sformatowany ciąg, rozpoczynając od pierwszego pozycji dostępne po <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>. Ta metoda zakończy się niepowodzeniem dla każdego z następujących powodów:  
  
-   Znaków w wartości wejściowej `input`, czy nie drukowalnych lub wartość wejściowa jest niezgodna odpowiadającego mu elementu maski.  
  
-   Brak wystarczającej liczby stanowisk edycji dostępna w sformatowanym ciągu po ostatniej pozycji.  
  
 Jeśli ta metoda nie powiedzie się, nie dodawane są, a metoda zwraca `false`.  
  
 Ta metoda działa tak samo, co wersja zgodnym z przesłoniętą wykonanie jednej <xref:System.String> parametru <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%29>, z tą różnicą, że Wyświetla dodatkowe informacje.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="AllowPromptAsInput">
      <MemberSignature Language="C#" Value="public bool AllowPromptAsInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPromptAsInput" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowPromptAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPromptAsInput { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowPromptAsInput : bool" Usage="System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy znak monitu powinny być traktowane jako prawidłowy znak danych wejściowych, czy nie.</summary>
        <value>
          <see langword="true" /> Jeśli użytkownik może wprowadzić <see cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" /> do formantu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> Wartość właściwości jest ustawiana w <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> konstruktora.  
  
 Nawet wtedy, gdy <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> jest `true`, Monituj znak muszą być prawidłowe dla bieżącej lokalizacji w masce w celu zaakceptowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="AsciiOnly">
      <MemberSignature Language="C#" Value="public bool AsciiOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsciiOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsciiOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsciiOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AsciiOnly : bool" Usage="System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy maska akceptuje znaki spoza zestawu znaków ASCII.</summary>
        <value>
          <see langword="true" /> Jeśli tylko są akceptowane ASCII; <see langword="false" /> Jeśli <see cref="T:System.ComponentModel.MaskedTextProvider" /> może akceptować dowolny dowolny znak Unicode. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A> Wartość właściwości jest ustawiana w <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> konstruktora.  
  
 Jeśli `true`, <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A> ogranicza dane wejściowe użytkownika do zestawu znaków ASCII.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.AsciiOnly" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="AssignedEditPositionCount">
      <MemberSignature Language="C#" Value="public int AssignedEditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AssignedEditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AssignedEditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AssignedEditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AssignedEditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę pozycji znaku można edytować, które już zostały pomyślnie przypisane wartości wejściowej.</summary>
        <value>
          <see cref="T:System.Int32" /> Zawierającą liczbę pozycji znaku można edytować maski wprowadzania, które zostały już przypisane wartość znaku w ciągu w formacie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Całkowita liczba pozycji znaku można edytować, reprezentowane przez <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> właściwość powinna być równa sumie <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> i <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="AvailableEditPositionCount">
      <MemberSignature Language="C#" Value="public int AvailableEditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AvailableEditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableEditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AvailableEditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableEditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę pozycji znaku można edytować maski wprowadzania, które nie mają jeszcze przypisanej wartości wejściowej.</summary>
        <value>
          <see cref="T:System.Int32" /> Umieszcza zawierającą liczbę znaków można edytować, który jeszcze nie zostanie przypisana wartość znaku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Całkowita liczba pozycji znaku można edytować, reprezentowane przez <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> właściwość powinna być równa sumie <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> i <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Clear">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści wprowadzonych znaków z ciągu sformatowana.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="maskedTextProvider.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie znaki wejściowe można edytować od sformatowany ciąg, zastępując znaki monitu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Clear> Metoda zainicjowaniu sformatowany ciąg, Wstawianie znaku zgłoszenia do wszystkich pozycji można edytować.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear (out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear([out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clear(System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear (ByRef resultHint As MaskedTextResultHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear([Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Clear :  -&gt; unit" Usage="maskedTextProvider.Clear resultHint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Czyści wszystkie znaki wejściowe można edytować od sformatowany ciąg, zastępując znaki monitu, a następnie generuje informacje opisowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Clear%28System.ComponentModel.MaskedTextResultHint%40%29> Metoda zainicjowaniu sformatowany ciąg, Wstawianie znaku zgłoszenia do wszystkich pozycji można edytować. Działa ona ekwiwalentnie do przesłoniętej wersji, która nie przyjmuje żadnych parametrów <xref:System.ComponentModel.MaskedTextProvider.Clear>, z wyjątkiem Wyświetla dodatkowe informacje.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="maskedTextProvider.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię bieżącego <see cref="T:System.ComponentModel.MaskedTextProvider" />.</summary>
        <returns>
          <see cref="T:System.ComponentModel.MaskedTextProvider" /> Obiektu ta metoda tworzy, rzutowany jako obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Clone%2A> Metoda zwraca nową kopię bieżącego <xref:System.ComponentModel.MaskedTextProvider>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.#ctor" />
        <altmember cref="T:System.ICloneable" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Culture" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo" Usage="System.ComponentModel.MaskedTextProvider.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kultury określająca wartość Lokalizowalny separatory i symbole zastępcze w wywołaniach maska wprowadzania.</summary>
        <value>A <see cref="T:System.Globalization.CultureInfo" /> zawierające skojarzone z maska wprowadzania informacji o kulturze.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Culture%2A> Właściwość jest ustawiona <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> konstruktora.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPasswordChar">
      <MemberSignature Language="C#" Value="public static char DefaultPasswordChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char DefaultPasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultPasswordChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property char DefaultPasswordChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPasswordChar : char" Usage="System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślne hasło znak używany zasłoniętej dane wejściowe użytkownika.</summary>
        <value>A <see cref="T:System.Char" /> reprezentujący domyślny znak hasła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar%2A> Właściwość jest zdefiniowana w <xref:System.ComponentModel.MaskedTextProvider> klasa może być znak gwiazdki (*).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.UseSystemPasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
      </Docs>
    </Member>
    <Member MemberName="EditPositionCount">
      <MemberSignature Language="C#" Value="public int EditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.EditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę stanowisk można edytować w sformatowanym ciągu.</summary>
        <value>
          <see cref="T:System.Int32" /> Zawierającą liczbę stanowisk można edytować w sformatowanym ciągu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Całkowita liczba pozycji znaku można edytować, reprezentowane przez <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> właściwości musi być równa sumie <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> i <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> właściwości. Ta wartość obejmuje wymaganych i opcjonalnych można edytować znaków.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="EditPositions">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator EditPositions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator EditPositions" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EditPositions As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerator ^ EditPositions { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EditPositions : System.Collections.IEnumerator" Usage="System.ComponentModel.MaskedTextProvider.EditPositions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nowo utworzony moduł wyliczający dla edytowalnego pozycji w sformatowanym ciągu.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" /> Obsługujący wyliczenie za pośrednictwem można edytować pozycje w sformatowanym ciągu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na każdy dostęp <xref:System.ComponentModel.MaskedTextProvider.EditPositions%2A> właściwości kolekcji tymczasowej, można edytować pozycji zostanie utworzony pobrany <xref:System.Collections.IEnumerator> działa.  
  
 Ta kolekcja jest tylko do odczytu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindAssignedEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindAssignedEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindAssignedEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAssignedEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindAssignedEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindAssignedEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindAssignedEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w sformatowanym ciągu, aby rozpocząć wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pozycję pierwszego przypisane pozycji można edytować po określonej pozycji za pomocą kierunek wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczona od zera pozycja pierwszego przypisane można edytować pozycji napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sformatowany ciąg składa się z edytowalne znaków i literały skopiowane z maską. Pozycje znaku można edytować będzie albo zajmowany przez znak monitu skopiowane z maski, jeśli są one nieprzypisane lub z prawidłowym znakiem danych wejściowych, jeżeli zostali przypisani dane wejściowe.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom%2A> Metoda jest używana do wyszukiwania pierwszego znaku przypisane po określonym kierunku położenie i wyszukiwania. Wynik następnie można przekazać jako parametru, aby <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania wartości przypisane w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> i <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom%2A> metody to uzupełnienie tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindAssignedEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindAssignedEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindAssignedEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAssignedEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindAssignedEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindAssignedEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindAssignedEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczona od zera pozycja w sformatowanym ciągu, gdzie rozpoczyna się wyszukiwanie.</param>
        <param name="endPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie kończy się wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pozycję pierwszego przypisane edycji pozycję między określonych pozycji za pomocą kierunek wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczona od zera pozycja pierwszego przypisane można edytować pozycji napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sformatowany ciąg składa się z edytowalne znaków i literały skopiowane z maską. Pozycje znaku można edytować będzie albo zajmowany przez znak monitu skopiowane z maski, jeśli są one nieprzypisane lub z prawidłowym znakiem danych wejściowych, jeżeli zostali przypisani dane wejściowe.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange%2A> Metoda jest używana do wyszukiwania pierwszego znaku przypisane między dwoma określonych pozycji, włącznie, za pomocą kierunek wyszukiwania. Wynik następnie można przekazać jako parametru, aby <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania wartości przypisane w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> i <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange%2A> metody to uzupełnienie tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w sformatowanym ciągu, aby rozpocząć wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pozycję pierwszego pozycji można edytować po określonej pozycji za pomocą kierunek wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczony od zera pozycja pierwszego pozycji edytowalne napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A> Metoda jest używana do wyszukiwania dla następnego przypisane lub nieprzypisanych pozycji można edytować w sformatowanym ciągu od określonej pozycji.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> Metodą jest uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczona od zera pozycja w sformatowanym ciągu, gdzie rozpoczyna się wyszukiwanie.</param>
        <param name="endPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie kończy się wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pozycję pierwszego pozycji można edytować określonych pozycji za pomocą kierunek wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczony od zera pozycja pierwszego pozycji edytowalne napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange%2A> Metoda jest używana do wyszukiwania pierwszego znaku można edytować między dwoma określonych pozycji, włącznie, za pomocą kierunek wyszukiwania. Wynik następnie można przekazać jako parametru, aby <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania wartości przypisane w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> Metodą jest uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindNonEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindNonEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindNonEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNonEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindNonEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindNonEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindNonEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w sformatowanym ciągu, aby rozpocząć wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pozycję pierwszego pozycji nie można edytować po określonej pozycji za pomocą kierunek wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczony od zera pozycja pierwszego pozycji literału napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> Metoda jest używana, aby wyszukać następny znak literału w sformatowanym ciągu od określonej pozycji. Wynik następnie można przekazać jako parametru, aby <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania wartości literału w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A> Metodą jest uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindNonEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindNonEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindNonEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNonEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindNonEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindNonEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindNonEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczona od zera pozycja w sformatowanym ciągu, gdzie rozpoczyna się wyszukiwanie.</param>
        <param name="endPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie kończy się wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pozycję pierwszego pozycji nie można edytować określonych pozycji za pomocą kierunek wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczony od zera pozycja pierwszego pozycji literału napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> Metoda jest używana do wyszukiwania pierwszy znak literału między dwoma określonych pozycji, włącznie, za pomocą kierunek wyszukiwania. Wynik następnie można przekazać jako parametru, aby <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania wartości literału w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange%2A> Metodą jest uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindUnassignedEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindUnassignedEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindUnassignedEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindUnassignedEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindUnassignedEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindUnassignedEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindUnassignedEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w sformatowanym ciągu, aby rozpocząć wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pozycję pierwszego pozycji można edytować nieprzypisany po określonej pozycji za pomocą kierunek wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczona od zera pozycja pierwszy nieprzypisanych pozycji można edytować napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sformatowany ciąg składa się z edytowalne znaków i literały skopiowane z maską. Pozycje znaku można edytować będzie albo zajmowany przez znak monitu skopiowane z maski, jeśli są one nieprzypisane lub z prawidłowym znakiem danych wejściowych, jeżeli zostali przypisani dane wejściowe.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom%2A> Metoda jest używana do wyszukiwania pierwszy nieprzypisanych znak po określonym kierunku położenie i wyszukiwania. Monituj znak powinien zajmować tej pozycji.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> i <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom%2A> metody to uzupełnienie tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindUnassignedEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindUnassignedEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindUnassignedEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindUnassignedEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindUnassignedEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindUnassignedEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindUnassignedEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczona od zera pozycja w sformatowanym ciągu, gdzie rozpoczyna się wyszukiwanie.</param>
        <param name="endPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie kończy się wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca położenie pierwszego pozycji można edytować nieprzypisany określonych pozycji za pomocą kierunek wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczona od zera pozycja pierwszy nieprzypisanych pozycji można edytować napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sformatowany ciąg składa się z edytowalne znaków i literały skopiowane z maską. Pozycje znaku można edytować będzie albo zajmowany przez znak monitu skopiowane z maski, jeśli są one nieprzypisane lub z prawidłowym znakiem danych wejściowych, jeżeli zostali przypisani dane wejściowe.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange%2A> Metoda jest używana do wyszukiwania dla pierwszego znaku nieprzypisane między dwoma określonych pozycji, włącznie, za pomocą kierunek wyszukiwania. Monituj znak powinien zajmować tej pozycji.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> i <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange%2A> metody to uzupełnienie tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetOperationResultFromHint">
      <MemberSignature Language="C#" Value="public static bool GetOperationResultFromHint (System.ComponentModel.MaskedTextResultHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetOperationResultFromHint(valuetype System.ComponentModel.MaskedTextResultHint hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint(System.ComponentModel.MaskedTextResultHint)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOperationResultFromHint (hint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetOperationResultFromHint(System::ComponentModel::MaskedTextResultHint hint);" />
      <MemberSignature Language="F#" Value="static member GetOperationResultFromHint : System.ComponentModel.MaskedTextResultHint -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint hint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hint" Type="System.ComponentModel.MaskedTextResultHint" />
      </Parameters>
      <Docs>
        <param name="hint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> wartość zazwyczaj uzyskiwane jako parametr wyjściowy przez poprzednią operację.</param>
        <summary>Określa, czy określony <see cref="T:System.ComponentModel.MaskedTextResultHint" /> oznacza powodzenie lub niepowodzenie.</summary>
        <returns>
          <see langword="true" /> Jeśli określony <see cref="T:System.ComponentModel.MaskedTextResultHint" /> wartość reprezentuje pomyślnie; w przeciwnym razie <see langword="false" /> Jeśli termin reprezentuje awarii.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujące metody <xref:System.ComponentModel.MaskedTextProvider> klasy zawierają parametr typu <xref:System.ComponentModel.MaskedTextResultHint> używany do wypełniania wyjściowego informacje na temat operacji metody: <xref:System.ComponentModel.MaskedTextProvider.Add%2A>, <xref:System.ComponentModel.MaskedTextProvider.Clear%2A>, <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A>, <xref:System.ComponentModel.MaskedTextProvider.Remove%2A>, <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A>, <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> , <xref:System.ComponentModel.MaskedTextProvider.Set%2A>, <xref:System.ComponentModel.MaskedTextProvider.VerifyChar%2A>, i <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A>. <xref:System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint%2A> Metoda interpretuje tej wartości i zwraca wartość logiczną wskazującą, czy <xref:System.ComponentModel.MaskedTextResultHint> zasygnalizują, że operacja zakończyła się powodzenie lub niepowodzenie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.MaskedTextResultHint" />
      </Docs>
    </Member>
    <Member MemberName="IncludeLiterals">
      <MemberSignature Language="C#" Value="public bool IncludeLiterals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeLiterals" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeLiterals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeLiterals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeLiterals : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy znaki literału maski wprowadzania mają być uwzględniane w sformatowanym ciągu.</summary>
        <value>
          <see langword="true" /> Jeśli dołączono literały; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości określi, czy monit i literałów znaków są wyświetlane podczas wywoływania <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody. Przez ustawienie obu tych właściwości, aby `false`, przeanalizowany ciąg będzie reprezentować tylko znaki, które zostały wprowadzone przez użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="IncludePrompt">
      <MemberSignature Language="C#" Value="public bool IncludePrompt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludePrompt" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludePrompt As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludePrompt { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludePrompt : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IncludePrompt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="P:System.Windows.Forms.MaskedTextBox.PromptChar" /> jest używana do reprezentowania braku danych wejściowych podczas wyświetlania sformatowany ciąg użytkownika.</summary>
        <value>
          <see langword="true" /> Jeśli monit znaku jest używana do reprezentowania pozycji, których dane wejściowe użytkownika nie została podana; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości określi, czy monit i literałów znaków są wyświetlane podczas wywoływania <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody. Przez ustawienie obu tych właściwości, aby `false`, przeanalizowany ciąg będzie reprezentować tylko znaki, które zostały wprowadzone przez użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertAt">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia znak lub ciąg na określonej pozycji w ciągu sformatowana.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : char * int -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Do wstawienia.</param>
        <param name="position">Liczony od zera pozycja w sformatowanym ciągu, aby wstawić znak.</param>
        <summary>Wstawia określony znak w określonej pozycji w ciągu sformatowana.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawienie powiodło się; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Metoda Wstawia znak do pierwszej pozycji edycji w lub przekracza określoną przez `pos` parametru. Ta metoda zostanie wprowadzony wszystkie istniejące znaki po punktu wstawiania w tryb failover, aby zwolnić miejsce dla wstawionego o jedną pozycję `input` znaków. Jeśli wystąpi jedno z następujących błędów, wstawiania nie jest wykonywane, i metoda zwraca `false`.  
  
-   `pos` Parametr jest mniejsza od zera lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie można odnaleźć znaku można edytować w sformatowanym ciągu na lub po przekroczeniu określonej pozycji `pos`.  
  
-   Znak wstawiania `input`, nie jest prawidłowym znakiem danych wejściowych, ponieważ nie jest drukowalnym lub jest niezgodna z odpowiadającego mu elementu maski.  
  
-   Tak, aby nie można przesunąć istniejące znaki są nie dostępnych pozycji po prawej stronie od punktu wstawiania.  
  
-   Przesunięcie istniejące znaki dałby w efekcie naruszenie maski.  
  
 Pusta `input` ciągu nie spowoduje zmiany w sformatowanego ciągu, ale zwróci `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (string input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(string input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As String, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(System::String ^ input, int position);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : string * int -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Do wstawienia.</param>
        <param name="position">Liczony od zera pozycja w sformatowanym ciągu do wstawienia do ciągu wejściowego.</param>
        <summary>Wstawia określony ciąg na określonej pozycji w ciągu sformatowana.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawienie powiodło się; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Metoda wstawia każdego znaku z `input` ciągu do pozycji Edytuj znajdujący się w pozycji `pos` i nowszych. Ta metoda zostanie wprowadzony wszystkie istniejące znaki po punkt wstawiania nowego wiersza dla każdego o jedną pozycję wstawieniu znaku. Jeśli wystąpi jedno z następujących błędów odbywa się nie wstawiania i metoda zwraca `false`.  
  
-   `pos` Parametr jest mniejsza od zera lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Znajdują się znaki wystarczająco nieedytowalne w sformatowanym ciągu na lub po przekroczeniu określonej pozycji `pos`, aby wstawić wszystkich znaków z `input` ciągu.  
  
-   Co najmniej jeden znak wstawiania nie są prawidłowy znak wejściowy ponieważ nie są druku, lub nie są zgodne z ich odpowiedni element maski.  
  
-   Brak wystarczającej ilości dostępnej pozycji po prawej stronie od punktu wstawiania tak, aby nie można przesunąć istniejące znaki.  
  
-   Przesunięcie istniejące znaki dałby w efekcie naruszenie maski. Należy pamiętać, że to przesunięcie odbywa się podczas wstawiania każdy pojedynczy znak.  
  
 Pusta `input` ciągu nie spowoduje zmiany w sformatowanego ciągu, ale zwróci `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (char input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(char input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.Char,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As Char, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(char input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : char * int *  *  -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Do wstawienia.</param>
        <param name="position">Liczony od zera pozycja w sformatowanym ciągu, aby wstawić znak.</param>
        <param name="testPosition">Jeśli metoda zakończy się pomyślnie, ostatni pozycji, gdzie został wstawiony znaku; w przeciwnym razie pierwszy pozycji, których wstawienie nie powiodło się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wynik operacji wstawiania. Parametr wyjściowy.</param>
        <summary>Wstawia określony znak w określonej pozycji w ramach sformatowany ciąg, zwracając ostatnia pozycja wstawiania i stanu operacji.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawienie powiodło się; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Metoda Wstawia znak do pierwszej pozycji edycji w lub przekracza określoną przez `pos` parametru. Ta metoda zostanie wprowadzony wszystkie istniejące znaki po punktu wstawiania w tryb failover, aby zwolnić miejsce dla wstawionego o jedną pozycję `input` znaków. Jeśli wystąpi jedno z następujących błędów, wstawiania nie jest wykonywane, i metoda zwraca `false`.  
  
-   `pos` Parametr jest mniejsza od zera lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie można odnaleźć znaku można edytować w sformatowanym ciągu na lub po przekroczeniu określonej pozycji `pos`.  
  
-   Znak wstawiania `input`, nie jest prawidłowym znakiem danych wejściowych, ponieważ nie jest drukowalnym lub jest niezgodna z odpowiadającego mu elementu maski.  
  
-   Tak, aby nie można przesunąć istniejące znaki są nie dostępnych pozycji po prawej stronie od punktu wstawiania.  
  
-   Przesunięcie istniejące znaki dałby w efekcie naruszenie maski.  
  
 Pusta `input` ciągu nie spowoduje zmiany w sformatowanego ciągu, ale zwróci `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (string input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(string input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.String,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As String, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(System::String ^ input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : string * int *  *  -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Do wstawienia.</param>
        <param name="position">Liczony od zera pozycja w sformatowanym ciągu do wstawienia do ciągu wejściowego.</param>
        <param name="testPosition">Jeśli metoda zakończy się pomyślnie, ostatni pozycji, gdzie został wstawiony znaku; w przeciwnym razie pierwszy pozycji, których wstawienie nie powiodło się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wynik operacji wstawiania. Parametr wyjściowy.</param>
        <summary>Wstawia określony ciąg na określonej pozycji w ramach sformatowany ciąg, zwracając ostatnia pozycja wstawiania i stanu operacji.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawienie powiodło się; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Metoda wstawia każdego znaku z `input` ciągu do pozycji Edytuj znajdujący się w pozycji `pos` i nowszych. Ta metoda zostanie wprowadzony wszystkie istniejące znaki po punkt wstawiania nowego wiersza dla każdego o jedną pozycję wstawieniu znaku. Jeśli wystąpi jedno z następujących błędów odbywa się nie wstawiania i metoda zwraca `false`.  
  
-   `pos` Parametr jest mniejsza od zera lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Znajdują się znaki wystarczająco nieedytowalne w sformatowanym ciągu na lub po przekroczeniu określonej pozycji `pos`, aby wstawić wszystkich znaków z `input` ciągu.  
  
-   Co najmniej jeden znak wstawiania nie są prawidłowy znak wejściowy ponieważ nie są druku, lub nie są zgodne z ich odpowiedni element maski.  
  
-   Brak wystarczającej ilości dostępnej pozycji po prawej stronie od punktu wstawiania tak, aby nie można przesunąć istniejące znaki.  
  
-   Przesunięcie istniejące znaki dałby w efekcie naruszenie maski. Należy pamiętać, że to przesunięcie odbywa się podczas wstawiania każdy pojedynczy znak.  
  
 Pusta `input` ciągu nie spowoduje zmiany w sformatowanego ciągu, ale zwróci `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InvalidIndex">
      <MemberSignature Language="C#" Value="public static int InvalidIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 InvalidIndex" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InvalidIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int InvalidIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InvalidIndex : int" Usage="System.ComponentModel.MaskedTextProvider.InvalidIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera górna granica zakresu nieprawidłowy indeksów.</summary>
        <value>Wartość reprezentująca największych nieprawidłowy indeks, zgodnie z ustaleniami implementacja dostawcy. Na przykład jeśli najniższą nieprawidłowy indeks to 0, ta właściwość zwracają wartość -1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.InvalidIndex%2A> Właściwość jest używana do reprezentowania wynik, który nie jest prawidłowy dla operacji indeksowania, takich jak <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> metody.  
  
 Podczas używania dostawcy lub zaimplementować własną powinien umożliwia zdecydować, czy indeksu jest nieprawidłowy, zamiast kodować znajomości nieprawidłowe wartości tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsAvailablePosition">
      <MemberSignature Language="C#" Value="public bool IsAvailablePosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAvailablePosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAvailablePosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAvailablePosition(int position);" />
      <MemberSignature Language="F#" Value="member this.IsAvailablePosition : int -&gt; bool" Usage="maskedTextProvider.IsAvailablePosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w masce do testowania.</param>
        <summary>Określa, czy określona pozycja jest dostępne do przypisania.</summary>
        <returns>
          <see langword="true" /> Jeśli określonej pozycji w sformatowanym ciągu można edytować, a nie został przypisany do jeszcze; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.IsAvailablePosition%2A> Metoda zwraca `true` tylko wtedy, gdy spełnione są wszystkie następujące warunki:  
  
-   `pos` Parametr znajduje się w granicach sformatowany ciąg; jego wartość jest większa niż lub równa zero i mniejsza niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Określona pozycja jest znak można edytować.  
  
-   Znak nie jest już przypisane do tej pozycji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsEditPosition">
      <MemberSignature Language="C#" Value="public bool IsEditPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEditPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEditPosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEditPosition(int position);" />
      <MemberSignature Language="F#" Value="member this.IsEditPosition : int -&gt; bool" Usage="maskedTextProvider.IsEditPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w masce do testowania.</param>
        <summary>Określa, czy określona pozycja jest edytowalny.</summary>
        <returns>
          <see langword="true" /> Jeśli określona pozycja w sformatowanym ciągu jest edytowalna; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.IsEditPosition%2A> Metoda zwraca `true` tylko wtedy, gdy są spełnione oba poniższe warunki:  
  
-   `pos` Parametr znajduje się w granicach sformatowany ciąg; jego wartość jest większa niż lub równa zero i mniejsza niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Określona pozycja jest znak można edytować.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsPassword">
      <MemberSignature Language="C#" Value="public bool IsPassword { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPassword" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPassword As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPassword { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPassword : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IsPassword" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy ochrona za pomocą hasła powinny być stosowane do sformatowanego ciągu.</summary>
        <value>
          <see langword="true" /> Jeśli ciąg wejściowy jest traktowane jako ciąg hasła. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ochrona za pomocą hasła mogą być inicjowane przy użyciu jednego z następujących dwóch sposobów:  
  
-   Ustawienie <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości innej niż`null` wartości.  
  
-   Ustawienie <xref:System.ComponentModel.MaskedTextProvider.IsPassword%2A> właściwości `true`., który ustawia również <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości <xref:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar%2A> wartość.  
  
 <xref:System.ComponentModel.MaskedTextProvider.IsPassword%2A> jest używany przez <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody w celu ustalenia, czy należy wyświetlić rzeczywiste znaki wejściowe lub je za pomocą zasłaniać <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="IsValidInputChar">
      <MemberSignature Language="C#" Value="public static bool IsValidInputChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidInputChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidInputChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidInputChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidInputChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidInputChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Char" /> Wartość do sprawdzenia.</param>
        <summary>Określa, czy określony znak jest prawidłowy znak danych wejściowych.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak zawiera prawidłową wartością wejściową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe znaki wejściowe to wszystkie drukowalnych znaków, które zawierają litery, cyfry, znaki interpunkcyjne, symbole i znak spacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="IsValidMaskChar">
      <MemberSignature Language="C#" Value="public static bool IsValidMaskChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidMaskChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidMaskChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidMaskChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidMaskChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidMaskChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Char" /> Wartość do sprawdzenia.</param>
        <summary>Określa, czy określony znak jest znakiem prawidłową maskę.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak zawiera wartość prawidłową maskę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowa maska znaków obejmują wszystkie drukowalnych znaków, które zawierają litery, cyfry, znaki interpunkcyjne, symbole i znak spacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="IsValidPasswordChar">
      <MemberSignature Language="C#" Value="public static bool IsValidPasswordChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidPasswordChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidPasswordChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidPasswordChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidPasswordChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidPasswordChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Char" /> Wartość do sprawdzenia.</param>
        <summary>Określa, czy określony znak jest znakiem prawidłowe hasło.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak zawiera wartość prawidłowe hasło w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hasło jest poprawne znaki obejmują wszystkie drukowalnych znaków i znakiem zerowym, która jest używana do wyłączenia funkcji hasła. Drukowalne znaki to litery, cyfry, znaki interpunkcyjne, symbole i znak spacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : char" Usage="System.ComponentModel.MaskedTextProvider.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu do pobrania.</param>
        <summary>Pobiera element w określonej pozycji w sformatowanym ciągu.</summary>
        <value>
          <see cref="T:System.Char" /> w określonej pozycji w sformatowanym ciągu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Właściwość jest standardowa indeksator <xref:System.ComponentModel.MaskedTextProvider> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> jest mniejsze zero lub większa niż lub równa <see cref="P:System.ComponentModel.MaskedTextProvider.Length" /> maski.</exception>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
      </Docs>
    </Member>
    <Member MemberName="LastAssignedPosition">
      <MemberSignature Language="C#" Value="public int LastAssignedPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LastAssignedPosition" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastAssignedPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LastAssignedPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LastAssignedPosition : int" Usage="System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera indeks w masce po prawej stronie wprowadzanych znaków, która ma przypisane do maski.</summary>
        <value>Jeśli co najmniej jeden znak danych wejściowych zostało przypisane do maski, <see cref="T:System.Int32" /> zawierających indeks po prawej stronie przypisane pozycji; w przeciwnym razie, jeśli przypisano nie pozycji, <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> Właściwość reprezentuje położony pozycji edycji w masce pokrewny ze źródłem, która ma przypisane wprowadzanych znaków. W przypadku języków odczytu od lewej do prawej (od lewej do prawej), takich jak angielski jest po prawej stronie przypisane pozycji; w przypadku języków, przeczytaj od prawej do lewej (RTL) to skrajnie po lewej stronie pozycji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.ComponentModel.MaskedTextProvider.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość maski, braku dowolnego maska modyfikator znaków.</summary>
        <value>
          <see cref="T:System.Int32" /> Zawierającą liczbę pozycji w masce, z wyjątkiem znaków, które modyfikują dane wejściowe maski.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Length%2A> Właściwość reprezentuje całkowita liczba znaków w masce, w tym znaki literału i edytowalne. Znaki literału może być określana przez odjęcie wartości <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> z <xref:System.ComponentModel.MaskedTextProvider.Length%2A>.  
  
 <xref:System.ComponentModel.MaskedTextProvider.Length%2A> opisano również długość sformatowanego ciągu, w tym wprowadzonych znaków, literałów i znaki monitu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="Mask">
      <MemberSignature Language="C#" Value="public string Mask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Mask" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Mask" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mask As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Mask { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Mask : string" Usage="System.ComponentModel.MaskedTextProvider.Mask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maska wprowadzania.</summary>
        <value>A <see cref="T:System.String" /> zawierającą pełną maskę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> Właściwość jest ustawiona <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> konstruktora. Ta maska musi zawierać tylko prawidłowe znaki zdefiniowanym jako język maskowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.#ctor" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clone" />
      </Docs>
    </Member>
    <Member MemberName="MaskCompleted">
      <MemberSignature Language="C#" Value="public bool MaskCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaskCompleted" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaskCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaskCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MaskCompleted : bool" Usage="System.ComponentModel.MaskedTextProvider.MaskCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wszystkie wymagane dane wejściowe zostały wprowadzone w ciąg formatowania.</summary>
        <value>
          <see langword="true" /> Jeśli wszystkie wymagane dane wejściowe zostały wprowadzone do maski; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> Właściwość sprawdza, czy tylko wymaganych elementów wejściowych. Aby określić, czy wprowadzono wszystkich wymaganych i opcjonalnych elementów wejściowych, użyj <xref:System.Windows.Forms.MaskedTextBox.MaskFull%2A?displayProperty=nameWithType> właściwość <xref:System.Windows.Forms.MaskedTextBox> klasy zamiast tego.  
  
 Bieżąca wartość <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwość określa, które elementy formatowania są traktowane jako wymaganych i opcjonalnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskCompleted" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="MaskFull">
      <MemberSignature Language="C#" Value="public bool MaskFull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaskFull" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaskFull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaskFull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MaskFull : bool" Usage="System.ComponentModel.MaskedTextProvider.MaskFull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wszystkie wymagane i opcjonalne dane wejściowe zostały wprowadzone w ciąg formatowania.</summary>
        <value>
          <see langword="true" /> Jeśli wszystkie wymagane i opcjonalne dane wejściowe zostały wprowadzone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby sprawdzić, czy tylko wymaganych elementów wejściowych zostały wprowadzone, należy użyć <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> właściwości zamiast tego. Bieżąca wartość <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwość określa, które elementy formatowania są traktowane jako wymaganych i opcjonalnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="PasswordChar">
      <MemberSignature Language="C#" Value="public char PasswordChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      <MemberSignature Language="VB.NET" Value="Public Property PasswordChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char PasswordChar { char get(); void set(char value); };" />
      <MemberSignature Language="F#" Value="member this.PasswordChar : char with get, set" Usage="System.ComponentModel.MaskedTextProvider.PasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znak, który ma zostać zamieniony na rzeczywiste znaki wejściowe.</summary>
        <value>
          <see cref="T:System.Char" /> Wartość używana jako znak hasła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane wejściowe użytkownika wielkość liter jest powszechną praktyką, aby ukryć informacje wprowadzone przez użytkownika podczas wykonywania operacji w danych wyjściowych. Jeśli <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwość jest ustawiona na innej niż`null` znaków, takich jak dane wyjściowe metody <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> będzie przesłaniać wprowadzonych znaków ze znakiem określonego hasła. Ustawienie tej właściwości na `null` spowoduje wyłączenie funkcji ochrony hasła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Znak hasło określone podczas ustawienie tej właściwości jest taka sama jak bieżący znak prompt, <see cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />. Dwa muszą być różne.</exception>
        <exception cref="T:System.ArgumentException">Znak określony, gdy ustawienie tej właściwości nie jest prawidłowym hasłem znakiem, zgodnie z ustaleniami <see cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" /> metody.</exception>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PromptChar">
      <MemberSignature Language="C#" Value="public char PromptChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PromptChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
      <MemberSignature Language="VB.NET" Value="Public Property PromptChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char PromptChar { char get(); void set(char value); };" />
      <MemberSignature Language="F#" Value="member this.PromptChar : char with get, set" Usage="System.ComponentModel.MaskedTextProvider.PromptChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znak używany do reprezentowania braku danych wejściowych użytkownika dla wszystkich dostępnych edycji pozycji.</summary>
        <value>Znak używany na monitowanie użytkownika o wprowadzenie danych. Wartość domyślna to znaku podkreślenia (_).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> Właściwość reprezentuje monitu znak, który jest używany przez <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody reprezentują bieżący stan sformatowany ciąg wejściowy. Monituj znak jest umieszczany w można edytować pozycje, które nie mają jeszcze przypisanej wartości wejściowej. Niektóre wersje <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda także zależeć od wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Prompt znak określony, gdy ustawienie tej właściwości jest taka sama jak bieżący znak hasło <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />. Dwa muszą być różne.</exception>
        <exception cref="T:System.ArgumentException">Znak określony, gdy ustawienie tej właściwości nie jest prawidłowym hasłem znakiem, zgodnie z ustaleniami <see cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" /> metody.</exception>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa ostatni znak przypisane z sformatowany ciąg.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; bool" Usage="maskedTextProvider.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa ostatni znak przypisane z sformatowany ciąg.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> Metody nie obowiązuje, jeśli żadne znaki nie jeszcze przypisany do maski.  
  
 Po usunięciu ostatniego znaku przypisane z sformatowany ciąg znaków maska edycji jest resetowany dla tej pozycji, umożliwiając wprowadzanie kolejnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove([out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Remove(System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove([Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Remove :  *  -&gt; bool" Usage="maskedTextProvider.Remove (testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="testPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie znak rzeczywiście został usunięty. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Usuwa ostatni znak przypisane z sformatowany ciąg, a następnie generuje, usunięcie pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> Metody nie obowiązuje, jeśli żadne znaki nie jeszcze przypisany do maski.  
  
 Po usunięciu ostatniego znaku przypisane z sformatowany ciąg znaków maska edycji jest resetowany dla tej pozycji, umożliwiając wprowadzanie kolejnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveAt">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa jeden lub więcej znaków przypisane z sformatowany ciąg.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int position);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; bool" Usage="maskedTextProvider.RemoveAt position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja znaku przypisanych do usunięcia.</param>
        <summary>Usuwa z sformatowany ciąg przypisane znak w określonej pozycji.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> Metody nie obowiązuje, jeśli żadne znaki nie przypisanych usuwania pozycji określonej. Ta metoda nie dotyczy znaki literału.  
  
 Po usunięciu znak pozostałym znakom wyższe umieszczony w masce będzie przesunąć w lewo do uzupełnij braki utworzone przez operację usunięcia. Opuszczone pozycje są resetowane dla danych wejściowych. Jeśli przepływ znaków nie może zgodnie z definicją maski, bez usuwania, sytuacji i <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zwraca `false`.  
  
 Wywołanie tej metody odpowiada dokładnie poniższe wywołanie przeciążonej <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%28System.Int32%2CSystem.Int32%29> wersji:  
  
 `RemoveAt(pos, pos);`  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int startPosition, int endPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 startPosition, int32 endPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (startPosition As Integer, endPosition As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int startPosition, int endPosition);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int * int -&gt; bool" Usage="maskedTextProvider.RemoveAt (startPosition, endPosition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczony od zera indeks pierwszego znaku przypisanych do usunięcia.</param>
        <param name="endPosition">Liczony od zera indeks ostatniego znaku przypisanych do usunięcia.</param>
        <summary>Usuwa znaki przypisane od określonej pozycji z sformatowany ciąg.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> Metoda nie ma wpływu Jeśli przypisane żadne znaki nie znajduje się w pozycji usuwania, określoną.  
  
 Po usunięciu znak pozostałym znakom wyższe umieszczony w masce będzie przesunąć w lewo do uzupełnij braki utworzone przez operację usunięcia. Opuszczone pozycje są resetowane dla danych wejściowych. Jeśli przepływ znaków nie może zgodnie z definicją maski, bez usuwania, sytuacji i <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zwraca `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int * int *  *  -&gt; bool" Usage="maskedTextProvider.RemoveAt (startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczony od zera indeks pierwszego znaku przypisanych do usunięcia.</param>
        <param name="endPosition">Liczony od zera indeks ostatniego znaku przypisanych do usunięcia.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja w sformatowanym ciągu, z której znaki rzeczywiście zostały usunięte; w przeciwnym razie pierwszy pozycji, gdzie operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Usuwa znaki przypisane od określonej pozycji z sformatowany ciąg, a następnie generuje, usunięcie pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> Metoda nie ma wpływu Jeśli przypisane żadne znaki nie znajduje się w pozycji usuwania, określoną.  
  
 Po usunięciu znak pozostałym znakom wyższe umieszczony w masce będzie przesunąć w lewo do uzupełnij braki utworzone przez operację usunięcia. Opuszczone pozycje są resetowane dla danych wejściowych. Jeśli przepływ znaków nie może zgodnie z definicją maski, bez usuwania, sytuacji i <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zwraca `false`.  
  
 Ta wersja <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zawiera dwa parametry dodatkowe dane wyjściowe, przekazując więcej informacji na temat działania metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zastępuje co najmniej jeden znak można edytować w sformatowanym ciągu określonych znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int -&gt; bool" Usage="maskedTextProvider.Replace (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Wartość, która zastępuje istniejącą wartość.</param>
        <param name="position">Liczony od zera pozycja do wyszukiwania dla pierwszego znaku można edytować, aby zastąpić.</param>
        <summary>Określona wartość znaku zastępuje pojedynczy znak na lub po przekroczeniu określonej pozycji.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie zastąpiony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%29> Metoda wyszukuje pierwszą pozycję można edytować w sformatowanym ciągu na lub po przekroczeniu określonej pozycji `pos`. Jeśli został znaleziony, wartość, które można edytować pozycji jest zmieniana na określony znak `input`. Dowolne z następujących warunków spowoduje błąd, który powoduje, że nie można zastąpić do wykonania i wartość `false` mają zostać zwrócone:  
  
-   `pos` Parametr jest mniejsza od zera lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie można odnaleźć znaku można edytować w sformatowanym ciągu na lub po przekroczeniu określonej pozycji `pos`.  
  
-   Znak zastępczy `input`, nie jest prawidłowym znakiem danych wejściowych, ponieważ nie jest drukowalnym lub jest niezgodna z odpowiadającego mu elementu maski.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int position);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int -&gt; bool" Usage="maskedTextProvider.Replace (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Używany do zastępowania istniejącego znaków można edytować wartość.</param>
        <param name="position">Liczony od zera pozycja do wyszukiwania dla pierwszego znaku można edytować, aby zastąpić.</param>
        <summary>Zastępuje edytowalne znaków, zaczynając od określonej pozycji z określonego ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie znaki zostały pomyślnie zastąpił; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%29> Metoda wyszukuje pierwszą pozycję można edytować na lub po przekroczeniu określonej pozycji `pos`. Działają, przy założeniu, że po tym punkcie są wystarczająco dużo można edytować pozycje, istniejące wartości znaków są zastąpione pojedynczo zawartość parametr typu ciąg zastępczy, `input`.  
  
 Poniższe warunki są traktowane jako błędy. Gdy wystąpi błąd, nie jest zastępowana i <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%29> zwraca `false`.  
  
-   `pos` Parametr jest mniejsza od zera lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie są wystarczająco dużo można edytować pozycje w sformatowanym ciągu do przechowywania zawartości w ciągu zamiennym.  
  
-   Jedna z wartości znak zastępczy, jest nieprawidłowa, ponieważ nie jest drukowalnym lub jest niezgodna z odpowiadającego mu elementu maski.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Wartość, która zastępuje istniejącą wartość.</param>
        <param name="position">Liczony od zera pozycja do wyszukiwania dla pierwszego znaku można edytować, aby zastąpić.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja w sformatowanym ciągu, której ostatni znak rzeczywiście został zastąpiony; w przeciwnym razie pierwszy pozycji, gdzie operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji zastępowania. Parametr wyjściowy.</param>
        <summary>Zastępuje pojedynczy znak na lub po przekroczeniu określonej pozycji określona wartość znaku, a następnie generuje, usunięcie pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie zastąpiony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metoda wyszukuje pierwszą pozycję można edytować w sformatowanym ciągu na lub po przekroczeniu określonej pozycji `pos`. Jeśli został znaleziony, wartość, które można edytować pozycji jest zmieniana na określony znak `input`. Dowolne z następujących warunków spowoduje błąd, co powoduje, że nie można zastąpić do wykonania i wartość `false` mają zostać zwrócone:  
  
-   `pos` Parametr jest mniejsza od zera lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie można odnaleźć znaku można edytować w sformatowanym ciągu na lub po przekroczeniu określonej pozycji `pos`.  
  
-   Znak zastępczy `input`, nie jest prawidłowym znakiem danych wejściowych, ponieważ nie jest drukowalnym lub jest niezgodna z odpowiadającego mu elementu maski.  
  
 Oprócz zwracanej wartości metoda ta ma dwa parametry wyjściowe o podanie dodatkowych informacji na temat operacji zastępowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Używany do zastępowania istniejącego znaków można edytować wartość.</param>
        <param name="position">Liczony od zera pozycja do wyszukiwania dla pierwszego znaku można edytować, aby zastąpić.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja w sformatowanym ciągu, której ostatni znak rzeczywiście został zastąpiony; w przeciwnym razie pierwszy pozycji, gdzie operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji zastępowania. Parametr wyjściowy.</param>
        <summary>Zastępuje szeroką gamę znaków można edytować, zaczynając od określonej pozycji z określonego ciągu, a następnie generuje, usunięcie pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie znaki zostały pomyślnie zastąpił; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metoda wyszukuje pierwszą pozycję można edytować na lub po przekroczeniu określonej pozycji `pos`. Działają na założeniu, że po tym punkcie są wystarczająco dużo można edytować pozycje, istniejące wartości znaków są zastąpione pojedynczo zawartość parametr typu ciąg zastępczy, `input`.  
  
 Poniższe warunki są traktowane jako błędy. Gdy wystąpi błąd, nie jest zastępowana i <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> zwraca `false`.  
  
-   `pos` Parametr jest mniejsza od zera lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie są wystarczająco dużo można edytować pozycje w sformatowanym ciągu do przechowywania zawartości w ciągu zamiennym.  
  
-   Jedna z wartości znak zastępczy, jest nieprawidłowa, ponieważ nie jest drukowalnym lub jest niezgodna z odpowiadającego mu elementu maski.  
  
 Oprócz zwracanej wartości metoda ta ma dwa parametry wyjściowe o podanie dodatkowych informacji na temat operacji zastępowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Wartość, która zastępuje istniejącą wartość.</param>
        <param name="startPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie rozpoczyna się zastąpienia.</param>
        <param name="endPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie kończy się zastąpienia.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja w sformatowanym ciągu, której ostatni znak rzeczywiście został zastąpiony; w przeciwnym razie pierwszy pozycji, gdzie operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji zastępowania. Parametr wyjściowy.</param>
        <summary>Zastępuje pojedynczy znak między określonym początkową i końcową pozycję z określona wartość znaku, a następnie generuje, usunięcie pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie zastąpiony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metoda wyszukuje pierwszą pozycję można edytować w sformatowanym ciągu od określonej początkowe i końcowe pozycji. Jeśli został znaleziony, wartość, które można edytować pozycji jest zmieniana na określony znak `input`. Dowolne z następujących warunków spowoduje błąd, co powoduje, że nie można zastąpić do wykonania i wartość `false` mają zostać zwrócone:  
  
-   `startPos` Lub `endPos` Parametry punktu przed rozpoczęciem sformatować ciąg lub znajduje się poza jego końcem.  
  
-   Nie można odnaleźć znaku można edytować w określonym przedziale czasu.  
  
-   Znak zastępczy `input`, nie jest prawidłowym znakiem danych wejściowych, ponieważ nie jest drukowalnym lub jest niezgodna z odpowiadającego mu elementu maski.  
  
 Oprócz zwracanej wartości metoda ta ma dwa parametry wyjściowe o podanie dodatkowych informacji na temat operacji zastępowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Używany do zastępowania istniejącego znaków można edytować wartość.</param>
        <param name="startPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie rozpoczyna się zastąpienia.</param>
        <param name="endPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie kończy się zastąpienia.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja w sformatowanym ciągu, której ostatni znak rzeczywiście został zastąpiony; w przeciwnym razie pierwszy pozycji, gdzie operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji zastępowania. Parametr wyjściowy.</param>
        <summary>Zastępuje zakresu edycji znaków między określonym początkową i końcową pozycję przy użyciu określonego ciągu, a następnie generuje, usunięcie pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie znaki zostały pomyślnie zastąpił; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> Metoda wyszukuje pierwszą pozycję można edytować w sformatowanym ciągu od określonej początkowe i końcowe pozycji. Działają na założeniu, że po tym punkcie są wystarczająco dużo można edytować pozycje, istniejące wartości znaków są zastąpione pojedynczo zawartość parametr typu ciąg zastępczy, `input`.  
  
 Poniższe warunki są traktowane jako błędy. Gdy wystąpi błąd, nie jest zastępowana i <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> zwraca `false`.  
  
-   `startPos` Lub `endPos` Parametry punktu przed rozpoczęciem sformatować ciąg lub znajduje się poza jego końcem.  
  
-   Nie są wystarczająco dużo można edytować pozycje w sformatowanym ciągu do przechowywania zawartości w ciągu zamiennym.  
  
-   Jedna z wartości znak zastępczy, jest nieprawidłowa, ponieważ nie jest drukowalnym lub jest niezgodna z odpowiadającego mu elementu maski.  
  
 Oprócz zwracanej wartości metoda ta ma dwa parametry wyjściowe o podanie dodatkowych informacji na temat operacji zastępowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="ResetOnPrompt">
      <MemberSignature Language="C#" Value="public bool ResetOnPrompt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResetOnPrompt" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      <MemberSignature Language="VB.NET" Value="Public Property ResetOnPrompt As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResetOnPrompt { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResetOnPrompt : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą sposób obsługi wprowadzanych znaków, który pasuje do znaku monitu.</summary>
        <value>
          <see langword="true" /> Jeżeli monitu znak jako dane wejściowe powoduje, że bieżącej pozycji można edytować w masce zerującego; w przeciwnym razie <see langword="false" /> do wskazywania do przetworzenia jako normalne znaki wejściowe monitu znaków. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider> można traktować dwie kategorie tępy, Monituj znaki i znaki w specjalny sposób. Normalnie, każdy znak wejściowy będą testowane pod względem maska, a następnie zaakceptowany lub odrzucony. Działających na założeniu, który <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> właściwości jest równa wartości innych niż `null`, ustawienie <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A> właściwości `true` wynikiem będzie przetwarzana w specjalny sposób monitu znak. Po dodaniu znaku zgłoszenia, powoduje to, bieżąca pozycja znaku maski do wyczyszczenia i bieżącej pozycji Zaawansowane na następny znak można edytować.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A> pierwszeństwo <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> właściwości zgodnie z opisem w poniższej tabeli.  
  
|<xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>|<xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>|Wynikowe zachowania|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------|  
|`true`|`true`|Można dodać znak monitu i sprawia, że bieżącej pozycji maski do zresetowania. Domyślnie.|  
|`true`|`false`|Można dodać znak monitu i sprawia, że bieżącej pozycji maski do zresetowania.|  
|`false`|`true`|Monituj znak jest przetwarzany jako normalny wprowadzanych znaków.|  
|`false`|`false`|Monituj znak nie jest prawidłowy i metod, które podjęto próbę dodania znak zakończy się niepowodzeniem.|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <Member MemberName="ResetOnSpace">
      <MemberSignature Language="C#" Value="public bool ResetOnSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResetOnSpace" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property ResetOnSpace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResetOnSpace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResetOnSpace : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą sposób obsługi danych wejściowych znak spacji.</summary>
        <value>
          <see langword="true" /> Jeśli wejściowy znak spacji powoduje, że bieżącej pozycji można edytować w masce zerującego; w przeciwnym razie <see langword="false" /> aby wskazać, że do przetworzenia jako normalny wprowadzanych znaków. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider> można traktować dwie kategorie znaków, spacje i znaki monitu w specjalny sposób. Normalnie, każdy znak wejściowy będą testowane pod względem maska, a następnie zaakceptowany lub odrzucony. Ustawienie <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> właściwości `true` spowoduje bieżąca pozycja znaku maski czyszczona i bieżące położenie jest Zaawansowane na następny znak można edytować.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> jest przydatne podczas przypisywania tekst, który został zapisany w wierszu polecenia, z wyjątkiem gdzie monit zostanie zastąpiony spacją. Przed przywróceniem takich parametrów, ustawienie <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> do `true` spowoduje zresetowanie znaki monitu w pozycjach zajmowane przez miejsca do magazynowania w ciągu wejściowym.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia sformatowany ciąg do określonego ciągu wejściowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Set(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Set (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Set : string -&gt; bool" Usage="maskedTextProvider.Set input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Wartość używana do ustawiania sformatowany ciąg.</param>
        <summary>Ustawia sformatowany ciąg do określonego ciągu wejściowego.</summary>
        <returns>
          <see langword="true" /> Jeśli pomyślnie ustawiono wszystkie znaki; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Set%2A> Metoda usuwa istniejącą zawartość elementu sformatowany ciąg, a następnie stosuje maski względem `input` ciągu, aby zaktualizować zawartość sformatowany ciąg.  
  
 Poniższe warunki są traktowane jako błędy. Gdy wystąpi błąd, sformatowany ciąg pozostanie niezmieniona i <xref:System.ComponentModel.MaskedTextProvider.Set%2A> zwraca `false`.  
  
-   Nie są wystarczająco dużo można edytować pozycje w sformatowanym ciągu do przechowywania zawartości w ciągu zamiennym.  
  
-   Jedna z wartości znak zastępczy, jest nieprawidłowa, ponieważ nie jest drukowalnym lub jest niezgodna z odpowiadającego mu elementu maski.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Set(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Set (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Set : string *  *  -&gt; bool" Usage="maskedTextProvider.Set (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Wartość używana do ustawiania sformatowany ciąg.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja w sformatowanym ciągu, której ostatni znak rzeczywiście został ustawiony; w przeciwnym razie pierwszy pozycji, gdzie operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wynik ustalonej operacji. Parametr wyjściowy.</param>
        <summary>Ustawia sformatowany ciąg do określonego ciągu wejściowego, a następnie generuje, usunięcie pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli pomyślnie ustawiono wszystkie znaki; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Set%2A> Metoda usuwa istniejącą zawartość elementu sformatowany ciąg, a następnie stosuje maski względem `input` ciągu, aby zaktualizować zawartość sformatowany ciąg.  
  
 Poniższe warunki są traktowane jako błędy. Gdy wystąpi błąd, sformatowany ciąg pozostanie niezmieniona i <xref:System.ComponentModel.MaskedTextProvider.Set%2A> zwraca `false`.  
  
-   Nie są wystarczająco dużo można edytować pozycje w sformatowanym ciągu do przechowywania zawartości w ciągu zamiennym.  
  
-   Jedna z wartości znak zastępczy, jest nieprawidłowa, ponieważ nie jest drukowalnym lub jest niezgodna z odpowiadającego mu elementu maski.  
  
 Ta wersja <xref:System.ComponentModel.MaskedTextProvider.Set%2A> zawiera dwa parametry dodatkowe dane wyjściowe, przekazując więcej informacji na temat działania metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="SkipLiterals">
      <MemberSignature Language="C#" Value="public bool SkipLiterals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipLiterals" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipLiterals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipLiterals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipLiterals : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.SkipLiterals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy pozycje znaku literału w masce może zostać zastąpiona przez ich te same wartości.</summary>
        <value>
          <see langword="true" /> Aby umożliwić tworzenie kopii literały, które mają zostać dodane; w przeciwnym razie <see langword="false" /> nie zezwalać na użytkownika zastąpić znaki literału. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maska wprowadzania może zawierać znaki literału i można edytować. Jeśli do dodania wprowadzanych znaków do położenia w masce zajmowane przez literału, wartość zostanie podjęta próba <xref:System.Windows.Forms.MaskedTextBox.SkipLiterals%2A> właściwość określa wynik.  
  
-   Jeśli ta właściwość jest `true`, jest on prawidłowy zastąpienie literału z taką samą wartość, podczas dodawania wprowadzonych znaków. Na przykład, wartość znaku ukośnika, `'/'`, może zostać dodany do położenia trzeciego maski `"00/00/000"`.  
  
-   Jeśli ta właściwość jest `false`, nie jest prawidłową można przypisać dowolną wartość w miejsce maska zajmowane przez znak literału.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      </Docs>
    </Member>
    <Member MemberName="ToDisplayString">
      <MemberSignature Language="C#" Value="public string ToDisplayString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToDisplayString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToDisplayString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToDisplayString();" />
      <MemberSignature Language="F#" Value="member this.ToDisplayString : unit -&gt; string" Usage="maskedTextProvider.ToDisplayString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca sformatowany ciąg w postaci wyświetlanej.</summary>
        <returns>Sformatowana <see cref="T:System.String" /> zawierającej monity i wszystkie literały maski.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> Metody zawsze będzie zawierać monit i literałów znaków w wartości zwracanej, bez względu na wartość <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> lub <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości. Ta metoda zawsze będzie wyświetlała znaki hasła, jeśli <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwość jest ustawiona na wartość znaku inne niż `null`.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> najczęściej jest używana do uzyskiwania ciąg wyświetlany w elementach interfejsu skojarzone z użytkownikami, takich jak <xref:System.Windows.Forms.MaskedTextBox>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca sformatowany ciąg.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="maskedTextProvider.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca sformatowany ciąg, który zawiera wszystkie wartości przypisane znaków.</summary>
        <returns>Sformatowana <see cref="T:System.String" /> zawierającą wszystkie wartości przypisane znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zawiera monity i wszystkie literały zgodnie z bieżących wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości, odpowiednio. Zawsze zwróci oryginalne znaki wejściowe, ignorowanie wartości <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawni informacje, które zwykle jest chroniony przez znaki hasła w interfejsie użytkownika, należy używać z najwyższą ostrożnością Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool -&gt; string" Usage="maskedTextProvider.ToString ignorePasswordChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar">
          <see langword="true" /> Aby zwrócić rzeczywiste znaków można edytować. w przeciwnym razie <see langword="false" /> z informacją, że <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> właściwość ma zostać wdrożona.</param>
        <summary>Zwraca sformatowany ciąg, opcjonalnie w tym znaki hasła.</summary>
        <returns>Sformatowana <see cref="T:System.String" /> zawierającej literały, monity i, opcjonalnie, znaki hasła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zawiera monity i wszystkie literały zgodnie z bieżących wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości, odpowiednio. Jeśli `ignorePasswordChar` parametr jest `true`, to zostanie zwrócona oryginalne znaki wejściowe, ignorowanie wartości <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości. Jeśli ten parametr jest `false`, użyje znaku hasła do ukrywania danych wejściowych użytkownika można edytować, jeśli <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości jest równa wartości innych niż `null`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda potencjalnie, co spowoduje wyświetlenie informacji, które zwykle jest chroniony przez znaki hasła w interfejsie użytkownika, należy używać z najwyższą ostrożnością Aby uniknąć przypadkowego ujawnienia poufne dane użytkowników.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool includePrompt, bool includeLiterals);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool includePrompt, bool includeLiterals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (includePrompt As Boolean, includeLiterals As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool includePrompt, bool includeLiterals);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool -&gt; string" Usage="maskedTextProvider.ToString (includePrompt, includeLiterals)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrompt">
          <see langword="true" /> Aby uwzględnić znaki monitu w zwracanym ciągu; w przeciwnym razie <see langword="false" />.</param>
        <param name="includeLiterals">
          <see langword="true" /> Aby uwzględnić znaków literałowych w zwracanym ciągu; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca sformatowany ciąg, opcjonalnie w tym znaki monit i literału.</summary>
        <returns>Sformatowana <see cref="T:System.String" /> zawierającą wszystkie przypisane znak wartości i opcjonalnie zawiera literały i wyświetla monit o.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zawiera monity i wszystkie literały zgodnie z wartościami `IncludePrompt` i `IncludeLiterals` parametrów, odpowiednio. Należy zauważyć, że te parametry zastąpienie wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości. Ta metoda zawsze zwraca oryginalne znaki wejściowe, ignorowanie wartości <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawni informacje, które zwykle jest chroniony przez znaki hasła w interfejsie użytkownika, należy używać z najwyższą ostrożnością Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="maskedTextProvider.ToString (startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie rozpoczyna się dane wyjściowe.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca podciąg ciągu sformatowana.</summary>
        <returns>W przypadku powodzenia podciąg sformatowane <see cref="T:System.String" />, który zawiera wszystkie wartości przypisane znaku; w przeciwnym razie <see cref="F:System.String.Empty" /> ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zwraca ciąg sformatowany ciąg, zaczynając od pozycji `startPos` i wraz z liczbą kolejnych znaków określoną przez `length` parametru. Zwracany ciąg zawiera monity i wszystkie literały zgodnie z bieżących wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości, odpowiednio. Zwracany ciąg będzie zawierał oryginalne znaki wejściowe; <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwość zawsze jest ignorowana.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawni informacje, które zwykle jest chroniony przez znaki hasła w interfejsie użytkownika, należy używać z najwyższą ostrożnością Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> wykonuje następujące akcje w przypadku wystąpienia niezgodności w parametrach wejściowych:  
  
-   Jeśli `startPos` jest mniejsza niż zero, pozycja początkowa jest równa zero.  
  
-   Jeśli `startPos` jest większa niż lub równa rzeczywiste <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu <xref:System.String.Empty> zwracany ciąg.  
  
-   Jeśli `length` jest większa niż liczba pozostałych znaków ostatnich początkową tylko pozostałe znaki są zwracane.  
  
-   Jeśli `length` jest mniejsza niż zero, <xref:System.String.Empty> zwracany ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (ignorePasswordChar, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar">
          <see langword="true" /> Aby zwrócić rzeczywiste znaków można edytować. w przeciwnym razie <see langword="false" /> z informacją, że <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> właściwość ma zostać wdrożona.</param>
        <param name="startPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie rozpoczyna się dane wyjściowe.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca podciąg sformatowany ciąg, opcjonalnie w tym znaki hasła.</summary>
        <returns>W przypadku powodzenia podciąg sformatowane <see cref="T:System.String" />, w tym literały, monity i, opcjonalnie, znaki hasła; w przeciwnym razie <see cref="F:System.String.Empty" /> ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zwraca ciąg sformatowany ciąg, zaczynając od pozycji `startPos` i wraz z liczbą kolejnych znaków określoną przez `length` parametru. Zwracany ciąg zawiera monity i wszystkie literały zgodnie z bieżących wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości, odpowiednio. Jeśli `ignorePasswordChar` parametr jest `true`, to zostanie zwrócona oryginalne znaki wejściowe, ignorowanie wartości <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości. Jeśli ten parametr jest `false`, użyje znaku hasła do ukrywania danych wejściowych użytkownika można edytować, jeśli <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości jest równa wartości innych niż `null`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda potencjalnie, co spowoduje wyświetlenie informacji, które zwykle jest chroniony przez znaki hasła w interfejsie użytkownika, należy używać z najwyższą ostrożnością Aby uniknąć przypadkowego ujawnienia poufne dane użytkowników.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> wykonuje następujące akcje w przypadku wystąpienia niezgodności w parametrach wejściowych:  
  
-   Jeśli `startPos` jest mniejsza niż zero, pozycja początkowa jest równa zero.  
  
-   Jeśli `startPos` jest większa niż lub równa rzeczywiste <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu <xref:System.String.Empty> zwracany ciąg.  
  
-   Jeśli `length` jest większa niż liczba pozostałych znaków ostatnich początkową tylko pozostałe znaki są zwracane.  
  
-   Jeśli `length` jest mniejsza niż zero, <xref:System.String.Empty> zwracany ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool includePrompt, bool includeLiterals, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (includePrompt As Boolean, includeLiterals As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (includePrompt, includeLiterals, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="includePrompt">
          <see langword="true" /> Aby uwzględnić znaki monitu w zwracanym ciągu; w przeciwnym razie <see langword="false" />.</param>
        <param name="includeLiterals">
          <see langword="true" /> Aby uwzględnić znaków literałowych w zwracanym ciągu; w przeciwnym razie <see langword="false" />.</param>
        <param name="startPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie rozpoczyna się dane wyjściowe.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca podciąg sformatowany ciąg, opcjonalnie w tym znaki monit i literału.</summary>
        <returns>W przypadku powodzenia podciąg sformatowane <see cref="T:System.String" />, zawierający wszystkie przypisane znak wartości i opcjonalnie zawiera literały i monitów; w przeciwnym razie <see cref="F:System.String.Empty" /> ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zwraca ciąg sformatowany ciąg, zaczynając od pozycji `startPos` i wraz z liczbą kolejnych znaków określoną przez `length` parametru. Zwracany ciąg zawiera monity i wszystkie literały zgodnie z wartościami `IncludePrompt` i `IncludeLiterals` parametrów, odpowiednio. Należy zauważyć, że te parametry zastąpienie wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości. Ta metoda zawsze zwraca oryginalne znaki wejściowe, ignorowanie wartości <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawni informacje, które zwykle jest chroniony przez znaki hasła w interfejsie użytkownika, należy używać z najwyższą ostrożnością Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> wykonuje następujące akcje w przypadku wystąpienia niezgodności w parametrach wejściowych:  
  
-   Jeśli `startPos` jest mniejsza niż zero, pozycja początkowa jest równa zero.  
  
-   Jeśli `startPos` jest większa niż lub równa rzeczywiste <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu <xref:System.String.Empty> zwracany ciąg.  
  
-   Jeśli `length` jest większa niż liczba pozostałych znaków ostatnich początkową tylko pozostałe znaki są zwracane.  
  
-   Jeśli `length` jest mniejsza niż zero, <xref:System.String.Empty> zwracany ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean, includePrompt As Boolean, includeLiterals As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool * bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (ignorePasswordChar, includePrompt, includeLiterals, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar">
          <see langword="true" /> Aby zwrócić rzeczywiste znaków można edytować. w przeciwnym razie <see langword="false" /> z informacją, że <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> właściwość ma zostać wdrożona.</param>
        <param name="includePrompt">
          <see langword="true" /> Aby uwzględnić znaki monitu w zwracanym ciągu; w przeciwnym razie <see langword="false" />.</param>
        <param name="includeLiterals">
          <see langword="true" /> Aby zwrócić znaków literałowych w zwracanym ciągu; w przeciwnym razie <see langword="false" />.</param>
        <param name="startPosition">Liczony od zera pozycja w sformatowanym ciągu, gdzie rozpoczyna się dane wyjściowe.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca podciąg sformatowany ciąg, opcjonalnie w tym wierszu, literał, a hasło znaki.</summary>
        <returns>W przypadku powodzenia podciąg sformatowane <see cref="T:System.String" />, zawierający wszystkie przypisane znak wartości i opcjonalnie zawiera literały, monity i hasło do znaków dwubajtowych; w przeciwnym razie <see cref="F:System.String.Empty" /> ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zwraca ciąg sformatowany ciąg, zaczynając od pozycji `startPos` i wraz z liczbą kolejnych znaków określoną przez `length` parametru. Zwracany ciąg zawiera monity i wszystkie literały zgodnie z wartościami `IncludePrompt` i `IncludeLiterals` parametrów, odpowiednio. Należy zauważyć, że te parametry zastąpienie wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości. Jeśli `ignorePasswordChar` parametr jest `true`, to zostanie zwrócona oryginalne znaki wejściowe, ignorowanie wartości <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości. Jeśli ten parametr jest `false`, użyje znaku hasła do ukrywania danych wejściowych użytkownika można edytować, jeśli <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości jest równa wartości innych niż `null`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda potencjalnie, co spowoduje wyświetlenie informacji, które zwykle jest chroniony przez znaki hasła w interfejsie użytkownika, należy używać z najwyższą ostrożnością Aby uniknąć przypadkowego ujawnienia poufne dane użytkowników.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> wykonuje następujące akcje w przypadku wystąpienia niezgodności w parametrach wejściowych:  
  
-   Jeśli `startPos` jest mniejsza niż zero, pozycja początkowa jest równa zero.  
  
-   Jeśli `startPos` jest większa niż lub równa rzeczywiste <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu <xref:System.String.Empty> zwracany ciąg.  
  
-   Jeśli `length` jest większa niż liczba pozostałych znaków ostatnich początkową tylko pozostałe znaki są zwracane.  
  
-   Jeśli `length` jest mniejsza niż zero, <xref:System.String.Empty> zwracany ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="VerifyChar">
      <MemberSignature Language="C#" Value="public bool VerifyChar (char input, int position, out System.ComponentModel.MaskedTextResultHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyChar(char input, int32 position, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyChar (input As Char, position As Integer, ByRef hint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyChar(char input, int position, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % hint);" />
      <MemberSignature Language="F#" Value="member this.VerifyChar : char * int *  -&gt; bool" Usage="maskedTextProvider.VerifyChar (input, position, hint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="hint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Wartość do sprawdzenia.</param>
        <param name="position">Pozycja w masce, aby przetestować wprowadzanych znaków względem.</param>
        <param name="hint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Sprawdza, czy określony znak może pomyślnie ustawiono w określonej pozycji.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak jest prawidłowy dla określonej pozycji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.VerifyChar%2A> Metoda sprawdza, czy pojedynczy znak wartość reprezentuje prawidłowych danych wejściowych w określonej pozycji w sformatowanym ciągu. Ta metoda zwróci `false` z następujących powodów:  
  
-   `pos` Parametr jest mniejsza od zera lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> z <xref:System.ComponentModel.MaskedTextProvider.Mask%2A>.  
  
-   Znak `input` nie jest prawidłowym znakiem wejściowy, zgodnie z ustaleniami <xref:System.ComponentModel.MaskedTextProvider.IsValidInputChar%2A> metody.  
  
-   `input` Nie jest zgodny z elementem maski w określonej pozycji `pos`.  
  
 Ostatni warunek może zależeć od bieżącej wartości <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>, <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>, <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> i <xref:System.ComponentModel.MaskedTextProvider.SkipLiterals%2A> właściwości.  
  
 Aby przetestować cały ciąg wejściowy przed maska, użyj jednej z <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> metody zamiast tego.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar(System.Char,System.Int32)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="VerifyEscapeChar">
      <MemberSignature Language="C#" Value="public bool VerifyEscapeChar (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyEscapeChar(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyEscapeChar (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyEscapeChar(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.VerifyEscapeChar : char * int -&gt; bool" Usage="maskedTextProvider.VerifyEscapeChar (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Wartość do sprawdzenia.</param>
        <param name="position">Pozycja w masce, aby przetestować wprowadzanych znaków względem.</param>
        <summary>Sprawdza, czy określony znak może być poprzedzone znakiem zmiany znaczenia w określonej pozycji.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak może być poprzedzone znakiem zmiany znaczenia w określonej pozycji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak jest nazywany *poprzedzone znakiem zmiany znaczenia* Jeśli jest to prawidłowe dane wejściowe, ale nie jest przypisany do tej pozycji w sformatowanym ciągu. W następujących trzech kategorii, poprzedzone znakiem zmiany znaczenia znaków należą:  
  
-   Znaki monitu będą miały zmienione znaczenie, jeśli <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> właściwość `true`.  
  
-   Wprowadzanie znaków będą miały zmienione znaczenie, jeśli mają taką samą wartość jak literał maski i <xref:System.ComponentModel.MaskedTextProvider.SkipLiterals%2A> właściwość `true`.  
  
-   Jeśli miały zmienione znaczenie znaków spacji <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> właściwość `true`.  
  
 <xref:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar%2A> Zwróci metoda `false` Jeśli `pos` parametr jest mniejsza od zera lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> z <xref:System.ComponentModel.MaskedTextProvider.Mask%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      </Docs>
    </Member>
    <MemberGroup MemberName="VerifyString">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza, czy można pomyślnie ustawiono określonego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VerifyString">
      <MemberSignature Language="C#" Value="public bool VerifyString (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyString(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyString (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyString(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.VerifyString : string -&gt; bool" Usage="maskedTextProvider.VerifyString input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Wartość do sprawdzenia.</param>
        <summary>Sprawdza, czy można pomyślnie ustawiono określonego ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli określony ciąg reprezentuje prawidłowy wejściowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> Stosuje `input` ciągu maski, bez wprowadzania zmian w rzeczywistości sformatowany ciąg, aby sprawdzić czy `input` są prawidłowymi odpowiednią <xref:System.ComponentModel.MaskedTextProvider.Set%2A> operacji. Ta metoda zwraca też wartość `true` Jeśli dane wejściowe są `null` lub ma zerową długość.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
      </Docs>
    </Member>
    <Member MemberName="VerifyString">
      <MemberSignature Language="C#" Value="public bool VerifyString (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyString(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyString(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyString (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyString(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.VerifyString : string *  *  -&gt; bool" Usage="maskedTextProvider.VerifyString (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Wartość do sprawdzenia.</param>
        <param name="testPosition">W przypadku powodzenia liczony od zera pozycja ostatni znak jest faktycznie testowana; w przeciwnym razie pierwszy pozycji, gdy test nie powiódł się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wynik działania testu. Parametr wyjściowy.</param>
        <summary>Sprawdza, czy określony ciąg mógł zostać ustawiony pomyślnie, a następnie generuje pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli określony ciąg reprezentuje prawidłowy wejściowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> Stosuje `input` ciągu maski, bez wprowadzania zmian w rzeczywistości sformatowany ciąg, aby sprawdzić czy `input` są prawidłowymi odpowiednią <xref:System.ComponentModel.MaskedTextProvider.Set%2A> operacji. Ta metoda zwraca też wartość `true` Jeśli dane wejściowe są `null` lub ma zerową długość.  
  
 Ta wersja <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> zawiera dwa parametry dodatkowe dane wyjściowe, przekazując więcej informacji na temat działania metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
      </Docs>
    </Member>
  </Members>
</Type>
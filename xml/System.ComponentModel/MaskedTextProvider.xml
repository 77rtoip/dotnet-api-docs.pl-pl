<Type Name="MaskedTextProvider" FullName="System.ComponentModel.MaskedTextProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c91a7e765b6cea93b50142a455c00d22426706eb" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36702277" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MaskedTextProvider : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MaskedTextProvider extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.MaskedTextProvider" />
  <TypeSignature Language="VB.NET" Value="Public Class MaskedTextProvider&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MaskedTextProvider : ICloneable" />
  <TypeSignature Language="F#" Value="type MaskedTextProvider = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje usługę analizowania maski, które mogą być używane przez dowolną liczbę formantów, które obsługują maskowania, takich jak <see cref="T:System.Windows.Forms.MaskedTextBox" /> formantu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MaskedTextBox> Formant zawiera maskę znaki literału i formatowanie elementów, które sprawdza on wszystkie dane wejściowe użytkownika przed. Zamiast trwale skojarzenie określonego aparatu analizy maski z <xref:System.Windows.Forms.MaskedTextBox>, formularze systemu Windows udostępnia go jako oddzielna usługa reprezentowany przez <xref:System.ComponentModel.MaskedTextProvider> klasy, która definiuje składnię języka maskowania omówione w dokumentacji <xref:System.Windows.Forms.MaskedTextBox.Mask%2A> właściwości.  
  
 Duża liczba członków <xref:System.Windows.Forms.MaskedTextBox> ich realizacji członkom o podobnej nazwie skojarzonego można znaleźć klasy <xref:System.ComponentModel.MaskedTextProvider>. Na przykład <xref:System.Windows.Forms.MaskedTextBox.PromptChar%2A?displayProperty=nameWithType> właściwość <xref:System.Windows.Forms.MaskedTextBox> klasy odwołuje się dostęp do <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> z <xref:System.ComponentModel.MaskedTextProvider> klasy.  
  
 Używane przez aparat analizy maski <xref:System.ComponentModel.MaskedTextProvider> jest modelowane maskowana kontrolka edycji zawarte w Microsoft Visual Basic 6 version. Język maskowania jest opisany w dokumentacji dotyczącej <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwości.  
  
 Następujące trzy różne ciągi są związane z <xref:System.ComponentModel.MaskedTextProvider> klasy.  
  
|Nazwa ciągu|Opis|  
|-----------------|-----------------|  
|Znak wejściowy lub ciąg|Reprezentuje znaki używane jako dane wejściowe, która jest stosowana wobec. W rzeczywistości ciąg wejściowy może się składać z wielu operacji wejściowych, w tym <xref:System.ComponentModel.MaskedTextProvider.Add%2A>, <xref:System.ComponentModel.MaskedTextProvider.Replace%2A>, <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A>, i <xref:System.ComponentModel.MaskedTextProvider.Remove%2A>. W związku z tym ciąg wejściowy nie jest bezpośrednio dostępny. Aspekty Obsługa ciągu wejściowego są jednak dostępne jednak <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> i <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>, <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>, i <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> właściwości.|  
|Maska|Reprezentuje dane wejściowe, formatowanie maska służący do przekształcania ciąg wejściowy ciąg sformatowany. Ten ciąg jest ustawiany w <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> i dostępne głównie jednak <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwości. Właściwości maski są również dostępne za pośrednictwem innych elementach członkowskich, takich jak <xref:System.ComponentModel.MaskedTextProvider.Length%2A>, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>, i <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> właściwości.|  
|Ciąg sformatowany|Określa ciąg, który daje podczas pełnego jest stosowana do ciągu wejściowego. Ciąg sformatowany można tworzyć zapytania o wiele elementów członkowskich klasy, w tym <xref:System.ComponentModel.MaskedTextProvider.Item%2A>, <xref:System.ComponentModel.MaskedTextProvider.Length%2A>, <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>, <xref:System.ComponentModel.MaskedTextProvider.MaskFull%2A>, <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A>, <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A>i tak dalej. Pełna wartość ciągu sformatowaną jest dostępna z <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody.|  
  
> [!NOTE]
>  Ciąg wejściowy może reprezentować bezpośrednia interwencja użytkownika, tak jak w przypadku <xref:System.Windows.Forms.MaskedTextBox>, lub mogą być generowane przez inne procesy, które nie są bezpośrednio związane z operacjami wejścia/wyjścia użytkownika.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MaskedTextBox" />
    <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskedTextProvider" />
    <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider mask" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określonej maski.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora jest dokładnym odpowiednikiem następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , null, true, '_', '\0', false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="restrictToAscii">
          <see langword="true" /> Aby ograniczyć dane wejściowe do znaków ASCII zgodnego; w przeciwnym razie <see langword="false" /> umożliwia całego zestawu Unicode.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określona maska i wartość ograniczenia ASCII.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora jest dokładnym odpowiednikiem następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , null, true, '_', '\0', restrictToASCII)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> która jest używana do ustawiania znaków separatora zależne od regionu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określona maska i kultury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora jest dokładnym odpowiednikiem następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , culture, true, '_', '\0', false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, char passwordChar, bool allowPromptAsInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, passwordChar As Char, allowPromptAsInput As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, passwordChar, allowPromptAsInput)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="passwordChar">A <see cref="T:System.Char" /> który będzie wyświetlany dla znaków wprowadzonych w ciągu hasła.</param>
        <param name="allowPromptAsInput">
          <see langword="true" /> Aby umożliwić znaku zgłoszenia jako dane wejściowe; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określona maska znak hasła, a wartość prompt użycia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora jest dokładnym odpowiednikiem następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , null, allowPromptAsInput, '_', passwordChar, false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> która jest używana do ustawiania znaków separatora zależne od regionu.</param>
        <param name="restrictToAscii">
          <see langword="true" /> Aby ograniczyć dane wejściowe do znaków ASCII zgodnego; w przeciwnym razie <see langword="false" /> umożliwia całego zestawu Unicode.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określonego maski, kultury i wartość ograniczenia ASCII.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora jest dokładnym odpowiednikiem następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , culture, true, '_', '\0', restrictToAscii)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, char passwordChar, bool allowPromptAsInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, passwordChar As Char, allowPromptAsInput As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, passwordChar, allowPromptAsInput)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> która jest używana do ustawiania znaków separatora zależne od regionu.</param>
        <param name="passwordChar">A <see cref="T:System.Char" /> który będzie wyświetlany dla znaków wprowadzonych w ciągu hasła.</param>
        <param name="allowPromptAsInput">
          <see langword="true" /> Aby umożliwić znaku zgłoszenia jako dane wejściowe; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określona maska, kultury, znak hasła i wartość prompt użycia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora jest dokładnym odpowiednikiem następujące wywołanie do <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , culture, allowPromptAsInput, '_', passwordChar, false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean,System.Char,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, allowPromptAsInput As Boolean, promptChar As Char, passwordChar As Char, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * bool * char * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, allowPromptAsInput, promptChar, passwordChar, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
        <Parameter Name="promptChar" Type="System.Char" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">A <see cref="T:System.String" /> reprezentujący maska wprowadzania.</param>
        <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> która jest używana do ustawiania znaków separatora zależne od regionu.</param>
        <param name="allowPromptAsInput">A <see cref="T:System.Boolean" /> wartość, która określa, czy znak monitu, powinno być dozwolone jako prawidłowy znak wejściowy.</param>
        <param name="promptChar">A <see cref="T:System.Char" /> , które będą wyświetlane jako symbol zastępczy dla danych wejściowych użytkownika.</param>
        <param name="passwordChar">A <see cref="T:System.Char" /> który będzie wyświetlany dla znaków wprowadzonych w ciągu hasła.</param>
        <param name="restrictToAscii">
          <see langword="true" /> Aby ograniczyć dane wejściowe do znaków ASCII zgodnego; w przeciwnym razie <see langword="false" /> umożliwia całego zestawu Unicode.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> przy użyciu określona maska, kultury, wartość prompt użycia znaku, znak hasła i wartość ograniczenia ASCII.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor reprezentuje najbardziej ogólnym przeciążone formularza. `mask` Parametru musi być zgodna z języka maskowania zdefiniowane przez <xref:System.ComponentModel.MaskedTextProvider> klasy, która została szczegółowo opisana w <xref:System.Windows.Forms.MaskedTextBox.Mask%2A?displayProperty=nameWithType> właściwość <xref:System.Windows.Forms.MaskedTextBox> klasy.  
  
 Ponieważ neutralne kultury nie można wykonać zapytania o informacje specyficzne dla kultury <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> użyje konstruktora <xref:System.Globalization.CultureInfo.GetCultures%2A> metodę wyszukiwania dla pierwszego nieneutralnej kultury służące do określenia znaków separatora właściwe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr maska jest <see langword="null" /> lub <see cref="F:System.String.Empty" />.  - lub - maska zawiera co najmniej jeden niedrukowalne znaki.</exception>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clone" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje znak wejściowy lub ciąg wejściowy ciąg sformatowany.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (char input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(char input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(char input);" />
      <MemberSignature Language="F#" Value="member this.Add : char -&gt; bool" Usage="maskedTextProvider.Add input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="input">A <see cref="T:System.Char" /> wartości, które mają być dołączane do sformatowanego ciągu.</param>
        <summary>Dodaje określony znak wejściowy do końca ciągu sformatowana.</summary>
        <returns>
          <see langword="true" /> gdy znak wejściowy został dodany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%29> Dodaje metody `input` znak po pozycji, która została ostatnio przypisana, i jest reprezentowany przez wartość pierwsze dostępne miejsce ciągu w formacie <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> właściwości. Ta metoda zakończy się niepowodzeniem dla żadnego z następujących powodów:  
  
-   Wartość wejściowa `input`, nie jest drukowania, lub nie odpowiada jego odpowiadającego mu elementu maski.  
  
-   Nie ma pozycji zero dostępne edycji ciągu w formacie lub istnieją nie pozycje edycji dostępne po ostatniej pozycji.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Add : string -&gt; bool" Usage="maskedTextProvider.Add input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">A <see cref="T:System.String" /> zawierające wartości znaków, które mają być dołączane do sformatowanego ciągu.</param>
        <summary>Dodaje określony ciąg wejściowy znaki na końcu ciągu sformatowaną.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie znaki w ciągu wejściowym zostały dodane pomyślnie; w przeciwnym razie <see langword="false" /> aby wskazać, że nie zostały dodane żadne znaki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%29> Metoda dodaje znaków z `input` ciąg sformatowany ciąg znaków, zaczynając od pierwszej pozycji dostępne po <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>. Ta metoda zakończy się niepowodzeniem dla żadnego z następujących powodów:  
  
-   Znaków w wartości wejściowej, `input`, są nie do drukowania lub wartość wejściowa nie odpowiada jego odpowiadającego mu elementu maski.  
  
-   Nie ma wystarczającej liczby pozycji dostępnych edycji ciągu w formacie po ostatniej pozycji.  
  
 Jeśli ta metoda zawiedzie, są wprowadzane nie dodatki i metoda zwraca `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (char input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(char input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.Char,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As Char, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(char input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Add : char *  *  -&gt; bool" Usage="maskedTextProvider.Add (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">A <see cref="T:System.Char" /> wartości, które mają być dołączane do sformatowanego ciągu.</param>
        <param name="testPosition">Liczona od zera pozycja ciągu w formacie, gdzie została podjęta próba dodania znak. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Dodaje określony znak wejściowy na końcu sformatowanego ciągu, a następnie generuje pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> gdy znak wejściowy został dodany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metoda próbuje dodać `input` znak po pozycji, która została ostatnio przypisana, i jest reprezentowany przez wartość pierwsze dostępne miejsce ciągu w formacie <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> właściwości. Ta metoda zakończy się niepowodzeniem, jeśli wszystkie pozycje dostępne są przed ostatniej pozycji przypisane. Ta metoda zakończy się niepowodzeniem dla żadnego z następujących powodów:  
  
-   Wartość wejściowa `input`, nie jest drukowania, lub nie odpowiada jego odpowiadającego mu elementu maski.  
  
-   Nie ma pozycji zero dostępne edycji ciągu w formacie lub istnieją nie pozycje edycji dostępne po ostatniej pozycji.  
  
 Ta metoda działa tak samo, jako wersja przesłoniętych biorąc pojedynczy <xref:System.Char> parametru <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%29>, ale on Wyświetla dodatkowe informacje.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Add : string *  *  -&gt; bool" Usage="maskedTextProvider.Add (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">A <see cref="T:System.String" /> zawierające wartości znaków, które mają być dołączane do sformatowanego ciągu.</param>
        <param name="testPosition">Liczona od zera pozycja ciągu w formacie, gdzie została podjęta próba dodania znak. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Dodaje znaki w określonym ciągu wejściowego na końcu ciągu sformatowaną, a następnie generuje pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie znaki w ciągu wejściowym zostały dodane pomyślnie; w przeciwnym razie <see langword="false" /> aby wskazać, że nie zostały dodane żadne znaki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metoda dodaje znaków z `input` ciąg sformatowany ciąg znaków, zaczynając od pierwszej pozycji dostępne po <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>. Ta metoda zakończy się niepowodzeniem dla żadnego z następujących powodów:  
  
-   Znaków w wartości wejściowej, `input`, są nie do drukowania lub wartość wejściowa nie odpowiada jego odpowiadającego mu elementu maski.  
  
-   Nie ma wystarczającej liczby pozycji dostępnych edycji ciągu w formacie po ostatniej pozycji.  
  
 Jeśli ta metoda zawiedzie, są wprowadzane nie dodatki i metoda zwraca `false`.  
  
 Ta metoda działa tak samo, jako wersja przesłoniętych biorąc pojedynczy <xref:System.String> parametru <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%29>, ale on Wyświetla dodatkowe informacje.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="AllowPromptAsInput">
      <MemberSignature Language="C#" Value="public bool AllowPromptAsInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPromptAsInput" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowPromptAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPromptAsInput { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowPromptAsInput : bool" Usage="System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy znak monitu powinny być traktowane jako prawidłowy znak wejściowy lub nie.</summary>
        <value>
          <see langword="true" /> Jeśli użytkownik może wprowadzić <see cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" /> w formancie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> Wartość właściwości jest ustawiana w <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> konstruktora.  
  
 Nawet wtedy, gdy <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> jest `true`, znaku zgłoszenia musi być prawidłowy dla bieżącej lokalizacji maski, aby akceptowane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="AsciiOnly">
      <MemberSignature Language="C#" Value="public bool AsciiOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsciiOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsciiOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsciiOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AsciiOnly : bool" Usage="System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy maska akceptuje znaki spoza zestawu znaków ASCII.</summary>
        <value>
          <see langword="true" /> Jeśli tylko ASCII są akceptowane; <see langword="false" /> Jeśli <see cref="T:System.ComponentModel.MaskedTextProvider" /> może akceptować dowolnych znaków Unicode. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A> Wartość właściwości jest ustawiana w <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> konstruktora.  
  
 Jeśli `true`, <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A> ogranicza danych wejściowych użytkownika do zestawu znaków ASCII.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.AsciiOnly" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="AssignedEditPositionCount">
      <MemberSignature Language="C#" Value="public int AssignedEditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AssignedEditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AssignedEditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AssignedEditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AssignedEditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę pozycji znaku można edytować, które już zostały pomyślnie przypisane wartości wejściowej.</summary>
        <value>
          <see cref="T:System.Int32" /> Zawierające liczby pozycji znaku można edytować maski wprowadzania już zostanie przypisana wartość znaku w ciągu sformatowana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Całkowita liczba pozycji znaku można edytować, reprezentowany przez <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> właściwość powinna być równa sumie <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> i <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="AvailableEditPositionCount">
      <MemberSignature Language="C#" Value="public int AvailableEditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AvailableEditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableEditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AvailableEditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableEditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę pozycji znaku można edytować w maska wprowadzania, których nie masz jeszcze przypisanej wartości wejściowej.</summary>
        <value>
          <see cref="T:System.Int32" /> Umieszcza zawierające liczbę znaków można edytować, który jeszcze nie zostały przypisane wartości znaków.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Całkowita liczba pozycji znaku można edytować, reprezentowany przez <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> właściwość powinna być równa sumie <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> i <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Clear">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści wprowadzanie znaków z ciągu sformatowana.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="maskedTextProvider.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie znaki wejściowych można edytować sformatowany ciągu, zastępując je znaki monitu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Clear> Metody ponownie inicjuje ciąg sformatowany Wstawianie znaku zgłoszenia do wszystkich pozycji można edytować.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear (out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear([out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clear(System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear (ByRef resultHint As MaskedTextResultHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear([Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Clear :  -&gt; unit" Usage="maskedTextProvider.Clear resultHint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Czyści wszystkie znaki wejściowych można edytować sformatowanego ciągu, zastępowanie znaki monitu i danych wyjściowych informacje opisowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Clear%28System.ComponentModel.MaskedTextResultHint%40%29> Metody ponownie inicjuje ciąg sformatowany Wstawianie znaku zgłoszenia do wszystkich pozycji można edytować. Działa ona ekwiwalentnie do przesłoniętych wersji, która nie przyjmuje żadnych parametrów <xref:System.ComponentModel.MaskedTextProvider.Clear>, z wyjątkiem on Wyświetla dodatkowe informacje.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="maskedTextProvider.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię bieżącego <see cref="T:System.ComponentModel.MaskedTextProvider" />.</summary>
        <returns>
          <see cref="T:System.ComponentModel.MaskedTextProvider" /> Obiektu ta metoda tworzy, rzutowany jako obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Clone%2A> Metoda zwraca nową kopię bieżącego <xref:System.ComponentModel.MaskedTextProvider>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.#ctor" />
        <altmember cref="T:System.ICloneable" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Culture" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo" Usage="System.ComponentModel.MaskedTextProvider.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kultura, która określa wartość Lokalizowalny separatorów i symboli zastępczych w maska wprowadzania.</summary>
        <value>A <see cref="T:System.Globalization.CultureInfo" /> zawierający informacje o ustawieniach kulturowych skojarzone z maska wprowadzania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Culture%2A> Właściwość jest ustawiona <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> konstruktora.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPasswordChar">
      <MemberSignature Language="C#" Value="public static char DefaultPasswordChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char DefaultPasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultPasswordChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property char DefaultPasswordChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPasswordChar : char" Usage="System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślne hasło znak używany zasłoniętej wejściowa użytkownika.</summary>
        <value>A <see cref="T:System.Char" /> reprezentujący domyślny znak hasła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar%2A> Właściwość jest zdefiniowana w <xref:System.ComponentModel.MaskedTextProvider> klasy jako znak gwiazdki (*).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.UseSystemPasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
      </Docs>
    </Member>
    <Member MemberName="EditPositionCount">
      <MemberSignature Language="C#" Value="public int EditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.EditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę pozycji można edytować ciągu w formacie.</summary>
        <value>
          <see cref="T:System.Int32" /> Zawierające liczbę pozycji można edytować ciągu w formacie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Całkowita liczba pozycji znaku można edytować, reprezentowany przez <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> właściwości, musi być równa sumie <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> i <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> właściwości. Ta wartość obejmuje wymaganych i opcjonalnych można edytować znaków.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="EditPositions">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator EditPositions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator EditPositions" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EditPositions As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerator ^ EditPositions { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EditPositions : System.Collections.IEnumerator" Usage="System.ComponentModel.MaskedTextProvider.EditPositions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nowo utworzony moduł wyliczający dla edytowalnego pozycji w ciągu sformatowana.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" /> Obsługującej wyliczenie za pośrednictwem można edytować pozycje ciągu w formacie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na dostęp każdy <xref:System.ComponentModel.MaskedTextProvider.EditPositions%2A> właściwość kolekcji tymczasowej można edytować pozycji zostanie utworzony pobranej <xref:System.Collections.IEnumerator> działa na.  
  
 Ta kolekcja jest tylko do odczytu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindAssignedEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindAssignedEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindAssignedEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAssignedEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindAssignedEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindAssignedEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindAssignedEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w sformatowany ciąg ma się rozpocząć wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pozycję pierwszego przypisane pozycji można edytować po określonej pozycji za pomocą kierunek określony wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczona od zera pozycja pierwszego przypisane można edytować pozycji napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg sformatowany składa się z można edytować znaków i literały skopiowanych z maską. Położenie znaku można edytować albo zostanie jest zajmowany przez znaku zgłoszenia skopiowane z maski, jeśli są one nieprzypisane lub nieprawidłowy znak wejściowy ma przypisanym danych wejściowych.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom%2A> Metoda jest używana do wyszukiwania pierwszego znaku przypisanej po określonym kierunku pozycji i wyszukiwania. Wynik później mogą być przekazywane jako parametr <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania przypisanej wartości w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> i <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom%2A> metody są uzupełnia tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindAssignedEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindAssignedEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindAssignedEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAssignedEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindAssignedEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindAssignedEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindAssignedEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczony od zera pozycja w ciąg sformatowany miejsce rozpoczęcia wyszukiwania.</param>
        <param name="endPosition">Liczona od zera pozycja ciągu w formacie, gdy kończy się wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pozycję pierwszego przypisane można edytować pozycji między określonych pozycji za pomocą kierunek określony wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczona od zera pozycja pierwszego przypisane można edytować pozycji napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg sformatowany składa się z można edytować znaków i literały skopiowanych z maską. Położenie znaku można edytować albo zostanie jest zajmowany przez znaku zgłoszenia skopiowane z maski, jeśli są one nieprzypisane lub nieprawidłowy znak wejściowy ma przypisanym danych wejściowych.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange%2A> Metoda jest używana do wyszukiwania pierwszego znaku przypisanej między dwóch określonych pozycji, włącznie, za pomocą kierunek określony wyszukiwania. Wynik później mogą być przekazywane jako parametr <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania przypisanej wartości w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> i <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange%2A> metody są uzupełnia tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w sformatowany ciąg ma się rozpocząć wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pierwszą pozycję można edytować po określonej pozycji za pomocą kierunek określony wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczony od zera pozycja pierwszą pozycję można edytować napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A> Metoda jest używana do wyszukiwania następnej przypisane lub nieprzypisane można edytować pozycji w ciągu sformatowaną po określonej pozycji.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> Metody jest uzupełnienia tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczony od zera pozycja w ciąg sformatowany miejsce rozpoczęcia wyszukiwania.</param>
        <param name="endPosition">Liczona od zera pozycja ciągu w formacie, gdy kończy się wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pierwszą pozycję można edytować między określonych pozycji za pomocą kierunek określony wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczony od zera pozycja pierwszą pozycję można edytować napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange%2A> Metoda jest używana do wyszukiwania pierwszego znaku można edytować między dwóch określonych pozycji, włącznie, za pomocą kierunek określony wyszukiwania. Wynik później mogą być przekazywane jako parametr <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania przypisanej wartości w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> Metody jest uzupełnienia tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindNonEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindNonEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindNonEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNonEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindNonEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindNonEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindNonEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w sformatowany ciąg ma się rozpocząć wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pierwszą pozycję nieedytowalnego po określonej pozycji za pomocą kierunek określony wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczony od zera pozycja pierwszą pozycję literału napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> Metoda jest używana do wyszukiwania następnej znak w ciągu sformatowaną po określonej pozycji. Wynik później mogą być przekazywane jako parametr <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora, aby uzyskać wartość literału w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A> Metody jest uzupełnienia tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindNonEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindNonEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindNonEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNonEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindNonEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindNonEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindNonEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczony od zera pozycja w ciąg sformatowany miejsce rozpoczęcia wyszukiwania.</param>
        <param name="endPosition">Liczona od zera pozycja ciągu w formacie, gdy kończy się wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pierwszą pozycję nieedytowalnego między określonych pozycji za pomocą kierunek określony wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczony od zera pozycja pierwszą pozycję literału napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> Metoda jest używana do wyszukiwania pierwszy znak między dwóch określonych pozycji, włącznie, za pomocą kierunek określony wyszukiwania. Wynik później mogą być przekazywane jako parametr <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora, aby uzyskać wartość literału w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange%2A> Metody jest uzupełnienia tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindUnassignedEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindUnassignedEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindUnassignedEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindUnassignedEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindUnassignedEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindUnassignedEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindUnassignedEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w sformatowany ciąg ma się rozpocząć wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pierwszą pozycję można edytować nieprzypisany po określonej pozycji za pomocą kierunek określony wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczony od zera pozycja pierwszą pozycję można edytować nieprzypisany napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg sformatowany składa się z można edytować znaków i literały skopiowanych z maską. Położenie znaku można edytować albo zostanie jest zajmowany przez znaku zgłoszenia skopiowane z maski, jeśli są one nieprzypisane lub nieprawidłowy znak wejściowy ma przypisanym danych wejściowych.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom%2A> Metoda jest używana do wyszukiwania dla pierwszego znaku nieprzypisane po określonym kierunku pozycji i wyszukiwania. Znak monitu powinny zajmować tej pozycji.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> i <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom%2A> metody są uzupełnia tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindUnassignedEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindUnassignedEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindUnassignedEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindUnassignedEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindUnassignedEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindUnassignedEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindUnassignedEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczony od zera pozycja w ciąg sformatowany miejsce rozpoczęcia wyszukiwania.</param>
        <param name="endPosition">Liczona od zera pozycja ciągu w formacie, gdy kończy się wyszukiwanie.</param>
        <param name="direction">A <see cref="T:System.Boolean" /> wskazujący wyszukiwania kierunek; albo <see langword="true" /> wyszukiwania do przodu lub <see langword="false" /> wyszukiwania do tyłu.</param>
        <summary>Zwraca pierwszą pozycję można edytować nieprzypisany między określonych pozycji za pomocą kierunek określony wyszukiwania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.Int32" /> reprezentujący liczony od zera pozycja pierwszą pozycję można edytować nieprzypisany napotkano; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg sformatowany składa się z można edytować znaków i literały skopiowanych z maską. Położenie znaku można edytować albo zostanie jest zajmowany przez znaku zgłoszenia skopiowane z maski, jeśli są one nieprzypisane lub nieprawidłowy znak wejściowy ma przypisanym danych wejściowych.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange%2A> Metoda jest używana do wyszukiwania dla pierwszego znaku nieprzypisane między dwóch określonych pozycji, włącznie, za pomocą kierunek określony wyszukiwania. Znak monitu powinny zajmować tej pozycji.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> i <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange%2A> metody są uzupełnia tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetOperationResultFromHint">
      <MemberSignature Language="C#" Value="public static bool GetOperationResultFromHint (System.ComponentModel.MaskedTextResultHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetOperationResultFromHint(valuetype System.ComponentModel.MaskedTextResultHint hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint(System.ComponentModel.MaskedTextResultHint)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOperationResultFromHint (hint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetOperationResultFromHint(System::ComponentModel::MaskedTextResultHint hint);" />
      <MemberSignature Language="F#" Value="static member GetOperationResultFromHint : System.ComponentModel.MaskedTextResultHint -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint hint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hint" Type="System.ComponentModel.MaskedTextResultHint" />
      </Parameters>
      <Docs>
        <param name="hint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> wartość zazwyczaj uzyskiwane jako parametr wyjściowy z poprzedniej operacji.</param>
        <summary>Określa, czy określony <see cref="T:System.ComponentModel.MaskedTextResultHint" /> oznacza powodzenie lub niepowodzenie.</summary>
        <returns>
          <see langword="true" /> Jeśli określony <see cref="T:System.ComponentModel.MaskedTextResultHint" /> wartość reprezentuje pomyślnie; w przeciwnym razie <see langword="false" /> Jeśli termin reprezentuje awarii.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujące metody <xref:System.ComponentModel.MaskedTextProvider> klasa zawiera parametr typu <xref:System.ComponentModel.MaskedTextResultHint> używany do wypełniania wyjściowego informacje na temat operacji metody: <xref:System.ComponentModel.MaskedTextProvider.Add%2A>, <xref:System.ComponentModel.MaskedTextProvider.Clear%2A>, <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A>, <xref:System.ComponentModel.MaskedTextProvider.Remove%2A>, <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A>, <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> , <xref:System.ComponentModel.MaskedTextProvider.Set%2A>, <xref:System.ComponentModel.MaskedTextProvider.VerifyChar%2A>, i <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A>. <xref:System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint%2A> Metoda interpretuje tę wartość i zwraca wartość logiczną wskazującą, czy <xref:System.ComponentModel.MaskedTextResultHint> zasygnalizują, że operacja zakończyła się powodzenie lub niepowodzenie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.MaskedTextResultHint" />
      </Docs>
    </Member>
    <Member MemberName="IncludeLiterals">
      <MemberSignature Language="C#" Value="public bool IncludeLiterals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeLiterals" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeLiterals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeLiterals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeLiterals : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy mają być uwzględniane znaki maski wprowadzania ciągu w formacie.</summary>
        <value>
          <see langword="true" /> Jeśli literały są uwzględniane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości określi, czy znaki monitu i literału są wyświetlane podczas wywoływania metody <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody. Przez ustawienie obu tych właściwości na `false`, analizowany ciąg będzie reprezentować tylko znaków wprowadzonych przez użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="IncludePrompt">
      <MemberSignature Language="C#" Value="public bool IncludePrompt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludePrompt" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludePrompt As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludePrompt { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludePrompt : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IncludePrompt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="P:System.Windows.Forms.MaskedTextBox.PromptChar" /> jest używana do reprezentowania braku danych wejściowych podczas wyświetlania sformatowanego ciągu użytkownika.</summary>
        <value>
          <see langword="true" /> Jeśli znak monitu jest używana do reprezentowania pozycji, których nie ma danych wprowadzonych przez użytkownika został podany; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości określi, czy znaki monitu i literału są wyświetlane podczas wywoływania metody <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody. Przez ustawienie obu tych właściwości na `false`, analizowany ciąg będzie reprezentować tylko znaków wprowadzonych przez użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertAt">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia znak lub ciągu na określonej pozycji w ciągu sformatowana.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : char * int -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Do wstawienia.</param>
        <param name="position">Liczony od zera pozycja w ciągu sformatowaną Wstaw znak.</param>
        <summary>Wstawia określony znak na określonej pozycji w ciągu sformatowana.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawienie powiodło się; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Metody Wstawia znak na pierwszą pozycję Edytuj w tym miejscu lub ponad określona przez `pos` parametru. Ta metoda zostanie przesunięte wszystkie istniejące znaki po punktu wstawiania przez jedną pozycję, aby zwolnić miejsce dla wstawionego `input` znaków. Jeśli wystąpi jedno z następujących błędów, wstawiania nie jest wykonywane, i metoda zwraca `false`.  
  
-   `pos` Parametrów jest mniejsza niż zero lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie można odnaleźć znaku można edytować ciągu w formacie na lub po określonej pozycji `pos`.  
  
-   Znak wstawiania `input`, nie jest prawidłowy znak wejściowy, ponieważ nie jest drukowania lub jest niezgodny z jej odpowiadającego mu elementu maski.  
  
-   Brak nie dostępnych pozycji z prawej strony punktu wstawiania, aby nie można przesunąć istniejące znaki.  
  
-   Przesunięcie istniejące znaki dałby w efekcie naruszenie maski.  
  
 Pusta `input` ciągu nie spowoduje zmiany w sformatowany ciąg, ale zwraca `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (string input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(string input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As String, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(System::String ^ input, int position);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : string * int -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Do wstawienia.</param>
        <param name="position">Liczony od zera pozycja w sformatowany ciąg, aby wstawić ciąg wejściowy.</param>
        <summary>Wstawia określony ciąg na określonej pozycji w ciągu sformatowana.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawienie powiodło się; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Metody wstawia każdego znaku z `input` ciąg na pozycje edycji znajdujący się w pozycji `pos` i nowszych. Ta metoda zostanie przesunięte wszystkie istniejące znaki po znaku wstawione przez jedną pozycję dla każdego punktu wstawiania. Jeśli wystąpi jedno z następujących błędów, wstawiania nie jest wykonywane, i metoda zwraca `false`.  
  
-   `pos` Parametrów jest mniejsza niż zero lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Istnieje nieedytowalny wystarczająco znaków ciągu w formacie na lub po określonej pozycji `pos`, aby wstawić wszystkie znaki od `input` ciągu.  
  
-   Co najmniej jeden znak wstawiania nie są prawidłowy znak wejściowy ponieważ nie są drukowania lub ich odpowiadającego mu elementu maska nie są zgodne.  
  
-   Nie ma wystarczająco dużo pozycji z prawej strony punktu wstawiania, aby nie można przesunąć istniejące znaki.  
  
-   Przesunięcie istniejące znaki dałby w efekcie naruszenie maski. Należy pamiętać, że ta zmieni występuje podczas wstawiania każdy znak oddzielnie.  
  
 Pusta `input` ciągu nie spowoduje zmiany w sformatowany ciąg, ale zwraca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (char input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(char input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.Char,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As Char, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(char input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : char * int *  *  -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Do wstawienia.</param>
        <param name="position">Liczony od zera pozycja w ciągu sformatowaną Wstaw znak.</param>
        <param name="testPosition">Jeśli metoda zakończy się pomyślnie, ostatni umieść gdzie wstawione znaku; w przeciwnym razie pierwszy pozycji, których wstawienie nie powiodło się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> krótkiej formie opisujący wynik operacji wstawiania. Parametr wyjściowy.</param>
        <summary>Wstawia określony znak na określonej pozycji w ciągu sformatowaną, zwracanie ostatniej pozycji wstawiania i stan operacji.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawienie powiodło się; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Metody Wstawia znak na pierwszą pozycję Edytuj w tym miejscu lub ponad określona przez `pos` parametru. Ta metoda zostanie przesunięte wszystkie istniejące znaki po punktu wstawiania przez jedną pozycję, aby zwolnić miejsce dla wstawionego `input` znaków. Jeśli wystąpi jedno z następujących błędów, wstawiania nie jest wykonywane, i metoda zwraca `false`.  
  
-   `pos` Parametrów jest mniejsza niż zero lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie można odnaleźć znaku można edytować ciągu w formacie na lub po określonej pozycji `pos`.  
  
-   Znak wstawiania `input`, nie jest prawidłowy znak wejściowy, ponieważ nie jest drukowania lub jest niezgodny z jej odpowiadającego mu elementu maski.  
  
-   Brak nie dostępnych pozycji z prawej strony punktu wstawiania, aby nie można przesunąć istniejące znaki.  
  
-   Przesunięcie istniejące znaki dałby w efekcie naruszenie maski.  
  
 Pusta `input` ciągu nie spowoduje zmiany w sformatowany ciąg, ale zwraca `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (string input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(string input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.String,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As String, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(System::String ^ input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : string * int *  *  -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Do wstawienia.</param>
        <param name="position">Liczony od zera pozycja w sformatowany ciąg, aby wstawić ciąg wejściowy.</param>
        <param name="testPosition">Jeśli metoda zakończy się pomyślnie, ostatni umieść gdzie wstawione znaku; w przeciwnym razie pierwszy pozycji, których wstawienie nie powiodło się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> krótkiej formie opisujący wynik operacji wstawiania. Parametr wyjściowy.</param>
        <summary>Wstawia określony ciąg na określonej pozycji w ciągu sformatowaną, zwracanie ostatniej pozycji wstawiania i stan operacji.</summary>
        <returns>
          <see langword="true" /> Jeśli wstawienie powiodło się; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Metody wstawia każdego znaku z `input` ciąg na pozycje edycji znajdujący się w pozycji `pos` i nowszych. Ta metoda zostanie przesunięte wszystkie istniejące znaki po znaku wstawione przez jedną pozycję dla każdego punktu wstawiania. Jeśli wystąpi jedno z następujących błędów, wstawiania nie jest wykonywane, i metoda zwraca `false`.  
  
-   `pos` Parametrów jest mniejsza niż zero lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Istnieje nieedytowalny wystarczająco znaków ciągu w formacie na lub po określonej pozycji `pos`, aby wstawić wszystkie znaki od `input` ciągu.  
  
-   Co najmniej jeden znak wstawiania nie są prawidłowy znak wejściowy ponieważ nie są drukowania lub ich odpowiadającego mu elementu maska nie są zgodne.  
  
-   Nie ma wystarczająco dużo pozycji z prawej strony punktu wstawiania, aby nie można przesunąć istniejące znaki.  
  
-   Przesunięcie istniejące znaki dałby w efekcie naruszenie maski. Należy pamiętać, że ta zmieni występuje podczas wstawiania każdy znak oddzielnie.  
  
 Pusta `input` ciągu nie spowoduje zmiany w sformatowany ciąg, ale zwraca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InvalidIndex">
      <MemberSignature Language="C#" Value="public static int InvalidIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 InvalidIndex" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InvalidIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int InvalidIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InvalidIndex : int" Usage="System.ComponentModel.MaskedTextProvider.InvalidIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera górna granica zakresu nieprawidłowy indeksów.</summary>
        <value>Wartość reprezentująca największy nieprawidłowy indeks, zgodnie z ustaleniami implementacja dostawcy. Na przykład jeśli najniższy prawidłowy indeks ma wartość 0, ta właściwość Zwróć -1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.InvalidIndex%2A> Właściwość jest używana do reprezentowania wynik, który jest nieprawidłowy dla operacji indeksowania, takich jak <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> metody.  
  
 Gdy korzystają z dostawcy lub implementować własnych, należy używać tej właściwości decyzji o tym, jeśli indeks jest nieprawidłowy, zamiast kodować wiedzy z nieprawidłowymi wartościami.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsAvailablePosition">
      <MemberSignature Language="C#" Value="public bool IsAvailablePosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAvailablePosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAvailablePosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAvailablePosition(int position);" />
      <MemberSignature Language="F#" Value="member this.IsAvailablePosition : int -&gt; bool" Usage="maskedTextProvider.IsAvailablePosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w masce do testowania.</param>
        <summary>Określa, czy określona pozycja jest dostępne do przypisania.</summary>
        <returns>
          <see langword="true" /> Jeśli określonej pozycji w ciągu sformatowaną można edytować, a nie został przypisany do jeszcze; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.IsAvailablePosition%2A> Metoda zwraca `true` tylko wtedy, gdy spełnione są wszystkie poniższe warunki:  
  
-   `pos` Parametru znajduje się w granicach ciąg sformatowany; jego wartość jest większa niż lub równa zero i mniejsza niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Określona pozycja jest znakiem można edytować.  
  
-   Znak nie ma już przypisane do tej pozycji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsEditPosition">
      <MemberSignature Language="C#" Value="public bool IsEditPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEditPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEditPosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEditPosition(int position);" />
      <MemberSignature Language="F#" Value="member this.IsEditPosition : int -&gt; bool" Usage="maskedTextProvider.IsEditPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja w masce do testowania.</param>
        <summary>Określa, czy można edytować określonej pozycji.</summary>
        <returns>
          <see langword="true" /> w przypadku określonej pozycji w ciągu sformatowaną można edytować; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.IsEditPosition%2A> Metoda zwraca `true` tylko wtedy, gdy są spełnione oba poniższe warunki:  
  
-   `pos` Parametru znajduje się w granicach ciąg sformatowany; jego wartość jest większa niż lub równa zero i mniejsza niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Określona pozycja jest znakiem można edytować.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsPassword">
      <MemberSignature Language="C#" Value="public bool IsPassword { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPassword" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPassword As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPassword { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPassword : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IsPassword" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy ochrona za pomocą hasła powinny być stosowane do sformatowanego ciągu.</summary>
        <value>
          <see langword="true" /> Jeśli ciąg wejściowy jest traktowane jako ciąg hasła. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ochrona za pomocą hasła może być inicjowana przy użyciu jednej z następujących sposobów:  
  
-   Ustawienie <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości niż`null` wartości.  
  
-   Ustawienie <xref:System.ComponentModel.MaskedTextProvider.IsPassword%2A> właściwości `true`., który określa również <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości <xref:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar%2A> wartość.  
  
 <xref:System.ComponentModel.MaskedTextProvider.IsPassword%2A> jest używany przez <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metod w celu ustalenia, czy Wyświetl znakom wejściowy lub przesłaniać je za pomocą <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="IsValidInputChar">
      <MemberSignature Language="C#" Value="public static bool IsValidInputChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidInputChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidInputChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidInputChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidInputChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidInputChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Char" /> Wartość do sprawdzenia.</param>
        <summary>Określa, czy określony znak jest nieprawidłowy znak wejściowy.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak zawiera prawidłową wartość wejściowa; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe znaki wejściowych obejmują wszystkie drukowalne znaki, które zawierają litery, cyfry, znaki interpunkcyjne, symbole i znaku spacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="IsValidMaskChar">
      <MemberSignature Language="C#" Value="public static bool IsValidMaskChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidMaskChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidMaskChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidMaskChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidMaskChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidMaskChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Char" /> Wartość do sprawdzenia.</param>
        <summary>Określa, czy określony znak jest znak prawidłową maskę.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak zawiera wartość prawidłową maskę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowa maska znaki to wszystkich znaków drukowalnych, które obejmują litery, cyfry, znaki interpunkcyjne, symbole i znaku spacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="IsValidPasswordChar">
      <MemberSignature Language="C#" Value="public static bool IsValidPasswordChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidPasswordChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidPasswordChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidPasswordChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidPasswordChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidPasswordChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Char" /> Wartość do sprawdzenia.</param>
        <summary>Określa, czy określony znak jest znak prawidłowe hasło.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak zawiera wartość prawidłowego hasła; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki prawidłowe hasło to wszystkich znaków drukowalnych i znak null, która jest używana do wyłączenia funkcji hasła. Drukowalne znaki to litery, cyfry, znaki interpunkcyjne, symbole i znaku spacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : char" Usage="System.ComponentModel.MaskedTextProvider.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu do pobrania.</param>
        <summary>Pobiera element w określonej pozycji w ciągu sformatowana.</summary>
        <value>
          <see cref="T:System.Char" /> w określonej pozycji w ciągu sformatowana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Właściwość jest standardowe indeksatora dla <xref:System.ComponentModel.MaskedTextProvider> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> jest większa niż zero lub większa niż <see cref="P:System.ComponentModel.MaskedTextProvider.Length" /> maski.</exception>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
      </Docs>
    </Member>
    <Member MemberName="LastAssignedPosition">
      <MemberSignature Language="C#" Value="public int LastAssignedPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LastAssignedPosition" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastAssignedPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LastAssignedPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LastAssignedPosition : int" Usage="System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera indeks maski po prawej stronie znak wejściowy przypisany do maski.</summary>
        <value>Jeśli co najmniej jeden znak wejściowy został przypisany do maski, <see cref="T:System.Int32" /> zawierających indeks po prawej stronie przypisane pozycji; w przeciwnym razie, jeśli przypisano pozycji, <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> Właściwość reprezentuje najdalszych pozycji edycji do maski pokrewny ze źródłem, przypisany znak wejściowy. Dla języków odczytu od lewej do prawej (od lewej do prawej), takich jak angielski to po prawej stronie przypisane pozycji; dla języków odczytać od prawej do lewej (od prawej do lewej) to pozycja po lewej stronie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.ComponentModel.MaskedTextProvider.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość maski, go nie ma żadnych maska modyfikator znaków.</summary>
        <value>
          <see cref="T:System.Int32" /> Zawierające liczbę pozycji maski, z wyjątkiem znaków, które modyfikują maska wprowadzania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Length%2A> Właściwość reprezentuje całkowita liczba znaków w masce literału i edytować znaków. Liczba znaków w literale można ustalić przez odjęcie wartości <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> z <xref:System.ComponentModel.MaskedTextProvider.Length%2A>.  
  
 <xref:System.ComponentModel.MaskedTextProvider.Length%2A> opisano również długość ciągu sformatowaną, w tym wprowadzanie znaków, literały i znaki monitu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="Mask">
      <MemberSignature Language="C#" Value="public string Mask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Mask" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Mask" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mask As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Mask { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Mask : string" Usage="System.ComponentModel.MaskedTextProvider.Mask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maska wprowadzania.</summary>
        <value>A <see cref="T:System.String" /> maską pełna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> Właściwość jest ustawiona <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> konstruktora. Ta maska musi zawierać tylko prawidłowe znaki, zgodnie z definicją w języku maskowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.#ctor" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clone" />
      </Docs>
    </Member>
    <Member MemberName="MaskCompleted">
      <MemberSignature Language="C#" Value="public bool MaskCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaskCompleted" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaskCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaskCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MaskCompleted : bool" Usage="System.ComponentModel.MaskedTextProvider.MaskCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wprowadzono wszystkie wymagane dane wejściowe do sformatowanego ciągu.</summary>
        <value>
          <see langword="true" /> Jeżeli wprowadzono wszystkie wymagane dane wejściowe do maski; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> Właściwość sprawdza tylko wymagane elementy wejściowe. Aby określić, czy wprowadzono wszystkich wymaganych i opcjonalnych elementów wejściowych, użyj <xref:System.Windows.Forms.MaskedTextBox.MaskFull%2A?displayProperty=nameWithType> właściwości <xref:System.Windows.Forms.MaskedTextBox> zamiast klasy.  
  
 Bieżąca wartość <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwość określa, które formatowania elementy są uważane za wymaganych i opcjonalnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskCompleted" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="MaskFull">
      <MemberSignature Language="C#" Value="public bool MaskFull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaskFull" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaskFull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaskFull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MaskFull : bool" Usage="System.ComponentModel.MaskedTextProvider.MaskFull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wprowadzono wszystkich danych wejściowych wymaganych i opcjonalnych w ciąg sformatowany.</summary>
        <value>
          <see langword="true" /> Jeśli zostały wprowadzone wszystkich danych wejściowych wymaganych i opcjonalnych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby sprawdzić, jeśli tylko wymaganych elementów wejściowych zostały wprowadzone, należy użyć <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> właściwości zamiast tego. Bieżąca wartość <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwość określa, które formatowania elementy są uważane za wymaganych i opcjonalnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="PasswordChar">
      <MemberSignature Language="C#" Value="public char PasswordChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      <MemberSignature Language="VB.NET" Value="Public Property PasswordChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char PasswordChar { char get(); void set(char value); };" />
      <MemberSignature Language="F#" Value="member this.PasswordChar : char with get, set" Usage="System.ComponentModel.MaskedTextProvider.PasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znak można podstawić rzeczywiste znaki wejściowego.</summary>
        <value>
          <see cref="T:System.Char" /> Wartość używana jako znak hasła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane wejściowe użytkownika poufnych jest powszechną praktyką było Ukryj rzeczywiste wprowadzonej przez użytkownika podczas operacji wyjścia. Jeśli <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwość jest ustawiona na innej`null` znaków, takich jak dane wyjściowe metody <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> będzie przesłaniać wprowadzanie znaków znakiem określonego hasła. Ustawienie tej właściwości na `null` spowoduje wyłączenie funkcji ochrony hasła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Określony znak hasła, gdy ustawienie dla tej właściwości jest taka sama jak bieżący znak monitu, <see cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />. Dwa muszą się różnić.</exception>
        <exception cref="T:System.ArgumentException">Znak określony, gdy ustawienie dla tej właściwości nie jest prawidłowe hasło znakiem, zgodnie z ustaleniami <see cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" /> metody.</exception>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PromptChar">
      <MemberSignature Language="C#" Value="public char PromptChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PromptChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
      <MemberSignature Language="VB.NET" Value="Public Property PromptChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char PromptChar { char get(); void set(char value); };" />
      <MemberSignature Language="F#" Value="member this.PromptChar : char with get, set" Usage="System.ComponentModel.MaskedTextProvider.PromptChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znak używany do reprezentowania braku danych wejściowych użytkownika dla wszystkich pozycji dostępnych edycji.</summary>
        <value>Znak używany do monit o podanie danych wejściowych. Wartość domyślna to znaku podkreślenia (_).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> Właściwość reprezentuje znak monitu, który jest używany przez <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody do reprezentowania bieżący stan sformatowany ciąg wejściowy. Znak monitu jest umieszczany w edycji miejsca, w których nie masz jeszcze przypisanej wartości wejściowej. Niektóre wersje <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zależy także wartość <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Znak monitu określone, gdy ustawienie dla tej właściwości jest taka sama jak bieżący znak hasła <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />. Dwa muszą się różnić.</exception>
        <exception cref="T:System.ArgumentException">Znak określony, gdy ustawienie dla tej właściwości nie jest prawidłowe hasło znakiem, zgodnie z ustaleniami <see cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" /> metody.</exception>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa ostatni znak przypisanej z sformatowanego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; bool" Usage="maskedTextProvider.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa ostatni znak przypisanej z sformatowanego ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> — Metoda nie ma efektu Jeśli nie są znaki jeszcze przypisany do maski.  
  
 Ostatni znak przypisanej zostanie usunięty z sformatowany ciąg znaków, znaków maski można edytować jest zresetowanie dla tej pozycji, umożliwiając kolejnych danych wejściowych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove([out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Remove(System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove([Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Remove :  *  -&gt; bool" Usage="maskedTextProvider.Remove (testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="testPosition">Liczony od zera pozycja ciągu w formacie, gdy znak rzeczywiście zostały usunięte. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Usuwa ostatni znak przypisanej sformatowanego ciągu, a następnie wyprowadza usuwania pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> — Metoda nie ma efektu Jeśli nie są znaki jeszcze przypisany do maski.  
  
 Ostatni znak przypisanej zostanie usunięty z sformatowany ciąg znaków, znaków maski można edytować jest zresetowanie dla tej pozycji, umożliwiając kolejnych danych wejściowych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveAt">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa co najmniej jeden znak przypisanej z sformatowanego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int position);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; bool" Usage="maskedTextProvider.RemoveAt position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera pozycja znaku przypisanej do usunięcia.</param>
        <summary>Usuwa z sformatowanego ciągu przypisanej znak na określonej pozycji.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> — Metoda nie ma efektu Jeśli nie są przypisane znaki na określonej pozycji usuwania. Ta metoda nie dotyczy literał znaków.  
  
 Znak zostanie usunięty, pozostałe znaki wyższej znajduje się w masce przesunie się w lewo, aby wypełnić przerwy utworzone przez operację usunięcia. Vacated pozycje są resetowane dla danych wejściowych. Jeśli przepływ znaków nie może zgodnie z definicją maski, bez usuwania występuje, i <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zwraca `false`.  
  
 Wywołanie tej metody jest dokładnym odpowiednikiem następujące wywołanie przeciążonej <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%28System.Int32%2CSystem.Int32%29> wersji:  
  
 `RemoveAt(pos, pos);`  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int startPosition, int endPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 startPosition, int32 endPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (startPosition As Integer, endPosition As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int startPosition, int endPosition);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int * int -&gt; bool" Usage="maskedTextProvider.RemoveAt (startPosition, endPosition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczony od zera indeks pierwszego znaku przypisanej do usunięcia.</param>
        <param name="endPosition">Liczony od zera indeks ostatni znak przypisanej do usunięcia.</param>
        <summary>Usuwa przypisanej znaki od określonej pozycji z sformatowanego ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> — Metoda nie ma efektu Jeśli nie są przypisane znaki w miejscach usuwania.  
  
 Znak zostanie usunięty, pozostałe znaki wyższej znajduje się w masce przesunie się w lewo, aby wypełnić przerwy utworzone przez operację usunięcia. Vacated pozycje są resetowane dla danych wejściowych. Jeśli przepływ znaków nie może zgodnie z definicją maski, bez usuwania występuje, i <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zwraca `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int * int *  *  -&gt; bool" Usage="maskedTextProvider.RemoveAt (startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczony od zera indeks pierwszego znaku przypisanej do usunięcia.</param>
        <param name="endPosition">Liczony od zera indeks ostatni znak przypisanej do usunięcia.</param>
        <param name="testPosition">W przypadku powodzenia liczony od zera pozycja w sformatowany ciąg gdzie znaki rzeczywiście zostały usunięte; w przeciwnym razie pierwszy pozycji, których działanie nie powiodło się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Usuwa przypisanej znaki od określonej pozycji z sformatowanego ciągu, a następnie generuje usuwania pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> — Metoda nie ma efektu Jeśli nie są przypisane znaki w miejscach usuwania.  
  
 Znak zostanie usunięty, pozostałe znaki wyższej znajduje się w masce przesunie się w lewo, aby wypełnić przerwy utworzone przez operację usunięcia. Vacated pozycje są resetowane dla danych wejściowych. Jeśli przepływ znaków nie może zgodnie z definicją maski, bez usuwania występuje, i <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zwraca `false`.  
  
 Ta wersja <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zawiera dwa parametry dodatkowe dane wyjściowe, aby przekazać więcej informacji na temat operacji metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamienia co najmniej jeden znak można edytować ciągu w formacie określonych znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int -&gt; bool" Usage="maskedTextProvider.Replace (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Wartość, która zastępuje istniejącą wartość.</param>
        <param name="position">Liczony od zera pozycja wyszukiwania dla pierwszego znaku można edytować w celu zastąpienia.</param>
        <summary>Określona wartość znaku zastępuje pojedynczy znak w tym miejscu lub poza określonej pozycji.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie zastąpił; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%29> Metody wyszukuje pierwszą pozycję można edytować ciągu w formacie na lub po określonej pozycji `pos`. Jeśli został znaleziony, wartość można edytować pozycji zostanie zmieniona na określony znak `input`. Dowolny z następujących warunków spowoduje błąd, który powoduje, że nie można zastąpić do wykonania i wartości `false` zwracaną:  
  
-   `pos` Parametrów jest mniejsza niż zero lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie można odnaleźć znaku można edytować ciągu w formacie na lub po określonej pozycji `pos`.  
  
-   Znak zastępczy `input`, nie jest prawidłowy znak wejściowy, ponieważ nie jest drukowania lub jest niezgodny z jej odpowiadającego mu elementu maski.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int position);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int -&gt; bool" Usage="maskedTextProvider.Replace (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Używany do zastępowania istniejącego znaków można edytować wartość.</param>
        <param name="position">Liczony od zera pozycja wyszukiwania dla pierwszego znaku można edytować w celu zastąpienia.</param>
        <summary>Zastępuje można edytować znaków, zaczynając od określonej pozycji z określonego ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie znaki pomyślnie zostały zastąpione. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%29> Metody wyszukuje pierwszą pozycję można edytować w tym miejscu lub poza określonej pozycji `pos`. Działają przy założeniu, że ma wystarczającej liczby pozycji można edytować po tym punkcie, istniejące wartości znakowych są zastąpionego kolei zawartość parametru ciąg zastępczy, `input`.  
  
 Poniższe warunki są traktowane jako błędy. Jeśli wystąpi błąd, nie jest zastępowana i <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%29> zwraca `false`.  
  
-   `pos` Parametrów jest mniejsza niż zero lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie ma wystarczającej liczby pozycji można edytować w sformatowanego ciągu do przechowywania zawartości ciąg zastępczy.  
  
-   Jedna z wartości znak zastępczy, jest nieprawidłowy, ponieważ nie jest drukowania, lub jest niezgodny z jej odpowiadającego mu elementu maski.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Wartość, która zastępuje istniejącą wartość.</param>
        <param name="position">Liczony od zera pozycja wyszukiwania dla pierwszego znaku można edytować w celu zastąpienia.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja ciągu w formacie, na którym ostatni znak faktycznie został zastąpiony; w przeciwnym razie pierwszy pozycji, których działanie nie powiodło się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> krótkiej formie opisujący wynik operacji wymiany. Parametr wyjściowy.</param>
        <summary>Zastępuje pojedynczy znak w tym miejscu lub ponad określona pozycja określona wartość znaku, a następnie generuje usuwania pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie zastąpił; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metody wyszukuje pierwszą pozycję można edytować ciągu w formacie na lub po określonej pozycji `pos`. Jeśli został znaleziony, wartość można edytować pozycji zostanie zmieniona na określony znak `input`. Dowolny z następujących warunków spowoduje błąd, co powoduje, że nie można zastąpić do wykonania i wartości `false` zwracaną:  
  
-   `pos` Parametrów jest mniejsza niż zero lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie można odnaleźć znaku można edytować ciągu w formacie na lub po określonej pozycji `pos`.  
  
-   Znak zastępczy `input`, nie jest prawidłowy znak wejściowy, ponieważ nie jest drukowania lub jest niezgodny z jej odpowiadającego mu elementu maski.  
  
 Oprócz zwracanej wartości ta metoda ma dwa parametry wyjściowe o podanie dodatkowych informacji na temat operacji wymiany.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Używany do zastępowania istniejącego znaków można edytować wartość.</param>
        <param name="position">Liczony od zera pozycja wyszukiwania dla pierwszego znaku można edytować w celu zastąpienia.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja ciągu w formacie, na którym ostatni znak faktycznie został zastąpiony; w przeciwnym razie pierwszy pozycji, których działanie nie powiodło się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> krótkiej formie opisujący wynik operacji wymiany. Parametr wyjściowy.</param>
        <summary>Zastępuje zakres znaków można edytować, zaczynając od określonej pozycji z określonego ciągu, a następnie generuje usuwania pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie znaki pomyślnie zostały zastąpione. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metody wyszukuje pierwszą pozycję można edytować w tym miejscu lub poza określonej pozycji `pos`. Działają na założeniu, że ma wystarczającej liczby pozycji można edytować po tym punkcie, istniejące wartości znakowych są zastąpionego kolei zawartość parametru ciąg zastępczy, `input`.  
  
 Poniższe warunki są traktowane jako błędy. Jeśli wystąpi błąd, nie jest zastępowana i <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> zwraca `false`.  
  
-   `pos` Parametrów jest mniejsza niż zero lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu.  
  
-   Nie ma wystarczającej liczby pozycji można edytować w sformatowanego ciągu do przechowywania zawartości ciąg zastępczy.  
  
-   Jedna z wartości znak zastępczy, jest nieprawidłowy, ponieważ nie jest drukowania, lub jest niezgodny z jej odpowiadającego mu elementu maski.  
  
 Oprócz zwracanej wartości ta metoda ma dwa parametry wyjściowe o podanie dodatkowych informacji na temat operacji wymiany.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Wartość, która zastępuje istniejącą wartość.</param>
        <param name="startPosition">Liczona od zera pozycja ciągu w formacie, gdy rozpoczyna się zastąpienia.</param>
        <param name="endPosition">Liczona od zera pozycja ciągu w formacie, gdy kończy się zastąpienia.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja ciągu w formacie, na którym ostatni znak faktycznie został zastąpiony; w przeciwnym razie pierwszy pozycji, których działanie nie powiodło się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> krótkiej formie opisujący wynik operacji wymiany. Parametr wyjściowy.</param>
        <summary>Zastępuje pojedynczy znak między określonym rozpoczęcia i zakończenia pozycji z określona wartość znaku, a następnie generuje usuwania pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został pomyślnie zastąpił; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metoda szuka pierwszą pozycję można edytować ciągu w formacie między określonym początkowa i końcowa pozycji. Jeśli został znaleziony, wartość można edytować pozycji zostanie zmieniona na określony znak `input`. Dowolny z następujących warunków spowoduje błąd, co powoduje, że nie można zastąpić do wykonania i wartości `false` zwracaną:  
  
-   `startPos` Lub `endPos` parametrów punktu przed rozpoczęciem ciąg sformatowany lub poza jego końcem.  
  
-   Nie można odnaleźć znaku można edytować w określonym interwale.  
  
-   Znak zastępczy `input`, nie jest prawidłowy znak wejściowy, ponieważ nie jest drukowania lub jest niezgodny z jej odpowiadającego mu elementu maski.  
  
 Oprócz zwracanej wartości ta metoda ma dwa parametry wyjściowe o podanie dodatkowych informacji na temat operacji wymiany.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Używany do zastępowania istniejącego znaków można edytować wartość.</param>
        <param name="startPosition">Liczona od zera pozycja ciągu w formacie, gdy rozpoczyna się zastąpienia.</param>
        <param name="endPosition">Liczona od zera pozycja ciągu w formacie, gdy kończy się zastąpienia.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja ciągu w formacie, na którym ostatni znak faktycznie został zastąpiony; w przeciwnym razie pierwszy pozycji, których działanie nie powiodło się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> krótkiej formie opisujący wynik operacji wymiany. Parametr wyjściowy.</param>
        <summary>Zastępuje zakres znaków można edytować między określonym rozpoczęcia i zakończenia pozycji z określonego ciągu, a następnie generuje usuwania pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie znaki pomyślnie zostały zastąpione. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> Metoda szuka pierwszą pozycję można edytować ciągu w formacie między określonym początkowa i końcowa pozycji. Działają na założeniu, że ma wystarczającej liczby pozycji można edytować po tym punkcie, istniejące wartości znakowych są zastąpionego kolei zawartość parametru ciąg zastępczy, `input`.  
  
 Poniższe warunki są traktowane jako błędy. Jeśli wystąpi błąd, nie jest zastępowana i <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> zwraca `false`.  
  
-   `startPos` Lub `endPos` parametrów punktu przed rozpoczęciem ciąg sformatowany lub poza jego końcem.  
  
-   Nie ma wystarczającej liczby pozycji można edytować w sformatowanego ciągu do przechowywania zawartości ciąg zastępczy.  
  
-   Jedna z wartości znak zastępczy, jest nieprawidłowy, ponieważ nie jest drukowania, lub jest niezgodny z jej odpowiadającego mu elementu maski.  
  
 Oprócz zwracanej wartości ta metoda ma dwa parametry wyjściowe o podanie dodatkowych informacji na temat operacji wymiany.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="ResetOnPrompt">
      <MemberSignature Language="C#" Value="public bool ResetOnPrompt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResetOnPrompt" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      <MemberSignature Language="VB.NET" Value="Public Property ResetOnPrompt As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResetOnPrompt { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResetOnPrompt : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą sposób obsługi znak wejściowy odpowiadającego znaku zgłoszenia.</summary>
        <value>
          <see langword="true" /> Jeżeli znaku zgłoszenia jako dane wejściowe powoduje, że bieżące położenie można edytować w masce zresetować; w przeciwnym razie <see langword="false" /> wskazująca, czy znak monitu jest do przetworzenia jako normalne znak wejściowy. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider> można traktować dwie kategorie znaków, nadać tempo lub znaki monitu w specjalny sposób. Zazwyczaj każdy znak wejściowy zostaną przetestowane przed maski i albo zaakceptowane lub odrzucone. Działających na założeniu, że <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> wartość właściwości jest równa wartości innych niż `null`, następnie ustawienie <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A> właściwości `true` spowoduje specjalnego przetwarzania dla znaku zgłoszenia. Po dodaniu znaku zgłoszenia powoduje bieżące położenie znaku maski do wyczyszczenia i bieżącą pozycję Zaawansowane na następny znak można edytować.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A> pierwszeństwo <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> właściwości zgodnie z opisem w poniższej tabeli.  
  
|<xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>|<xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>|Efekty|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------|  
|`true`|`true`|Można dodać znaku zgłoszenia i powoduje bieżące położenie maski zostaną zresetowane. Domyślnie.|  
|`true`|`false`|Można dodać znaku zgłoszenia i powoduje bieżące położenie maski zostaną zresetowane.|  
|`false`|`true`|Znak monitu jest przetwarzany jako normalne znak wejściowy.|  
|`false`|`false`|Znak monitu jest nieprawidłowy i metody próby dodania znak zakończy się niepowodzeniem.|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <Member MemberName="ResetOnSpace">
      <MemberSignature Language="C#" Value="public bool ResetOnSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResetOnSpace" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property ResetOnSpace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResetOnSpace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResetOnSpace : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która określa obsługi wejściowych spacją.</summary>
        <value>
          <see langword="true" /> Jeśli znak wejściowy miejsce powoduje, że bieżące położenie można edytować w masce zresetować; w przeciwnym razie <see langword="false" /> aby wskazać, że do przetworzenia jako normalne znak wejściowy. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider> można traktować dwie kategorie znaków, spacje i znaki monitu w specjalny sposób. Zazwyczaj każdy znak wejściowy zostaną przetestowane przed maski i albo zaakceptowane lub odrzucone. Ustawienie <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> właściwości `true` spowoduje bieżącego położenia znaku maski czyszczona oraz bieżące położenie jest Zaawansowane na następny znak można edytować.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> jest przydatne w przypadku przypisywania tekst, który został zapisany z wyłączeniem wiersza, gdy monit jest zastępowany spacją. Przed przywróceniem taki ciąg, ustawienie <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> do `true` spowoduje zresetowanie znaki monitu w miejscach zajmowane przez spacje w ciągu wejściowym.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia ciąg sformatowany określonego ciągu wejściowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Set(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Set (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Set : string -&gt; bool" Usage="maskedTextProvider.Set input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Wartość używana do ustawiania sformatowanego ciągu.</param>
        <summary>Ustawia ciąg sformatowany określonego ciągu wejściowego.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie znaki pomyślnie zostały ustawione; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Set%2A> Metody usuwa istniejącą zawartość elementu sformatowany ciąg znaków, a następnie stosuje maski przed `input` ciąg, aby zaktualizować zawartość sformatowanego ciągu.  
  
 Poniższe warunki są traktowane jako błędy. Gdy wystąpi błąd, ciąg sformatowany pozostanie niezmieniona i <xref:System.ComponentModel.MaskedTextProvider.Set%2A> zwraca `false`.  
  
-   Nie ma wystarczającej liczby pozycji można edytować w sformatowanego ciągu do przechowywania zawartości ciąg zastępczy.  
  
-   Jedna z wartości znak zastępczy, jest nieprawidłowy, ponieważ nie jest drukowania, lub jest niezgodny z jej odpowiadającego mu elementu maski.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Set(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Set (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Set : string *  *  -&gt; bool" Usage="maskedTextProvider.Set (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Wartość używana do ustawiania sformatowanego ciągu.</param>
        <param name="testPosition">W przypadku powodzenia liczona od zera pozycja ciągu w formacie, na którym rzeczywiście została ustawiona po ostatnim znaku; w przeciwnym razie pierwszy pozycji, których działanie nie powiodło się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> krótkiej formie opisujący wynik operacji set. Parametr wyjściowy.</param>
        <summary>Ustawia ciąg sformatowany do określonego ciągu wejściowego, a następnie generuje usuwania pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie znaki pomyślnie zostały ustawione; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Set%2A> Metody usuwa istniejącą zawartość elementu sformatowany ciąg znaków, a następnie stosuje maski przed `input` ciąg, aby zaktualizować zawartość sformatowanego ciągu.  
  
 Poniższe warunki są traktowane jako błędy. Gdy wystąpi błąd, ciąg sformatowany pozostanie niezmieniona i <xref:System.ComponentModel.MaskedTextProvider.Set%2A> zwraca `false`.  
  
-   Nie ma wystarczającej liczby pozycji można edytować w sformatowanego ciągu do przechowywania zawartości ciąg zastępczy.  
  
-   Jedna z wartości znak zastępczy, jest nieprawidłowy, ponieważ nie jest drukowania, lub jest niezgodny z jej odpowiadającego mu elementu maski.  
  
 Ta wersja <xref:System.ComponentModel.MaskedTextProvider.Set%2A> zawiera dwa parametry dodatkowe dane wyjściowe, aby przekazać więcej informacji na temat operacji metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="SkipLiterals">
      <MemberSignature Language="C#" Value="public bool SkipLiterals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipLiterals" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipLiterals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipLiterals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipLiterals : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.SkipLiterals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy pozycje znak maski mogą zostać zastąpione przez ich takie same wartości.</summary>
        <value>
          <see langword="true" /> Zezwalaj na literały ma zostać dodana z powrotem; w przeciwnym razie <see langword="false" /> uniemożliwia użytkownikowi Zastąp znaki. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maska wprowadzania może zawierać znaków literału i edytować. Jeśli jest podejmowana próba, Dodaj znak wejściowy miejsce zajmowane przez literału, wartości maski <xref:System.Windows.Forms.MaskedTextBox.SkipLiterals%2A> właściwość określa wynik.  
  
-   Jeśli ta właściwość jest `true`, jest prawidłową Zastąp taką samą wartość literału podczas dodawania wprowadzanie znaków. Na przykład wartość znaku ukośnika, `'/'`, można go dodać do trzeciego pozycji maski `"00/00/000"`.  
  
-   Jeśli ta właściwość jest `false`, nie jest prawidłową można przypisać wartości do pozycji maska zajmowane przez znak.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      </Docs>
    </Member>
    <Member MemberName="ToDisplayString">
      <MemberSignature Language="C#" Value="public string ToDisplayString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToDisplayString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToDisplayString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToDisplayString();" />
      <MemberSignature Language="F#" Value="member this.ToDisplayString : unit -&gt; string" Usage="maskedTextProvider.ToDisplayString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg sformatowany w postaci wyświetlanej.</summary>
        <returns>Sformatowany <see cref="T:System.String" /> zawierającą monity i literały maski.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> Metody zawsze zawiera znaki monitu i literału w zwracanej wartości, niezależnie od wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> lub <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości. Ta metoda zawsze spowoduje wyświetlenie znaków hasła, jeśli <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwość ma ustawioną wartość znaków innych niż `null`.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> jest najczęściej używany do uzyskania ciąg wyświetlany w elementach interfejsu skojarzonego użytkownika, takich jak <xref:System.Windows.Forms.MaskedTextBox>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg sformatowany.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="maskedTextProvider.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca sformatowany ciąg, który zawiera wszystkie wartości przypisanej znaków.</summary>
        <returns>Sformatowany <see cref="T:System.String" /> zawierającą wszystkie wartości przypisanej znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążone <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zawiera monity i literały zgodnie z bieżącymi wartościami <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości, odpowiednio. Zawsze zwróci oryginalnego wprowadzanie znaków ignorowanie wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawnia informacje, które zwykle jest chroniony przez znaków hasła w interfejsie użytkownika, należy używać z najwyższą ostrożność Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool -&gt; string" Usage="maskedTextProvider.ToString ignorePasswordChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar">
          <see langword="true" /> Aby przywrócić znakom można edytować; w przeciwnym razie <see langword="false" /> z informacją, że <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> właściwości ma zostać wdrożona.</param>
        <summary>Zwraca ciąg sformatowany, opcjonalnie tym znaków hasła.</summary>
        <returns>Sformatowany <see cref="T:System.String" /> zawierającą literały monity i opcjonalnie znaków hasła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążone <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zawiera monity i literały zgodnie z bieżącymi wartościami <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości, odpowiednio. Jeśli `ignorePasswordChar` parametr jest `true`, zwróci oryginalnego wprowadzanie znaków ignorowanie wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości. Jeśli ten parametr ma `false`, zostanie użyty do ukrywania danych wejściowych użytkownika można edytować, jeśli znak hasła <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> wartość właściwości jest równa wartości innych niż `null`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda potencjalnie ujawnia informacje, które zwykle jest chroniony przez znaków hasła w interfejsie użytkownika, należy używać z najwyższą ostrożność Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool includePrompt, bool includeLiterals);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool includePrompt, bool includeLiterals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (includePrompt As Boolean, includeLiterals As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool includePrompt, bool includeLiterals);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool -&gt; string" Usage="maskedTextProvider.ToString (includePrompt, includeLiterals)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrompt">
          <see langword="true" /> Aby uwzględnić znaki monitu w ciągu zwracanego; w przeciwnym razie <see langword="false" />.</param>
        <param name="includeLiterals">
          <see langword="true" /> Aby uwzględnić znaki w ciągu zwracanego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca ciąg sformatowany, opcjonalnie tym Monituj i literał znaków.</summary>
        <returns>Sformatowany <see cref="T:System.String" /> zawierającą wszystkie znak przypisanej wartości i opcjonalnie zawiera literały i wyświetla monit o.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążone <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zawiera literały według wartości i wyświetla monit `IncludePrompt` i `IncludeLiterals` parametry, odpowiednio. Zwróć uwagę, że te parametry zastąpienie wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości. Ta metoda zawsze zwraca oryginalnego wprowadzanie znaków ignorowanie wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawnia informacje, które zwykle jest chroniony przez znaków hasła w interfejsie użytkownika, należy używać z najwyższą ostrożność Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="maskedTextProvider.ToString (startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startPosition">Liczony od zera pozycja w ciąg sformatowany którym rozpoczyna się dane wyjściowe.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca podciąg sformatowanego ciągu.</summary>
        <returns>W przypadku powodzenia podciąg sformatowany <see cref="T:System.String" />, która obejmuje wszystkie wartości przypisanej znaków; w przeciwnym razie <see cref="F:System.String.Empty" /> ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążone <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zwraca ciąg sformatowany ciąg znaków, zaczynając od pozycji `startPos` i tym kolejne liczby znaków określonych przez `length` parametru. Zwracany ciąg zawiera monity i literały zgodnie z bieżącymi wartościami <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości, odpowiednio. Zwracany ciąg będzie zawierał oryginalnego wprowadzanie znaków; <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwość zawsze jest ignorowana.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawnia informacje, które zwykle jest chroniony przez znaków hasła w interfejsie użytkownika, należy używać z najwyższą ostrożność Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> w przypadku niezgodności w parametrach wejściowych, wykonuje następujące czynności:  
  
-   Jeśli `startPos` jest mniejsza od zera, pozycja początkowa jest ustawiony na zero.  
  
-   Jeśli `startPos` jest większa niż lub równa rzeczywiste <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu <xref:System.String.Empty> zwrócony ciąg.  
  
-   Jeśli `length` jest większa niż liczba pozostałych znaków ostatnich znaków pozycję początkową, tylko pozostałe są zwracane.  
  
-   Jeśli `length` jest mniejsza niż lub równa zero, <xref:System.String.Empty> zwrócony ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (ignorePasswordChar, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar">
          <see langword="true" /> Aby przywrócić znakom można edytować; w przeciwnym razie <see langword="false" /> z informacją, że <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> właściwości ma zostać wdrożona.</param>
        <param name="startPosition">Liczony od zera pozycja w ciąg sformatowany którym rozpoczyna się dane wyjściowe.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca ciąg sformatowany ciąg znaków, opcjonalnie tym znaków hasła.</summary>
        <returns>W przypadku powodzenia podciąg sformatowany <see cref="T:System.String" />, w tym literały monity i opcjonalnie znaków hasła; w przeciwnym razie <see cref="F:System.String.Empty" /> ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążone <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zwraca ciąg sformatowany ciąg znaków, zaczynając od pozycji `startPos` i tym kolejne liczby znaków określonych przez `length` parametru. Zwracany ciąg zawiera monity i literały zgodnie z bieżącymi wartościami <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości, odpowiednio. Jeśli `ignorePasswordChar` parametr jest `true`, zwróci oryginalnego wprowadzanie znaków ignorowanie wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości. Jeśli ten parametr ma `false`, zostanie użyty do ukrywania danych wejściowych użytkownika można edytować, jeśli znak hasła <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> wartość właściwości jest równa wartości innych niż `null`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda potencjalnie ujawnia informacje, które zwykle jest chroniony przez znaków hasła w interfejsie użytkownika, należy używać z najwyższą ostrożność Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> w przypadku niezgodności w parametrach wejściowych, wykonuje następujące czynności:  
  
-   Jeśli `startPos` jest mniejsza od zera, pozycja początkowa jest ustawiony na zero.  
  
-   Jeśli `startPos` jest większa niż lub równa rzeczywiste <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu <xref:System.String.Empty> zwrócony ciąg.  
  
-   Jeśli `length` jest większa niż liczba pozostałych znaków ostatnich znaków pozycję początkową, tylko pozostałe są zwracane.  
  
-   Jeśli `length` jest mniejsza niż lub równa zero, <xref:System.String.Empty> zwrócony ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool includePrompt, bool includeLiterals, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (includePrompt As Boolean, includeLiterals As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (includePrompt, includeLiterals, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="includePrompt">
          <see langword="true" /> Aby uwzględnić znaki monitu w ciągu zwracanego; w przeciwnym razie <see langword="false" />.</param>
        <param name="includeLiterals">
          <see langword="true" /> Aby uwzględnić znaki w ciągu zwracanego; w przeciwnym razie <see langword="false" />.</param>
        <param name="startPosition">Liczony od zera pozycja w ciąg sformatowany którym rozpoczyna się dane wyjściowe.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca ciąg sformatowany ciąg znaków, opcjonalnie tym Monituj i literał znaków.</summary>
        <returns>W przypadku powodzenia podciąg sformatowany <see cref="T:System.String" />, zawierający wszystkie znak przypisanej wartości i opcjonalnie zawiera literały i monity; w przeciwnym razie <see cref="F:System.String.Empty" /> ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążone <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zwraca ciąg sformatowany ciąg znaków, zaczynając od pozycji `startPos` i tym kolejne liczby znaków określonych przez `length` parametru. Zwracany ciąg zawiera literały według wartości i wyświetla monit `IncludePrompt` i `IncludeLiterals` parametry, odpowiednio. Zwróć uwagę, że te parametry zastąpienie wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości. Ta metoda zawsze zwraca oryginalnego wprowadzanie znaków ignorowanie wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawnia informacje, które zwykle jest chroniony przez znaków hasła w interfejsie użytkownika, należy używać z najwyższą ostrożność Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> w przypadku niezgodności w parametrach wejściowych, wykonuje następujące czynności:  
  
-   Jeśli `startPos` jest mniejsza od zera, pozycja początkowa jest ustawiony na zero.  
  
-   Jeśli `startPos` jest większa niż lub równa rzeczywiste <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu <xref:System.String.Empty> zwrócony ciąg.  
  
-   Jeśli `length` jest większa niż liczba pozostałych znaków ostatnich znaków pozycję początkową, tylko pozostałe są zwracane.  
  
-   Jeśli `length` jest mniejsza niż lub równa zero, <xref:System.String.Empty> zwrócony ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean, includePrompt As Boolean, includeLiterals As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool * bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (ignorePasswordChar, includePrompt, includeLiterals, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar">
          <see langword="true" /> Aby przywrócić znakom można edytować; w przeciwnym razie <see langword="false" /> z informacją, że <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> właściwości ma zostać wdrożona.</param>
        <param name="includePrompt">
          <see langword="true" /> Aby uwzględnić znaki monitu w ciągu zwracanego; w przeciwnym razie <see langword="false" />.</param>
        <param name="includeLiterals">
          <see langword="true" /> Aby zwrócić Literały ciągu zwracanego; w przeciwnym razie <see langword="false" />.</param>
        <param name="startPosition">Liczony od zera pozycja w ciąg sformatowany którym rozpoczyna się dane wyjściowe.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca ciąg sformatowany ciąg znaków, opcjonalnie w tym wierszu, literal, a hasło znaków.</summary>
        <returns>W przypadku powodzenia podciąg sformatowany <see cref="T:System.String" />, zawierający wszystkie przypisanej znak wartości i opcjonalnie zawiera literały, monity i znaków hasła; w przeciwnym razie <see cref="F:System.String.Empty" /> ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążone <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metoda zwraca ciąg sformatowany ciąg znaków, zaczynając od pozycji `startPos` i tym kolejne liczby znaków określonych przez `length` parametru. Zwracany ciąg zawiera literały według wartości i wyświetla monit `IncludePrompt` i `IncludeLiterals` parametry, odpowiednio. Zwróć uwagę, że te parametry zastąpienie wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości. Jeśli `ignorePasswordChar` parametr jest `true`, zwróci oryginalnego wprowadzanie znaków ignorowanie wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości. Jeśli ten parametr ma `false`, zostanie użyty do ukrywania danych wejściowych użytkownika można edytować, jeśli znak hasła <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> wartość właściwości jest równa wartości innych niż `null`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda potencjalnie ujawnia informacje, które zwykle jest chroniony przez znaków hasła w interfejsie użytkownika, należy używać z najwyższą ostrożność Aby uniknąć przypadkowego ujawnienia danych poufnych użytkownika.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> w przypadku niezgodności w parametrach wejściowych, wykonuje następujące czynności:  
  
-   Jeśli `startPos` jest mniejsza od zera, pozycja początkowa jest ustawiony na zero.  
  
-   Jeśli `startPos` jest większa niż lub równa rzeczywiste <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu <xref:System.String.Empty> zwrócony ciąg.  
  
-   Jeśli `length` jest większa niż liczba pozostałych znaków ostatnich znaków pozycję początkową, tylko pozostałe są zwracane.  
  
-   Jeśli `length` jest mniejsza niż lub równa zero, <xref:System.String.Empty> zwrócony ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="VerifyChar">
      <MemberSignature Language="C#" Value="public bool VerifyChar (char input, int position, out System.ComponentModel.MaskedTextResultHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyChar(char input, int32 position, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyChar (input As Char, position As Integer, ByRef hint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyChar(char input, int position, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % hint);" />
      <MemberSignature Language="F#" Value="member this.VerifyChar : char * int *  -&gt; bool" Usage="maskedTextProvider.VerifyChar (input, position, hint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="hint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Wartość do sprawdzenia.</param>
        <param name="position">Pozycja w masce do testowania znak wejściowy przed.</param>
        <param name="hint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> opisujący krótkiej formie wyniku operacji. Parametr wyjściowy.</param>
        <summary>Sprawdza, czy określony znak może pomyślnie ustawiono na określonej pozycji.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak jest nieprawidłowa dla określonej pozycji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.VerifyChar%2A> Metoda sprawdza, czy wartość pojedynczy znak reprezentuje prawidłową wartość wejściową w określonej pozycji w ciągu sformatowana. Ta metoda zwróci `false` z następujących powodów:  
  
-   `pos` Parametrów jest mniejsza niż zero lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> z <xref:System.ComponentModel.MaskedTextProvider.Mask%2A>.  
  
-   Znak `input` nie jest prawidłowym znakiem wejściowych, na podstawie <xref:System.ComponentModel.MaskedTextProvider.IsValidInputChar%2A> metody.  
  
-   `input` Nie jest zgodny z elementem maski w określonej pozycji `pos`.  
  
 Ostatni warunek może zależeć od bieżącej wartości <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>, <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>, <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> i <xref:System.ComponentModel.MaskedTextProvider.SkipLiterals%2A> właściwości.  
  
 Aby przetestować cały ciąg wejściowy przed maski, użyj jednej z <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> metody zamiast tego.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar(System.Char,System.Int32)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="VerifyEscapeChar">
      <MemberSignature Language="C#" Value="public bool VerifyEscapeChar (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyEscapeChar(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyEscapeChar (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyEscapeChar(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.VerifyEscapeChar : char * int -&gt; bool" Usage="maskedTextProvider.VerifyEscapeChar (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.Char" /> Wartość do sprawdzenia.</param>
        <param name="position">Pozycja w masce do testowania znak wejściowy przed.</param>
        <summary>Sprawdza, czy określony znak może użyć znaków ucieczki w określonej pozycji.</summary>
        <returns>
          <see langword="true" /> Jeśli określony znak może użyć znaków ucieczki w określonej pozycji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak jest określany jako *wpisywany* Jeśli jest ona prawidłową wartość wejściową, ale nie jest przypisany do tej pozycji w ciągu sformatowana. Znaki ucieczki spadek znaków na następujące trzy kategorie:  
  
-   Znaki monitu są anulowane, jeśli <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> jest właściwość `true`.  
  
-   Wprowadzanie znaków będą miały zmienione znaczenie, jeśli mają taką samą wartość jak literał maski, a <xref:System.ComponentModel.MaskedTextProvider.SkipLiterals%2A> jest właściwość `true`.  
  
-   Spacje są anulowane, jeśli <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> jest właściwość `true`.  
  
 <xref:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar%2A> Metoda również zwraca `false` Jeśli `pos` parametrów jest mniejsza niż zero lub większa niż <xref:System.ComponentModel.MaskedTextProvider.Length%2A> z <xref:System.ComponentModel.MaskedTextProvider.Mask%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      </Docs>
    </Member>
    <MemberGroup MemberName="VerifyString">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza, czy można pomyślnie ustawiono określonego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VerifyString">
      <MemberSignature Language="C#" Value="public bool VerifyString (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyString(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyString (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyString(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.VerifyString : string -&gt; bool" Usage="maskedTextProvider.VerifyString input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Wartość do sprawdzenia.</param>
        <summary>Sprawdza, czy można pomyślnie ustawiono określonego ciągu.</summary>
        <returns>
          <see langword="true" /> Jeśli określony ciąg reprezentuje prawidłową wartość wejściową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> Stosuje `input` ciągu maski, zmieniając faktycznie sformatowany ciąg, aby przetestować czy `input` będzie ważny w odpowiedniej <xref:System.ComponentModel.MaskedTextProvider.Set%2A> operacji. Ta metoda zwraca również wartość `true` Jeśli dane wejściowe są `null` lub ma zerową długość.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
      </Docs>
    </Member>
    <Member MemberName="VerifyString">
      <MemberSignature Language="C#" Value="public bool VerifyString (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyString(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyString(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyString (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyString(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.VerifyString : string *  *  -&gt; bool" Usage="maskedTextProvider.VerifyString (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">
          <see cref="T:System.String" /> Wartość do sprawdzenia.</param>
        <param name="testPosition">W przypadku powodzenia liczony od zera pozycja ostatni znak faktycznie przetestowane; w przeciwnym razie pierwszy pozycji, których nie powiodło się uruchomienie testu. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> krótkiej formie opisujący wynik operacji testu. Parametr wyjściowy.</param>
        <summary>Sprawdza, czy określony ciąg można ustawić pomyślnie, a następnie generuje pozycji i informacje opisowe.</summary>
        <returns>
          <see langword="true" /> Jeśli określony ciąg reprezentuje prawidłową wartość wejściową; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> Stosuje `input` ciągu maski, zmieniając faktycznie sformatowany ciąg, aby przetestować czy `input` będzie ważny w odpowiedniej <xref:System.ComponentModel.MaskedTextProvider.Set%2A> operacji. Ta metoda zwraca również wartość `true` Jeśli dane wejściowe są `null` lub ma zerową długość.  
  
 Ta wersja <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> zawiera dwa parametry dodatkowe dane wyjściowe, aby przekazać więcej informacji na temat operacji metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
      </Docs>
    </Member>
  </Members>
</Type>
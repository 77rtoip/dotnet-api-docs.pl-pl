<Type Name="MaskedTextProvider" FullName="System.ComponentModel.MaskedTextProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b2b61558f32d7a2c5995390f3f245e752463c5be" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69327154" /></Metadata><TypeSignature Language="C#" Value="public class MaskedTextProvider : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MaskedTextProvider extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.MaskedTextProvider" />
  <TypeSignature Language="VB.NET" Value="Public Class MaskedTextProvider&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MaskedTextProvider : ICloneable" />
  <TypeSignature Language="F#" Value="type MaskedTextProvider = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje usługę analizy masek, która może być używana przez dowolną liczbę kontrolek obsługujących maskowanie, takich jak <see cref="T:System.Windows.Forms.MaskedTextBox" /> kontrolka.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MaskedTextBox> Kontrolka zawiera maskę składającą się z znaków literału i elementów formatowania, które sprawdza wszystkie dane wejściowe użytkownika. Zamiast trwałego kojarzenia określonego aparatu analizy masek z programem <xref:System.Windows.Forms.MaskedTextBox>, Windows Forms udostępnia go jako oddzielną usługę reprezentowanej <xref:System.ComponentModel.MaskedTextProvider> przez klasę, która definiuje składnię języka maskowania omówionego w dokumentacji programu <xref:System.Windows.Forms.MaskedTextBox.Mask%2A> właściwość.  
  
 Wiele elementów członkowskich <xref:System.Windows.Forms.MaskedTextBox> klasy odwołuje się do ich implementacji do elementów członkowskich <xref:System.ComponentModel.MaskedTextProvider>o podobnej nazwie. Na przykład <xref:System.Windows.Forms.MaskedTextBox.PromptChar%2A?displayProperty=nameWithType> <xref:System.ComponentModel.MaskedTextProvider> Właściwość <xref:System.Windows.Forms.MaskedTextBox> klasy<xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> odwołuje się do wszystkich elementów dostępu do klasy.  
  
 Aparat analizy masek używany przez <xref:System.ComponentModel.MaskedTextProvider> program jest modelowany po zamaskowanej kontrolce edycji zawartej w Microsoft Visual Basic w wersji 6. Jego język maskujący został opisany w dokumentacji <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwości.  
  
 Następujące trzy unikatowe ciągi są związane z <xref:System.ComponentModel.MaskedTextProvider> klasą.  
  
|Nazwa ciągu|Opis|  
|-----------------|-----------------|  
|Wprowadź znak lub ciąg|Reprezentuje znaki używane jako dane wejściowe, względem których jest stosowana maska. W rzeczywistości ciąg wejściowy może składać się z wielu operacji <xref:System.ComponentModel.MaskedTextProvider.Add%2A>wejścia, takich jak <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A>, <xref:System.ComponentModel.MaskedTextProvider.Replace%2A>,, i <xref:System.ComponentModel.MaskedTextProvider.Remove%2A>. W związku z tym nie można uzyskać dostępu do ciągu wejściowego bezpośrednio. Jednak aspekty obsługi ciągów wejściowych są <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> dostępne za pomocą właściwości i <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>, <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>, i <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> .|  
|Bitowa|Przedstawia maskę formatowania danych wejściowych służącą do przekształcania ciągu wejściowego w sformatowany ciąg. Ten ciąg jest ustawiany w <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> i uzyskuje dostęp głównie za <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> pośrednictwem właściwości. Właściwości maski są również dostępne za pomocą innych elementów członkowskich, takich jak <xref:System.ComponentModel.MaskedTextProvider.Length%2A>właściwości, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>i. <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A>|  
|Sformatowany ciąg|Reprezentuje ciąg, który powstaje, gdy pełna maska zostanie zastosowana do ciągu wejściowego. W sformatowanym ciągu można zbadać wiele elementów członkowskich <xref:System.ComponentModel.MaskedTextProvider.Item%2A>klasy, w tym <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>, <xref:System.ComponentModel.MaskedTextProvider.Length%2A>,, <xref:System.ComponentModel.MaskedTextProvider.MaskFull%2A> <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A>,, i tak dalej. Pełna wartość sformatowanego ciągu jest dostępna <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> w metodach i. <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>|  
  
> [!NOTE]
>  Ciąg wejściowy może reprezentować bezpośrednie dane wejściowe użytkownika, tak jak w <xref:System.Windows.Forms.MaskedTextBox>przypadku lub mogą być generowane przez inne procesy, które nie są bezpośrednio skojarzone z operacjami wejścia/wyjścia użytkownika.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MaskedTextBox" />
    <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskedTextProvider" />
    <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider mask" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mask"><see cref="T:System.String" /> Reprezentujący maskę wejściową.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy przy użyciu określonej maski.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tego konstruktora jest dokładnie równoważne z następującym wywołaniem <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , null, true, '_', '\0', false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask"><see cref="T:System.String" /> Reprezentujący maskę wejściową.</param>
        <param name="restrictToAscii"><see langword="true" />Aby ograniczyć dane wejściowe do znaków zgodnych ze standardem ASCII; w <see langword="false" /> przeciwnym razie zezwolić na cały zestaw Unicode.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy przy użyciu określonej maski i wartości ograniczenia ASCII.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tego konstruktora jest dokładnie równoważne z następującym wywołaniem <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , null, true, '_', '\0', restrictToASCII)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="mask"><see cref="T:System.String" /> Reprezentujący maskę wejściową.</param>
        <param name="culture"><see cref="T:System.Globalization.CultureInfo" /> , Który służy do ustawiania znaków separatora zależnego od regionu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy przy użyciu określonej maski i kultury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tego konstruktora jest dokładnie równoważne z następującym wywołaniem <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , culture, true, '_', '\0', false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, char passwordChar, bool allowPromptAsInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, passwordChar As Char, allowPromptAsInput As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, passwordChar, allowPromptAsInput)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask"><see cref="T:System.String" /> Reprezentujący maskę wejściową.</param>
        <param name="passwordChar">Element <see cref="T:System.Char" /> , który będzie wyświetlany dla znaków wprowadzonych w ciągu hasła.</param>
        <param name="allowPromptAsInput"><see langword="true" />Aby zezwolić na znak monitu jako dane wejściowe; w <see langword="false" />przeciwnym razie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy przy użyciu określonej maski, znaku hasła i wartości użycia monitu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tego konstruktora jest dokładnie równoważne z następującym wywołaniem <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , null, allowPromptAsInput, '_', passwordChar, false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask"><see cref="T:System.String" /> Reprezentujący maskę wejściową.</param>
        <param name="culture"><see cref="T:System.Globalization.CultureInfo" /> , Który służy do ustawiania znaków separatora zależnego od regionu.</param>
        <param name="restrictToAscii"><see langword="true" />Aby ograniczyć dane wejściowe do znaków zgodnych ze standardem ASCII; w <see langword="false" /> przeciwnym razie zezwolić na cały zestaw Unicode.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy przy użyciu określonych wartości ograniczeń maska, kultura i ASCII.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tego konstruktora jest dokładnie równoważne z następującym wywołaniem <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , culture, true, '_', '\0', restrictToAscii)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, char passwordChar, bool allowPromptAsInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, passwordChar As Char, allowPromptAsInput As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, passwordChar, allowPromptAsInput)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask"><see cref="T:System.String" /> Reprezentujący maskę wejściową.</param>
        <param name="culture"><see cref="T:System.Globalization.CultureInfo" /> , Który służy do ustawiania znaków separatora zależnego od regionu.</param>
        <param name="passwordChar">Element <see cref="T:System.Char" /> , który będzie wyświetlany dla znaków wprowadzonych w ciągu hasła.</param>
        <param name="allowPromptAsInput"><see langword="true" />Aby zezwolić na znak monitu jako dane wejściowe; w <see langword="false" />przeciwnym razie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy przy użyciu określonej maski, kultury, znaku hasła i wartości użycia monitu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tego konstruktora jest dokładnie równoważne z następującym wywołaniem <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> konstruktora:  
  
 `MaskedTextProvider(mask , culture, allowPromptAsInput, '_', passwordChar, false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean,System.Char,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, allowPromptAsInput As Boolean, promptChar As Char, passwordChar As Char, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * bool * char * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, allowPromptAsInput, promptChar, passwordChar, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
        <Parameter Name="promptChar" Type="System.Char" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask"><see cref="T:System.String" /> Reprezentujący maskę wejściową.</param>
        <param name="culture"><see cref="T:System.Globalization.CultureInfo" /> , Który służy do ustawiania znaków separatora zależnego od regionu.</param>
        <param name="allowPromptAsInput"><see cref="T:System.Boolean" /> Wartość określająca, czy znak monitu powinien być dozwolony jako prawidłowy znak wejściowy.</param>
        <param name="promptChar">Element <see cref="T:System.Char" /> , który będzie wyświetlany jako symbol zastępczy dla danych wejściowych użytkownika.</param>
        <param name="passwordChar">Element <see cref="T:System.Char" /> , który będzie wyświetlany dla znaków wprowadzonych w ciągu hasła.</param>
        <param name="restrictToAscii"><see langword="true" />Aby ograniczyć dane wejściowe do znaków zgodnych ze standardem ASCII; w <see langword="false" /> przeciwnym razie zezwolić na cały zestaw Unicode.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.MaskedTextProvider" /> klasy przy użyciu określonej maski, kultury, wartości użycia monitu, znaku monitu, znaku hasła oraz wartości ograniczenia ASCII.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor reprezentuje najbardziej ogólny format przeciążony. Parametr musi być zgodny z językiem maskowania zdefiniowanym <xref:System.ComponentModel.MaskedTextProvider> przez klasę, <xref:System.Windows.Forms.MaskedTextBox.Mask%2A?displayProperty=nameWithType> która jest szczegółowa <xref:System.Windows.Forms.MaskedTextBox> we właściwości klasy. `mask`  
  
 Ponieważ nie można zbadać kultur neutralnych dla informacji specyficznych dla kultury, <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> Konstruktor <xref:System.Globalization.CultureInfo.GetCultures%2A> użyje metody, aby wyszukać pierwszą kulturę nieneutralną, która zostanie użyta do określenia odpowiednich znaków separatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr maski ma <see langword="null" /> wartość lub <see cref="F:System.String.Empty" />.  
  
—lub— 
Maska zawiera jeden lub więcej znaków, które nie są drukowalne.</exception>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clone" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje znak wejściowy lub ciąg wejściowy do sformatowanego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (char input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(char input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(char input);" />
      <MemberSignature Language="F#" Value="member this.Add : char -&gt; bool" Usage="maskedTextProvider.Add input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.Char" /> Wartość, która ma zostać dołączona do sformatowanego ciągu.</param>
        <summary>Dodaje określony znak wejściowy do końca sformatowanego ciągu.</summary>
        <returns><see langword="true" />Jeśli znak wejściowy został pomyślnie dodany; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dodaje wartość znakudo<xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> pierwszego dostępnego położenia w sformatowanym ciągu po pozycji, która została ostatnio przypisana, która jest reprezentowana przez właściwość. `input` <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%29> Ta metoda zakończy się niepowodzeniem z jednego z następujących powodów:  
  
-   Wartość `input`wejściowa nie może być drukowana lub nie pasuje do odpowiadającego jej elementu maski.  
  
-   W sformatowanym ciągu nie ma żadnych dostępnych pozycji edycji lub nie ma żadnych dostępnych pozycji edycji po ostatnim przypisanym położeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Add : string -&gt; bool" Usage="maskedTextProvider.Add input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Zawierająca wartości znakowe, które mają być dołączane do sformatowanego ciągu.</param>
        <summary>Dodaje znaki w określonym ciągu wejściowym do końca sformatowanego ciągu.</summary>
        <returns><see langword="true" />Jeśli wszystkie znaki z ciągu wejściowego zostały pomyślnie dodane; w <see langword="false" /> przeciwnym razie, aby wskazać, że żadne znaki nie zostały dodane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dodaje znaki `input` z ciągu do sformatowanego ciągu, zaczynając od pierwszego dostępnego położenia po <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>. <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%29> Ta metoda zakończy się niepowodzeniem z jednego z następujących powodów:  
  
-   Dowolnych znaków w wartości `input`wejściowej,,,, nie można drukować lub wartość wejściowa nie jest zgodna z odpowiadającym jej elementem maski.  
  
-   Za mało dostępnych pozycji edycji w ciągu sformatowanym po ostatnim przypisanym położeniu.  
  
 Jeśli ta metoda nie powiedzie się, żadne dodatkowe operacje nie są `false`wprowadzane i metoda zwraca.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="input" /></exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (char input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(char input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.Char,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As Char, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(char input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Add : char *  *  -&gt; bool" Usage="maskedTextProvider.Add (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.Char" /> Wartość, która ma zostać dołączona do sformatowanego ciągu.</param>
        <param name="testPosition">Pozycja od zera w sformatowanym ciągu, w którym podjęto próbę dodania znaku. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji. Parametr wyjściowy.</param>
        <summary>Dodaje określony znak wejściowy do końca sformatowanego ciągu, a następnie wyprowadza informacje o pozycji i opisie.</summary>
        <returns><see langword="true" />Jeśli znak wejściowy został pomyślnie dodany; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda próbuje `input` dodać wartość znaku do pierwszego dostępnego położenia w sformatowanym ciągu po pozycji, która została ostatnio przypisana, <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> która jest reprezentowana przez właściwość. <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Ta metoda zakończy się niepowodzeniem, jeśli wszystkie dostępne pozycje są przed ostatnim przypisanym pozycją. Ta metoda zakończy się niepowodzeniem z jednego z następujących powodów:  
  
-   Wartość `input`wejściowa nie może być drukowana lub nie pasuje do odpowiadającego jej elementu maski.  
  
-   W sformatowanym ciągu nie ma żadnych dostępnych pozycji edycji lub nie ma żadnych dostępnych pozycji edycji po ostatnim przypisanym położeniu.  
  
 Ta metoda działa tak samo, jak przesłonięta wersja przy <xref:System.Char> użyciu jednego <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%29>parametru, z tą różnicą, że wyprowadza dodatkowe informacje.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Add : string *  *  -&gt; bool" Usage="maskedTextProvider.Add (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Zawierająca wartości znakowe, które mają być dołączane do sformatowanego ciągu.</param>
        <param name="testPosition">Pozycja od zera w sformatowanym ciągu, w którym podjęto próbę dodania znaku. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji. Parametr wyjściowy.</param>
        <summary>Dodaje znaki w określonym ciągu wejściowym do końca sformatowanego ciągu, a następnie wyprowadza pozycję i informacje opisowe.</summary>
        <returns><see langword="true" />Jeśli wszystkie znaki z ciągu wejściowego zostały pomyślnie dodane; w <see langword="false" /> przeciwnym razie, aby wskazać, że żadne znaki nie zostały dodane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dodaje znaki `input` z ciągu do sformatowanego ciągu, zaczynając od pierwszego dostępnego położenia po <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>. <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Ta metoda zakończy się niepowodzeniem z jednego z następujących powodów:  
  
-   Dowolnych znaków w wartości `input`wejściowej,,,, nie można drukować lub wartość wejściowa nie jest zgodna z odpowiadającym jej elementem maski.  
  
-   Za mało dostępnych pozycji edycji w ciągu sformatowanym po ostatnim przypisanym położeniu.  
  
 Jeśli ta metoda nie powiedzie się, żadne dodatkowe operacje nie są `false`wprowadzane i metoda zwraca.  
  
 Ta metoda działa tak samo, jak przesłonięta wersja przy <xref:System.String> użyciu jednego <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%29>parametru, z tą różnicą, że wyprowadza dodatkowe informacje.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="AllowPromptAsInput">
      <MemberSignature Language="C#" Value="public bool AllowPromptAsInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPromptAsInput" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowPromptAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPromptAsInput { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowPromptAsInput : bool" Usage="System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy znak monitu powinien być traktowany jako prawidłowy znak wejściowy, czy nie.</summary>
        <value><see langword="true" />Jeśli użytkownik może wejść <see cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" /> do kontrolki; w przeciwnym razie,. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość właściwości jest ustawiana <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> w konstruktorze. <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>  
  
 Nawet jeśli <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> jest `true`, znak monitu musi być prawidłowy dla bieżącej lokalizacji w masce, aby można ją było zaakceptować.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="AsciiOnly">
      <MemberSignature Language="C#" Value="public bool AsciiOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsciiOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsciiOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsciiOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AsciiOnly : bool" Usage="System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy maska akceptuje znaki spoza zestawu znaków ASCII.</summary>
        <value><see langword="true" />w przypadku zaakceptowania tylko kodu ASCII; <see langword="false" /> Jeśli<see cref="T:System.ComponentModel.MaskedTextProvider" /> może akceptować dowolny dowolny znak Unicode. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość właściwości jest ustawiana <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> w konstruktorze. <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>  
  
 Jeśli `true` program<xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A> ograniczy dane wejściowe użytkownika do zestawu znaków ASCII.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.AsciiOnly" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="AssignedEditPositionCount">
      <MemberSignature Language="C#" Value="public int AssignedEditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AssignedEditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AssignedEditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AssignedEditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AssignedEditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę edytowalnych pozycji znaków, do których pomyślnie przypisano wartość wejściową.</summary>
        <value><see cref="T:System.Int32" /> Zawierający liczbę edytowalnych pozycji znaku w masce wejściowej, do której przypisano już wartość znaku w ciągu sformatowanym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Całkowita liczba edytowalnych pozycji znaku reprezentowanej przez <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> właściwość powinna być równa sumie <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> właściwości i.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="AvailableEditPositionCount">
      <MemberSignature Language="C#" Value="public int AvailableEditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AvailableEditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableEditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AvailableEditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableEditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę edytowalnych pozycji znaku w masce wejściowej, do której nie została jeszcze przypisana wartość wejściowa.</summary>
        <value><see cref="T:System.Int32" /> Zawierający liczbę edytowalnych pozycji znaków, do których nie została jeszcze przypisana wartość znaku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Całkowita liczba edytowalnych pozycji znaku reprezentowanej przez <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> właściwość powinna być równa sumie <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> właściwości i.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Clear">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści wszystkie znaki wejściowe z sformatowanego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="maskedTextProvider.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie edytowalne znaki wejściowe z sformatowanego ciągu, zastępując je znakami monitu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Clear> Metoda ponownie inicjuje sformatowany ciąg, wstawiając znak monitu do wszystkich pozycji edytowalnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear (out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear([out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clear(System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear (ByRef resultHint As MaskedTextResultHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear([Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Clear :  -&gt; unit" Usage="maskedTextProvider.Clear resultHint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji. Parametr wyjściowy.</param>
        <summary>Czyści wszystkie edytowalne znaki wejściowe z sformatowanego ciągu, zastępując je znakami monitu, a następnie wyprowadza informacje opisowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Clear%28System.ComponentModel.MaskedTextResultHint%40%29> Metoda ponownie inicjuje sformatowany ciąg, wstawiając znak monitu do wszystkich pozycji edytowalnych. Funkcja IT jest równoważna z przesłoniętą wersją, która nie <xref:System.ComponentModel.MaskedTextProvider.Clear>przyjmuje żadnych parametrów, z tą różnicą, że wyprowadza dodatkowe informacje.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="maskedTextProvider.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię bieżącego <see cref="T:System.ComponentModel.MaskedTextProvider" />elementu.</summary>
        <returns>Obiekt <see cref="T:System.ComponentModel.MaskedTextProvider" /> tworzony przez tę metodę, rzutowany jako obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca nową kopię bieżącego <xref:System.ComponentModel.MaskedTextProvider>elementu. <xref:System.ComponentModel.MaskedTextProvider.Clone%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.#ctor" />
        <altmember cref="T:System.ICloneable" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Culture" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo" Usage="System.ComponentModel.MaskedTextProvider.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kulturę, która określa wartość lokalizowalnych separatorów i symboli zastępczych w masce wejściowej.</summary>
        <value><see cref="T:System.Globalization.CultureInfo" /> Zawierający informacje o kulturze skojarzone z maską wejściową.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest ustawiana <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> w konstruktorze. <xref:System.ComponentModel.MaskedTextProvider.Culture%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPasswordChar">
      <MemberSignature Language="C#" Value="public static char DefaultPasswordChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char DefaultPasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultPasswordChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property char DefaultPasswordChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPasswordChar : char" Usage="System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny znak hasła używany do ukrywania danych wejściowych użytkownika.</summary>
        <value><see cref="T:System.Char" /> Reprezentuje domyślny znak hasła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest zdefiniowana <xref:System.ComponentModel.MaskedTextProvider> w klasie jako znak gwiazdki (*). <xref:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.UseSystemPasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
      </Docs>
    </Member>
    <Member MemberName="EditPositionCount">
      <MemberSignature Language="C#" Value="public int EditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.EditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę edytowalnych pozycji w sformatowanym ciągu.</summary>
        <value><see cref="T:System.Int32" /> Zawierający liczbę pozycji edytowalnych w formatowanym ciągu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Całkowita liczba edytowalnych pozycji znaku reprezentowanej przez <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> właściwość musi być równa sumie <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> właściwości i. Ta wartość obejmuje zarówno wymagane, jak i opcjonalne znaki edytowalne.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="EditPositions">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator EditPositions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator EditPositions" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EditPositions As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerator ^ EditPositions { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EditPositions : System.Collections.IEnumerator" Usage="System.ComponentModel.MaskedTextProvider.EditPositions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nowo utworzony moduł wyliczający dla pozycji edytowalnych w sformatowanym ciągu.</summary>
        <value><see cref="T:System.Collections.IEnumerator" /> Obsługuje Wyliczenie na pozycji edytowalnych w sformatowanym ciągu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na każdym dostępie <xref:System.ComponentModel.MaskedTextProvider.EditPositions%2A> do właściwości jest tworzona <xref:System.Collections.IEnumerator> tymczasowa kolekcja pozycji edytowalnych.  
  
 Ta kolekcja jest tylko do odczytu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindAssignedEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindAssignedEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindAssignedEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAssignedEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindAssignedEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindAssignedEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindAssignedEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja od zera w sformatowanym ciągu, aby rozpocząć wyszukiwanie.</param>
        <param name="direction">Wskazujący kierunek wyszukiwania — <see langword="true" /> do wyszukiwania w przód lub <see langword="false" /> do wyszukiwania wstecznego. <see cref="T:System.Boolean" /></param>
        <summary>Zwraca pozycję pierwszej przypisanej pozycji edytowalnej po podanej pozycji przy użyciu określonego kierunku wyszukiwania.</summary>
        <returns>Jeśli to <see cref="T:System.Int32" /> się powiedzie, oznacza to, że wystąpiła pozycja od zera do pierwszej przypisanej pozycji edytowalnej; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sformatowany ciąg składa się z edytowalnych znaków i literałów skopiowanych z maski. Edytowalne pozycje znaku będą zajęte przez znak monitu skopiowany z maski, jeśli są nieprzypisane lub z prawidłowym znakiem wejściowym, jeśli przypisano dane wejściowe.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom%2A> Metoda jest używana do wyszukiwania pierwszego przypisanego znaku po określonej pozycji i kierunku wyszukiwania. Wynik można następnie przesłać jako parametr do <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania przypisanej wartości w tym miejscu.  
  
 Metody <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> i<xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom%2A> są uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindAssignedEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindAssignedEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindAssignedEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAssignedEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindAssignedEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindAssignedEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindAssignedEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Pozycja od zera w sformatowanym ciągu, w którym rozpocznie się wyszukiwanie.</param>
        <param name="endPosition">Pozycja od zera w sformatowanym ciągu, w którym ma się zakończyć wyszukiwanie.</param>
        <param name="direction">Wskazujący kierunek wyszukiwania — <see langword="true" /> do wyszukiwania w przód lub <see langword="false" /> do wyszukiwania wstecznego. <see cref="T:System.Boolean" /></param>
        <summary>Zwraca pozycję pierwszej przypisanej pozycji do edycji między określonymi pozycjami przy użyciu określonego kierunku wyszukiwania.</summary>
        <returns>Jeśli to <see cref="T:System.Int32" /> się powiedzie, oznacza to, że wystąpiła pozycja od zera do pierwszej przypisanej pozycji edytowalnej; w przeciwnym razie <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sformatowany ciąg składa się z edytowalnych znaków i literałów skopiowanych z maski. Edytowalne pozycje znaku będą zajęte przez znak monitu skopiowany z maski, jeśli są nieprzypisane lub z prawidłowym znakiem wejściowym, jeśli przypisano dane wejściowe.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange%2A> Metoda jest używana do wyszukiwania pierwszego przypisanego znaku między dwoma określonymi położeniami, włącznie z zastosowaniem określonego kierunku wyszukiwania. Wynik można następnie przesłać jako parametr do <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania przypisanej wartości w tym miejscu.  
  
 Metody <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> i<xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange%2A> są uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja od zera w sformatowanym ciągu, aby rozpocząć wyszukiwanie.</param>
        <param name="direction">Wskazujący kierunek wyszukiwania — <see langword="true" /> do wyszukiwania w przód lub <see langword="false" /> do wyszukiwania wstecznego. <see cref="T:System.Boolean" /></param>
        <summary>Zwraca pozycję pierwszej pozycji edytowalnej po podanej pozycji przy użyciu określonego kierunku wyszukiwania.</summary>
        <returns>Jeśli to <see cref="T:System.Int32" /> się powiedzie, oznacza to, że wystąpiła pozycja od zera w pierwszej <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />pozycji edytowalnej; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A> Metoda jest używana do wyszukania kolejnej przypisanej lub nieprzypisanej pozycji edytowalnej w sformatowanym ciągu po określonym położeniu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> Metoda jest uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Pozycja od zera w sformatowanym ciągu, w którym rozpocznie się wyszukiwanie.</param>
        <param name="endPosition">Pozycja od zera w sformatowanym ciągu, w którym ma się zakończyć wyszukiwanie.</param>
        <param name="direction">Wskazujący kierunek wyszukiwania — <see langword="true" /> do wyszukiwania w przód lub <see langword="false" /> do wyszukiwania wstecznego. <see cref="T:System.Boolean" /></param>
        <summary>Zwraca pozycję pierwszej pozycji edytowalnej między określonymi pozycjami przy użyciu określonego kierunku wyszukiwania.</summary>
        <returns>Jeśli to <see cref="T:System.Int32" /> się powiedzie, oznacza to, że wystąpiła pozycja od zera w pierwszej <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />pozycji edytowalnej; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange%2A> Metoda jest używana do wyszukiwania pierwszego znaku edytowalnego między dwoma określonymi położeniami, włącznie z zastosowaniem określonego kierunku wyszukiwania. Wynik można następnie przesłać jako parametr do <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania przypisanej wartości w tym miejscu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> Metoda jest uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindNonEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindNonEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindNonEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNonEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindNonEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindNonEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindNonEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja od zera w sformatowanym ciągu, aby rozpocząć wyszukiwanie.</param>
        <param name="direction">Wskazujący kierunek wyszukiwania — <see langword="true" /> do wyszukiwania w przód lub <see langword="false" /> do wyszukiwania wstecznego. <see cref="T:System.Boolean" /></param>
        <summary>Zwraca pozycję pierwszej nieedytowalnej pozycji po podanej pozycji przy użyciu określonego kierunku wyszukiwania.</summary>
        <returns>Jeśli to <see cref="T:System.Int32" /> się powiedzie, reprezentuje pozycję od zera w pierwszej pozycji literału; w przeciwnym <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> Metoda jest używana do wyszukiwania następnego znaku literału w sformatowanym ciągu po określonym położeniu. Wynik może następnie zostać przesłany jako parametr do <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania wartości literału w tym położeniu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A> Metoda jest uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindNonEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindNonEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindNonEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNonEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindNonEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindNonEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindNonEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Pozycja od zera w sformatowanym ciągu, w którym rozpocznie się wyszukiwanie.</param>
        <param name="endPosition">Pozycja od zera w sformatowanym ciągu, w którym ma się zakończyć wyszukiwanie.</param>
        <param name="direction">Wskazujący kierunek wyszukiwania — <see langword="true" /> do wyszukiwania w przód lub <see langword="false" /> do wyszukiwania wstecznego. <see cref="T:System.Boolean" /></param>
        <summary>Zwraca pozycję pierwszej nieedytowalnej pozycji między określonymi położeniami przy użyciu określonego kierunku wyszukiwania.</summary>
        <returns>Jeśli to <see cref="T:System.Int32" /> się powiedzie, reprezentuje pozycję od zera w pierwszej pozycji literału; w przeciwnym <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> Metoda jest używana do wyszukiwania pierwszego znaku literału między dwoma określonymi położeniami, włącznie z zastosowaniem określonego kierunku wyszukiwania. Wynik może następnie zostać przesłany jako parametr do <xref:System.ComponentModel.MaskedTextProvider.Item%2A> indeksatora w celu uzyskania wartości literału w tym położeniu.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange%2A> Metoda jest uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindUnassignedEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindUnassignedEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindUnassignedEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindUnassignedEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindUnassignedEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindUnassignedEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindUnassignedEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja od zera w sformatowanym ciągu, aby rozpocząć wyszukiwanie.</param>
        <param name="direction">Wskazujący kierunek wyszukiwania — <see langword="true" /> do wyszukiwania w przód lub <see langword="false" /> do wyszukiwania wstecznego. <see cref="T:System.Boolean" /></param>
        <summary>Zwraca pozycję pierwszej nieprzypisanej pozycji edytowalnej po podanej pozycji przy użyciu określonego kierunku wyszukiwania.</summary>
        <returns>Jeśli to <see cref="T:System.Int32" /> się powiedzie, oznacza to, że wystąpiła pozycja od zera pierwszej nieprzypisanej <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />pozycji edytowalnej; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sformatowany ciąg składa się z edytowalnych znaków i literałów skopiowanych z maski. Edytowalne pozycje znaku będą zajęte przez znak monitu skopiowany z maski, jeśli są nieprzypisane lub z prawidłowym znakiem wejściowym, jeśli przypisano dane wejściowe.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom%2A> Metoda jest używana do wyszukania pierwszego nieprzypisanego znaku po określonej pozycji i kierunku wyszukiwania. Znak monitu powinien zajmować tę pozycję.  
  
 Metody <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> i<xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom%2A> są uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindUnassignedEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindUnassignedEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindUnassignedEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindUnassignedEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindUnassignedEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindUnassignedEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindUnassignedEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Pozycja od zera w sformatowanym ciągu, w którym rozpocznie się wyszukiwanie.</param>
        <param name="endPosition">Pozycja od zera w sformatowanym ciągu, w którym ma się zakończyć wyszukiwanie.</param>
        <param name="direction">Wskazujący kierunek wyszukiwania — <see langword="true" /> do wyszukiwania w przód lub <see langword="false" /> do wyszukiwania wstecznego. <see cref="T:System.Boolean" /></param>
        <summary>Zwraca pozycję pierwszej nieprzypisanej pozycji do edycji między określonymi pozycjami przy użyciu określonego kierunku wyszukiwania.</summary>
        <returns>Jeśli to <see cref="T:System.Int32" /> się powiedzie, oznacza to, że wystąpiła pozycja od zera pierwszej nieprzypisanej <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />pozycji edytowalnej; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sformatowany ciąg składa się z edytowalnych znaków i literałów skopiowanych z maski. Edytowalne pozycje znaku będą zajęte przez znak monitu skopiowany z maski, jeśli są nieprzypisane lub z prawidłowym znakiem wejściowym, jeśli przypisano dane wejściowe.  
  
 <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange%2A> Metoda jest używana do wyszukiwania pierwszego nieprzypisanego znaku między dwoma określonymi położeniami, włącznie z zastosowaniem określonego kierunku wyszukiwania. Znak monitu powinien zajmować tę pozycję.  
  
 Metody <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> i<xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange%2A> są uzupełnieniem tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetOperationResultFromHint">
      <MemberSignature Language="C#" Value="public static bool GetOperationResultFromHint (System.ComponentModel.MaskedTextResultHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetOperationResultFromHint(valuetype System.ComponentModel.MaskedTextResultHint hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint(System.ComponentModel.MaskedTextResultHint)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOperationResultFromHint (hint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetOperationResultFromHint(System::ComponentModel::MaskedTextResultHint hint);" />
      <MemberSignature Language="F#" Value="static member GetOperationResultFromHint : System.ComponentModel.MaskedTextResultHint -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint hint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hint" Type="System.ComponentModel.MaskedTextResultHint" />
      </Parameters>
      <Docs>
        <param name="hint"><see cref="T:System.ComponentModel.MaskedTextResultHint" /> Wartość zwykle uzyskana jako parametr wyjściowy z poprzedniej operacji.</param>
        <summary>Określa, czy określony <see cref="T:System.ComponentModel.MaskedTextResultHint" /> oznacza powodzenie lub niepowodzenie.</summary>
        <returns><see langword="true" />Jeśli określona <see cref="T:System.ComponentModel.MaskedTextResultHint" /> wartość reprezentuje powodzenie; <see langword="false" /> w przeciwnym razie reprezentuje błąd.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider> Następujące metody klasy zawierają parametr typu <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> <xref:System.ComponentModel.MaskedTextProvider.Add%2A> <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> <xref:System.ComponentModel.MaskedTextProvider.Clear%2A> <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A>, który jest używany do wyprowadzania informacji o działaniu metody:,,,, <xref:System.ComponentModel.MaskedTextResultHint> , <xref:System.ComponentModel.MaskedTextProvider.Set%2A>, <xref:System.ComponentModel.MaskedTextProvider.VerifyChar%2A>i .<xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> Metoda interpretuje tę wartość i zwraca wartość logiczną wskazującą, <xref:System.ComponentModel.MaskedTextResultHint> czy została zasygnalizowania, że operacja była sukcesem lub niepowodzeniem. <xref:System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.MaskedTextResultHint" />
      </Docs>
    </Member>
    <Member MemberName="IncludeLiterals">
      <MemberSignature Language="C#" Value="public bool IncludeLiterals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeLiterals" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeLiterals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeLiterals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeLiterals : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy znaki literału w masce wejściowej powinny być zawarte w sformatowanym ciągu.</summary>
        <value><see langword="true" />Jeśli są uwzględniane literały; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> określają, czy znaki monitu i literału pojawiają się podczas wywoływania metody. Po ustawieniu obu tych właściwości na `false`, przeanalizowany ciąg będzie reprezentował tylko znaki wprowadzone przez użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="IncludePrompt">
      <MemberSignature Language="C#" Value="public bool IncludePrompt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludePrompt" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludePrompt As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludePrompt { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludePrompt : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IncludePrompt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="P:System.Windows.Forms.MaskedTextBox.PromptChar" /> jest używana do reprezentowania braku danych wejściowych użytkownika podczas wyświetlania sformatowanego ciągu.</summary>
        <value><see langword="true" />Jeśli znak monitu jest używany do reprezentowania pozycji, w których nie podano danych wejściowych użytkownika; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> określają, czy znaki monitu i literału pojawiają się podczas wywoływania metody. Po ustawieniu obu tych właściwości na `false`, przeanalizowany ciąg będzie reprezentował tylko znaki wprowadzone przez użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertAt">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia znak lub ciąg w określonym miejscu w formacie ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : char * int -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.Char" /> Do wstawienia.</param>
        <param name="position">Pozycja od zera w sformatowanym ciągu, aby wstawić znak.</param>
        <summary>Wstawia określony znak w podanej pozycji w sformatowanym ciągu.</summary>
        <returns><see langword="true" />Jeśli wstawianie zakończyło się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wstawia znak do pierwszej pozycji edycji, który jest określony `pos` przez parametr. <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Ta metoda przesunie wszystkie istniejące znaki po punkcie wstawiania przez jedną pozycję, aby zwolnić miejsce dla wstawionego `input` znaku. W przypadku wystąpienia jednego z następujących błędów Wstawianie nie jest wykonywane, a metoda zwraca `false`.  
  
-   Wartość parametru jest mniejsza od zera lub większa <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od sformatowanego ciągu. `pos`  
  
-   Nie znaleziono znaku edytowalnego w sformatowanym ciągu znajdującym się w określonym położeniu `pos`lub poza nim.  
  
-   Znak wstawiania,, `input`nie jest prawidłowym znakiem wejściowym, ponieważ nie można go wydrukować lub nie pasuje do odpowiadającego mu elementu maski.  
  
-   Brak dostępnych pozycji z prawej strony punktu wstawiania, tak aby nie można było przesunąć istniejących znaków.  
  
-   Przesunięcie istniejących znaków spowodowałoby naruszenie maski.  
  
 Pusty `input` ciąg nie spowoduje zmiany w sformatowanym ciągu, ale zwróci `true`wartość.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (string input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(string input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As String, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(System::String ^ input, int position);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : string * int -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Do wstawienia.</param>
        <param name="position">Pozycja od zera w sformatowanym ciągu, aby wstawić ciąg wejściowy.</param>
        <summary>Wstawia określony ciąg w określonym położeniu w sformatowanym ciągu.</summary>
        <returns><see langword="true" />Jeśli wstawianie zakończyło się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wstawia każdy znak `input` z ciągu do pozycji edycji znajdujących się na pozycji `pos` i poza. <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Ta metoda przesunie wszystkie istniejące znaki po punkcie wstawiania przez jedną pozycję dla każdego wstawionego znaku. Jeśli wystąpi jeden z następujących błędów, wstawianie nie jest wykonywane, a metoda zwraca `false`.  
  
-   Wartość parametru jest mniejsza od zera lub większa <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od sformatowanego ciągu. `pos`  
  
-   Nie ma wystarczającej liczby edytowalnych znaków w sformatowanym ciągu w określonym położeniu `pos`lub poza nim, aby wstawić wszystkie znaki `input` z ciągu.  
  
-   Jeden lub więcej znaków wstawiania nie jest prawidłowym znakiem wejściowym, ponieważ nie są drukowalne lub nie pasują do odpowiadającego im elementu maski.  
  
-   Nie ma wystarczającej liczby dostępnych pozycji z prawej strony punktu wstawiania, aby nie można było przesunąć istniejących znaków.  
  
-   Przesunięcie istniejących znaków spowodowałoby naruszenie maski. Należy zauważyć, że przesunięcie odbywa się podczas wstawiania każdego pojedynczego znaku.  
  
 Pusty `input` ciąg nie spowoduje zmiany w sformatowanym ciągu, ale zwróci `true`wartość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="input" /></exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (char input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(char input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.Char,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As Char, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(char input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : char * int *  *  -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.Char" /> Do wstawienia.</param>
        <param name="position">Pozycja od zera w sformatowanym ciągu, aby wstawić znak.</param>
        <param name="testPosition">Jeśli metoda zakończy się pomyślnie, ostatnią pozycją, w której został wstawiony znak; w przeciwnym razie pierwsze miejsce, w którym nie powiodła się Wstawianie. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji wstawiania. Parametr wyjściowy.</param>
        <summary>Wstawia określony znak w podanej pozycji w sformatowanym ciągu, zwracając ostatnią pozycję wstawienia i stan operacji.</summary>
        <returns><see langword="true" />Jeśli wstawianie zakończyło się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wstawia znak do pierwszej pozycji edycji, który jest określony `pos` przez parametr. <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Ta metoda przesunie wszystkie istniejące znaki po punkcie wstawiania przez jedną pozycję, aby zwolnić miejsce dla wstawionego `input` znaku. W przypadku wystąpienia jednego z następujących błędów Wstawianie nie jest wykonywane, a metoda zwraca `false`.  
  
-   Wartość parametru jest mniejsza od zera lub większa <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od sformatowanego ciągu. `pos`  
  
-   Nie znaleziono znaku edytowalnego w sformatowanym ciągu znajdującym się w określonym położeniu `pos`lub poza nim.  
  
-   Znak wstawiania,, `input`nie jest prawidłowym znakiem wejściowym, ponieważ nie można go wydrukować lub nie pasuje do odpowiadającego mu elementu maski.  
  
-   Brak dostępnych pozycji z prawej strony punktu wstawiania, tak aby nie można było przesunąć istniejących znaków.  
  
-   Przesunięcie istniejących znaków spowodowałoby naruszenie maski.  
  
 Pusty `input` ciąg nie spowoduje zmiany w sformatowanym ciągu, ale zwróci `true`wartość.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (string input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(string input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.String,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As String, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(System::String ^ input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : string * int *  *  -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Do wstawienia.</param>
        <param name="position">Pozycja od zera w sformatowanym ciągu, aby wstawić ciąg wejściowy.</param>
        <param name="testPosition">Jeśli metoda zakończy się pomyślnie, ostatnią pozycją, w której został wstawiony znak; w przeciwnym razie pierwsze miejsce, w którym nie powiodła się Wstawianie. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji wstawiania. Parametr wyjściowy.</param>
        <summary>Wstawia określony ciąg w określonym położeniu w sformatowanym ciągu, zwracając ostatnią pozycję wstawienia i stan operacji.</summary>
        <returns><see langword="true" />Jeśli wstawianie zakończyło się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wstawia każdy znak `input` z ciągu do pozycji edycji znajdujących się na pozycji `pos` i poza. <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Ta metoda przesunie wszystkie istniejące znaki po punkcie wstawiania przez jedną pozycję dla każdego wstawionego znaku. Jeśli wystąpi jeden z następujących błędów, wstawianie nie jest wykonywane, a metoda zwraca `false`.  
  
-   Wartość parametru jest mniejsza od zera lub większa <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od sformatowanego ciągu. `pos`  
  
-   Nie ma wystarczającej liczby edytowalnych znaków w sformatowanym ciągu w określonym położeniu `pos`lub poza nim, aby wstawić wszystkie znaki `input` z ciągu.  
  
-   Jeden lub więcej znaków wstawiania nie jest prawidłowym znakiem wejściowym, ponieważ nie są drukowalne lub nie pasują do odpowiadającego im elementu maski.  
  
-   Nie ma wystarczającej liczby dostępnych pozycji z prawej strony punktu wstawiania, aby nie można było przesunąć istniejących znaków.  
  
-   Przesunięcie istniejących znaków spowodowałoby naruszenie maski. Należy zauważyć, że przesunięcie odbywa się podczas wstawiania każdego pojedynczego znaku.  
  
 Pusty `input` ciąg nie spowoduje zmiany w sformatowanym ciągu, ale zwróci `true`wartość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="input" /></exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InvalidIndex">
      <MemberSignature Language="C#" Value="public static int InvalidIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 InvalidIndex" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InvalidIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int InvalidIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InvalidIndex : int" Usage="System.ComponentModel.MaskedTextProvider.InvalidIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera górną granicę zakresu nieprawidłowych indeksów.</summary>
        <value>Wartość reprezentująca największy nieprawidłowy indeks określony przez implementację dostawcy. Na przykład, jeśli najniższy prawidłowy indeks to 0, ta właściwość zwróci wartość-1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość służy do reprezentowania wyniku, który jest nieprawidłowy dla operacji indeksowania, takich <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> jak metoda. <xref:System.ComponentModel.MaskedTextProvider.InvalidIndex%2A>  
  
 W przypadku użycia dostawcy lub zaimplementowania własnego elementu należy użyć tej właściwości, aby zdecydować, czy indeks jest nieprawidłowy, a nie z czytelną wiedzą o nieprawidłowych wartościach.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsAvailablePosition">
      <MemberSignature Language="C#" Value="public bool IsAvailablePosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAvailablePosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAvailablePosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAvailablePosition(int position);" />
      <MemberSignature Language="F#" Value="member this.IsAvailablePosition : int -&gt; bool" Usage="maskedTextProvider.IsAvailablePosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja od zera w masce do przetestowania.</param>
        <summary>Określa, czy określone położenie jest dostępne do przypisania.</summary>
        <returns><see langword="true" />Jeśli określona pozycja w sformatowanym ciągu jest edytowalna i nie została jeszcze przypisana. w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.IsAvailablePosition%2A> Metoda zwraca`true` tylko wtedy, gdy spełnione są wszystkie następujące warunki:  
  
-   Parametr znajduje się w granicach sformatowanego ciągu; oznacza to, że jego wartość jest większa lub równa zero i mniejsza <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od sformatowanego ciągu. `pos`  
  
-   Określona pozycja jest znakiem edytowalnym.  
  
-   Znak nie został już przypisany do tego położenia.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsEditPosition">
      <MemberSignature Language="C#" Value="public bool IsEditPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEditPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEditPosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEditPosition(int position);" />
      <MemberSignature Language="F#" Value="member this.IsEditPosition : int -&gt; bool" Usage="maskedTextProvider.IsEditPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja od zera w masce do przetestowania.</param>
        <summary>Określa, czy podaną pozycję można edytować.</summary>
        <returns><see langword="true" />Jeśli określona pozycja w sformatowanym ciągu jest edytowalna; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.IsEditPosition%2A> Metoda zwraca`true` tylko wtedy, gdy oba z następujących warunków są spełnione:  
  
-   Parametr znajduje się w granicach sformatowanego ciągu; oznacza to, że jego wartość jest większa lub równa zero i mniejsza <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od sformatowanego ciągu. `pos`  
  
-   Określona pozycja jest znakiem edytowalnym.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsPassword">
      <MemberSignature Language="C#" Value="public bool IsPassword { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPassword" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPassword As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPassword { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPassword : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IsPassword" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy należy zastosować ochronę hasłem do sformatowanego ciągu.</summary>
        <value><see langword="true" />Jeśli ciąg wejściowy ma być traktowany jako ciąg hasła; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ochronę hasłem można zainicjować przy użyciu jednego z następujących dwóch sposobów:  
  
-   Ustawianie właściwości na`null` wartość niebędącą wartością. <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>  
  
-   Ustawienie właściwości na `true` ,która<xref:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar%2A> również ustawia Właściwośćnawartość.<xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> <xref:System.ComponentModel.MaskedTextProvider.IsPassword%2A>  
  
 <xref:System.ComponentModel.MaskedTextProvider.IsPassword%2A>jest używana przez <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> metody i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> do określenia, czy należy ujawniać rzeczywiste znaki wejściowe, czy zasłaniać je <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>za pomocą.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="IsValidInputChar">
      <MemberSignature Language="C#" Value="public static bool IsValidInputChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidInputChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidInputChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidInputChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidInputChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidInputChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Char" /> Wartość do przetestowania.</param>
        <summary>Określa, czy określony znak jest prawidłowym znakiem wejściowym.</summary>
        <returns><see langword="true" />Jeśli określony znak zawiera prawidłową wartość wejściową; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe znaki wejściowe obejmują wszystkie znaki drukowalne, takie jak litery, cyfry, znaki interpunkcyjne, symbole i znak spacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="IsValidMaskChar">
      <MemberSignature Language="C#" Value="public static bool IsValidMaskChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidMaskChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidMaskChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidMaskChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidMaskChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidMaskChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Char" /> Wartość do przetestowania.</param>
        <summary>Określa, czy określony znak jest prawidłowym znakiem maski.</summary>
        <returns><see langword="true" />Jeśli określony znak zawiera prawidłową wartość maski; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe znaki maski obejmują wszystkie drukowalne znaki, takie jak litery, cyfry, znaki interpunkcyjne, symbole i znak spacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="IsValidPasswordChar">
      <MemberSignature Language="C#" Value="public static bool IsValidPasswordChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidPasswordChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidPasswordChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidPasswordChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidPasswordChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidPasswordChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Char" /> Wartość do przetestowania.</param>
        <summary>Określa, czy określony znak jest prawidłowym znakiem hasła.</summary>
        <returns><see langword="true" />Jeśli określony znak zawiera prawidłową wartość hasła; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe znaki hasła obejmują wszystkie znaki drukowalne i znak null, które są używane do wyłączania funkcji hasła. Znaki drukowalne zawierają litery, cyfry, znaki interpunkcyjne, symbole i znak spacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : char" Usage="System.ComponentModel.MaskedTextProvider.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) elementu do pobrania.</param>
        <summary>Pobiera element w określonym położeniu w sformatowanym ciągu.</summary>
        <value><see cref="T:System.Char" /> Na określonej pozycji w sformatowanym ciągu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest standardowym indeksatorem <xref:System.ComponentModel.MaskedTextProvider> dla klasy. <xref:System.ComponentModel.MaskedTextProvider.Item%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa lub równa <see cref="P:System.ComponentModel.MaskedTextProvider.Length" /> wartości maski.</exception>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
      </Docs>
    </Member>
    <Member MemberName="LastAssignedPosition">
      <MemberSignature Language="C#" Value="public int LastAssignedPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LastAssignedPosition" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastAssignedPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LastAssignedPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LastAssignedPosition : int" Usage="System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera indeks w masce po prawej stronie znaku wejściowego, który został przypisany do maski.</summary>
        <value>Jeśli do maski jest przypisany co najmniej jeden znak wejściowy, <see cref="T:System.Int32" /> zawierający indeks przypisanej do prawej pozycji; w przeciwnym razie, jeśli żadna pozycja nie została <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />przypisana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> Właściwość reprezentuje miejsce do edycji w masce względem pochodzenia, do którego przypisano znak wejściowy. W przypadku języków odczytanych od lewej do prawej (LTR), takich jak angielski, jest to przypisana do prawej pozycji pozycja; w przypadku języków odczytywanych od prawej do lewej (RTL) będzie to pozycja z lewej strony.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.ComponentModel.MaskedTextProvider.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość maski, Brak znaków modyfikatora maski.</summary>
        <value><see cref="T:System.Int32" /> Zawierający liczbę pozycji w masce, z wyłączeniem znaków, które modyfikują wprowadzanie maski.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Length%2A> Właściwość reprezentuje łączną liczbę znaków w masce, w tym literał i znaki edytowalne. Liczbę znaków literału można określić przez odjęcie wartości elementu <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> <xref:System.ComponentModel.MaskedTextProvider.Length%2A>od.  
  
 <xref:System.ComponentModel.MaskedTextProvider.Length%2A>opisuje także Długość sformatowanego ciągu, w tym znaki wejściowe, literały i znaki monitu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="Mask">
      <MemberSignature Language="C#" Value="public string Mask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Mask" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Mask" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mask As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Mask { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Mask : string" Usage="System.ComponentModel.MaskedTextProvider.Mask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maskę wejściową.</summary>
        <value>A <see cref="T:System.String" /> zawiera pełną maskę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest ustawiana <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> w konstruktorze. <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> Ta maska musi zawierać tylko prawidłowe znaki zdefiniowane przez język maskowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.#ctor" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clone" />
      </Docs>
    </Member>
    <Member MemberName="MaskCompleted">
      <MemberSignature Language="C#" Value="public bool MaskCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaskCompleted" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaskCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaskCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MaskCompleted : bool" Usage="System.ComponentModel.MaskedTextProvider.MaskCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wszystkie wymagane dane wejściowe zostały wprowadzone do sformatowanego ciągu.</summary>
        <value><see langword="true" />Jeśli wszystkie wymagane dane wejściowe zostały wprowadzone do maski; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> Właściwość sprawdza tylko wymagane elementy wejściowe. Aby określić, czy wszystkie wymagane i opcjonalne elementy wejściowe zostały wprowadzone, należy zamiast <xref:System.Windows.Forms.MaskedTextBox.MaskFull%2A?displayProperty=nameWithType> tego użyć właściwości <xref:System.Windows.Forms.MaskedTextBox> klasy.  
  
 Bieżąca wartość <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwości określa, które elementy formatowania są uważane za wymagane i które są opcjonalne.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskCompleted" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="MaskFull">
      <MemberSignature Language="C#" Value="public bool MaskFull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaskFull" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaskFull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaskFull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MaskFull : bool" Usage="System.ComponentModel.MaskedTextProvider.MaskFull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wszystkie wymagane i opcjonalne dane wejściowe zostały wprowadzone do sformatowanego ciągu.</summary>
        <value><see langword="true" />Jeśli wprowadzono wszystkie wymagane i opcjonalne dane wejściowe; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby sprawdzić, czy wprowadzono tylko wymagane elementy wejściowe, użyj <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> właściwości. Bieżąca wartość <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> właściwości określa, które elementy formatowania są uważane za wymagane i które są opcjonalne.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="PasswordChar">
      <MemberSignature Language="C#" Value="public char PasswordChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      <MemberSignature Language="VB.NET" Value="Public Property PasswordChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char PasswordChar { char get(); void set(char value); };" />
      <MemberSignature Language="F#" Value="member this.PasswordChar : char with get, set" Usage="System.ComponentModel.MaskedTextProvider.PasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znak, który ma zostać zastąpiony dla rzeczywistych znaków wejściowych.</summary>
        <value><see cref="T:System.Char" /> Wartość używana jako znak hasła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku poufnych danych wejściowych użytkownika powszechną procedurą jest ukrycie rzeczywistych informacji wprowadzonych przez użytkownika podczas operacji wyjściowych. Jeśli właściwość jest ustawiona na`null` nieznakowe, metody wyjściowe, takie jak <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> , będą zasłaniać znaki wejściowe z określonym znakiem hasła. <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Ustawienie tej właściwości na `null` wartość spowoduje wyłączenie funkcji ochrony haseł.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Znak hasła określony podczas ustawiania tej właściwości jest taki sam jak w przypadku bieżącego znaku <see cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />monitu. Te dwa muszą być różne.</exception>
        <exception cref="T:System.ArgumentException">Znak określony podczas ustawiania tej właściwości nie jest prawidłowym znakiem hasła określonym przez <see cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" /> metodę.</exception>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PromptChar">
      <MemberSignature Language="C#" Value="public char PromptChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PromptChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
      <MemberSignature Language="VB.NET" Value="Public Property PromptChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char PromptChar { char get(); void set(char value); };" />
      <MemberSignature Language="F#" Value="member this.PromptChar : char with get, set" Usage="System.ComponentModel.MaskedTextProvider.PromptChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znak używany do reprezentowania braku danych wejściowych użytkownika dla wszystkich dostępnych pozycji edycji.</summary>
        <value>Znak używany do monitowania użytkownika o dane wejściowe. Wartość domyślna to podkreślenie (_).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość reprezentuje znak monitu, który jest używany <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> przez metody i <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> do reprezentowania bieżącego stanu sformatowanego ciągu wejściowego. <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> Znak monitu jest umieszczany w pozycji edytowalnych, do których nie została jeszcze przypisana wartość wejściowa. Niektóre wersje <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody również zależą od wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Znak monitu określony podczas ustawiania tej właściwości jest taki sam jak bieżący znak <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />hasła. Te dwa muszą być różne.</exception>
        <exception cref="T:System.ArgumentException">Znak określony podczas ustawiania tej właściwości nie jest prawidłowym znakiem hasła określonym przez <see cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" /> metodę.</exception>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa ostatni przypisany znak z sformatowanego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; bool" Usage="maskedTextProvider.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa ostatni przypisany znak z sformatowanego ciągu.</summary>
        <returns><see langword="true" />Jeśli znak został pomyślnie usunięty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> nie działa, jeśli nie ma jeszcze żadnych znaków przypisanych do maski.  
  
 Po usunięciu ostatniego przypisanego znaku z sformatowanego ciągu, edytowalny znak maski jest resetowany dla tej pozycji, co pozwala na kolejne dane wejściowe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove([out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Remove(System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove([Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Remove :  *  -&gt; bool" Usage="maskedTextProvider.Remove (testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="testPosition">Pozycja od zera w sformatowanym ciągu, w którym znak został rzeczywiście usunięty. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji. Parametr wyjściowy.</param>
        <summary>Usuwa ostatni przypisany znak z sformatowanego ciągu, a następnie wyprowadza pozycję usunięcia i informacje opisowe.</summary>
        <returns><see langword="true" />Jeśli znak został pomyślnie usunięty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> nie działa, jeśli nie ma jeszcze żadnych znaków przypisanych do maski.  
  
 Po usunięciu ostatniego przypisanego znaku z sformatowanego ciągu, edytowalny znak maski jest resetowany dla tej pozycji, co pozwala na kolejne dane wejściowe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveAt">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa jeden lub więcej przypisanych znaków z sformatowanego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int position);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; bool" Usage="maskedTextProvider.RemoveAt position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja od zera przypisanego znaku do usunięcia.</param>
        <summary>Usuwa przypisany znak z podanej pozycji z sformatowanego ciągu.</summary>
        <returns><see langword="true" />Jeśli znak został pomyślnie usunięty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> nie działa, jeśli nie ma żadnych przypisanych znaków w określonym położeniu usuwania. Ta metoda nie ma wpływ na znaki literału.  
  
 Po usunięciu znaku pozostałe znaki umieszczone w masce zostaną przesunięte w lewo, aby wypełnić przerwy utworzoną przez usunięcie. Pozycje opuszczone są resetowane dla danych wejściowych. Jeśli przenoszenie znaków jest uniemożliwione przez definicję maski, nie następuje usunięcie i <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zwraca. `false`  
  
 To wywołanie metody jest dokładnie równoważne następującej wywołaniu przeciążonej <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%28System.Int32%2CSystem.Int32%29> wersji:  
  
 `RemoveAt(pos, pos);`  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int startPosition, int endPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 startPosition, int32 endPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (startPosition As Integer, endPosition As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int startPosition, int endPosition);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int * int -&gt; bool" Usage="maskedTextProvider.RemoveAt (startPosition, endPosition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startPosition">Indeks (liczony od zera) pierwszego przypisanego znaku do usunięcia.</param>
        <param name="endPosition">Indeks (liczony od zera) ostatniego przypisanego znaku do usunięcia.</param>
        <summary>Usuwa przypisane znaki między określonymi pozycjami z sformatowanego ciągu.</summary>
        <returns><see langword="true" />Jeśli znak został pomyślnie usunięty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> nie działa, jeśli nie ma żadnych przypisanych znaków w określonych pozycjach usuwania.  
  
 Po usunięciu znaku pozostałe znaki umieszczone w masce zostaną przesunięte w lewo, aby wypełnić przerwy utworzoną przez usunięcie. Pozycje opuszczone są resetowane dla danych wejściowych. Jeśli przenoszenie znaków jest uniemożliwione przez definicję maski, nie następuje usunięcie i <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zwraca. `false`  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int * int *  *  -&gt; bool" Usage="maskedTextProvider.RemoveAt (startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="startPosition">Indeks (liczony od zera) pierwszego przypisanego znaku do usunięcia.</param>
        <param name="endPosition">Indeks (liczony od zera) ostatniego przypisanego znaku do usunięcia.</param>
        <param name="testPosition">Jeśli to się powiedzie, pozycja od zera w sformatowanym ciągu, w którym znaki zostały faktycznie usunięte; w przeciwnym razie, pierwsze miejsce, w którym operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji. Parametr wyjściowy.</param>
        <summary>Usuwa przypisane znaki między określonymi pozycjami z sformatowanego ciągu, a następnie wyprowadza pozycję usunięcia i informacje opisowe.</summary>
        <returns><see langword="true" />Jeśli znak został pomyślnie usunięty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> nie działa, jeśli nie ma żadnych przypisanych znaków w określonych pozycjach usuwania.  
  
 Po usunięciu znaku pozostałe znaki umieszczone w masce zostaną przesunięte w lewo, aby wypełnić przerwy utworzoną przez usunięcie. Pozycje opuszczone są resetowane dla danych wejściowych. Jeśli przenoszenie znaków jest uniemożliwione przez definicję maski, nie następuje usunięcie i <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zwraca. `false`  
  
 Ta wersja programu <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> zawiera dwa dodatkowe parametry wyjściowe umożliwiające przekazanie większej ilości informacji na temat operacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamienia jeden lub więcej edytowalnych znaków w sformatowanym ciągu z określonymi znakami.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int -&gt; bool" Usage="maskedTextProvider.Replace (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.Char" /> Wartość, która zastąpi istniejącą wartość.</param>
        <param name="position">Pozycja od zera, aby wyszukać pierwszy znak edytowalny, który ma zostać zamieniony.</param>
        <summary>Zamienia pojedynczy znak na lub poza określoną pozycję o określoną wartość znaku.</summary>
        <returns><see langword="true" />Jeśli znak został pomyślnie zastąpiony; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje pierwsze miejsce edytowalne w sformatowanym ciągu na określonej `pos`pozycji lub poza nią. <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%29> Jeśli zostanie znaleziony, wartość pozycji edytowalnej jest zmieniana na określony znak, `input`. Dowolny z następujących warunków spowoduje błąd, który powoduje, że zastąpienie nie zostanie wykonane i wartość `false` , która ma zostać zwrócona:  
  
-   Wartość parametru jest mniejsza od zera lub większa <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od sformatowanego ciągu. `pos`  
  
-   Nie znaleziono znaku edytowalnego w sformatowanym ciągu znajdującym się w określonym położeniu `pos`lub poza nim.  
  
-   Znak zastępczy nie `input`jest prawidłowym znakiem wejściowym, ponieważ nie można go wydrukować lub nie pasuje do odpowiadającego mu elementu maski.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int position);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int -&gt; bool" Usage="maskedTextProvider.Replace (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Wartość służąca do zastępowania istniejących znaków do edycji.</param>
        <param name="position">Pozycja od zera, aby wyszukać pierwszy znak edytowalny, który ma zostać zamieniony.</param>
        <summary>Zamienia zakres edytowalnych znaków, zaczynając od określonej pozycji z określonym ciągiem.</summary>
        <returns><see langword="true" />Jeśli wszystkie znaki zostały pomyślnie zastąpione; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje pierwsze miejsce edytowalne na określonej `pos`pozycji lub poza nią. <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%29> Przy założeniu, że po tym momencie jest wystarczająca możliwość edytowalnych pozycji, istniejące wartości znakowe są zamieniane jeden do jednego z zawartością parametru `input`zastępczego ciągu.  
  
 Poniższe warunki są uznawane za błędy. Gdy wystąpi błąd, nie następuje zamiana i <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%29> zwraca `false`.  
  
-   Wartość parametru jest mniejsza od zera lub większa <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od sformatowanego ciągu. `pos`  
  
-   W sformatowanym ciągu nie ma wystarczającej liczby edytowalnych pozycji do przechowywania zawartości ciągu zamiennego.  
  
-   Jedna z wartości znaków zastępczych jest nieprawidłowa, ponieważ nie jest drukowana lub nie pasuje do odpowiadającego jej elementu maski.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="input" /></exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.Char" /> Wartość, która zastąpi istniejącą wartość.</param>
        <param name="position">Pozycja od zera, aby wyszukać pierwszy znak edytowalny, który ma zostać zamieniony.</param>
        <param name="testPosition">Jeśli to się powiedzie, pozycja od zera w sformatowanym ciągu, w którym ostatni znak został faktycznie zastąpiony; w przeciwnym razie, pierwsze miejsce, w którym operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji zamiany. Parametr wyjściowy.</param>
        <summary>Zastępuje pojedynczy znak znajdujący się w określonej pozycji lub poza nią określoną wartością znaku, a następnie wyprowadza pozycję usunięcia i informacje opisowe.</summary>
        <returns><see langword="true" />Jeśli znak został pomyślnie zastąpiony; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje pierwsze miejsce edytowalne w sformatowanym ciągu na określonej `pos`pozycji lub poza nią. <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Jeśli zostanie znaleziony, wartość pozycji edytowalnej jest zmieniana na określony znak, `input`. Dowolny z poniższych warunków spowoduje wystąpienie błędu, który powoduje, że zastąpienie nie zostanie wykonane i wartość `false` , która ma zostać zwrócona:  
  
-   Wartość parametru jest mniejsza od zera lub większa <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od sformatowanego ciągu. `pos`  
  
-   Nie znaleziono znaku edytowalnego w sformatowanym ciągu znajdującym się w określonym położeniu `pos`lub poza nim.  
  
-   Znak zastępczy nie `input`jest prawidłowym znakiem wejściowym, ponieważ nie można go wydrukować lub nie pasuje do odpowiadającego mu elementu maski.  
  
 Oprócz wartości zwracanej ta metoda ma dwa parametry wyjściowe umożliwiające dostarczenie dodatkowych informacji na temat operacji zastępczej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Wartość służąca do zastępowania istniejących znaków do edycji.</param>
        <param name="position">Pozycja od zera, aby wyszukać pierwszy znak edytowalny, który ma zostać zamieniony.</param>
        <param name="testPosition">Jeśli to się powiedzie, pozycja od zera w sformatowanym ciągu, w którym ostatni znak został faktycznie zastąpiony; w przeciwnym razie, pierwsze miejsce, w którym operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji zamiany. Parametr wyjściowy.</param>
        <summary>Zastępuje zakres edytowalnych znaków, zaczynając od określonej pozycji o określonym ciągu, a następnie wyprowadza pozycję usunięcia i informacje opisowe.</summary>
        <returns><see langword="true" />Jeśli wszystkie znaki zostały pomyślnie zastąpione; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje pierwsze miejsce edytowalne na określonej `pos`pozycji lub poza nią. <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Przy założeniu, że po tym momencie jest wystarczająca możliwość edytowalnych pozycji, istniejące wartości znakowe są zamieniane jeden na jeden z zawartością parametru `input`zastępczego ciągu.  
  
 Poniższe warunki są uznawane za błędy. Gdy wystąpi błąd, nie następuje zamiana i <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> zwraca `false`.  
  
-   Wartość parametru jest mniejsza od zera lub większa <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od sformatowanego ciągu. `pos`  
  
-   W sformatowanym ciągu nie ma wystarczającej liczby edytowalnych pozycji do przechowywania zawartości ciągu zamiennego.  
  
-   Jedna z wartości znaków zastępczych jest nieprawidłowa, ponieważ nie jest drukowana lub nie pasuje do odpowiadającego jej elementu maski.  
  
 Oprócz wartości zwracanej ta metoda ma dwa parametry wyjściowe umożliwiające dostarczenie dodatkowych informacji na temat operacji zastępczej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.Char" /> Wartość, która zastąpi istniejącą wartość.</param>
        <param name="startPosition">Pozycja od zera w sformatowanym ciągu, w którym rozpocznie się zamienianie.</param>
        <param name="endPosition">Pozycja od zera w sformatowanym ciągu, w którym następuje zastąpienie.</param>
        <param name="testPosition">Jeśli to się powiedzie, pozycja od zera w sformatowanym ciągu, w którym ostatni znak został faktycznie zastąpiony; w przeciwnym razie, pierwsze miejsce, w którym operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji zamiany. Parametr wyjściowy.</param>
        <summary>Zamienia pojedynczy znak między określonymi pozycjami początkowymi i końcowymi o określoną wartość znaku, a następnie wyprowadza pozycję usunięcia i informacje opisowe.</summary>
        <returns><see langword="true" />Jeśli znak został pomyślnie zastąpiony; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Metoda wyszukuje pierwszą edytowalną pozycję w sformatowanym ciągu między określonymi pozycjami początkowymi i końcowymi. Jeśli zostanie znaleziony, wartość pozycji edytowalnej jest zmieniana na określony znak, `input`. Dowolny z poniższych warunków spowoduje wystąpienie błędu, który powoduje, że zastąpienie nie zostanie wykonane i wartość `false` , która ma zostać zwrócona:  
  
-   Parametr `startPos` lub`endPos` wskazuje przed początkiem sformatowanego ciągu lub poza jego końcem.  
  
-   W określonym interwale nie znaleziono znaku edytowalnego.  
  
-   Znak zastępczy nie `input`jest prawidłowym znakiem wejściowym, ponieważ nie można go wydrukować lub nie pasuje do odpowiadającego mu elementu maski.  
  
 Oprócz wartości zwracanej ta metoda ma dwa parametry wyjściowe umożliwiające dostarczenie dodatkowych informacji na temat operacji zastępczej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int * int *  *  -&gt; bool" Usage="maskedTextProvider.Replace (input, startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Wartość służąca do zastępowania istniejących znaków do edycji.</param>
        <param name="startPosition">Pozycja od zera w sformatowanym ciągu, w którym rozpocznie się zamienianie.</param>
        <param name="endPosition">Pozycja od zera w sformatowanym ciągu, w którym następuje zastąpienie.</param>
        <param name="testPosition">Jeśli to się powiedzie, pozycja od zera w sformatowanym ciągu, w którym ostatni znak został faktycznie zastąpiony; w przeciwnym razie, pierwsze miejsce, w którym operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji zamiany. Parametr wyjściowy.</param>
        <summary>Zastępuje zakres edytowalnych znaków między określonymi pozycjami początkowymi i końcowymi z określonym ciągiem, a następnie wyprowadza pozycję usunięcia i informacje opisowe.</summary>
        <returns><see langword="true" />Jeśli wszystkie znaki zostały pomyślnie zastąpione; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> Metoda wyszukuje pierwszą edytowalną pozycję w sformatowanym ciągu między określonymi pozycjami początkowymi i końcowymi. Przy założeniu, że po tym momencie jest wystarczająca możliwość edytowalnych pozycji, istniejące wartości znakowe są zamieniane jeden na jeden z zawartością parametru `input`zastępczego ciągu.  
  
 Poniższe warunki są uznawane za błędy. Gdy wystąpi błąd, nie następuje zamiana i <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> zwraca `false`.  
  
-   Parametr `startPos` lub`endPos` wskazuje przed początkiem sformatowanego ciągu lub poza jego końcem.  
  
-   W sformatowanym ciągu nie ma wystarczającej liczby edytowalnych pozycji do przechowywania zawartości ciągu zamiennego.  
  
-   Jedna z wartości znaków zastępczych jest nieprawidłowa, ponieważ nie jest drukowana lub nie pasuje do odpowiadającego jej elementu maski.  
  
 Oprócz wartości zwracanej ta metoda ma dwa parametry wyjściowe umożliwiające dostarczenie dodatkowych informacji na temat operacji zastępczej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="ResetOnPrompt">
      <MemberSignature Language="C#" Value="public bool ResetOnPrompt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResetOnPrompt" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      <MemberSignature Language="VB.NET" Value="Public Property ResetOnPrompt As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResetOnPrompt { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResetOnPrompt : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą sposób obsługi znaku wejściowego, który pasuje do znaku monitu.</summary>
        <value><see langword="true" />Jeśli znak monitu wprowadzony jako dane wejściowe powoduje, że aktualna pozycja edytowalna w masce ma zostać zresetowana; w przeciwnym <see langword="false" /> razie, aby wskazać, że znak monitu ma być przetwarzany jako normalny znak wejściowy. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider>może traktować dwie kategorie znaków, tępy i znaki monitu w specjalny sposób. Zwykle każdy znak wejściowy będzie testowany względem maski i został zaakceptowany lub odrzucony. Działając na założeniu, że <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> właściwość jest ustawiona na wartość inną niż `null`, a następnie ustawienie <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A> właściwości na `true` spowoduje przetworzenie specjalnego przetwarzania dla znaku monitu. Po dodaniu znaku monitu spowoduje to wyczyszczenie bieżącego położenia znaku maski i bieżące położenie, które ma być zaawansowane, do następnego znaku edytowalnego.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>ma pierwszeństwo przed <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> właściwością, zgodnie z opisem w poniższej tabeli.  
  
|<xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>|<xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>|Zachowanie rezultatowe|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------|  
|`true`|`true`|Znak monitu może zostać dodany i powoduje zresetowanie bieżącej pozycji maski. Domyślnie.|  
|`true`|`false`|Znak monitu może zostać dodany i powoduje zresetowanie bieżącej pozycji maski.|  
|`false`|`true`|Znak monitu jest przetwarzany jako normalny znak wejściowy.|  
|`false`|`false`|Znak monitu jest nieprawidłowy i metody, które próbują dodać znak, zakończą się niepowodzeniem.|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <Member MemberName="ResetOnSpace">
      <MemberSignature Language="C#" Value="public bool ResetOnSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResetOnSpace" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property ResetOnSpace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResetOnSpace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResetOnSpace : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, jak ma być obsługiwany znak wejściowy.</summary>
        <value><see langword="true" />Jeśli znak wprowadzania miejsca powoduje zresetowanie bieżącej pozycji do edycji w masce; w przeciwnym <see langword="false" /> razie, aby wskazać, że ma być przetwarzany jako normalny znak wejściowy. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider>może traktować dwie kategorie znaków, spacje i znaki monitu w specjalny sposób. Zwykle każdy znak wejściowy będzie testowany względem maski i został zaakceptowany lub odrzucony. Ustawienie właściwości na `true` spowoduje, że bieżąca pozycja znaku maski jest czyszczona, a bieżące położenie jest zaawansowane do następnego znaku edytowalnego. <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A>  
  
 <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A>jest przydatne podczas przypisywania tekstu, który został zapisany z wyjątkiem monitu, gdzie monit jest zastępowany spacją. Przed przywróceniem tego ciągu, ustawienie <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> `true` spowoduje zresetowanie znaków monitu w miejscach zajmowanych przez spacje w ciągu wejściowym.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia ciąg sformatowany na określony ciąg wejściowy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Set(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Set (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Set : string -&gt; bool" Usage="maskedTextProvider.Set input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Wartość użyta do ustawienia sformatowanego ciągu.</param>
        <summary>Ustawia ciąg sformatowany na określony ciąg wejściowy.</summary>
        <returns><see langword="true" />Jeśli wszystkie znaki zostały pomyślnie ustawione; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda czyści istniejącą zawartość sformatowanego ciągu, a następnie stosuje maskę `input` względem ciągu, aby zaktualizować zawartość sformatowanego ciągu. <xref:System.ComponentModel.MaskedTextProvider.Set%2A>  
  
 Poniższe warunki są uznawane za błędy. Gdy wystąpi błąd, sformatowany ciąg pozostaje niezmieniony i <xref:System.ComponentModel.MaskedTextProvider.Set%2A> zwraca. `false`  
  
-   W sformatowanym ciągu nie ma wystarczającej liczby edytowalnych pozycji do przechowywania zawartości ciągu zamiennego.  
  
-   Jedna z wartości znaków zastępczych jest nieprawidłowa, ponieważ nie jest drukowana lub nie pasuje do odpowiadającego jej elementu maski.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="input" /></exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Set(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Set (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Set : string *  *  -&gt; bool" Usage="maskedTextProvider.Set (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Wartość użyta do ustawienia sformatowanego ciągu.</param>
        <param name="testPosition">Jeśli to się powiedzie, pozycja od zera w sformatowanym ciągu, w którym został faktycznie ustawiony ostatni znak; w przeciwnym razie, pierwsze miejsce, w którym operacja nie powiodła się. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji ustawiania. Parametr wyjściowy.</param>
        <summary>Ustawia ciąg sformatowany na określony ciąg wejściowy, a następnie wyprowadza pozycję usunięcia i informacje opisowe.</summary>
        <returns><see langword="true" />Jeśli wszystkie znaki zostały pomyślnie ustawione; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda czyści istniejącą zawartość sformatowanego ciągu, a następnie stosuje maskę `input` względem ciągu, aby zaktualizować zawartość sformatowanego ciągu. <xref:System.ComponentModel.MaskedTextProvider.Set%2A>  
  
 Poniższe warunki są uznawane za błędy. Gdy wystąpi błąd, sformatowany ciąg pozostaje niezmieniony i <xref:System.ComponentModel.MaskedTextProvider.Set%2A> zwraca. `false`  
  
-   W sformatowanym ciągu nie ma wystarczającej liczby edytowalnych pozycji do przechowywania zawartości ciągu zamiennego.  
  
-   Jedna z wartości znaków zastępczych jest nieprawidłowa, ponieważ nie jest drukowana lub nie pasuje do odpowiadającego jej elementu maski.  
  
 Ta wersja programu <xref:System.ComponentModel.MaskedTextProvider.Set%2A> zawiera dwa dodatkowe parametry wyjściowe umożliwiające przekazanie większej ilości informacji na temat operacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="input" /></exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="SkipLiterals">
      <MemberSignature Language="C#" Value="public bool SkipLiterals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipLiterals" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipLiterals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipLiterals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipLiterals : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.SkipLiterals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy pozycje znaku literału w masce mogą zostać zastąpione przez ich te same wartości.</summary>
        <value><see langword="true" />Aby zezwolić na dodawanie literałów; w przeciwnym <see langword="false" /> razie, aby nie zezwalać użytkownikowi na zastępowanie znaków literału. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maski wejściowe mogą zawierać literały i znaki edytowalne. Jeśli podjęto próbę dodania znaku wejściowego do pozycji w masce, która jest zajęta przez literał, wartość <xref:System.Windows.Forms.MaskedTextBox.SkipLiterals%2A> właściwości określa wynik.  
  
-   Jeśli ta właściwość ma `true`wartość, jest ona prawidłowa, aby zastąpić literał o tej samej wartości przy dodawaniu znaków wejściowych. Na przykład wartość znaku ukośnika odwrotnego, `'/'`można dodać do trzeciego położenia maski. `"00/00/000"`  
  
-   Jeśli ta właściwość jest `false`, nie można przypisać żadnej wartości do pozycji maski, która jest zajęta przez znak literału.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      </Docs>
    </Member>
    <Member MemberName="ToDisplayString">
      <MemberSignature Language="C#" Value="public string ToDisplayString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToDisplayString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToDisplayString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToDisplayString();" />
      <MemberSignature Language="F#" Value="member this.ToDisplayString : unit -&gt; string" Usage="maskedTextProvider.ToDisplayString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca sformatowany ciąg w postaci, w której jest do odtworzenia.</summary>
        <returns>Sformatowany <see cref="T:System.String" /> , który zawiera znaki i literały maski.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zawsze będzie zawierać monit i znaki literału w zwracanej wartości, niezależnie od wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> właściwości lub <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A>. <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> Ta metoda będzie zawsze wyświetlała znaki hasła, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Jeśli właściwość jest ustawiona na wartość znaku inną niż `null`.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A>jest często używany do uzyskiwania ciągu do wyświetlania w elementach skojarzonych z interfejsem użytkownika, <xref:System.Windows.Forms.MaskedTextBox>takich jak.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca sformatowany ciąg.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="maskedTextProvider.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca sformatowany ciąg, który zawiera wszystkie przypisane wartości znaków.</summary>
        <returns>Sformatowana <see cref="T:System.String" /> , która zawiera wszystkie przypisane wartości znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody obejmuje odpowiednio polecenia i literały zgodnie z bieżącymi wartościami <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> właściwości i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> . Zawsze zwróci oryginalne znaki wejściowe, ignorując wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawnia informacje, które są zwykle chronione w interfejsie użytkownika przez znaki hasła, powinno być używane z największą ostrożnością, aby uniknąć przypadkowego ujawnienia poufnych danych użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool -&gt; string" Usage="maskedTextProvider.ToString ignorePasswordChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar"><see langword="true" />Aby zwrócić rzeczywiste znaki edytowalne; w przeciwnym <see langword="false" /> razie, aby wskazać <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> , że właściwość ma być honorna.</param>
        <summary>Zwraca sformatowany ciąg, opcjonalnie uwzględniając znaki hasła.</summary>
        <returns>Sformatowana <see cref="T:System.String" /> , która zawiera literały, znaki i opcjonalnie hasła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody obejmuje odpowiednio polecenia i literały zgodnie z bieżącymi wartościami <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> właściwości i <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> . Jeśli parametr jest `true`, zwróci oryginalne znaki wejściowe, ignorując wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości. `ignorePasswordChar` Jeśli ten parametr ma `false`wartość, użyje znaku hasła, aby zaciemnienie edytowalnych danych wejściowych użytkownika <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> , jeśli właściwość jest ustawiona na inną niż `null`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda potencjalnie ujawnia informacje, które są zwykle chronione w interfejsie użytkownika za pomocą znaków hasła, powinno być używane z największą ostrożnością, aby uniknąć przypadkowego ujawnienia poufnych danych użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool includePrompt, bool includeLiterals);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool includePrompt, bool includeLiterals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (includePrompt As Boolean, includeLiterals As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool includePrompt, bool includeLiterals);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool -&gt; string" Usage="maskedTextProvider.ToString (includePrompt, includeLiterals)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrompt"><see langword="true" />Aby uwzględnić znaki monitu w zwracanym ciągu; w przeciwnym razie. <see langword="false" /></param>
        <param name="includeLiterals"><see langword="true" />Aby uwzględnić znaki literału w zwracanym ciągu; w przeciwnym razie. <see langword="false" /></param>
        <summary>Zwraca sformatowany ciąg, opcjonalnie uwzględniając monit i znaki literału.</summary>
        <returns>Sformatowany <see cref="T:System.String" /> , który zawiera wszystkie przypisane wartości znaków i opcjonalnie zawiera literały i polecenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody obejmuje odpowiednio polecenia i literały zgodnie z wartościami `IncludePrompt` parametrów i `IncludeLiterals` . Zwróć uwagę, że te parametry zastępują wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości. Ta metoda zawsze zwróci oryginalne znaki wejściowe, ignorując wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawnia informacje, które są zwykle chronione w interfejsie użytkownika przez znaki hasła, powinno być używane z największą ostrożnością, aby uniknąć przypadkowego ujawnienia poufnych danych użytkownika.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="maskedTextProvider.ToString (startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startPosition">Pozycja od zera w sformatowanym ciągu, w którym rozpoczyna się wyjście.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca podciąg sformatowanego ciągu.</summary>
        <returns>Jeśli to się powiedzie, podciąg sformatowanego <see cref="T:System.String" />, który zawiera wszystkie przypisane wartości znaków; <see cref="F:System.String.Empty" /> w przeciwnym razie ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody zwraca podciąg sformatowanego ciągu, rozpoczynając od pozycji `startPos` i uwzględniając kolejną liczbę znaków określoną przez `length` parametr. Zwrócony ciąg zawiera polecenia i literały odpowiednio do bieżących wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> właściwości i. <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Ciąg zwracany będzie zawierać oryginalne znaki wejściowe; <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwość jest zawsze ignorowana.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawnia informacje, które są zwykle chronione w interfejsie użytkownika przez znaki hasła, powinno być używane z największą ostrożnością, aby uniknąć przypadkowego ujawnienia poufnych danych użytkownika.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>wykonuje następujące akcje w przypadku niezgodności w parametrach wejściowych:  
  
-   Jeśli `startPos` jest mniejsza od zera, pozycja początkowa jest ustawiona na zero.  
  
-   Jeśli `startPos` jest większa lub równa wartości rzeczywistej <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu, <xref:System.String.Empty> zwracany jest ciąg.  
  
-   Jeśli `length` jest większa niż pozostała liczba znaków poza pozycją początkową, zwracane są tylko pozostałe znaki.  
  
-   Jeśli `length` jest mniejsza lub równa zero <xref:System.String.Empty> , zwracany jest ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (ignorePasswordChar, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar"><see langword="true" />Aby zwrócić rzeczywiste znaki edytowalne; w przeciwnym <see langword="false" /> razie, aby wskazać <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> , że właściwość ma być honorna.</param>
        <param name="startPosition">Pozycja od zera w sformatowanym ciągu, w którym rozpoczyna się wyjście.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca podciąg ciągu sformatowanego, opcjonalnie dołączając znaki hasła.</summary>
        <returns>Jeśli to się powiedzie, podciąg sformatowanego <see cref="T:System.String" />, który obejmuje literały, polecenia i opcjonalnie znaki hasła; <see cref="F:System.String.Empty" /> w przeciwnym razie ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody zwraca podciąg sformatowanego ciągu, rozpoczynając od pozycji `startPos` i uwzględniając kolejną liczbę znaków określoną przez `length` parametr. Zwrócony ciąg zawiera polecenia i literały odpowiednio do bieżących wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> właściwości i. <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Jeśli parametr jest `true`, zwróci oryginalne znaki wejściowe, ignorując wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości. `ignorePasswordChar` Jeśli ten parametr ma `false`wartość, użyje znaku hasła, aby zaciemnienie edytowalnych danych wejściowych użytkownika <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> , jeśli właściwość jest ustawiona na inną niż `null`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda potencjalnie ujawnia informacje, które są zwykle chronione w interfejsie użytkownika za pomocą znaków hasła, powinno być używane z największą ostrożnością, aby uniknąć przypadkowego ujawnienia poufnych danych użytkownika.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>wykonuje następujące akcje w przypadku niezgodności w parametrach wejściowych:  
  
-   Jeśli `startPos` jest mniejsza od zera, pozycja początkowa jest ustawiona na zero.  
  
-   Jeśli `startPos` jest większa lub równa wartości rzeczywistej <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu, <xref:System.String.Empty> zwracany jest ciąg.  
  
-   Jeśli `length` jest większa niż pozostała liczba znaków poza pozycją początkową, zwracane są tylko pozostałe znaki.  
  
-   Jeśli `length` jest mniejsza lub równa zero <xref:System.String.Empty> , zwracany jest ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool includePrompt, bool includeLiterals, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (includePrompt As Boolean, includeLiterals As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (includePrompt, includeLiterals, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="includePrompt"><see langword="true" />Aby uwzględnić znaki monitu w zwracanym ciągu; w przeciwnym razie. <see langword="false" /></param>
        <param name="includeLiterals"><see langword="true" />Aby uwzględnić znaki literału w zwracanym ciągu; w przeciwnym razie. <see langword="false" /></param>
        <param name="startPosition">Pozycja od zera w sformatowanym ciągu, w którym rozpoczyna się wyjście.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca podciąg sformatowanego ciągu, opcjonalnie uwzględniając monit i znaki literału.</summary>
        <returns>Jeśli to się powiedzie, podciąg sformatowanego <see cref="T:System.String" />, który zawiera wszystkie przypisane wartości znaków i opcjonalnie zawiera literały i znaki tekstowe; <see cref="F:System.String.Empty" /> w przeciwnym razie ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody zwraca podciąg sformatowanego ciągu, rozpoczynając od pozycji `startPos` i uwzględniając kolejną liczbę znaków określoną przez `length` parametr. Ciąg zwracany zawiera polecenia i literały odpowiednio do wartości `IncludePrompt` parametrów i. `IncludeLiterals` Zwróć uwagę, że te parametry zastępują wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> właściwości. Ta metoda zawsze zwróci oryginalne znaki wejściowe, ignorując wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda ujawnia informacje, które są zwykle chronione w interfejsie użytkownika przez znaki hasła, powinno być używane z największą ostrożnością, aby uniknąć przypadkowego ujawnienia poufnych danych użytkownika.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>wykonuje następujące akcje w przypadku niezgodności w parametrach wejściowych:  
  
-   Jeśli `startPos` jest mniejsza od zera, pozycja początkowa jest ustawiona na zero.  
  
-   Jeśli `startPos` jest większa lub równa wartości rzeczywistej <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu, <xref:System.String.Empty> zwracany jest ciąg.  
  
-   Jeśli `length` jest większa niż pozostała liczba znaków poza pozycją początkową, zwracane są tylko pozostałe znaki.  
  
-   Jeśli `length` jest mniejsza lub równa zero <xref:System.String.Empty> , zwracany jest ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean, includePrompt As Boolean, includeLiterals As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool * bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (ignorePasswordChar, includePrompt, includeLiterals, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar"><see langword="true" />Aby zwrócić rzeczywiste znaki edytowalne; w przeciwnym <see langword="false" /> razie, aby wskazać <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> , że właściwość ma być honorna.</param>
        <param name="includePrompt"><see langword="true" />Aby uwzględnić znaki monitu w zwracanym ciągu; w przeciwnym razie. <see langword="false" /></param>
        <param name="includeLiterals"><see langword="true" />Aby zwrócić znaki literału w zwracanym ciągu; w przeciwnym razie. <see langword="false" /></param>
        <param name="startPosition">Pozycja od zera w sformatowanym ciągu, w którym rozpoczyna się wyjście.</param>
        <param name="length">Liczba znaków do zwrócenia.</param>
        <summary>Zwraca podciąg sformatowanego ciągu, opcjonalnie uwzględniając znaki monitu, literału i hasła.</summary>
        <returns>Jeśli to się powiedzie, podciąg sformatowanego <see cref="T:System.String" />, który zawiera wszystkie przypisane wartości znaków i opcjonalnie zawiera literały, polecenia i hasła; <see cref="F:System.String.Empty" /> w przeciwnym razie ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja przeciążonej <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> metody zwraca podciąg sformatowanego ciągu, rozpoczynając od pozycji `startPos` i uwzględniając kolejną liczbę znaków określoną przez `length` parametr. Ciąg zwracany zawiera polecenia i literały odpowiednio do wartości `IncludePrompt` parametrów i. `IncludeLiterals` Zwróć uwagę, że te parametry zastępują wartości <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> właściwości <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> i. Jeśli parametr jest `true`, zwróci oryginalne znaki wejściowe, ignorując wartość <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> właściwości. `ignorePasswordChar` Jeśli ten parametr ma `false`wartość, użyje znaku hasła, aby zaciemnienie edytowalnych danych wejściowych użytkownika <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> , jeśli właściwość jest ustawiona na inną niż `null`.  
  
> [!IMPORTANT]
>  Ponieważ ta metoda potencjalnie ujawnia informacje, które są zwykle chronione w interfejsie użytkownika za pomocą znaków hasła, powinno być używane z największą ostrożnością, aby uniknąć przypadkowego ujawnienia poufnych danych użytkownika.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>wykonuje następujące akcje w przypadku niezgodności w parametrach wejściowych:  
  
-   Jeśli `startPos` jest mniejsza od zera, pozycja początkowa jest ustawiona na zero.  
  
-   Jeśli `startPos` jest większa lub równa wartości rzeczywistej <xref:System.ComponentModel.MaskedTextProvider.Length%2A> sformatowanego ciągu, <xref:System.String.Empty> zwracany jest ciąg.  
  
-   Jeśli `length` jest większa niż pozostała liczba znaków poza pozycją początkową, zwracane są tylko pozostałe znaki.  
  
-   Jeśli `length` jest mniejsza lub równa zero <xref:System.String.Empty> , zwracany jest ciąg.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="VerifyChar">
      <MemberSignature Language="C#" Value="public bool VerifyChar (char input, int position, out System.ComponentModel.MaskedTextResultHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyChar(char input, int32 position, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyChar (input As Char, position As Integer, ByRef hint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyChar(char input, int position, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % hint);" />
      <MemberSignature Language="F#" Value="member this.VerifyChar : char * int *  -&gt; bool" Usage="maskedTextProvider.VerifyChar (input, position, hint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="hint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.Char" /> Wartość do przetestowania.</param>
        <param name="position">Pozycja w masce, dla której ma zostać przetestowany znak wejściowy.</param>
        <param name="hint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji. Parametr wyjściowy.</param>
        <summary>Testuje, czy określony znak można ustawić pomyślnie na określonej pozycji.</summary>
        <returns><see langword="true" />Jeśli określony znak jest prawidłowy dla określonej pozycji; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.ComponentModel.MaskedTextProvider.VerifyChar%2A> sprawdza, czy pojedynczy znak reprezentuje prawidłowe dane wejściowe w podanej pozycji w sformatowanym ciągu. Ta metoda zwróci `false` następujące przyczyny:  
  
-   Wartość parametru jest mniejsza od zera lub większa <xref:System.ComponentModel.MaskedTextProvider.Length%2A> od <xref:System.ComponentModel.MaskedTextProvider.Mask%2A>wartości. `pos`  
  
-   Znak `input` nie jest prawidłowym znakiem wejściowym, określonym <xref:System.ComponentModel.MaskedTextProvider.IsValidInputChar%2A> przez metodę.  
  
-   Element nie `pos`jest zgodny z maską w podanej pozycji. `input`  
  
 Ostatni warunek <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>może zależeć od bieżącej wartości właściwości, <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>, <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> i <xref:System.ComponentModel.MaskedTextProvider.SkipLiterals%2A> .  
  
 Aby przetestować cały ciąg wejściowy dla maski, zamiast tego użyj jednej z <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> metod.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar(System.Char,System.Int32)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="VerifyEscapeChar">
      <MemberSignature Language="C#" Value="public bool VerifyEscapeChar (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyEscapeChar(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyEscapeChar (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyEscapeChar(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.VerifyEscapeChar : char * int -&gt; bool" Usage="maskedTextProvider.VerifyEscapeChar (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.Char" /> Wartość do przetestowania.</param>
        <param name="position">Pozycja w masce, dla której ma zostać przetestowany znak wejściowy.</param>
        <summary>Testuje, czy określony znak zostanie zmieniony na określonej pozycji.</summary>
        <returns><see langword="true" />Jeśli określony znak zostanie zmieniony na określonej pozycji; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak jest określany jako *ucieczki* , jeśli jest prawidłowym wejściem, ale nie jest przypisany do tej pozycji w sformatowanym ciągu. Znaki ucieczki należą do następujących trzech kategorii:  
  
-   Znaki monitu są wyprowadzane, <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> Jeśli właściwość `true`jest.  
  
-   Znaki wejściowe są wyprowadzane, jeśli mają taką samą wartość jak literał w masce, i jeśli <xref:System.ComponentModel.MaskedTextProvider.SkipLiterals%2A> właściwość jest. `true`  
  
-   W przypadku, <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> gdy właściwość jest `true`.  
  
 Metoda <xref:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar%2A> zostanie również zwrócona `false` , jeśli `pos` parametr <xref:System.ComponentModel.MaskedTextProvider.Length%2A> jest mniejszy <xref:System.ComponentModel.MaskedTextProvider.Mask%2A>od zera lub większy od.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      </Docs>
    </Member>
    <MemberGroup MemberName="VerifyString">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Testuje, czy określony ciąg można ustawić pomyślnie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VerifyString">
      <MemberSignature Language="C#" Value="public bool VerifyString (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyString(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyString (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyString(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.VerifyString : string -&gt; bool" Usage="maskedTextProvider.VerifyString input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Wartość do przetestowania.</param>
        <summary>Testuje, czy określony ciąg można ustawić pomyślnie.</summary>
        <returns><see langword="true" />Jeśli określony ciąg reprezentuje prawidłowe dane wejściowe; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stosuje ciąg z maską bez zmieniania sformatowanego ciągu, aby `input` sprawdzić, czy będzie on prawidłowy w odpowiedniej <xref:System.ComponentModel.MaskedTextProvider.Set%2A> operacji. `input` <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> Ta metoda zwraca również `true` wartość `null` , jeśli dane wejściowe mają wartość lub ma zerową długość.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
      </Docs>
    </Member>
    <Member MemberName="VerifyString">
      <MemberSignature Language="C#" Value="public bool VerifyString (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyString(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyString(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyString (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyString(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.VerifyString : string *  *  -&gt; bool" Usage="maskedTextProvider.VerifyString (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><see cref="T:System.String" /> Wartość do przetestowania.</param>
        <param name="testPosition">Jeśli to się powiedzie, pozycja od zera ostatniego znaku rzeczywiście przetestowana; w przeciwnym razie, pierwsze miejsce, w którym test zakończył się niepowodzeniem. Parametr wyjściowy.</param>
        <param name="resultHint">A <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , który zwięzłie opisuje wynik operacji testowej. Parametr wyjściowy.</param>
        <summary>Testuje, czy określony ciąg można ustawić pomyślnie, a następnie dane wyjściowe dotyczące pozycji i opisów.</summary>
        <returns><see langword="true" />Jeśli określony ciąg reprezentuje prawidłowe dane wejściowe; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stosuje ciąg z maską bez zmieniania sformatowanego ciągu, aby `input` sprawdzić, czy będzie on prawidłowy w odpowiedniej <xref:System.ComponentModel.MaskedTextProvider.Set%2A> operacji. `input` <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> Ta metoda zwraca również `true` wartość `null` , jeśli dane wejściowe mają wartość lub ma zerową długość.  
  
 Ta wersja programu <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> zawiera dwa dodatkowe parametry wyjściowe umożliwiające przekazanie większej ilości informacji na temat operacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
      </Docs>
    </Member>
  </Members>
</Type>

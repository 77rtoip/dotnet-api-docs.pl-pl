<Type Name="TypeConverter" FullName="System.ComponentModel.TypeConverter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5f481b34feb6da5934d7304387e22b436d3287b0" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69381109" /></Metadata><TypeSignature Language="C#" Value="public class TypeConverter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TypeConverter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.TypeConverter" />
  <TypeSignature Language="VB.NET" Value="Public Class TypeConverter" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeConverter" />
  <TypeSignature Language="F#" Value="type TypeConverter = class" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia jednolity sposób konwersji typów wartości na inne typy, a także do uzyskiwania dostępu do standardowych wartości i podwłaściwości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowym typem konwertera jest jeden, który konwertuje do i z reprezentacji tekstowej. Konwerter typu dla klasy jest powiązany z klasą z <xref:System.ComponentModel.TypeConverterAttribute>. Jeśli ten atrybut nie zostanie przesłonięty, wszystkie klasy dziedziczące z tej klasy używają tego samego konwertera typów, który jest klasą bazową.  
  
> [!NOTE]
>  W przypadku typów ogólnych nie należy bezpośrednio uzyskiwać dostępu do konwertera typów. Zamiast tego należy uzyskać dostęp do odpowiedniego konwertera przy użyciu polecenia <xref:System.ComponentModel.TypeDescriptor>. Aby uzyskać więcej informacji, zobacz przykłady kodu podane poniżej. 
>
> Jednak podczas korzystania z języka XAML procesor XAML wyszukuje <xref:System.ComponentModel.TypeConverterAttribute> bezpośrednio, zamiast przechodzić przez. <xref:System.ComponentModel.TypeDescriptor> W przypadkach, w których należy <xref:System.ComponentModel.TypeDescriptor> utworzyć wystąpienie z kodu lub w przypadku tworzenia wystąpienia udostępnionego w zasobach WPF, można je skonstruować bezpośrednio bez odwoływania <xref:System.ComponentModel.TypeDescriptor> się lub innej obsługi odbicia i typu.  
  
 Klasy pochodne <xref:System.ComponentModel.TypeConverter> są często przywoływane w sposób, w jaki procesor XAML konwertuje atrybut lub wartość tekstu inicjującego z znacznika (który jest z siebie ciągiem) i generuje obiekt dla reprezentacji w czasie wykonywania. Autorzy typów niestandardowych, którzy zamierzają obsługiwać zachowanie konwersji typu dla języka XAML zwykle <xref:System.ComponentModel.TypeConverter> implementują klasę, która obsługuje `ConvertFrom` własne zachowanie w ciągu. Takie zachowanie umożliwia konwersję typu z ciągu podanego jako wartość atrybutu XAML i udostępnia procesor XAML z obsługą, która jest wymagana do utworzenia obiektu z ciągu, tak aby obiekt można było utworzyć w analizowanym grafie obiektów. Typy niestandardowe lub składowe typów niestandardowych są wskazywane przez <xref:System.ComponentModel.TypeConverterAttribute> zastosowanie do definicji, z atrybutem odwołującym <xref:System.ComponentModel.TypeConverter> się do implementacji niestandardowej. Aby uzyskać więcej informacji, zobacz [Typy konwerterów dla języka XAML — Omówienie](~/docs/framework/xaml-services/type-converters-for-xaml-overview.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wystąpienie konwertera typów i powiązać je z klasą. Klasa implementująca konwerter, `MyClassConverter`musi dziedziczyć <xref:System.ComponentModel.TypeConverter> po klasie.  
  
 [!code-cpp[Classic TypeConverter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TypeConverter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TypeConverter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TypeConverter Example/CS/source.cs#1)]
 [!code-vb[Classic TypeConverter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TypeConverter Example/VB/source.vb#1)]  
  
 Jeśli masz właściwość, która ma Wyliczenie, sprawdź, czy wartość wyliczenia jest prawidłowa przed ustawieniem właściwości. Następny przykład kodu wymaga zadeklarowania wyliczeniowego `MyPropertyEnum` .  
  
 [!code-cpp[Classic TypeConverter Example#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TypeConverter Example/CPP/source.cpp#2)]
 [!code-csharp[Classic TypeConverter Example#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TypeConverter Example/CS/source.cs#2)]
 [!code-vb[Classic TypeConverter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TypeConverter Example/VB/source.vb#2)]  
  
 Innym typowym użyciem konwertera typów jest konwertowanie obiektu na ciąg. Poniższy przykład kodu drukuje nazwę <xref:System.Drawing.Color> przechowywaną w zmiennej. `c`  
  
 [!code-cpp[Classic TypeConverter Example#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TypeConverter Example/CPP/source.cpp#3)]
 [!code-csharp[Classic TypeConverter Example#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TypeConverter Example/CS/source.cs#3)]
 [!code-vb[Classic TypeConverter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TypeConverter Example/VB/source.vb#3)]  
  
 Można również użyć konwertera typów, aby przekonwertować wartość z jej nazwy, jak pokazano w następnym przykładzie kodu.  
  
 [!code-cpp[Classic TypeConverter Example#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TypeConverter Example/CPP/source.cpp#4)]
 [!code-csharp[Classic TypeConverter Example#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TypeConverter Example/CS/source.cs#4)]
 [!code-vb[Classic TypeConverter Example#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TypeConverter Example/VB/source.vb#4)]  
  
 W poniższym przykładzie kodu można użyć konwertera typów do drukowania zestawu wartości standardowych obsługiwanych przez obiekt.  
  
 [!code-cpp[Classic TypeConverter Example#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TypeConverter Example/CPP/source.cpp#5)]
 [!code-csharp[Classic TypeConverter Example#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TypeConverter Example/CS/source.cs#5)]
 [!code-vb[Classic TypeConverter Example#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TypeConverter Example/VB/source.vb#5)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Dziedzicz po <see cref="T:System.ComponentModel.TypeConverter" /> , aby zaimplementować własne wymagania dotyczące konwersji. W przypadku dziedziczenia z tej klasy można przesłonić następujące metody: 
-Aby obsługiwać konwersję typu niestandardowego <see cref="M:System.ComponentModel.TypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)" />, Zastąp metody <see cref="M:System.ComponentModel.TypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)" />, <see cref="M:System.ComponentModel.TypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)" />, <see cref="M:System.ComponentModel.TypeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)" /> i.  
  
— Aby przekonwertować typy, które muszą ponownie utworzyć obiekt, aby zmienić jego wartość, Zastąp <see cref="M:System.ComponentModel.TypeConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> metody <see cref="M:System.ComponentModel.TypeConverter.GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext)" /> i.  
  
— Aby skonwertować typy, które obsługują właściwości, <see cref="M:System.ComponentModel.TypeConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> Zastąp <see cref="M:System.ComponentModel.TypeConverter.GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext)" /> metody i. Jeśli konwertowana Klasa nie ma właściwości i musisz zaimplementować właściwości, można użyć <see cref="T:System.ComponentModel.TypeConverter.SimplePropertyDescriptor" /> klasy jako podstawy do implementowania deskryptorów właściwości. W przypadku dziedziczenia <see cref="T:System.ComponentModel.TypeConverter.SimplePropertyDescriptor" />z, należy <see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" /> zastąpić metody i <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" /> .  
  
— Aby skonwertować typy, które obsługują wartości standardowe <see cref="M:System.ComponentModel.TypeConverter.GetStandardValues(System.ComponentModel.ITypeDescriptorContext)" />, Zastąp <see cref="M:System.ComponentModel.TypeConverter.GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext)" />metody <see cref="M:System.ComponentModel.TypeConverter.GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext)" /> , <see cref="M:System.ComponentModel.TypeConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)" /> i.  
  
 <block subset="none" type="note"><para>  
 Typ pochodny może być oznaczony jako <see langword="internal" /> lub <see langword="private" />, ale wystąpienie typu <see cref="T:System.ComponentModel.TypeDescriptor" /> można utworzyć za pomocą klasy. Nie zapisuj niezabezpieczonego kodu przez założenie, że obiekt wywołujący jest zaufany. Załóżmy zamiast tego, że obiekty wywołujące mogą tworzyć wystąpienia typu w częściowej relacji zaufania.  
  
</para></block>  
  
 Aby uzyskać więcej informacji na temat konwerterów typów ogólnych (innych niż XAML), [zobacz How to: Implementowanie konwertera](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/ayybcxe5(v=vs.120)) typów lub [konwersji typów uogólnionych](https://msdn.microsoft.com/library/49253ae6-7657-4810-82ab-1176a6feeada).</para></block>
    <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
    <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
    <altmember cref="T:System.ComponentModel.TypeConverter.SimplePropertyDescriptor" />
    <altmember cref="T:System.ComponentModel.TypeConverter.StandardValuesCollection" />
    <related type="Article" href="https://msdn.microsoft.com/library/51a65860-efcb-4fe0-95a0-1c679cde66b7">Typy konwerterów dla XAML — Omówienie</related>
    <related type="Article" href="https://msdn.microsoft.com/library/5dfb299a-b6e2-41b8-8694-e6ac987547f1">Atrybuty CLR związane z językiem XAML dla niestandardowych typów i bibliotek</related>
    <related type="Article" href="https://msdn.microsoft.com/library/c2667cbd-2f46-4a7f-9dfc-53696e35e8e4">Definiowanie typów niestandardowych do użytku z usługami .NET Framework XAML</related>
    <related type="Article" href="https://msdn.microsoft.com/library/0e11f386-808c-4eae-9ba6-029ad7ba2211">Dokumentacja dotycząca pojęć dotyczących usługi NET XAML</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeConverter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.TypeConverter" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConvertFrom">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca czy ten konwerter może skonwertować obiekt jednego typu na typ tego konwertera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConvertFrom">
      <MemberSignature Language="C#" Value="public bool CanConvertFrom (Type sourceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConvertFrom(class System.Type sourceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.CanConvertFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanConvertFrom (sourceType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConvertFrom(Type ^ sourceType);" />
      <MemberSignature Language="F#" Value="member this.CanConvertFrom : Type -&gt; bool" Usage="typeConverter.CanConvertFrom sourceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="sourceType"><see cref="T:System.Type" /> Reprezentuje typ, z którego ma zostać przeprowadzona konwersja.</param>
        <summary>Zwraca czy ten konwerter może skonwertować obiekt danego typu na typ tego konwertera.</summary>
        <returns><see langword="true" />Jeśli ten konwerter może wykonać konwersję; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `false`zawsze zwraca wartość. Nigdy nie zwraca `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFrom">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFrom (System.ComponentModel.ITypeDescriptorContext context, Type sourceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFrom(class System.ComponentModel.ITypeDescriptorContext context, class System.Type sourceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFrom (context As ITypeDescriptorContext, sourceType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFrom(System::ComponentModel::ITypeDescriptorContext ^ context, Type ^ sourceType);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFrom : System.ComponentModel.ITypeDescriptorContext * Type -&gt; bool&#xA;override this.CanConvertFrom : System.ComponentModel.ITypeDescriptorContext * Type -&gt; bool" Usage="typeConverter.CanConvertFrom (context, sourceType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="sourceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="sourceType"><see cref="T:System.Type" /> Reprezentuje typ, z którego ma zostać przeprowadzona konwersja.</param>
        <summary>Zwraca czy ten konwerter może skonwertować obiekt danego typu na typ tego konwertera przy użyciu określonego kontekstu.</summary>
        <returns><see langword="true" />Jeśli ten konwerter może wykonać konwersję; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda `false`ta zwraca `sourceType` wartość, <xref:System.ComponentModel.Design.Serialization.InstanceDescriptor>chyba że jest to.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, aby zapewnić własne wymagania dotyczące konwersji.  
  
Użyj parametru <paramref name="context" /> , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być <see langword="null" />, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić <see langword="null" />.</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConvertTo">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca czy ten konwerter może przekonwertować obiekt na określony typ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConvertTo">
      <MemberSignature Language="C#" Value="public bool CanConvertTo (Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConvertTo(class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.CanConvertTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanConvertTo (destinationType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConvertTo(Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.CanConvertTo : Type -&gt; bool" Usage="typeConverter.CanConvertTo destinationType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="destinationType"><see cref="T:System.Type" /> Reprezentuje typ, do którego chcesz dokonać konwersji.</param>
        <summary>Zwraca czy ten konwerter może przekonwertować obiekt na określony typ.</summary>
        <returns><see langword="true" />Jeśli ten konwerter może wykonać konwersję; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `destinationType` jest ciągiem, domyślna <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementacja zawsze zwraca wartość `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertTo">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertTo (System.ComponentModel.ITypeDescriptorContext context, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertTo(class System.ComponentModel.ITypeDescriptorContext context, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertTo (context As ITypeDescriptorContext, destinationType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertTo(System::ComponentModel::ITypeDescriptorContext ^ context, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertTo : System.ComponentModel.ITypeDescriptorContext * Type -&gt; bool&#xA;override this.CanConvertTo : System.ComponentModel.ITypeDescriptorContext * Type -&gt; bool" Usage="typeConverter.CanConvertTo (context, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="destinationType"><see cref="T:System.Type" /> Reprezentuje typ, do którego chcesz dokonać konwersji.</param>
        <summary>Zwraca czy ten konwerter może przekonwertować obiekt na określony typ, przy użyciu określonego kontekstu.</summary>
        <returns><see langword="true" />Jeśli ten konwerter może wykonać konwersję; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 Jeśli `destinationType` jest ciągiem, domyślna <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementacja zawsze zwraca wartość `true`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, aby zapewnić własne wymagania dotyczące konwersji.</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertFrom">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje daną wartość na typ tego konwertera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertFrom">
      <MemberSignature Language="C#" Value="public object ConvertFrom (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ConvertFrom(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertFrom(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertFrom (value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ConvertFrom(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ConvertFrom : obj -&gt; obj" Usage="typeConverter.ConvertFrom value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do przekonwertowania.</param>
        <summary>Konwertuje daną wartość na typ tego konwertera.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowaną wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertFrom">
      <MemberSignature Language="C#" Value="public virtual object ConvertFrom (System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFrom(class System.ComponentModel.ITypeDescriptorContext context, class System.Globalization.CultureInfo culture, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFrom (context As ITypeDescriptorContext, culture As CultureInfo, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFrom(System::ComponentModel::ITypeDescriptorContext ^ context, System::Globalization::CultureInfo ^ culture, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFrom : System.ComponentModel.ITypeDescriptorContext * System.Globalization.CultureInfo * obj -&gt; obj&#xA;override this.ConvertFrom : System.ComponentModel.ITypeDescriptorContext * System.Globalization.CultureInfo * obj -&gt; obj" Usage="typeConverter.ConvertFrom (context, culture, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="culture"><see cref="T:System.Globalization.CultureInfo" /> Do użycia jako bieżąca kultura.</param>
        <param name="value"><see cref="T:System.Object" /> Do przekonwertowania.</param>
        <summary>Konwertuje dany obiekt na typ tego konwertera przy użyciu określonych informacji o kontekście i kulturze.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowaną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Autorzy typów niestandardowych, którzy zamierzają obsługiwać zachowanie konwersji typu dla języka XAML zazwyczaj <xref:System.ComponentModel.TypeConverter> implementują klasę <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> , która obsługuje zachowanie z ciągu. Takie zachowanie umożliwia konwersję typu z ciągu podanego jako wartość atrybutu XAML i udostępnia procesor XAML z obsługą, która jest wymagana do utworzenia obiektu z ciągu, tak aby obiekt można było utworzyć w analizowanym grafie obiektów. Typy niestandardowe lub składowe typów niestandardowych są wskazywane przez <xref:System.ComponentModel.TypeConverterAttribute> zastosowanie do definicji, z atrybutem odwołującym <xref:System.ComponentModel.TypeConverter> się do implementacji niestandardowej.  
  
 Na potrzeby języka XAML zazwyczaj nie są stosowane implementacje rozgałęzienia oparte `culture`na systemie. Dzieje się tak, ponieważ XAML jest wstępnie skompilowany w kontekście środowiska programistycznego i informacje specyficzne dla kultury dla języka XAML środowiska uruchomieniowego nie są istotne dla konwersji typu XAML. Aby uzyskać więcej informacji, zobacz [Typy konwerterów dla języka XAML — Omówienie](~/docs/framework/xaml-services/type-converters-for-xaml-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, aby zapewnić własne wymagania dotyczące konwersji.  
  
Użyj parametru <paramref name="context" /> , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być <see langword="null" />, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić <see langword="null" />.  
  
Dla wzorców implementacji dla konwerterów typów, które są używane do obsługi języka XAML i typów niestandardowych, zobacz [konwertery typów dla języka XAML — Omówienie](~/docs/framework/xaml-services/type-converters-for-xaml-overview.md).</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
        <related type="Article" href="https://msdn.microsoft.com/library/51a65860-efcb-4fe0-95a0-1c679cde66b7">Typy konwerterów dla XAML — Omówienie</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertFromInvariantString">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość na typ tego konwertera przy użyciu niezmiennej kultury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertFromInvariantString">
      <MemberSignature Language="C#" Value="public object ConvertFromInvariantString (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ConvertFromInvariantString(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertFromInvariantString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertFromInvariantString (text As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ConvertFromInvariantString(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ConvertFromInvariantString : string -&gt; obj" Usage="typeConverter.ConvertFromInvariantString text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text"><see cref="T:System.String" /> Do przekonwertowania.</param>
        <summary>Konwertuje dany ciąg na typ tego konwertera przy użyciu niezmiennej kultury.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowany tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zawsze zwraca wartość `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <Member MemberName="ConvertFromInvariantString">
      <MemberSignature Language="C#" Value="public object ConvertFromInvariantString (System.ComponentModel.ITypeDescriptorContext context, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ConvertFromInvariantString(class System.ComponentModel.ITypeDescriptorContext context, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertFromInvariantString(System.ComponentModel.ITypeDescriptorContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertFromInvariantString (context As ITypeDescriptorContext, text As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ConvertFromInvariantString(System::ComponentModel::ITypeDescriptorContext ^ context, System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ConvertFromInvariantString : System.ComponentModel.ITypeDescriptorContext * string -&gt; obj" Usage="typeConverter.ConvertFromInvariantString (context, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="text"><see cref="T:System.String" /> Do przekonwertowania.</param>
        <summary>Konwertuje dany ciąg na typ tego konwertera przy użyciu niezmiennej kultury i określonego kontekstu.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowany tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek jest zgłaszany, jeśli nie można przekonwertować ciągu na odpowiedni obiekt. Domyślna implementacja zawsze zwraca wartość `null`.  
  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertFromString">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określony tekst na obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public object ConvertFromString (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ConvertFromString(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertFromString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertFromString (text As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ConvertFromString(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ConvertFromString : string -&gt; obj" Usage="typeConverter.ConvertFromString text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Tekstowa reprezentacja obiektu do przekonwertowania.</param>
        <summary>Konwertuje określony tekst na obiekt.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowany tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zawsze zwraca wartość `null`.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem tej funkcji, <xref:System.ComponentModel.TypeConverter> zobacz Klasa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można przekonwertować ciągu na odpowiedni obiekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public object ConvertFromString (System.ComponentModel.ITypeDescriptorContext context, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ConvertFromString(class System.ComponentModel.ITypeDescriptorContext context, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertFromString(System.ComponentModel.ITypeDescriptorContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertFromString (context As ITypeDescriptorContext, text As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ConvertFromString(System::ComponentModel::ITypeDescriptorContext ^ context, System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ConvertFromString : System.ComponentModel.ITypeDescriptorContext * string -&gt; obj" Usage="typeConverter.ConvertFromString (context, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="text"><see cref="T:System.String" /> Do przekonwertowania.</param>
        <summary>Konwertuje dany tekst do obiektu, przy użyciu określonego kontekstu.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowany tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek jest zgłaszany, jeśli nie można przekonwertować ciągu na odpowiedni obiekt. Domyślna implementacja zawsze zwraca wartość `null`.  
  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public object ConvertFromString (System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ConvertFromString(class System.ComponentModel.ITypeDescriptorContext context, class System.Globalization.CultureInfo culture, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertFromString(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertFromString (context As ITypeDescriptorContext, culture As CultureInfo, text As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ConvertFromString(System::ComponentModel::ITypeDescriptorContext ^ context, System::Globalization::CultureInfo ^ culture, System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ConvertFromString : System.ComponentModel.ITypeDescriptorContext * System.Globalization.CultureInfo * string -&gt; obj" Usage="typeConverter.ConvertFromString (context, culture, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. Jeśli <see langword="null" /> jest zakończony, założono bieżącą kulturę.</param>
        <param name="text"><see cref="T:System.String" /> Do przekonwertowania.</param>
        <summary>Konwertuje dany tekst do obiektu, przy użyciu określonych informacji o kontekście i kulturze.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowany tekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek jest zgłaszany, jeśli nie można przekonwertować ciągu na odpowiedni obiekt. Domyślna implementacja zawsze zwraca wartość `null`.  
  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertTo">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje dany obiekt wartości na określony typ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertTo">
      <MemberSignature Language="C#" Value="public object ConvertTo (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ConvertTo(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertTo(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertTo (value As Object, destinationType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ConvertTo(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.ConvertTo : obj * Type -&gt; obj" Usage="typeConverter.ConvertTo (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do przekonwertowania.</param>
        <param name="destinationType"><see cref="T:System.Type" /> Do<paramref name="value" /> konwersji parametru na.</param>
        <summary>Konwertuje dany obiekt wartości na określony typ, używając argumentów.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowaną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowym typem konwersji do i z jest obiekt ciągu. Ta implementacja wywołuje <xref:System.Object.ToString%2A> obiekt, jeśli obiekt jest prawidłowy i jeśli typ docelowy jest ciągiem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="destinationType" /></exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertTo">
      <MemberSignature Language="C#" Value="public virtual object ConvertTo (System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertTo(class System.ComponentModel.ITypeDescriptorContext context, class System.Globalization.CultureInfo culture, object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertTo (context As ITypeDescriptorContext, culture As CultureInfo, value As Object, destinationType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertTo(System::ComponentModel::ITypeDescriptorContext ^ context, System::Globalization::CultureInfo ^ culture, System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="abstract member ConvertTo : System.ComponentModel.ITypeDescriptorContext * System.Globalization.CultureInfo * obj * Type -&gt; obj&#xA;override this.ConvertTo : System.ComponentModel.ITypeDescriptorContext * System.Globalization.CultureInfo * obj * Type -&gt; obj" Usage="typeConverter.ConvertTo (context, culture, value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. Jeśli <see langword="null" /> jest zakończony, założono bieżącą kulturę.</param>
        <param name="value"><see cref="T:System.Object" /> Do przekonwertowania.</param>
        <param name="destinationType"><see cref="T:System.Type" /> Do<paramref name="value" /> konwersji parametru na.</param>
        <summary>Konwertuje dany obiekt wartości na określony typ, przy użyciu określonych informacji o kontekście i kulturze.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowaną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najczęściej używane typy do przekonwertowania to i z obiektu String. Ta implementacja wywołuje <xref:System.Object.ToString%2A> obiekt, jeśli obiekt jest prawidłowy i jeśli typ docelowy jest ciągiem.  
  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 Autorzy typów niestandardowych, którzy zamierzają obsługiwać zachowanie konwersji typu dla języka XAML zazwyczaj <xref:System.ComponentModel.TypeConverter> implementują klasę <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> , która obsługuje zachowanie z ciągu. Te konwertery typów mogą również <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementować obsługę serializacji z powrotem do języka XAML.  
  
 Niektóre scenariusze serializacji XAML nie mogą być odpowiednio rozkierowane <xref:System.ComponentModel.TypeConverter> . W takich przypadkach może być konieczne zdefiniowanie <xref:System.Windows.Markup.ValueSerializer> , który obsługuje przypadki serializacji, które w przeciwnym razie byłyby obsługiwane przez. <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Markup.ValueSerializer>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="destinationType" /></exception>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, aby zapewnić własne wymagania dotyczące konwersji.  
  
Dla wzorców implementacji dla konwerterów typów, które są używane do obsługi języka XAML i typów niestandardowych, zobacz [konwertery typów dla języka XAML — Omówienie](~/docs/framework/xaml-services/type-converters-for-xaml-overview.md).</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
        <related type="Article" href="https://msdn.microsoft.com/library/51a65860-efcb-4fe0-95a0-1c679cde66b7">Typy konwerterów dla XAML — Omówienie</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertToInvariantString">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określoną wartość na reprezentację niezmienną typu Culture.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertToInvariantString">
      <MemberSignature Language="C#" Value="public string ConvertToInvariantString (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ConvertToInvariantString(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertToInvariantString(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertToInvariantString (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ConvertToInvariantString(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ConvertToInvariantString : obj -&gt; string" Usage="typeConverter.ConvertToInvariantString value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do przekonwertowania.</param>
        <summary>Konwertuje określoną wartość na reprezentację niezmienną typu Culture.</summary>
        <returns><see cref="T:System.String" /> Reprezentujący przekonwertowane wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten `context` parametr może służyć do wyodrębnienia dodatkowych informacji o środowisku, z którego ten konwerter jest wywoływany. Może to być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 W zależności od implementacji programu formatującego wartości może być możliwe przekazanie zwróconego ciągu z powrotem do programu formatującego wartości, aby ponownie utworzyć wystąpienie obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <Member MemberName="ConvertToInvariantString">
      <MemberSignature Language="C#" Value="public string ConvertToInvariantString (System.ComponentModel.ITypeDescriptorContext context, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ConvertToInvariantString(class System.ComponentModel.ITypeDescriptorContext context, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertToInvariantString(System.ComponentModel.ITypeDescriptorContext,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertToInvariantString (context As ITypeDescriptorContext, value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ConvertToInvariantString(System::ComponentModel::ITypeDescriptorContext ^ context, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ConvertToInvariantString : System.ComponentModel.ITypeDescriptorContext * obj -&gt; string" Usage="typeConverter.ConvertToInvariantString (context, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="value"><see cref="T:System.Object" /> Do przekonwertowania.</param>
        <summary>Konwertuje określoną wartość na reprezentację w postaci ciągu niezmiennej, przy użyciu określonego kontekstu.</summary>
        <returns><see cref="T:System.String" /> Reprezentujący przekonwertowane wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 W zależności od implementacji programu formatującego wartości może być możliwe przekazanie zwróconego ciągu z powrotem do programu formatującego wartości, aby ponownie utworzyć wystąpienie obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertToString">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określoną wartość na reprezentację ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public string ConvertToString (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ConvertToString(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertToString(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertToString (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ConvertToString(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ConvertToString : obj -&gt; string" Usage="typeConverter.ConvertToString value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do przekonwertowania.</param>
        <summary>Konwertuje określoną wartość na reprezentację ciągu.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowaną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W zależności od implementacji programu formatującego wartości może być możliwe przekazanie zwróconego ciągu z powrotem do programu formatującego wartości, aby ponownie utworzyć wystąpienie obiektu.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem na tej funkcji <xref:System.ComponentModel.TypeConverter> , zobacz Klasa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public string ConvertToString (System.ComponentModel.ITypeDescriptorContext context, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ConvertToString(class System.ComponentModel.ITypeDescriptorContext context, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertToString(System.ComponentModel.ITypeDescriptorContext,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertToString (context As ITypeDescriptorContext, value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ConvertToString(System::ComponentModel::ITypeDescriptorContext ^ context, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ConvertToString : System.ComponentModel.ITypeDescriptorContext * obj -&gt; string" Usage="typeConverter.ConvertToString (context, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="value"><see cref="T:System.Object" /> Do przekonwertowania.</param>
        <summary>Konwertuje daną wartość na reprezentację ciągu przy użyciu danego kontekstu.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowaną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 W zależności od implementacji programu formatującego wartości może być możliwe przekazanie zwróconego ciągu z powrotem do programu formatującego wartości, aby ponownie utworzyć wystąpienie obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public string ConvertToString (System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ConvertToString(class System.ComponentModel.ITypeDescriptorContext context, class System.Globalization.CultureInfo culture, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.ConvertToString(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertToString (context As ITypeDescriptorContext, culture As CultureInfo, value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ConvertToString(System::ComponentModel::ITypeDescriptorContext ^ context, System::Globalization::CultureInfo ^ culture, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ConvertToString : System.ComponentModel.ITypeDescriptorContext * System.Globalization.CultureInfo * obj -&gt; string" Usage="typeConverter.ConvertToString (context, culture, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. Jeśli <see langword="null" /> jest zakończony, założono bieżącą kulturę.</param>
        <param name="value"><see cref="T:System.Object" /> Do przekonwertowania.</param>
        <summary>Konwertuje daną wartość na reprezentację ciągu, przy użyciu określonych informacji o kontekście i kulturze.</summary>
        <returns><see cref="T:System.Object" /> Reprezentuje przekonwertowaną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 W zależności od implementacji programu formatującego wartości może być możliwe przekazanie zwróconego ciągu z powrotem do programu formatującego wartości, aby ponownie utworzyć wystąpienie obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wykonać konwersji.</exception>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje ponowne utworzenie <see cref="T:System.Object" /> podanego zestawu wartości właściwości dla obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (System.Collections.IDictionary propertyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstance(class System.Collections.IDictionary propertyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.CreateInstance(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (propertyValues As IDictionary) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstance(System::Collections::IDictionary ^ propertyValues);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : System.Collections.IDictionary -&gt; obj" Usage="typeConverter.CreateInstance propertyValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="propertyValues"><see cref="T:System.Collections.IDictionary" /> Reprezentuje słownik nowych wartości właściwości.</param>
        <summary>Powoduje ponowne utworzenie <see cref="T:System.Object" /> podanego zestawu wartości właściwości dla obiektu.</summary>
        <returns>Reprezentujący podaną <see cref="T:System.Collections.IDictionary" />lub <see langword="null" /> Jeśli nie można utworzyć obiektu. <see cref="T:System.Object" /> Ta metoda zawsze zwraca <see langword="null" />wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody należy użyć w przypadku obiektów, które są niezmienne, ale dla których chcesz podać właściwości możliwe do zmiany.  
  
 Słownik dostarczony przez `propertyValues` parametr ma serię par nazwa/wartość, po <xref:System.ComponentModel.TypeConverter.GetProperties%2A>jednej dla każdej właściwości zwróconej przez.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary propertyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(class System.ComponentModel.ITypeDescriptorContext context, class System.Collections.IDictionary propertyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateInstance (context As ITypeDescriptorContext, propertyValues As IDictionary) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::ComponentModel::ITypeDescriptorContext ^ context, System::Collections::IDictionary ^ propertyValues);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : System.ComponentModel.ITypeDescriptorContext * System.Collections.IDictionary -&gt; obj&#xA;override this.CreateInstance : System.ComponentModel.ITypeDescriptorContext * System.Collections.IDictionary -&gt; obj" Usage="typeConverter.CreateInstance (context, propertyValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="propertyValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="propertyValues"><see cref="T:System.Collections.IDictionary" /> Nowe wartości właściwości.</param>
        <summary>Tworzy wystąpienie typu, z którym <see cref="T:System.ComponentModel.TypeConverter" /> jest skojarzone, przy użyciu określonego kontekstu, z uwzględnieniem zestawu wartości właściwości dla tego obiektu.</summary>
        <returns>Reprezentujący podaną <see cref="T:System.Collections.IDictionary" />lub <see langword="null" /> Jeśli nie można utworzyć obiektu. <see cref="T:System.Object" /> Ta metoda zawsze zwraca <see langword="null" />wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody należy użyć w przypadku obiektów, które są niezmienne, ale dla których chcesz podać właściwości możliwe do zmiany.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, jeśli typ, który ma zostać przekonwertowany, musi ponownie utworzyć obiekt, aby zmienić jego wartość.  
  
Użyj parametru <paramref name="context" /> , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być <see langword="null" />, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić <see langword="null" />.  
  
Słownik dostarczony przez <paramref name="propertyValues" /> parametr ma serię par nazwa/wartość, po <see cref="M:System.ComponentModel.TypeConverter.GetProperties(System.Object)" />jednej dla każdej właściwości zwróconej przez.</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="typeConverter.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Do konwersji lub <see langword="null" /> Jeśli obiekt jest niedostępny. <see cref="T:System.Object" /></param>
        <summary>Zwraca wyjątek, który ma zostać zgłoszony, gdy nie można wykonać konwersji.</summary>
        <returns><see cref="T:System.Exception" /> Reprezentuje wyjątek, który ma zostać zgłoszony, gdy nie można wykonać konwersji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Automatycznie generowane przez tę metodę.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="typeConverter.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Do konwersji lub <see langword="null" /> Jeśli obiekt jest niedostępny. <see cref="T:System.Object" /></param>
        <param name="destinationType"><see cref="T:System.Type" /> Reprezentuje typ, do którego przekonwertowano próbę konwersji.</param>
        <summary>Zwraca wyjątek, który ma zostać zgłoszony, gdy nie można wykonać konwersji.</summary>
        <returns><see cref="T:System.Exception" /> Reprezentuje wyjątek, który ma zostać zgłoszony, gdy nie można wykonać konwersji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Automatycznie generowane przez tę metodę.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCreateInstanceSupported">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca czy zmiana wartości w tym obiekcie wymaga wywołania <see cref="M:System.ComponentModel.TypeConverter.CreateInstance(System.Collections.IDictionary)" /> metody w celu utworzenia nowej wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCreateInstanceSupported">
      <MemberSignature Language="C#" Value="public bool GetCreateInstanceSupported ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetCreateInstanceSupported() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetCreateInstanceSupported" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCreateInstanceSupported () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetCreateInstanceSupported();" />
      <MemberSignature Language="F#" Value="member this.GetCreateInstanceSupported : unit -&gt; bool" Usage="typeConverter.GetCreateInstanceSupported " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy zmiana wartości w tym obiekcie wymaga wywołania <see cref="M:System.ComponentModel.TypeConverter.CreateInstance(System.Collections.IDictionary)" /> metody w celu utworzenia nowej wartości.</summary>
        <returns><see langword="true" />Jeśli zmiana właściwości w tym obiekcie wymaga wywołania <see cref="M:System.ComponentModel.TypeConverter.CreateInstance(System.Collections.IDictionary)" /> do utworzenia nowej wartości; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCreateInstanceSupported">
      <MemberSignature Language="C#" Value="public virtual bool GetCreateInstanceSupported (System.ComponentModel.ITypeDescriptorContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetCreateInstanceSupported(class System.ComponentModel.ITypeDescriptorContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCreateInstanceSupported (context As ITypeDescriptorContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetCreateInstanceSupported(System::ComponentModel::ITypeDescriptorContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member GetCreateInstanceSupported : System.ComponentModel.ITypeDescriptorContext -&gt; bool&#xA;override this.GetCreateInstanceSupported : System.ComponentModel.ITypeDescriptorContext -&gt; bool" Usage="typeConverter.GetCreateInstanceSupported context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <summary>Zwraca czy zmiana wartości w tym obiekcie wymaga wywołania <see cref="M:System.ComponentModel.TypeConverter.CreateInstance(System.Collections.IDictionary)" /> do utworzenia nowej wartości przy użyciu określonego kontekstu.</summary>
        <returns><see langword="true" />Jeśli zmiana właściwości w tym obiekcie wymaga wywołania <see cref="M:System.ComponentModel.TypeConverter.CreateInstance(System.Collections.IDictionary)" /> do utworzenia nowej wartości; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `false`zawsze zwraca wartość.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, jeśli typ, który ma zostać przekonwertowany, musi ponownie utworzyć obiekt, aby zmienić jego wartość.  
  
Użyj parametru <paramref name="context" /> , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być <see langword="null" />, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić <see langword="null" />.</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję właściwości typu tablicy określonej przez parametr value.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetProperties (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetProperties(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties (value As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetProperties : obj -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="typeConverter.GetProperties value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Określa typ tablicy, dla której mają zostać pobrane właściwości. <see cref="T:System.Object" /></param>
        <summary>Zwraca kolekcję właściwości typu tablicy określonej przez parametr value.</summary>
        <returns>Z właściwościami, które są dostępne dla tego typu danych, lub <see langword="null" /> Jeśli nie ma żadnych właściwości. <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `null`zawsze zwraca wartość.  
  
 Domyślnie typ nie zwraca właściwości. Łatwa implementacja tej metody może wywołać <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> prawidłowy typ danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetProperties (System.ComponentModel.ITypeDescriptorContext context, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.ComponentModel.ITypeDescriptorContext context, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties (context As ITypeDescriptorContext, value As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::ComponentModel::ITypeDescriptorContext ^ context, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetProperties : System.ComponentModel.ITypeDescriptorContext * obj -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="typeConverter.GetProperties (context, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="value">Określa typ tablicy, dla której mają zostać pobrane właściwości. <see cref="T:System.Object" /></param>
        <summary>Zwraca kolekcję właściwości typu tablicy określonej przez parametr value przy użyciu określonego kontekstu.</summary>
        <returns>Z właściwościami, które są dostępne dla tego typu danych, lub <see langword="null" /> Jeśli nie ma żadnych właściwości. <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `null`zawsze zwraca wartość.  
  
 Domyślnie typ nie zwraca właściwości. Łatwa implementacja tej metody może wywołać <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> prawidłowy typ danych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetProperties (System.ComponentModel.ITypeDescriptorContext context, object value, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.ComponentModel.ITypeDescriptorContext context, object value, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProperties (context As ITypeDescriptorContext, value As Object, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::ComponentModel::ITypeDescriptorContext ^ context, System::Object ^ value, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.ComponentModel.ITypeDescriptorContext * obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection&#xA;override this.GetProperties : System.ComponentModel.ITypeDescriptorContext * obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="typeConverter.GetProperties (context, value, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="value">Określa typ tablicy, dla której mają zostać pobrane właściwości. <see cref="T:System.Object" /></param>
        <param name="attributes">Tablica typu <see cref="T:System.Attribute" /> , która jest używana jako filtr.</param>
        <summary>Zwraca kolekcję właściwości typu tablicy określonej przez parametr value, przy użyciu określonego kontekstu i atrybutów.</summary>
        <returns>Z właściwościami, które są dostępne dla tego typu danych, lub <see langword="null" /> Jeśli nie ma żadnych właściwości. <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `null`zawsze zwraca wartość.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, jeśli typ, który ma zostać przekonwertowany, obsługuje właściwości.  
  
Użyj parametru <paramref name="context" /> , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być <see langword="null" />, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić <see langword="null" />.  
  
Tablica atrybutów służy do filtrowania tablicy. Atrybuty mogą zawierać kombinację <see cref="T:System.Type" /> obiektów i. <see cref="T:System.Attribute" /> Filtrowanie jest zdefiniowane przy użyciu następujących reguł: 
-A <see cref="T:System.Type" /> jest traktowany jako symbol wieloznaczny; pasuje do właściwości, <see cref="T:System.Type" /> która ma w jej zestawie atrybutów.  
  
-Jeśli właściwość nie ma <see cref="T:System.Attribute" /> tej samej klasy, właściwość nie jest uwzględniona w zwracanej tablicy.  
  
-Jeśli atrybut jest wystąpieniem <see cref="T:System.Attribute" />, właściwość musi być dokładnym dopasowaniem lub nie jest uwzględniona w zwracanej tablicy.  
  
— Jeśli <see cref="T:System.Attribute" /> wystąpienie jest określone i jest właściwością domyślną, jest zawarte w zwracanej tablicy, nawet jeśli nie ma żadnego wystąpienia <see cref="T:System.Attribute" /> właściwości.</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPropertiesSupported">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca czy ten obiekt obsługuje właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPropertiesSupported">
      <MemberSignature Language="C#" Value="public bool GetPropertiesSupported ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetPropertiesSupported() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetPropertiesSupported" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertiesSupported () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetPropertiesSupported();" />
      <MemberSignature Language="F#" Value="member this.GetPropertiesSupported : unit -&gt; bool" Usage="typeConverter.GetPropertiesSupported " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy ten obiekt obsługuje właściwości.</summary>
        <returns><see langword="true" />Jeśli <see cref="M:System.ComponentModel.TypeConverter.GetProperties(System.Object)" /> należy wywołać, <see langword="false" />aby znaleźć właściwości tego obiektu; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `false`zawsze zwraca wartość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertiesSupported">
      <MemberSignature Language="C#" Value="public virtual bool GetPropertiesSupported (System.ComponentModel.ITypeDescriptorContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetPropertiesSupported(class System.ComponentModel.ITypeDescriptorContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPropertiesSupported (context As ITypeDescriptorContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetPropertiesSupported(System::ComponentModel::ITypeDescriptorContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertiesSupported : System.ComponentModel.ITypeDescriptorContext -&gt; bool&#xA;override this.GetPropertiesSupported : System.ComponentModel.ITypeDescriptorContext -&gt; bool" Usage="typeConverter.GetPropertiesSupported context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <summary>Zwraca czy ten obiekt obsługuje właściwości, używając określonego kontekstu.</summary>
        <returns><see langword="true" />Jeśli <see cref="M:System.ComponentModel.TypeConverter.GetProperties(System.Object)" /> należy wywołać, <see langword="false" />aby znaleźć właściwości tego obiektu; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `false`zawsze zwraca wartość.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, jeśli typ, który ma zostać przekonwertowany, obsługuje właściwości.  
  
Użyj parametru <paramref name="context" /> , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być <see langword="null" />, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić <see langword="null" />.</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStandardValues">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję wartości standardowych dla typu danych, dla których zaprojektowano ten konwerter typów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStandardValues">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection GetStandardValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ICollection GetStandardValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetStandardValues" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStandardValues () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ICollection ^ GetStandardValues();" />
      <MemberSignature Language="F#" Value="member this.GetStandardValues : unit -&gt; System.Collections.ICollection" Usage="typeConverter.GetStandardValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję wartości standardowych z domyślnego kontekstu dla typu danych, dla którego zaprojektowano ten konwerter typów.</summary>
        <returns>Zawiera standardowy zestaw prawidłowych wartości lub <see langword="null" /> Jeśli typ danych nie obsługuje standardowego zestawu wartości. <see cref="T:System.ComponentModel.TypeConverter.StandardValuesCollection" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `null`zawsze zwraca wartość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStandardValues">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues (System.ComponentModel.ITypeDescriptorContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter/StandardValuesCollection GetStandardValues(class System.ComponentModel.ITypeDescriptorContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetStandardValues(System.ComponentModel.ITypeDescriptorContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStandardValues (context As ITypeDescriptorContext) As TypeConverter.StandardValuesCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter::StandardValuesCollection ^ GetStandardValues(System::ComponentModel::ITypeDescriptorContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member GetStandardValues : System.ComponentModel.ITypeDescriptorContext -&gt; System.ComponentModel.TypeConverter.StandardValuesCollection&#xA;override this.GetStandardValues : System.ComponentModel.ITypeDescriptorContext -&gt; System.ComponentModel.TypeConverter.StandardValuesCollection" Usage="typeConverter.GetStandardValues context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter+StandardValuesCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu, którego można użyć do wyodrębnienia dodatkowych informacji o środowisku, z którego ten konwerter jest wywoływany. Ten parametr lub właściwości tego parametru mogą być <see langword="null" />.</param>
        <summary>Zwraca kolekcję wartości standardowych dla typu danych, który jest przeznaczony dla tego konwertera typów w przypadku podanego kontekstu formatu.</summary>
        <returns>, Który zawiera standardowy zestaw prawidłowych wartości lub <see langword="null" /> Jeśli typ danych nie obsługuje standardowego zestawu wartości. <see cref="T:System.ComponentModel.TypeConverter.StandardValuesCollection" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z implementacją w programie <xref:System.ComponentModel.TypeConverter>ta metoda zawsze zwraca wartość. `null`  
  
   
  
## Examples  
 Aby zapoznać się z przykładem na tej funkcji <xref:System.ComponentModel.TypeConverter> , zobacz Klasa.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, jeśli typ, który ma zostać przekonwertowany, obsługuje wartości standardowe.</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStandardValuesExclusive">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca czy kolekcja wartości standardowych zwracana z <see cref="M:System.ComponentModel.TypeConverter.GetStandardValues" /> jest listą wyłączną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStandardValuesExclusive">
      <MemberSignature Language="C#" Value="public bool GetStandardValuesExclusive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetStandardValuesExclusive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetStandardValuesExclusive" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStandardValuesExclusive () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetStandardValuesExclusive();" />
      <MemberSignature Language="F#" Value="member this.GetStandardValuesExclusive : unit -&gt; bool" Usage="typeConverter.GetStandardValuesExclusive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy kolekcja wartości standardowych zwracana z <see cref="M:System.ComponentModel.TypeConverter.GetStandardValues" /> jest listą wyłączną.</summary>
        <returns><see langword="true" />Jeśli zwracana z <see cref="M:System.ComponentModel.TypeConverter.GetStandardValues" /> jest wyczerpującą listą możliwych wartości; <see cref="T:System.ComponentModel.TypeConverter.StandardValuesCollection" /> <see langword="false" /> jeśli są możliwe inne wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `false`zawsze zwraca wartość.  
  
 Jeśli lista ma charakter wyłączny, na przykład w typie danych wyliczenia, żadne inne wartości nie są prawidłowe. Jeśli lista nie jest wyłączna, wówczas inne prawidłowe wartości mogą istnieć oprócz listy standardowych wartości, które <xref:System.ComponentModel.TypeConverter.GetStandardValues%2A> zapewnia metoda. Jeśli wartości są wyłączne, na liście zwracanej <xref:System.ComponentModel.TypeConverter.GetStandardValues%2A> przez nie należy zezwalać na edytowanie tych wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStandardValuesExclusive">
      <MemberSignature Language="C#" Value="public virtual bool GetStandardValuesExclusive (System.ComponentModel.ITypeDescriptorContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetStandardValuesExclusive(class System.ComponentModel.ITypeDescriptorContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStandardValuesExclusive (context As ITypeDescriptorContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetStandardValuesExclusive(System::ComponentModel::ITypeDescriptorContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member GetStandardValuesExclusive : System.ComponentModel.ITypeDescriptorContext -&gt; bool&#xA;override this.GetStandardValuesExclusive : System.ComponentModel.ITypeDescriptorContext -&gt; bool" Usage="typeConverter.GetStandardValuesExclusive context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <summary>Zwraca czy kolekcja wartości standardowych zwracana z <see cref="M:System.ComponentModel.TypeConverter.GetStandardValues" /> jest listą wykluczającą możliwych wartości przy użyciu określonego kontekstu.</summary>
        <returns><see langword="true" />Jeśli zwracana z <see cref="M:System.ComponentModel.TypeConverter.GetStandardValues" /> jest wyczerpującą listą możliwych wartości; <see cref="T:System.ComponentModel.TypeConverter.StandardValuesCollection" /> <see langword="false" /> jeśli są możliwe inne wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `false`zawsze zwraca wartość.  
  
 Jeśli lista ma charakter wyłączny, na przykład w typie danych wyliczenia, żadne inne wartości nie są prawidłowe. Jeśli lista nie jest wyłączna, wówczas inne prawidłowe wartości mogą istnieć oprócz listy standardowych wartości, które <xref:System.ComponentModel.TypeConverter.GetStandardValues%2A> zapewnia metoda. Jeśli wartości są wyłączne, na liście zwracanej <xref:System.ComponentModel.TypeConverter.GetStandardValues%2A> przez nie należy zezwalać na edytowanie tych wartości.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, jeśli typ, który ma zostać przekonwertowany, obsługuje wartości standardowe.  
  
Użyj parametru <paramref name="context" /> , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być <see langword="null" />, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić <see langword="null" />.</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStandardValuesSupported">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca czy ten obiekt obsługuje standardowy zestaw wartości, które można pobrać z listy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStandardValuesSupported">
      <MemberSignature Language="C#" Value="public bool GetStandardValuesSupported ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetStandardValuesSupported() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetStandardValuesSupported" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStandardValuesSupported () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetStandardValuesSupported();" />
      <MemberSignature Language="F#" Value="member this.GetStandardValuesSupported : unit -&gt; bool" Usage="typeConverter.GetStandardValuesSupported " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy ten obiekt obsługuje standardowy zestaw wartości, które można pobrać z listy.</summary>
        <returns><see langword="true" />Jeśli <see cref="M:System.ComponentModel.TypeConverter.GetStandardValues" /> należy wywołać, <see langword="false" />aby znaleźć wspólny zestaw wartości obsługiwany przez obiekt; w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStandardValuesSupported">
      <MemberSignature Language="C#" Value="public virtual bool GetStandardValuesSupported (System.ComponentModel.ITypeDescriptorContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetStandardValuesSupported(class System.ComponentModel.ITypeDescriptorContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStandardValuesSupported (context As ITypeDescriptorContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetStandardValuesSupported(System::ComponentModel::ITypeDescriptorContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member GetStandardValuesSupported : System.ComponentModel.ITypeDescriptorContext -&gt; bool&#xA;override this.GetStandardValuesSupported : System.ComponentModel.ITypeDescriptorContext -&gt; bool" Usage="typeConverter.GetStandardValuesSupported context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <summary>Zwraca czy ten obiekt obsługuje standardowy zestaw wartości, które można pobrać z listy przy użyciu określonego kontekstu.</summary>
        <returns><see langword="true" />Jeśli <see cref="M:System.ComponentModel.TypeConverter.GetStandardValues" /> należy wywołać, <see langword="false" />aby znaleźć wspólny zestaw wartości obsługiwany przez obiekt; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgodnie z zaimplementowaną w tej klasie Metoda ta `false`zawsze zwraca wartość.  
  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, jeśli typ, który ma zostać przekonwertowany, obsługuje wartości standardowe.</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsValid">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca czy dany obiekt wartości jest prawidłowy dla tego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValid(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.IsValid(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValid (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValid(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValid : obj -&gt; bool" Usage="typeConverter.IsValid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do przetestowania pod kątem ważności.</param>
        <summary>Zwraca czy dany obiekt wartości jest prawidłowy dla tego typu.</summary>
        <returns><see langword="true" />Jeśli określona wartość jest prawidłowa dla tego obiektu; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] <xref:System.ComponentModel.TypeConverter.IsValid%2A> , Metoda<xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> przechwytuje wyjątki z metod i. Jeśli typ wartości wejściowej powoduje <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> zwrócenie `false`lub jeśli wartość wejściowa powoduje <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> wygenerowanie wyjątku, <xref:System.ComponentModel.TypeConverter.IsValid%2A> Metoda zwraca `false`.  
  
 Aby włączyć starsze zachowanie, Wstaw następujące wiersze do pliku konfiguracji aplikacji, na przykład Application1. exe. config.  
  
```xml  
<configuration>  
  <appSettings>  
    <add key="UseCompatibleTypeConverterBehavior" value="true" />  
  </appSettings>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, jeśli typ, który ma zostać przekonwertowany, obsługuje wartości standardowe, które można zweryfikować.  
  
Metoda jest używana do walidacji wartości w typie, a nie do określenia, czy <paramref name="value" /> można ją przekonwertować na dany typ. <see cref="M:System.ComponentModel.TypeConverter.IsValid(System.Object)" /> Na przykład może <see cref="M:System.ComponentModel.TypeConverter.IsValid(System.Object)" /> służyć do określenia, czy dana wartość jest prawidłowa dla typu wyliczenia. Aby zapoznać się z przykładem, zobacz <see cref="T:System.ComponentModel.EnumConverter" />.  
  
Można napisać własną metodę <c>WillConvertSucceed</c> , zawijając <see cref="Overload:System.ComponentModel.TypeConverter.ConvertTo" /> metody i <see cref="Overload:System.ComponentModel.TypeConverter.ConvertFrom" /> w blokach wyjątków.</para></block>
        <altmember cref="T:System.ComponentModel.EnumConverter" />
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public virtual bool IsValid (System.ComponentModel.ITypeDescriptorContext context, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValid(class System.ComponentModel.ITypeDescriptorContext context, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValid (context As ITypeDescriptorContext, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValid(System::ComponentModel::ITypeDescriptorContext ^ context, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValid : System.ComponentModel.ITypeDescriptorContext * obj -&gt; bool&#xA;override this.IsValid : System.ComponentModel.ITypeDescriptorContext * obj -&gt; bool" Usage="typeConverter.IsValid (context, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.ComponentModel.ITypeDescriptorContext" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.ComponentModel.ITypeDescriptorContext" /> Zawiera kontekst formatu.</param>
        <param name="value"><see cref="T:System.Object" /> Aby sprawdzić poprawność.</param>
        <summary>Zwraca czy dany obiekt wartości jest prawidłowy dla tego typu i dla określonego kontekstu.</summary>
        <returns><see langword="true" />Jeśli określona wartość jest prawidłowa dla tego obiektu; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `context` , aby wyodrębnić dodatkowe informacje o środowisku, z którego ten konwerter jest wywoływany. Ten parametr może być `null`, więc zawsze sprawdzaj. Ponadto właściwości obiektu kontekstu mogą zwrócić `null`.  
  
 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] <xref:System.ComponentModel.TypeConverter.IsValid%2A> , Metoda<xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> przechwytuje wyjątki z metod i. Jeśli typ wartości wejściowej powoduje <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> zwrócenie `false`lub jeśli wartość wejściowa powoduje <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> wygenerowanie wyjątku, <xref:System.ComponentModel.TypeConverter.IsValid%2A> Metoda zwraca `false`.  
  
 Aby włączyć starsze zachowanie, Wstaw następujące wiersze do pliku konfiguracji aplikacji, na przykład Application1. exe. config.  
  
```xml  
<configuration>  
  <appSettings>  
    <add key="UseCompatibleTypeConverterBehavior" value="true" />  
  </appSettings>  
</configuration>  
```  
  
   
  
## Examples  
 Aby zapoznać się z przykładem tej funkcji, <xref:System.ComponentModel.TypeConverter> zobacz Klasa.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Zastąp tę metodę, jeśli typ, który ma zostać przekonwertowany, obsługuje wartości standardowe, które można zweryfikować.  
  
Metoda jest używana do walidacji wartości w typie, a nie do określenia, czy <paramref name="value" /> można ją przekonwertować na dany typ. <see cref="M:System.ComponentModel.TypeConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)" /> Na przykład może <see cref="M:System.ComponentModel.TypeConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)" /> służyć do określenia, czy dana wartość jest prawidłowa dla typu wyliczenia. Aby zapoznać się z przykładem, zobacz <see cref="T:System.ComponentModel.EnumConverter" />.</para></block>
        <altmember cref="T:System.ComponentModel.ITypeDescriptorContext" />
        <altmember cref="T:System.ComponentModel.EnumConverter" />
      </Docs>
    </Member>
    <Member MemberName="SortProperties">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.PropertyDescriptorCollection SortProperties (System.ComponentModel.PropertyDescriptorCollection props, string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.ComponentModel.PropertyDescriptorCollection SortProperties(class System.ComponentModel.PropertyDescriptorCollection props, string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeConverter.SortProperties(System.ComponentModel.PropertyDescriptorCollection,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Function SortProperties (props As PropertyDescriptorCollection, names As String()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ SortProperties(System::ComponentModel::PropertyDescriptorCollection ^ props, cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberSignature Language="F#" Value="member this.SortProperties : System.ComponentModel.PropertyDescriptorCollection * string[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="typeConverter.SortProperties (props, names)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="props" Type="System.ComponentModel.PropertyDescriptorCollection" />
        <Parameter Name="names" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="props">Obiekt <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> , który ma właściwości do sortowania.</param>
        <param name="names">Tablica nazw w kolejności, w której właściwości mają być wyświetlane w kolekcji.</param>
        <summary>Sortuje kolekcję właściwości.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> , który zawiera posortowane właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie właściwości w kolekcji, które nie znajdują się jeszcze w tablicy nazw, są dodawane alfabetycznie do końca. Jeśli parametr jest pustą tablicą lub `null`, wszystkie właściwości w kolekcji są sortowane alfabetycznie. `names`  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
  </Members>
</Type>

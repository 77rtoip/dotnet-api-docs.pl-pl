<Type Name="TypeDescriptor" FullName="System.ComponentModel.TypeDescriptor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8b8fe91c09ff1fd148d4a705bf84c204e251f96e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36700757" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit TypeDescriptor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.TypeDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDescriptor sealed" />
  <TypeSignature Language="F#" Value="type TypeDescriptor = class" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera informacje dotyczące właściwości składnika, takie jak jego atrybuty, właściwości i zdarzeń. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Platforma .NET Framework zapewnia dwa sposoby metadanych dla typu: odbicie interfejsu API zawarte w <xref:System.Reflection?displayProperty=nameWithType> przestrzeni nazw i <xref:System.ComponentModel.TypeDescriptor> klasy. Odbicie jest mechanizm ogólne dostępne dla wszystkich typów, ponieważ jego foundation jest określana w <xref:System.Object.GetType%2A> metody głównego <xref:System.Object> klasy. Informacje, które zwraca dla typu nie jest rozszerzalny, że nie można zmodyfikować po kompilacji typu docelowego. Aby uzyskać więcej informacji, zobacz Tematy w [odbicia](~/docs/framework/reflection-and-codedom/reflection.md).  
  
 Z kolei <xref:System.ComponentModel.TypeDescriptor> mechanizmu kontroli extensible składników: tych klas, które implementują <xref:System.ComponentModel.IComponent> interfejsu. W odróżnieniu od odbicia go nie kontrolują dla metod. <xref:System.ComponentModel.TypeDescriptor> można dynamicznie rozszerzyć dostępne za pośrednictwem składnika docelowy kilku usług <xref:System.ComponentModel.Component.Site%2A>. W poniższej tabeli przedstawiono te usługi.  
  
|Nazwa usługi|Opis|  
|------------------|-----------------|  
|<xref:System.ComponentModel.IExtenderProvider>|Włącza inną klasę, taką jak <xref:System.Windows.Forms.ToolTip>w celu zapewnienia dodatkowych właściwości składnika.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Włącza inny obiekt do zmodyfikowania metadanych standardowe udostępnianym przez składnik.|  
|<xref:System.ComponentModel.ICustomTypeDescriptor>|Umożliwia tworzenie klasy całkowicie i dynamicznie określić własne metadanych, zastępując mechanizmu kontroli standardowe <xref:System.ComponentModel.TypeDescriptor>.|  
  
 Rozszerzalność dostarczonych przez <xref:System.ComponentModel.TypeDescriptor> czasu projektowania reprezentację składnika różnią się od rzeczywistej reprezentacja środowiska wykonawczego, dzięki czemu umożliwia <xref:System.ComponentModel.TypeDescriptor> przydatne podczas projektowania infrastruktury.  
  
 Wszystkie metody w <xref:System.ComponentModel.TypeDescriptor> są `static`. Nie można utworzyć wystąpienia tej klasy, a ta klasa nie może być dziedziczona.  
  
 Można ustawić właściwości i zdarzenia wartości dwa różne sposoby: określ je w klasie, składnika lub je zmienić w czasie projektowania. Ponieważ można ustawić wartości dwa sposoby, przeciążonej metody <xref:System.ComponentModel.TypeDescriptor> podjąć dwa różne typy parametrów: typu klasy lub wystąpienia obiektu.  
  
 Jeśli chcesz uzyskać dostęp <xref:System.ComponentModel.TypeDescriptor> informacji i utworzono wystąpienie obiektu, należy użyć metody, która odwołuje się do składnika. Użyć metody, która odwołuje się do typu klasy tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 Właściwości i zdarzenia są buforowane przez <xref:System.ComponentModel.TypeDescriptor> szybkości. Zwykle są one stałe dla okresu istnienia obiektu. Jednak dostawcy rozszerzeń i projektantów zmienić zbiór właściwości obiektu. Jeśli jest dostępna, a następnie <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> metoda musi zostać wywołana w celu aktualizacji pamięci podręcznej.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.EventDescriptor" />
    <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.ComponentModel.IComponent" />
    <altmember cref="T:System.ComponentModel.ISite" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddAttributes">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje atrybuty klasy do elementu docelowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (object instance, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(object instance, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAttributes (instance As Object, ParamArray attributes As Attribute()) As TypeDescriptionProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ AddAttributes(System::Object ^ instance, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member AddAttributes : obj * Attribute[] -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.AddAttributes (instance, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie elementu docelowego.</param>
        <param name="attributes">Tablica <see cref="T:System.Attribute" /> obiekty do dodania do klasy składnika.</param>
        <summary>Dodaje atrybuty klasy do obiektu docelowego składnika.</summary>
        <returns>Nowo utworzony <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> które zostało użyte do dodania określonych atrybutów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Object%2CSystem.Attribute%5B%5D%29> Metody dodaje atrybuty klasy do określonego wystąpienia składnika. Ponieważ jest to typowe wymagania aplikacji przy użyciu okna Projektant formularzy systemu Windows w usłudze Visual Studio i właściwości, ta metoda zapewnia skrót, tworząc Dostawca opisu typu, który już scala podane atrybuty z atrybutami istnieje w klasie. Wartość zwracana jest Dostawca opisu typu, które zostało użyte do dodania atrybutów. Ten dostawca później mogą zostać przekazane do <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> metodą podczas dodane atrybuty nie są już potrzebne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z parametrów jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
      </Docs>
    </Member>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ AddAttributes(Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member AddAttributes : Type * Attribute[] -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.AddAttributes (type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <param name="attributes">Tablica <see cref="T:System.Attribute" /> obiekty do dodania do klasy składnika.</param>
        <summary>Dodaje atrybuty klasy na typ docelowy składnika.</summary>
        <returns>Nowo utworzony <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> które zostało użyte do dodania określonych atrybutów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Type%2CSystem.Attribute%5B%5D%29> Metoda dodaje atrybuty klasy na określony typ składnika. Ponieważ jest to typowe wymagania aplikacji przy użyciu okna Projektant formularzy systemu Windows w usłudze Visual Studio i właściwości, ta metoda zapewnia skrót, tworząc Dostawca opisu typu, który już scala podane atrybuty z atrybutami istnieje w klasie. Wartość zwracana jest Dostawca opisu typu, które zostało użyte do dodania atrybutów. Ten dostawca później mogą zostać przekazane do <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> metodą podczas dodane atrybuty nie są już potrzebne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden z parametrów jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
      </Docs>
    </Member>
    <Member MemberName="AddEditorTable">
      <MemberSignature Language="C#" Value="public static void AddEditorTable (Type editorBaseType, System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddEditorTable(class System.Type editorBaseType, class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddEditorTable (editorBaseType As Type, table As Hashtable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddEditorTable(Type ^ editorBaseType, System::Collections::Hashtable ^ table);" />
      <MemberSignature Language="F#" Value="static member AddEditorTable : Type * System.Collections.Hashtable -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddEditorTable (editorBaseType, table)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">Typ podstawowy edytor można dodać tabeli edytora. Jeśli tabela już istnieje dla tego typu, ta metoda będzie nic nie rób.</param>
        <param name="table">
          <see cref="T:System.Collections.Hashtable" /> Do dodania.</param>
        <summary>Dodaje tabeli edytora dla edytora danego typu podstawowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.AddEditorTable%2A> Metoda dodaje tabeli edytora dla edytora danego typu podstawowego. Zazwyczaj edytory są określone jako metadanych składnika. Jednak jeśli brak metadanych dla edytorze żądany podstawowy typ znajduje się na składnik skojarzony <xref:System.ComponentModel.TypeDescriptor> wyszukiwania tabeli edytora dla typu edytora, jeśli znajduje się jeden. Po dodaniu deskryptor typu tabeli edytor nie może zostać usunięty, a właścicielem deskryptor typu. Deskryptor typu swobodnie może wprowadzać modyfikacje do tej tabeli.  
  
 Format tabeli Edytor używa typy danych jako klucze i edytory jako wartości. Wartość części wpisu w tabeli reprezentuje wystąpienie edytora. Może mieć jedną z trzech wartości. Zawiera ciąg, deskryptor typu jest założenie, że jest to pełna nazwa typu i następnie obciążenia typ obiektu. Jeśli zawiera on typ, uzyskanie Edytor będzie można utworzyć wystąpienia tego typu. Na koniec część wartość może zawierać wystąpienia faktycznym edytorem. Deskryptor typu rozpoznaje edytora do wystąpienia, zapisze wystąpienia powrót do tabeli do użytku w przyszłości.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje Dostawca opisu typu do listy dostawców dla tej deskryptor typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddProvider (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member AddProvider : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProvider (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> Do dodania.</param>
        <param name="instance">Wystąpienie elementu docelowego.</param>
        <summary>Dodaje dostawcę opisu typu dla pojedynczego wystąpienia składnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> Metoda dodaje Dostawca opisu typu, aby dostaw typ informacji dla pojedynczego wystąpienia składnika. Jeśli dostawca jest dodawany przez tej metody, dostawca <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A> nie będzie można wywołać metody, ponieważ wystąpienie już istnieje.  
  
 Tej metody nie są zachowywane twardych odwołania do składnika, więc nie zapobiega składnika z finalizowanie.  
  
 Istnieje możliwość dodania wielu dostawców opisu typu dla tego samego typu lub obiektu. W takim przypadku pierwszy dostawca opisu typu napotkano udostępniający informacje o typie będzie służyć wyłącznie. Ponieważ dostawców typów informacje są przechowywane w stosie, ostatniego dostawcę dodane będzie pierwszego zapytanie. Umożliwia to zachowanie <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> i <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A> metody mają być używane do wypychania i pop wpisz opis dostawcy zgodnie z wymaganiami w specyficznych scenariuszach.  
  
 Jeśli się powiedzie, ta metoda wywołuje metodę <xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Object%29> metoda `instance` parametru.  
  
> [!NOTE]
>  Dwie wersje tej metody dostarczyło wyników przy użyciu różnych zakresów. <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> Metody pobierającej <xref:System.Object> parametru dotyczy tylko to pojedyncze wystąpienie składnika określony. Z kolei innych przeciążenia, który przyjmuje <xref:System.Type> parametr ma wpływ na wszystkie wystąpienia elementu opisanego przez tego typu.  
  
 Użyj <xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> metodę, jeśli należy wywołać pochodzących z częściowo zaufanego kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member AddProvider : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProvider (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> Do dodania.</param>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Dodaje dostawcę opisu typu dla klasy składnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> Metoda dodaje Dostawca opisu typu, że dostaw wpisz informacje dla określonej klasy, klasy pochodne i wszystkich wystąpień tego typu.  
  
> [!NOTE]
>  `type` Parametr może być dowolnego typu, w tym interfejsie. Na przykład, aby zapewnić typu niestandardowego i informacje o wystąpieniu dla wszystkich składników, należy określić `typeof(IComponent)`. Przekazywanie `typeof(object)` wywoła dostawcy do dostarczania informacji o typie dla wszystkich typów.  
  
 Ta metoda nie przechowuje twardych odwołania do dowolnego obiektu, nie zapobiega obiektów z finalizowanie.  
  
 Istnieje możliwość dodania wielu dostawców opisu typu dla tego samego typu lub obiektu. W takim przypadku pierwszy dostawca opisu typu napotkano udostępniający informacje o typie będzie służyć wyłącznie. Ponieważ dostawców typów informacje są przechowywane w stosie, ostatniego dostawcę dodane będą proszeni pierwsza z nich. Umożliwia to zachowanie <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> i <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A> metody mają być używane do wypychania i pop wpisz opis dostawcy zgodnie z wymaganiami w specyficznych scenariuszach.  
  
 Jeśli się powiedzie, ta metoda wywołuje metodę <xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Type%29> metoda `type` parametru.  
  
> [!NOTE]
>  Dwie wersje tej metody dostarczyło wyników przy użyciu różnych zakresów. <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> Metody pobierającej <xref:System.Object> parametru dotyczy tylko to pojedyncze wystąpienie składnika określony. Z kolei innych przeciążenia, który przyjmuje <xref:System.Type> parametr ma wpływ na wszystkie wystąpienia elementu opisanego przez tego typu.  
  
 Użyj <xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> metodę, jeśli należy wywołać pochodzących z częściowo zaufanego kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddProviderTransparent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje Dostawca opisu typu do listy dostawców dla tej deskryptor typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddProviderTransparent (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member AddProviderTransparent : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProviderTransparent (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> Do dodania.</param>
        <param name="instance">Wystąpienie elementu docelowego.</param>
        <summary>Dodaje dostawcę opisu typu dla pojedynczego wystąpienia składnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana z częściowo zaufanego kodu. Jeśli <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> jest zdefiniowany, wywołujący można zarejestrować dostawcę dla określonego wystąpienia jeśli jej typ jest również częściowo zaufany.  
  
 Użyj <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> metodę, jeśli nie należy wywoływać z częściowo zaufanego kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Aby uzyskać dostęp do rejestru. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzony typ: <see cref="T:System.Security.PermissionSet" /> , co jest wymagane przez zestaw definiujący <paramref name="instance" /> typ parametru.</permission>
      </Docs>
    </Member>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member AddProviderTransparent : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProviderTransparent (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> Do dodania.</param>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Dodaje dostawcę opisu typu dla klasy składnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana z częściowo zaufanego kodu. Jeśli <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> jest zdefiniowana, wywołujący można zarejestrować dostawcę dla określonego typu, jeśli jest również częściowo zaufany.  
  
 Użyj <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> metodę, jeśli nie należy wywoływać z częściowo zaufanego kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Aby uzyskać dostęp do rejestru. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzony typ: <see cref="T:System.Security.PermissionSet" /> , co jest wymagane przez zestaw definiujący <paramref name="type" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ComNativeDescriptorHandler">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ComNativeDescriptorHandler As IComNativeDescriptorHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::ComponentModel::IComNativeDescriptorHandler ^ ComNativeDescriptorHandler { System::ComponentModel::IComNativeDescriptorHandler ^ get(); void set(System::ComponentModel::IComNativeDescriptorHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ComNativeDescriptorHandler : System.ComponentModel.IComNativeDescriptorHandler with get, set" Usage="System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated.  Use a type description provider to supply type information for COM types instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComNativeDescriptorHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia dostawcę dla składnika modelu COM (Object) informacje o typie dla składnika docelowego.</summary>
        <value>
          <see cref="T:System.ComponentModel.IComNativeDescriptorHandler" /> Wystąpienia reprezentującej COM typ informacji o dostawcy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler%2A> Właściwości i <xref:System.ComponentModel.IComNativeDescriptorHandler> interfejsu są przestarzałe. Aby uzyskać więcej informacji, zobacz <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
        <altmember cref="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      </Docs>
    </Member>
    <Member MemberName="ComObjectType">
      <MemberSignature Language="C#" Value="public static Type ComObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type ComObjectType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ComObjectType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Type ^ ComObjectType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComObjectType : Type" Usage="System.ComponentModel.TypeDescriptor.ComObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ obiektu składnika modelu COM (Object) reprezentowanego przez składnik docelowy.</summary>
        <value>
          <see cref="T:System.Type" /> Reprezentowany przez ten składnik obiektu modelu COM lub <see langword="null" /> dla obiektów COM z systemem innym niż.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> Właściwość zwraca typ, który można przekazać do <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> metody do zdefiniowania dostawcy opis typów dla typów COM.  
  
 <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> Właściwości i innych elementów członkowskich w tej klasie zastępują funkcjonalność w przestarzałe <xref:System.ComponentModel.IComNativeDescriptorHandler> interfejsu. Do zaimplementowania warstwie mapowania między obiektu COM i <xref:System.ComponentModel.TypeDescriptor>, Dodaj <xref:System.ComponentModel.TypeDescriptionProvider> do obsługi typu <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateAssociation">
      <MemberSignature Language="C#" Value="public static void CreateAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateAssociation (primary As Object, secondary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateAssociation(System::Object ^ primary, System::Object ^ secondary);" />
      <MemberSignature Language="F#" Value="static member CreateAssociation : obj * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.CreateAssociation (primary, secondary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">Podstawowy <see cref="T:System.Object" />.</param>
        <param name="secondary">Pomocniczy <see cref="T:System.Object" />.</param>
        <summary>Tworzy skojarzenie podstawowe i pomocnicze między dwoma obiektami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> Metoda tworzy skojarzenie między podstawowym i pomocniczym obiektu. Po utworzeniu skojarzenia projektanta lub inny mechanizm filtrowania można dodać właściwości, które kierować do obu obiektu do obiektu podstawowego zestawu właściwości. Po wywołaniu właściwości względem obiektu podstawowego <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> metoda zostanie wywołana w celu rozwiązania wystąpienie rzeczywistego obiektu powiązanej z jej parametr typu.  
  
 A <xref:System.WeakReference> służy do obsługi skojarzenie obiektu podstawowego i pomocniczego; w związku z tym ta metoda nie uniemożliwiają albo obiekt sfinalizowana, a następnie odzyskać przez wyrzucanie elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="primary" /> jest równa <paramref name="secondary" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, Type designerBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, class System.Type designerBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDesigner (component As IComponent, designerBaseType As Type) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, Type ^ designerBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateDesigner : System.ComponentModel.IComponent * Type -&gt; System.ComponentModel.Design.IDesigner" Usage="System.ComponentModel.TypeDescriptor.CreateDesigner (component, designerBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="designerBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.ComponentModel.IComponent" /> , Który określa składnik do skojarzenia z projektanta.</param>
        <param name="designerBaseType">A <see cref="T:System.Type" /> reprezentujący typ designer, aby utworzyć.</param>
        <summary>Tworzy wystąpienie projektanta skojarzone z określonego składnika i określonego typu projektanta.</summary>
        <returns>
          <see cref="T:System.ComponentModel.Design.IDesigner" /> Projektanta dla tego składnika, czyli wystąpienia lub <see langword="null" /> w przypadku nieodnalezienia projektanta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda nie może znaleźć prawidłowej <xref:System.ComponentModel.DesignerAttribute>, wyszukiwania przez nią w hierarchii klasy projektanta. Jeśli nie można odnaleźć projektanta w hierarchii klas, zwraca `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.IComponent" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEvent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowy deskryptor zdarzeń, który jest taki sam jak istniejący deskryptor zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, System.ComponentModel.EventDescriptor oldEventDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, class System.ComponentModel.EventDescriptor oldEventDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.ComponentModel.EventDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateEvent (componentType As Type, oldEventDescriptor As EventDescriptor, ParamArray attributes As Attribute()) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ CreateEvent(Type ^ componentType, System::ComponentModel::EventDescriptor ^ oldEventDescriptor, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateEvent : Type * System.ComponentModel.EventDescriptor * Attribute[] -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateEvent (componentType, oldEventDescriptor, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldEventDescriptor" Type="System.ComponentModel.EventDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">Typ składnika, do których chcesz utworzyć nowe zdarzenie.</param>
        <param name="oldEventDescriptor">Istniejące informacje zdarzeń.</param>
        <param name="attributes">Nowe atrybuty.</param>
        <summary>Tworzy nowy deskryptor zdarzeń, który jest identyczny deskryptora istniejące zdarzenia po upływie istniejące <see cref="T:System.ComponentModel.EventDescriptor" />.</summary>
        <returns>Nowy <see cref="T:System.ComponentModel.EventDescriptor" /> który został scalony atrybutów określonych metadanych z istniejących atrybutów metadanych.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wymagany do zbadania niepublicznych elementów członkowskich składnika. Łącze dostępu żądanie <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> typu <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ CreateEvent(Type ^ componentType, System::String ^ name, Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateEvent : Type * string * Type * Attribute[] -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateEvent (componentType, name, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">Typ składnika zdarzenia znajduje się.</param>
        <param name="name">Nazwa zdarzenia.</param>
        <param name="type">Typ delegata, który obsługuje zdarzenie.</param>
        <param name="attributes">Atrybuty dla tego zdarzenia.</param>
        <summary>Tworzy nowy deskryptor zdarzeń nie jest taka sama jak istniejącego deskryptora zdarzeń dynamiczne generowanie informacje deskryptora z określonego zdarzenia w typie.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> Który jest powiązany z typem.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wymagany do zbadania niepublicznych elementów członkowskich składnika. Łącze dostępu żądanie <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> typu <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.IServiceProvider provider, class System.Type objectType, class System.Type[] argTypes, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (provider As IServiceProvider, objectType As Type, argTypes As Type(), args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(IServiceProvider ^ provider, Type ^ objectType, cli::array &lt;Type ^&gt; ^ argTypes, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : IServiceProvider * Type * Type[] * obj[] -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.CreateInstance (provider, objectType, argTypes, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="argTypes" Type="System.Type[]" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="provider">Dostawcy usług, która zapewnia <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> usługi. Ten parametr może być <see langword="null" />.</param>
        <param name="objectType">
          <see cref="T:System.Type" /> Obiektu do utworzenia.</param>
        <param name="argTypes">Tablica opcjonalne typy parametrów, które mają być przekazane do konstruktora obiektu. Ten parametr może być <see langword="null" /> lub tablicą o zerowej długości.</param>
        <param name="args">Tablica opcjonalne parametry do przekazania do konstruktora obiektu. Jeśli nie <see langword="null" />, liczba elementów musi być taka sama jak <c>argTypes</c>.</param>
        <summary>Tworzy obiekt, który można zastąpić inny typ danych.</summary>
        <returns>Wystąpienie typu danych substitute, jeśli skojarzone <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> zostanie odnaleziony; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A> Wyszuka metody <xref:System.ComponentModel.TypeDescriptionProvider> skojarzonego z określonym `objectType` — typ danych. Ta metoda po raz pierwszy próbuje uzyskać od dostawcy opis typów `provider` parametru. Jeśli to się nie powiedzie, wewnętrzny tabel wyszukiwania dla dostawcy (te wpisy zostały utworzone przy użyciu poprzednich wywołań <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A>). W przypadku odnalezienia dostawcę, ta metoda będzie delegowane Wywołanie utworzenia tego obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="objectType" /> jest <see langword="null" />, lub <paramref name="args" /> jest <see langword="null" /> podczas <paramref name="argTypes" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argTypes" /> i <paramref name="args" /> mają różne liczby elementów.</exception>
        <block subset="none" type="overrides">
          <para>Jeśli klasa pochodna nie zawiera wystąpienia zastępczych, Metoda ta powinna wywoływać implementację podstawową.</para>
        </block>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProperty">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowy deskryptor właściwości dla istniejącej właściwości składnika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, class System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.ComponentModel.PropertyDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProperty (componentType As Type, oldPropertyDescriptor As PropertyDescriptor, ParamArray attributes As Attribute()) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ CreateProperty(Type ^ componentType, System::ComponentModel::PropertyDescriptor ^ oldPropertyDescriptor, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateProperty : Type * System.ComponentModel.PropertyDescriptor * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateProperty (componentType, oldPropertyDescriptor, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldPropertyDescriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> Składnika, że właściwość jest elementem członkowskim.</param>
        <param name="oldPropertyDescriptor">Istniejące deskryptor właściwości.</param>
        <param name="attributes">Nowe atrybuty dla tej właściwości.</param>
        <summary>Tworzy nowy deskryptor właściwości z istniejącej deskryptora właściwości, za pomocą określonego istniejącego <see cref="T:System.ComponentModel.PropertyDescriptor" /> i atrybut tablicy.</summary>
        <returns>Nowy <see cref="T:System.ComponentModel.PropertyDescriptor" /> z atrybutami określonych metadanych scalone z istniejących atrybutów metadanych.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wymagany do zbadania niepublicznych elementów członkowskich składnika. Łącze dostępu żądanie <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> typu <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ CreateProperty(Type ^ componentType, System::String ^ name, Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateProperty : Type * string * Type * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateProperty (componentType, name, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> Składnika, że właściwość jest elementem członkowskim.</param>
        <param name="name">Nazwa właściwości.</param>
        <param name="type">
          <see cref="T:System.Type" /> Właściwości.</param>
        <param name="attributes">Nowe atrybuty dla tej właściwości.</param>
        <summary>Tworzy i dynamicznie wiąże deskryptora właściwości typu przy użyciu nazwy określonej właściwości, typ i atrybut tablicy.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptor" /> który jest powiązany z określonego typu i z atrybutami określonych metadanych scalone z istniejących atrybutów metadanych.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wymagany do zbadania niepublicznych elementów członkowskich składnika. Łącze dostępu żądanie <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> typu <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetAssociation">
      <MemberSignature Language="C#" Value="public static object GetAssociation (Type type, object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAssociation(class System.Type type, object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAssociation(Type ^ type, System::Object ^ primary);" />
      <MemberSignature Language="F#" Value="static member GetAssociation : Type * obj -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetAssociation (type, primary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <param name="primary">Podstawowy obiekt skojarzenia.</param>
        <summary>Zwraca wystąpienie typu skojarzonego z określonym obiektem podstawowego.</summary>
        <returns>Wystąpienia typu dodatkowej, który został skojarzony z obiektem głównej, jeśli skojarzenie istnieje; w przeciwnym razie <paramref name="primary" /> Jeśli nie zostanie określony skojarzenie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wykonano poprzednie skojarzenia dla `type` przy użyciu parametru <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> metody, a następnie <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> metoda zwraca prawidłowy obiekt dodatkowej do wywołania dla żądanego typu. W przeciwnym razie <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> wyszukuje zgodny projektanta dla `type` i zwraca projektanta, jeśli został znaleziony. Ta metoda nie zwraca `null`.  
  
 A <xref:System.WeakReference> służy do obsługi skojarzenie obiektu podstawowego i pomocniczego; w związku z tym ta metoda nie uniemożliwiają obiekt podstawowy lub pomocniczy sfinalizowana, a następnie odzyskać przez wyrzucanie elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.Design.IDesignerHost.GetDesigner(System.ComponentModel.IComponent)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttributes">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję atrybutów dla składnika lub typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (component As Object) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : obj -&gt; System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.TypeDescriptor.GetAttributes component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, dla którego chcesz pobrać atrybutów.</param>
        <summary>Zwraca kolekcję atrybutów dla określonego składnika.</summary>
        <returns>
          <see cref="T:System.ComponentModel.AttributeCollection" /> Zawierających atrybuty dla składnika. Jeśli <paramref name="component" /> jest <see langword="null" />, ta metoda zwraca pustą kolekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybutów zwracanych w wyniku <xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A> metoda może być modyfikowany dynamicznie z oryginalnego składnika źródła wyświetlania przez dostawców rozszerzeń (<xref:System.ComponentModel.IExtenderProvider>), filtrować usług (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>) i atrybutu filtrów.  
  
 Podczas definiowania atrybutu niestandardowego o <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> ustawioną `true`, konieczne jest przesłonięcie <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> właściwości w celu zapewnienia unikatowości. Jeśli wszystkie wystąpienia atrybut są unikatowe, Zastąp <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> do zwrócenia tożsamości obiektu atrybut. Jeśli tylko niektóre wystąpienia atrybut są unikatowe, zwrócona wartość <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> który zwróci równości w takich przypadkach. Na przykład niektóre atrybuty mają parametru konstruktora, który działa jako unikatowy klucz. Dla tych atrybutów, zwróć wartość parametru konstruktora z <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> właściwości.  
  
> [!NOTE]
>  Domyślna implementacja <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> zwraca tożsamości typu niezależnie od wartości <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> właściwości. Aby można było zwracać wiele wystąpień <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> atrybutu z <xref:System.ComponentModel.AttributeCollection>, atrybut musi zastąpić <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Na przykład tej metody, zobacz <xref:System.ComponentModel.AttributeCollection.Matches%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (componentType As Type) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : Type -&gt; System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.TypeDescriptor.GetAttributes componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Zwraca kolekcję atrybutów dla określonego typu składnika.</summary>
        <returns>
          <see cref="T:System.ComponentModel.AttributeCollection" /> z atrybutami dla typu składnika. Jeżeli kondycja składnika jest <see langword="null" />, ta metoda zwraca pustą kolekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja tej metody należy wywołać tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 W przypadku atrybutów z <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> ustawioną `true`, kolekcji atrybutów usuwa zduplikowane wystąpienia. Są to wystąpień, w którym <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> właściwość zwraca równe wartości.  
  
 Podczas definiowania atrybutu niestandardowego o <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> ustawioną `true`, konieczne jest przesłonięcie <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> właściwości w celu zapewnienia unikatowości. Jeśli wszystkie wystąpienia atrybut są unikatowe, Zastąp <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> do zwrócenia tożsamości obiektu atrybut. Jeśli tylko niektóre wystąpienia atrybut są unikatowe, zwrócona wartość <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> który zwróci równości w takich przypadkach. Na przykład niektóre atrybuty mają parametru konstruktora, który działa jako unikatowy klucz. Dla tych atrybutów, zwróć wartość parametru konstruktora z <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> właściwości.  
  
> [!NOTE]
>  Domyślna implementacja <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> zwraca tożsamości typu niezależnie od wartości <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> właściwości. Aby można było zwracać wiele wystąpień <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> atrybutu z <xref:System.ComponentModel.AttributeCollection>, atrybut musi zastąpić <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (component As Object, noCustomTypeDesc As Boolean) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : obj * bool -&gt; System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.TypeDescriptor.GetAttributes (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, dla którego chcesz pobrać atrybutów.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> Aby użyć linii bazowej zestawu atrybutów z deskryptora typu niestandardowego, jeśli <c>składnika</c> jest typu <see cref="T:System.ComponentModel.ICustomTypeDescriptor" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca kolekcję atrybutów dla określonego składnika i wartość Boolean wskazująca, że utworzono deskryptora typu niestandardowego.</summary>
        <returns>
          <see cref="T:System.ComponentModel.AttributeCollection" /> z atrybutami dla składnika. Jeżeli kondycja składnika jest <see langword="null" />, ta metoda zwraca pustą kolekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybutów zwracanych w wyniku <xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A> metoda może być modyfikowany dynamicznie z oryginalnego źródła składników wyświetlania przez dostawców rozszerzeń (<xref:System.ComponentModel.IExtenderProvider>), filtrować usług (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>) i atrybutu filtrów.  
  
 Podczas definiowania atrybutu niestandardowego o <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> ustawioną `true`, konieczne jest przesłonięcie <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> właściwości w celu zapewnienia unikatowości. Jeśli wszystkie wystąpienia atrybut są unikatowe, Zastąp <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> do zwrócenia tożsamości obiektu atrybut. Jeśli tylko niektóre wystąpienia atrybut są unikatowe, zwrócona wartość <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> który zwróci równości w takich przypadkach. Na przykład niektóre atrybuty mają parametru konstruktora, który działa jako unikatowy klucz. Dla tych atrybutów, zwróć wartość parametru konstruktora z <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> właściwości.  
  
> [!NOTE]
>  Domyślna implementacja <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> zwraca tożsamości typu niezależnie od wartości <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> właściwości. Aby można było zwracać wiele wystąpień <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> atrybutu z <xref:System.ComponentModel.AttributeCollection>, atrybut musi zastąpić <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetClassName">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwę klasy dla określonego składnika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetClassName : obj -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetClassName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> Dla którego ma nazwę klasy.</param>
        <summary>Zwraca nazwę klasy dla określonego składnika przy użyciu domyślnego deskryptora typu.</summary>
        <returns>A <see cref="T:System.String" /> zawierający nazwę klasy dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta metoda zwraca pełny <xref:System.Type> nazwę `component` typ parametru. Na przykład nazwa klasy dla przycisku jest "System.Windows.Forms.Button". Jeśli `component` implementuje <xref:System.ComponentModel.ICustomTypeDescriptor>, może on zwrócić alternatywną nazwę.  
  
 Ta metoda jest odpowiednikiem przeciążone <xref:System.ComponentModel.TypeDescriptor.GetClassName%28System.Object%2CSystem.Boolean%29> metody z drugim parametrem `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (componentType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetClassName : Type -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetClassName componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Zwraca nazwę klasy dla określonego typu.</summary>
        <returns>A <see cref="T:System.String" /> zawierający nazwę klasy dla typu określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa deskryptora typu niestandardowego pamięci podręcznej dla określonego typu do odnajdywania nazwy klasy skojarzone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (component As Object, noCustomTypeDesc As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetClassName : obj * bool -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetClassName (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> Dla którego ma nazwę klasy.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> uwzględnienie informacji opisu typu niestandardowego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca nazwę klasy dla określonego składnika przy użyciu deskryptora typu niestandardowego.</summary>
        <returns>A <see cref="T:System.String" /> zawierający nazwę klasy dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta metoda zwraca pełny <xref:System.Type> nazwę `component` typ parametru. Na przykład nazwa klasy dla przycisku jest "System.Windows.Forms.Button". Jeśli `component` implementuje parametru <xref:System.ComponentModel.ICustomTypeDescriptor>, może on zwrócić alternatywną nazwę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComponentName">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwę określonego składnika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetComponentName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetComponentName : obj -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetComponentName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> Dla którego ma nazwę klasy.</param>
        <summary>Zwraca nazwę określonego składnika przy użyciu domyślnego deskryptora typu.</summary>
        <returns>A <see cref="T:System.String" /> zawierającą nazwę określonego składnika lub <see langword="null" /> Jeśli nie została żadna nazwa składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta metoda zwraca nazwę lokacji składnika, jeśli taka istnieje. Na przykład nazwa klasy dla przycisku jest "System.Windows.Forms.Button".  
  
 Ta metoda jest odpowiednikiem przeciążone <xref:System.ComponentModel.TypeDescriptor.GetComponentName%28System.Object%2CSystem.Boolean%29> metody z drugim parametrem `false`.  
  
 Ta metoda jest używana w czasie projektowania pobrać nazwy wystąpienia składnika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComponentName (component As Object, noCustomTypeDesc As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetComponentName(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetComponentName : obj * bool -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetComponentName (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> Dla którego ma nazwę klasy.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> uwzględnienie informacji opisu typu niestandardowego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca nazwę określonego składnika przy użyciu deskryptora typu niestandardowego.</summary>
        <returns>Nazwa klasy dla określonego składnika lub <see langword="null" /> Jeśli nie została żadna nazwa składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana w czasie projektowania pobrać nazwy wystąpienia składnika. Zwykle ta metoda zwraca nazwę lokacji składnika, jeśli taka istnieje. Na przykład nazwa klasy dla przycisku jest "System.Windows.Forms.Button". Jeśli zaimplementowano składnik <xref:System.ComponentModel.ICustomTypeDescriptor> interfejsu, może on zwrócić alternatywną nazwę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetComponentName" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConverter">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca konwerter typów dla składnika lub typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetConverter (component As Object) As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetConverter : obj -&gt; System.ComponentModel.TypeConverter" Usage="System.ComponentModel.TypeDescriptor.GetConverter component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać konwerter.</param>
        <summary>Zwraca konwerter typów dla typu określonego składnika.</summary>
        <returns>A <see cref="T:System.ComponentModel.TypeConverter" /> określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda lokalizuje konwertera odpowiedniego typu, wyszukując <xref:System.ComponentModel.TypeConverterAttribute>. Nie można znaleźć <xref:System.ComponentModel.TypeConverterAttribute>, aż do znalezienia typem pierwotnym wzdłuż hierarchii klasę podstawową klasy.  
  
 Ta metoda jest odpowiednikiem przeciążone <xref:System.ComponentModel.TypeDescriptor.GetConverter%2A> metody z drugim parametrem `false`.  
  
   
  
## Examples  
 Na przykład za pomocą tej metody, zobacz <xref:System.ComponentModel.TypeConverter> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="System.ComponentModel.TypeDescriptor.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Zwraca konwerter typu dla określonego typu.</summary>
        <returns>A <see cref="T:System.ComponentModel.TypeConverter" /> dla określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja tej metody należy wywołać tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 Ta metoda sprawdza konwertera odpowiedniego typu, wyszukując <xref:System.ComponentModel.TypeConverterAttribute>. Nie można znaleźć <xref:System.ComponentModel.TypeConverterAttribute>, aż do znalezienia typem pierwotnym wzdłuż hierarchii klasę podstawową klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetConverter (component As Object, noCustomTypeDesc As Boolean) As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetConverter : obj * bool -&gt; System.ComponentModel.TypeConverter" Usage="System.ComponentModel.TypeDescriptor.GetConverter (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać konwerter.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> uwzględnienie informacji opisu typu niestandardowego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca konwerter typów dla typu określonego składnika deskryptora typu niestandardowego.</summary>
        <returns>A <see cref="T:System.ComponentModel.TypeConverter" /> określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza odpowiedniego typu konwertera przez próby znalezienia <xref:System.ComponentModel.TypeConverterAttribute>. Nie można znaleźć <xref:System.ComponentModel.TypeConverterAttribute>, aż do znalezienia typem pierwotnym wzdłuż hierarchii klasę podstawową klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDefaultEvent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca domyślne zdarzenie dla składnika lub typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (component As Object) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetDefaultEvent : obj -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultEvent component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać zdarzenia.</param>
        <summary>Zwraca domyślne zdarzenie dla określonego składnika.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> Ze zdarzeniem domyślne lub <see langword="null" /> Jeśli brak zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest odpowiednikiem przeciążone <xref:System.ComponentModel.TypeDescriptor.GetDefaultEvent%28System.Object%2CSystem.Boolean%29> metody z drugim parametrem `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (componentType As Type) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetDefaultEvent : Type -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultEvent componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Zwraca domyślne zdarzenie dla określonego typu składnika.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> Ze zdarzeniem domyślne lub <see langword="null" /> Jeśli brak zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja tej metody należy wywołać tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (component As Object, noCustomTypeDesc As Boolean) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetDefaultEvent : obj * bool -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultEvent (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać zdarzenia.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> uwzględnienie informacji opisu typu niestandardowego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca domyślne zdarzenie dla składnika o deskryptora typu niestandardowego.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> Ze zdarzeniem domyślne lub <see langword="null" /> Jeśli brak zdarzeń.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDefaultProperty">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca domyślną właściwość dla składnika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (component As Object) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetDefaultProperty : obj -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultProperty component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać domyślnej właściwości dla.</param>
        <summary>Zwraca domyślną właściwość dla określonego składnika.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptor" /> z właściwością domyślną lub <see langword="null" /> , jeśli nie ma żadnych właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `component` parametr jest `null`, ta metoda zwraca `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (componentType As Type) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetDefaultProperty : Type -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultProperty componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">A <see cref="T:System.Type" /> reprezentujący klasę, aby pobrać właściwość.</param>
        <summary>Zwraca domyślną właściwość dla określonego typu składnika.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptor" /> z właściwością domyślną lub <see langword="null" /> , jeśli nie ma żadnych właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja tej metody należy wywołać tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 Jeśli `componentType` parametr jest `null`, ta metoda zwraca `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (component As Object, noCustomTypeDesc As Boolean) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetDefaultProperty : obj * bool -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultProperty (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać domyślnej właściwości dla.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> uwzględnienie informacji opisu typu niestandardowego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca domyślną właściwość dla określonego składnika deskryptora typu niestandardowego.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptor" /> z właściwością domyślną lub <see langword="null" /> , jeśli nie ma żadnych właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `component` parametr jest `null`, ta metoda zwraca `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEditor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca edytora określonego typu podstawowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEditor (component As Object, editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(System::Object ^ component, Type ^ editorBaseType);" />
      <MemberSignature Language="F#" Value="static member GetEditor : obj * Type -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetEditor (component, editorBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać edytora.</param>
        <param name="editorBaseType">A <see cref="T:System.Type" /> reprezentujący typ bazowy edytor, który ma zostać znaleziony.</param>
        <summary>Pobiera edytor z określonym typem bazowym dla określonego składnika.</summary>
        <returns>Wystąpienie edytora, która może być rzutowana na typ określony Edytor lub <see langword="null" /> w przypadku nieodnalezienia nie Edytor żądanego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ `editorBaseType` jest zwykle <xref:System.Drawing.Design.UITypeEditor>, ale można również używać innych typów (na przykład <xref:System.ComponentModel.ComponentEditor> i <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Można zdefiniować wiele edytorów dla właściwości. Ta metoda umożliwia wybranie edytor, którego chcesz użyć.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> lub <paramref name="editorBaseType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (Type type, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(class System.Type type, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Type,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(Type ^ type, Type ^ editorBaseType);" />
      <MemberSignature Language="F#" Value="static member GetEditor : Type * Type -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetEditor (type, editorBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <param name="editorBaseType">A <see cref="T:System.Type" /> reprezentujący typ podstawowy próbujesz odnaleźć edytora.</param>
        <summary>Zwraca edytora określonego typu podstawowego dla określonego typu.</summary>
        <returns>Wystąpienie obiektu edytora, które mogą być rzutowane na danego typu podstawowego lub <see langword="null" /> w przypadku nieodnalezienia nie Edytor żądanego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ `editorBaseType` jest zwykle <xref:System.Drawing.Design.UITypeEditor>, ale można również używać innych typów (na przykład <xref:System.ComponentModel.ComponentEditor> i <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Można zdefiniować wiele edytorów dla typu. Ta metoda umożliwia wybierz ten, który ma być używany.  
  
 Ta wersja tej metody należy wywołać tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="editorBaseType" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEditor (component As Object, editorBaseType As Type, noCustomTypeDesc As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(System::Object ^ component, Type ^ editorBaseType, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetEditor : obj * Type * bool -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetEditor (component, editorBaseType, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać edytora.</param>
        <param name="editorBaseType">A <see cref="T:System.Type" /> reprezentujący typ bazowy edytor, który ma zostać znaleziony.</param>
        <param name="noCustomTypeDesc">Flaga wskazująca, czy informacje o opisie typu niestandardowego należy traktować jako.</param>
        <summary>Zwraca edytora określonego typu podstawowego i deskryptora typu niestandardowego dla określonego składnika.</summary>
        <returns>Wystąpienie edytora, która może być rzutowana na typ określony Edytor lub <see langword="null" /> w przypadku nieodnalezienia nie Edytor żądanego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ `editorBaseType` jest zwykle <xref:System.Drawing.Design.UITypeEditor>, ale można również używać innych typów (na przykład <xref:System.ComponentModel.ComponentEditor> i <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Można zdefiniować wiele edytorów dla właściwości. Ta metoda umożliwia wybranie edytor, którego chcesz użyć.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> lub <paramref name="editorBaseType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję zdarzenia dla składnika lub typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać zdarzenia.</param>
        <summary>Zwraca kolekcję zdarzeń dla określonego składnika.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> Zdarzenia dla tego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobiera kolekcję zdarzeń, które danego `component` wystąpienia parametru zapewnia. Ta kolekcja może się różnić od zestaw zdarzeń, który zawiera klasę. Jeśli `component` parametru jest ulokowany, lokacji można dodać lub usunąć dodatkowe zdarzenia.  
  
 Jeśli `component` jest `null`, zwracana jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
   
  
## Examples  
 Na przykład tej metody, zobacz <xref:System.ComponentModel.EventDescriptorCollection.Count%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (componentType As Type) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetEvents : Type -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Zwraca kolekcję zdarzeń dla określonego typu składnika.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> Zdarzenia dla tego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja tej metody należy wywołać tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 Jeśli `componentType` parametr jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, attributes As Attribute()) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj * Attribute[] -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (component, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać zdarzenia.</param>
        <param name="attributes">Tablica typu <see cref="T:System.Attribute" /> służąca jako filtr.</param>
        <summary>Zwraca kolekcję zdarzeń dla określonego składnika przy użyciu określonej tablicy atrybutów jako filtr.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> Ze zdarzeniami, spełniających określone atrybuty dla tego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia `component` parametru może się różnić od zdarzenia klasy, ponieważ lokacji można dodawać i usuwać zdarzenia, jeśli `component` parametru jest ulokowany.  
  
 `attributes` Tablica mogą mieć różnych <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowana za pomocą następujących reguł:  
  
-   A <xref:System.Type> jest traktowany jako symbolu wieloznacznego, zdarzenie, dla którego jest on zgodny <xref:System.Type> w jego zestaw atrybutów.  
  
-   Jeśli nie ma zdarzenia <xref:System.Attribute> do tej samej klasy zdarzenia nie znajduje się w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute> klasy, zdarzenia musi być w pełni zgodne lub nie znajduje się w zwracanych tablicy.  
  
-   Jeśli <xref:System.Attribute> zostało określone wystąpienie i jest zdarzenie domyślne, nawet jeśli dostępny jest wystąpienie nie zostało uwzględnione w zwracana tablica <xref:System.Attribute> w zdarzeniu.  
  
 Jeśli `component` jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, noCustomTypeDesc As Boolean) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj * bool -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać zdarzenia.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> uwzględnienie informacji opisu typu niestandardowego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca kolekcję zdarzeń dla określonego składnika deskryptora typu niestandardowego.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> Zdarzenia dla tego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera zbierania zdarzeń, które danego `component` wystąpienia parametru zapewnia. To może się różnić od zestaw zdarzeń, który zawiera klasę. Jeśli `component` parametru jest ulokowany, lokacji można dodać lub usunąć dodatkowe zdarzenia.  
  
 Jeśli `component` jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (componentType As Type, attributes As Attribute()) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(Type ^ componentType, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetEvents : Type * Attribute[] -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (componentType, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <param name="attributes">Tablica typu <see cref="T:System.Attribute" /> służąca jako filtr.</param>
        <summary>Zwraca kolekcję zdarzeń dla określonego typu składnika przy użyciu określonej tablicy atrybutów jako filtr.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> Ze zdarzeniami, spełniających określone atrybuty dla tego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja tej metody należy wywołać tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 `attributes` Tablicy parametrów mogą mieć różnych <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowana za pomocą następujących reguł:  
  
-   A <xref:System.Type> jest traktowany jako symbolu wieloznacznego, zdarzenie, dla którego jest on zgodny <xref:System.Type> w jego zestaw atrybutów.  
  
-   Jeśli nie ma zdarzenia <xref:System.Attribute> do tej samej klasy zdarzenia nie znajduje się w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute> klasy, zdarzenia musi być w pełni zgodne lub nie znajduje się w zwracanych tablicy.  
  
-   Jeśli <xref:System.Attribute> zostało określone wystąpienie i jest zdarzenie domyślne, nawet jeśli dostępny jest wystąpienie nie zostało uwzględnione w zwracana tablica <xref:System.Attribute> w zdarzeniu.  
  
 Jeśli `componentType` parametr jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, attributes As Attribute(), noCustomTypeDesc As Boolean) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj * Attribute[] * bool -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (component, attributes, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać zdarzenia.</param>
        <param name="attributes">Tablica typu <see cref="T:System.Attribute" /> do użycia jako filtr.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> uwzględnienie informacji opisu typu niestandardowego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca kolekcję zdarzeń dla określonego składnika przy użyciu określonej tablicy atrybutów jako filtr i deskryptora typu niestandardowego.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> Ze zdarzeniami, spełniających określone atrybuty dla tego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia `component` parametru może się różnić od zdarzenia klasy, ponieważ lokacji można dodawać i usuwać zdarzenia, jeśli `component` parametru jest ulokowany.  
  
 `attributes` Tablicy parametrów mogą mieć różnych <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowana za pomocą następujących reguł:  
  
-   A <xref:System.Type> jest traktowany jako symbolu wieloznacznego, zdarzenie, dla którego jest on zgodny <xref:System.Type> w jego zestaw atrybutów.  
  
-   Jeśli nie ma zdarzenia <xref:System.Attribute> do tej samej klasy zdarzenia nie znajduje się w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute> klasy, zdarzenia musi być w pełni zgodne lub nie znajduje się w zwracanych tablicy.  
  
-   Jeśli <xref:System.Attribute> zostało określone wystąpienie i jest zdarzenie domyślne, nawet jeśli dostępny jest wystąpienie nie zostało uwzględnione w zwracana tablica <xref:System.Attribute> w zdarzeniu.  
  
 Jeśli `component` jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetFullComponentName">
      <MemberSignature Language="C#" Value="public static string GetFullComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullComponentName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetFullComponentName : obj -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetFullComponentName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.ComponentModel.Component" /> Można znaleźć nazwy dla.</param>
        <summary>Zwraca w pełni kwalifikowana nazwa składnika.</summary>
        <returns>W pełni kwalifikowana nazwa określonego składnika lub <see langword="null" /> Jeśli składnik nie ma nazwy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wielu przypadkach <xref:System.ComponentModel.TypeDescriptor.GetFullComponentName%2A> metoda zwróci taką samą wartość jak <xref:System.ComponentModel.TypeDescriptor.GetComponentName%2A> metody. Jednak jeśli składnik znajduje się w kontenerze zagnieżdżonych lub ma inne zagnieżdżonych semantykę, mogą zwracać inną nazwę FQDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetFullComponentName(System.Object)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję właściwości składnika lub typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać właściwości.</param>
        <summary>Zwraca kolekcję właściwości dla określonego składnika.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwości dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości składnika może się różnić od właściwości klasy, ponieważ lokacji można dodać lub usunąć właściwości, jeśli składnik jest ulokowany.  
  
 Jeśli `component` parametr jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> metodę, aby uzyskać dostęp do właściwości formantu. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.ComponentModel.Design.ComponentDesigner> klasy.  
  
 [!code-csharp[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/CS/Form1.cs#8)]
 [!code-vb[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (componentType As Type) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetProperties : Type -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">A <see cref="T:System.Type" /> reprezentujący składnik można pobrać właściwości.</param>
        <summary>Zwraca kolekcję właściwości dla określonego typu składnika.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwości dla określonego typu składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja tej metody należy wywołać tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 Jeśli `componentType` parametr jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (component, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać właściwości.</param>
        <param name="attributes">Tablica typu <see cref="T:System.Attribute" /> do użycia jako filtr.</param>
        <summary>Zwraca kolekcję właściwości dla określonego składnika przy użyciu określonej tablicy atrybutów jako filtr.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwościami, spełniających określone atrybuty dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości `component` parametru może się różnić od właściwości klasy, ponieważ lokacji można dodać lub usunąć właściwości, jeśli `component` parametru jest ulokowany.  
  
 `attributes` Tablicy parametrów służy do filtrowania tablicy. Filtrowanie jest definiowana za pomocą następujących reguł:  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> do tej samej klasy właściwość nie jest objęta zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute> klasy, właściwość musi być w pełni zgodne lub nie znajduje się w zwracanych tablicy.  
  
-   Jeśli <xref:System.Attribute> zostało określone wystąpienie i jest właściwością domyślną, nawet jeśli dostępny jest wystąpienie nie zostało uwzględnione w zwracana tablica <xref:System.Attribute> we właściwości.  
  
-   Jeśli `attributes` ma atrybut domyślny <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> Metoda odpowiada przypadku, gdy właściwość nie ma atrybut zastosowany.  
  
 Jeśli `component` jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wdrożyć <xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Windows.Forms.Design.PropertyTab> klasy.  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, noCustomTypeDesc As Boolean) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj * bool -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać właściwości.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> Aby nie należy wziąć pod uwagę informacje o opisie typu niestandardowego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca kolekcję właściwości dla określonego składnika przy użyciu domyślnego deskryptora typu.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwości dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości `component` parametru może się różnić od właściwości klasy, ponieważ lokacji można dodać lub usunąć właściwości, jeśli `component` parametru jest ulokowany.  
  
 Jeśli `component` jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (componentType As Type, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(Type ^ componentType, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetProperties : Type * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (componentType, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <param name="attributes">Tablica typu <see cref="T:System.Attribute" /> do użycia jako filtr.</param>
        <summary>Zwraca kolekcję właściwości dla określonego typu składnika przy użyciu określonej tablicy atrybutów jako filtr.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwościami, spełniających określone atrybuty dla tego typu składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja tej metody należy wywołać tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 `attributes` Tablicy parametrów służy do filtrowania tablicy. Filtrowanie jest definiowana za pomocą następujących reguł:  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> do tej samej klasy właściwość nie jest objęta zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute> klasy, właściwość musi być w pełni zgodne lub nie znajduje się w zwracanych tablicy.  
  
-   Jeśli <xref:System.Attribute> zostało określone wystąpienie i jest właściwością domyślną, nawet jeśli dostępny jest wystąpienie nie zostało uwzględnione w zwracana tablica <xref:System.Attribute> we właściwości.  
  
-   Jeśli `attributes` ma atrybut domyślny <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> Metoda odpowiada przypadku, gdy właściwość nie ma atrybut zastosowany.  
  
 Jeśli `componentType` parametr jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wdrożyć <xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Windows.Forms.Design.PropertyTab> klasy.  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, attributes As Attribute(), noCustomTypeDesc As Boolean) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj * Attribute[] * bool -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (component, attributes, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik można pobrać właściwości.</param>
        <param name="attributes">Tablica typu <see cref="T:System.Attribute" /> do użycia jako filtr.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> uwzględnienie informacji opisu typu niestandardowego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zwraca kolekcję właściwości dla określonego składnika przy użyciu określonej tablicy atrybutów jako filtr i deskryptora typu niestandardowego.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> ze zdarzeniami, spełniających określone atrybuty dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości `component` może się różnić od właściwości klasy, ponieważ lokacji można dodać lub usunąć właściwości, jeśli `component` jest ulokowany.  
  
 `attributes` Tablicy parametrów służy do filtrowania tablicy. Filtrowanie jest definiowana za pomocą następujących reguł:  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> do tej samej klasy właściwość nie jest objęta zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute> klasy, właściwość musi być w pełni zgodne lub nie znajduje się w zwracanych tablicy.  
  
-   Jeśli <xref:System.Attribute> zostało określone wystąpienie i jest właściwością domyślną, nawet jeśli dostępny jest wystąpienie nie zostało uwzględnione w zwracana tablica <xref:System.Attribute> we właściwości.  
  
-   Jeśli `attributes` ma atrybut domyślny <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> Metoda odpowiada przypadku, gdy właściwość nie ma atrybut zastosowany.  
  
 Jeśli `component` parametr jest `null`, zwracany jest pustej kolekcji.  
  
 Kolejność zwracana Kolekcja nie jest gwarantowana identyczne między wywołaniami, więc zawsze kolejność przed użyciem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> jest między procesami obiektu zdalnego.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca dostawcy opisu typu dla składnika lub typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProvider (instance As Object) As TypeDescriptionProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ GetProvider(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member GetProvider : obj -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.GetProvider instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie elementu docelowego.</param>
        <summary>Zwraca dostawcy opisu typu dla określonego składnika.</summary>
        <returns>A <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> skojarzone z określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A> Metoda zawsze zwraca Dostawca opisu typu. Nawet domyślne <xref:System.ComponentModel.TypeDescriptor> implementacji jest oparty na <xref:System.ComponentModel.TypeDescriptionProvider>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ GetProvider(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetProvider : Type -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.GetProvider type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Zwraca typ dostawcy opisu dla określonego typu.</summary>
        <returns>A <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> skojarzone z określonym typem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A> Metoda zawsze zwraca Dostawca opisu typu. Nawet domyślne <xref:System.ComponentModel.TypeDescriptor> implementacji jest oparty na <xref:System.ComponentModel.TypeDescriptionProvider>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetReflectionType">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> który może służyć do wykonywania odbicia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReflectionType (instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetReflectionType(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member GetReflectionType : obj -&gt; Type" Usage="System.ComponentModel.TypeDescriptor.GetReflectionType instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie elementu docelowego.</param>
        <summary>Zwraca <see cref="T:System.Type" /> który może służyć do wykonywania odbicia, podany obiekt.</summary>
        <returns>A <see cref="T:System.Type" /> dla określonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> Metoda jest wersję niskiego poziomu <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> metody. <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> zwykle służy do wykonywania standardowych odbicia względem obiektu, gdy Brak deskryptora typu niestandardowego może znajdować się na jej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetReflectionType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetReflectionType : Type -&gt; Type" Usage="System.ComponentModel.TypeDescriptor.GetReflectionType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Zwraca <see cref="T:System.Type" /> który może służyć do wykonywania odbicia, danego typu klasy.</summary>
        <returns>A <see cref="T:System.Type" /> określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> Metoda jest wersję niskiego poziomu <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> metody. <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> zwykle służy do wykonywania standardowych odbicia z klasą, gdy Brak deskryptora typu niestandardowego może znajdować się na jej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="InterfaceType">
      <MemberSignature Language="C#" Value="public static Type InterfaceType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type InterfaceType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.InterfaceType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InterfaceType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Type ^ InterfaceType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InterfaceType : Type" Usage="System.ComponentModel.TypeDescriptor.InterfaceType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który reprezentuje typ dostawcy opisu dla wszystkich typów interfejsu.</summary>
        <value>A <see cref="T:System.Type" /> reprezentujący niestandardowego dostawcy opisu typu wszystkie typy interfejsów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.InterfaceType%2A> Pobiera właściwość <xref:System.Type> obiekt, który można przekazać do <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> metod do zdefiniowania dostawcy opisu typu dla typów interfejsów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści właściwości i zdarzenia z pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Refresh (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member Refresh : obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, dla którego właściwości lub zdarzenia zostały zmienione.</param>
        <summary>Czyści właściwości i zdarzenia dla określonego składnika z pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości i zdarzenia są buforowane przez <xref:System.ComponentModel.TypeDescriptor> szybkości. Zwykle są one stałe dla okresu istnienia obiektu. Jednak dostawcy rozszerzeń i projektantów zmienić zbiór właściwości obiektu. Jeśli nie, ich powinny wywoływać tej metody, aby wyczyścić deskryptorów właściwości i zdarzenia obiektu. Ta metoda jest używana tylko w czasie projektowania. Nie jest on używany w czasie wykonywania.  
  
 Ta metoda również zgłasza <xref:System.ComponentModel.TypeDescriptor.Refreshed> zdarzenie po zmianie właściwości lub zdarzenia składnika. To zdarzenie jest wywoływane tylko, jeśli wystąpił wcześniejszym wywołaniu <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> lub <xref:System.ComponentModel.TypeDescriptor.GetEvents%2A> metodę, która informacje w pamięci podręcznej.  
  
   
  
## Examples  
 Na przykład za pomocą tej metody, zobacz <xref:System.ComponentModel.RefreshEventHandler> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member Refresh : System.Reflection.Assembly -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">
          <see cref="T:System.Reflection.Assembly" /> Reprezentujący zestawu, aby odświeżyć. Każdy <see cref="T:System.Type" /> w tym zestawie zostaną odświeżone.</param>
        <summary>Czyści właściwości i zdarzenia dla określonego zestawu z pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości i zdarzenia są buforowane przez <xref:System.ComponentModel.TypeDescriptor> szybkości. Zwykle są one stałe dla okresu istnienia obiektu. Jednak dostawcy rozszerzeń i projektantów zmienić zbiór właściwości obiektu. Jeśli tak się one wywołać tę metodę, aby wyczyścić deskryptorów właściwości i zdarzenia obiektu. Ta metoda jest używana tylko w czasie projektowania. Nie jest on używany w czasie wykonywania.  
  
 Przed wprowadzeniem wywołanie <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> metodę, aby wyczyścić pamięć podręczną, należy wywołać <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> metoda dla określonego zestawu najpierw buforowanie tych informacji.  
  
 Ta metoda również zgłasza <xref:System.ComponentModel.TypeDescriptor.Refreshed> zdarzenie, aby powiadomić wszystkich klas, które chcą być powiadamiani, gdy wartość właściwości zmian składnika.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Assembly" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Module module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Module module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Reflection::Module ^ module);" />
      <MemberSignature Language="F#" Value="static member Refresh : System.Reflection.Module -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh module" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="module">
          <see cref="T:System.Reflection.Module" /> Reprezentujący modułu, aby odświeżyć. Każdy <see cref="T:System.Type" /> w tym module zostaną odświeżone.</param>
        <summary>Czyści właściwości i zdarzenia dla określonego modułu z pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości i zdarzenia są buforowane przez <xref:System.ComponentModel.TypeDescriptor> szybkości. Zwykle są one stałe dla okresu istnienia obiektu. Jednak dostawcy rozszerzeń i projektantów zmienić zbiór właściwości obiektu. Jeśli tak się one wywołać tę metodę, aby wyczyścić deskryptorów właściwości i zdarzenia obiektu. Ta metoda jest używana tylko w czasie projektowania. Nie jest on używany w czasie wykonywania.  
  
 Przed wprowadzeniem wywołanie <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> metodę, aby wyczyścić pamięć podręczną, należy wywołać <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> metoda dla określonego modułu najpierw buforowanie tych informacji.  
  
 Ta metoda również zgłasza <xref:System.ComponentModel.TypeDescriptor.Refreshed> zdarzenie, aby powiadomić wszystkich klas, które chcą być powiadamiani, gdy wartość właściwości zmian składnika.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Refresh : Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Czyści właściwości i zdarzenia dla określonego typu składnika z pamięci podręcznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja tej metody należy wywołać tylko wtedy, gdy nie masz wystąpienie obiektu.  
  
 Właściwości i zdarzenia są buforowane przez <xref:System.ComponentModel.TypeDescriptor> szybkości. Zwykle są one stałe dla okresu istnienia obiektu. Jednak dostawcy rozszerzeń i projektantów zmienić zbiór właściwości obiektu. Jeśli tak się one wywołać tę metodę, aby wyczyścić deskryptorów właściwości i zdarzenia obiektu. Ta metoda jest używana tylko w czasie projektowania. Nie jest on używany w czasie wykonywania.  
  
 Ta metoda również zgłasza <xref:System.ComponentModel.TypeDescriptor.Refreshed> zdarzenie po zmianie właściwości lub zdarzenia składnika. To zdarzenie jest wywoływane tylko, jeśli wystąpił wcześniejszym wywołaniu <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> lub <xref:System.ComponentModel.TypeDescriptor.GetEvents%2A> metodę, która informacje w pamięci podręcznej.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refreshed">
      <MemberSignature Language="C#" Value="public static event System.ComponentModel.RefreshEventHandler Refreshed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RefreshEventHandler Refreshed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Refreshed As RefreshEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::ComponentModel::RefreshEventHandler ^ Refreshed;" />
      <MemberSignature Language="F#" Value="member this.Refreshed : System.ComponentModel.RefreshEventHandler " Usage="member this.Refreshed : System.ComponentModel.RefreshEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RefreshEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po wyczyszczeniu pamięci podręcznej dla składnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [NIB: Korzystanie z zdarzenia](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 Na przykład za pomocą tego zdarzenia, zobacz <xref:System.ComponentModel.RefreshEventHandler> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociation">
      <MemberSignature Language="C#" Value="public static void RemoveAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveAssociation (primary As Object, secondary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveAssociation(System::Object ^ primary, System::Object ^ secondary);" />
      <MemberSignature Language="F#" Value="static member RemoveAssociation : obj * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveAssociation (primary, secondary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">Podstawowy <see cref="T:System.Object" />.</param>
        <param name="secondary">Pomocniczy <see cref="T:System.Object" />.</param>
        <summary>Usuwa skojarzenie między dwoma obiektami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.RemoveAssociation%2A> Metoda usuwa skojarzenie między dwa obiekty utworzone przez <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> metody.  
  
 A <xref:System.WeakReference> służy do obsługi skojarzenie obiektu podstawowego i pomocniczego; w związku z tym ta metoda nie ma wpływu albo obiekt jest sfinalizowany lub odzyskana przez wyrzucanie elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociations">
      <MemberSignature Language="C#" Value="public static void RemoveAssociations (object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociations(object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociations(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveAssociations (primary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveAssociations(System::Object ^ primary);" />
      <MemberSignature Language="F#" Value="static member RemoveAssociations : obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveAssociations primary" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">Podstawowy <see cref="T:System.Object" /> w skojarzeniu.</param>
        <summary>Usuwa wszystkie skojarzenia dla obiekt podstawowy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.RemoveAssociations%2A> Metoda usuwa wszystkie skojarzenia między podstawowym obiektu i wszystkich jego dodatkowej obiekty utworzone przez wywołania <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> metody.  
  
 A <xref:System.WeakReference> służy do obsługi skojarzenie obiektu podstawowego i pomocniczego; w związku z tym ta metoda nie ma wpływu podczas podstawowej obiekty pomocnicze są sfinalizowany lub odzyskana przez wyrzucanie elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="primary" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa Dostawca opisu typu uprzednio dodanych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveProvider (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member RemoveProvider : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProvider (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> Do usunięcia.</param>
        <param name="instance">Wystąpienie elementu docelowego.</param>
        <summary>Usuwa uprzednio dodanych typ dostawcy opis, który jest skojarzony z określonym obiektem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wcześniej dodane w dostawcy opisu typu <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> metody. Usunięcie dostawcy powoduje, że <xref:System.ComponentModel.TypeDescriptor.Refreshed> się dla obiektu skojarzonego zdarzenia.  
  
 Użyj <xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> metodę, jeśli należy wywołać pochodzących z częściowo zaufanego kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member RemoveProvider : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProvider (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> Do usunięcia.</param>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Usuwa uprzednio dodanych typ dostawcy opis, który jest skojarzony z określonym typem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wcześniej dodane w dostawcy opisu typu <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> metody. Usunięcie dostawcy powoduje, że <xref:System.ComponentModel.TypeDescriptor.Refreshed> się do skojarzonego typu zdarzenia.  
  
 Użyj <xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> metodę, jeśli należy wywołać pochodzących z częściowo zaufanego kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzony stan:</permission>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveProviderTransparent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa Dostawca opisu typu uprzednio dodanych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveProviderTransparent (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member RemoveProviderTransparent : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProviderTransparent (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> Do usunięcia.</param>
        <param name="instance">Wystąpienie elementu docelowego.</param>
        <summary>Usuwa uprzednio dodanych typ dostawcy opis, który jest skojarzony z określonym obiektem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wcześniej dodane w dostawcy opisu typu <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> metody. Usunięcie dostawcy powoduje, że <xref:System.ComponentModel.TypeDescriptor.Refreshed> się dla obiektu skojarzonego zdarzenia.  
  
 Ta metoda może być wywołana z częściowo zaufanego kodu. Jeśli <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> jest zdefiniowany, wywołujący można zarejestrować dostawcę dla określonego wystąpienia jeśli jej typ jest również częściowo zaufany.  
  
 Użyj <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> metodę, jeśli nie należy wywoływać z częściowo zaufanego kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Aby uzyskać dostęp do rejestru. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzony typ: <see cref="T:System.Security.PermissionSet" /> , co jest wymagane przez zestaw definiujący <paramref name="instance" /> typ parametru.</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member RemoveProviderTransparent : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProviderTransparent (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> Do usunięcia.</param>
        <param name="type">
          <see cref="T:System.Type" /> Elementu docelowego.</param>
        <summary>Usuwa uprzednio dodanych typ dostawcy opis, który jest skojarzony z określonym typem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wcześniej dodane w dostawcy opisu typu <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> metody. Usunięcie dostawcy powoduje, że <xref:System.ComponentModel.TypeDescriptor.Refreshed> się do skojarzonego typu zdarzenia.  
  
 Ta metoda może być wywołana z częściowo zaufanego kodu. Jeśli <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> jest zdefiniowana, wywołujący można wyrejestrować dostawcę dla określonego typu, jeśli jest również częściowo zaufany.  
  
 Użyj <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> metodę, jeśli nie należy wywoływać z częściowo zaufanego kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeden lub oba parametry są <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Aby uzyskać dostęp do rejestru. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzony typ: <see cref="T:System.Security.PermissionSet" /> , co jest wymagane przez zestaw definiujący <paramref name="type" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptorArray">
      <MemberSignature Language="C#" Value="public static void SortDescriptorArray (System.Collections.IList infos);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SortDescriptorArray(class System.Collections.IList infos) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.SortDescriptorArray(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SortDescriptorArray (infos As IList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SortDescriptorArray(System::Collections::IList ^ infos);" />
      <MemberSignature Language="F#" Value="static member SortDescriptorArray : System.Collections.IList -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.SortDescriptorArray infos" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="infos" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="infos">
          <see cref="T:System.Collections.IList" /> Zawierający deskryptorów do sortowania.</param>
        <summary>Sortuje deskryptory przy użyciu nazwy deskryptora.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="infos" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.Refresh" />
      </Docs>
    </Member>
  </Members>
</Type>
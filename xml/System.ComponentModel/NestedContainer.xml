<Type Name="NestedContainer" FullName="System.ComponentModel.NestedContainer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a124ee078be65668efae6c08b17c83ac01930fb7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30443205" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NestedContainer : System.ComponentModel.Container, IDisposable, System.ComponentModel.INestedContainer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NestedContainer extends System.ComponentModel.Container implements class System.ComponentModel.IContainer, class System.ComponentModel.INestedContainer, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.NestedContainer" />
  <TypeSignature Language="VB.NET" Value="Public Class NestedContainer&#xA;Inherits Container&#xA;Implements IDisposable, INestedContainer" />
  <TypeSignature Language="C++ CLI" Value="public ref class NestedContainer : System::ComponentModel::Container, IDisposable, System::ComponentModel::INestedContainer" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Container</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.INestedContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia podstawową implementację dla <see cref="T:System.ComponentModel.INestedContainer" /> interfejs, który umożliwia kontenerom składnika, do którego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.NestedContainer> Proste wdrożenia jest klasa <xref:System.ComponentModel.INestedContainer> interfejs, który definiuje składnika logicznie zawierający zero lub więcej składników i jest własnością składnika nadrzędnego. Zachowanie zagnieżdżone kontenery różni się od standardowego <xref:System.ComponentModel.Container> na różne sposoby, takie jak:  
  
-   Lokacji cechy, takie jak <xref:System.ComponentModel.Component.DesignMode%2A> i <xref:System.ComponentModel.Component.GetService%2A> są kierowane za pośrednictwem składnika będący właścicielem witryny.  
  
-   Witryny <xref:System.ComponentModel.ISite.Name%2A> właściwość jest kwalifikowaną nazwę, która zawiera nazwę składnika będący właścicielem oraz kropki (.) i nazwy składnika podrzędnego.  
  
-   <xref:System.ComponentModel.NestedContainer.GetService%2A> zapewnia obsługę <xref:System.ComponentModel.INestedContainer> jako usługa.  
  
-   Jeśli składnika, do którego zostanie usunięty, kontener jest także usunięty.  
  
 Ponadto projektantów traktować zagnieżdżone kontenery inaczej. Host projektanta chce tylko jeden kontener — jeden powiązanych z hostem. W związku z tym składnikiem Dodawanie i usuwanie zdarzeń nie są wywoływane, gdy składnik jest dodane lub usunięte z kontenera zagnieżdżonych. Jednak ponieważ usług przepływać przez kontener zagnieżdżonych, składnik zdarzenia zmiany są wywoływane, gdy składnik w kontenerze zagnieżdżonych zostanie zmieniona.  
  
 Tej różnicy w śledzenie zdarzeń również wpływa na funkcjonalność cofania, który jest ściśle związany z serializacją. Aparat cofania standardowe <xref:System.ComponentModel.Design.IReferenceService> do śledzenia zmian wprowadzanych do składników. Jeśli aparat cofania nie może zidentyfikować nazwę składnika za pośrednictwem usługi odwołania, aparat zignoruje wszystkie zmiany dotyczące tego składnika. Ta usługa automatycznie rozpoznaje zmiany składników zawartych w niej tylko wtedy, gdy są one widoczne jako właściwości publiczne tylko do odczytu o tej samej nazwie w swoich właścicieli. W przeciwnym razie deweloper musi przejść pomyślnie zdarzenia zmiany składnika do właściciela. Na przykład, jeśli składnik zagnieżdżonych `Text` właściwości resurfaced jest jej właścicielem składnika jako `Address` właściwości, gdy `Text` zmienić właściwości, należy programowo wprowadzić zmianę właściwości dla odpowiedniego `Address` właściwości lub też że zmiany nie będą śledzone przez cofania.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.INestedContainer" />
    <altmember cref="T:System.ComponentModel.IContainer" />
    <altmember cref="T:System.ComponentModel.ISite" />
    <altmember cref="T:System.ComponentModel.Design.IReferenceService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NestedContainer (System.ComponentModel.IComponent owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IComponent owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.NestedContainer.#ctor(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (owner As IComponent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NestedContainer(System::ComponentModel::IComponent ^ owner);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owner">
          <see cref="T:System.ComponentModel.IComponent" /> , Który jest właścicielem tego kontenera zagnieżdżonych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.NestedContainer" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor rejestruje w jego właściciel <xref:System.ComponentModel.IComponent.Disposed> zdarzeń, aby Kontener zagnieżdżony <xref:System.ComponentModel.NestedContainer.Dispose%2A> automatycznie zostanie wywołana metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" /> jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.NestedContainer.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="CreateSite">
      <MemberSignature Language="C#" Value="protected override System.ComponentModel.ISite CreateSite (System.ComponentModel.IComponent component, string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.ComponentModel.ISite CreateSite(class System.ComponentModel.IComponent component, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.NestedContainer.CreateSite(System.ComponentModel.IComponent,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateSite (component As IComponent, name As String) As ISite" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::ComponentModel::ISite ^ CreateSite(System::ComponentModel::IComponent ^ component, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.ComponentModel.IComponent" /> Można utworzyć witrynę sieci.</param>
        <param name="name">Nazwę można przypisać do <c>składnika</c>, lub <see langword="null" /> Aby pominąć nazwę przypisania.</param>
        <summary>Tworzy witrynę dla składnika w tym kontenerze.</summary>
        <returns>Nowo utworzony <see cref="T:System.ComponentModel.ISite" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `name` parametr jest `null`, <xref:System.ComponentModel.IComponent> zostanie dodany do kontenera zagnieżdżonych bez nazwę identyfikującą.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.Container.CreateSite(System.ComponentModel.IComponent,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.NestedContainer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby używane przez kontener zagnieżdżonych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.ComponentModel.NestedContainer> odwołania. Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" /> należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose(Boolean)" />, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [przesłaniania metody Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
        <altmember cref="M:System.ComponentModel.NestedContainer.#ctor(System.ComponentModel.IComponent)" />
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="protected override object GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.NestedContainer.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetService (service As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ GetService(Type ^ service);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">
          <see cref="T:System.Type" /> Usługi do pobrania.</param>
        <summary>Pobiera obiekt usługi określonego typu, jeśli jest dostępna.</summary>
        <returns>
          <see cref="T:System.Object" /> Implementującej żądanej usługi lub <see langword="null" /> Jeśli usługi nie można rozpoznać.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.ComponentModel.Container.GetService%2A?displayProperty=nameWithType> metody. Ta implementacja usuwa tylko żądania dotyczące <xref:System.ComponentModel.INestedContainer> i <xref:System.ComponentModel.IContainer> usług.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.Container.GetService(System.Type)" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IComponent Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IComponent Owner" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.NestedContainer.Owner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Owner As IComponent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IComponent ^ Owner { System::ComponentModel::IComponent ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.INestedContainer.Owner</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnika, do którego ten kontener zagnieżdżonych.</summary>
        <value>
          <see cref="T:System.ComponentModel.IComponent" /> , Który jest właścicielem tego kontenera zagnieżdżonych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnika, do którego jest cech, który odróżnia zagnieżdżone kontenery z zwykłej kontenerów.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.IComponent" />
        <altmember cref="T:System.ComponentModel.IContainer" />
        <altmember cref="P:System.ComponentModel.INestedContainer.Owner" />
      </Docs>
    </Member>
    <Member MemberName="OwnerName">
      <MemberSignature Language="C#" Value="protected virtual string OwnerName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OwnerName" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.NestedContainer.OwnerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property OwnerName As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::String ^ OwnerName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę składnika, do którego.</summary>
        <value>Nazwa składnika, do którego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może zostać zastąpiona w celu Podaj nazwę właściciela niestandardowych. Domyślna implementacja wyszukuje witryny właściciela <xref:System.ComponentModel.INestedSite> i wywołania <xref:System.ComponentModel.INestedSite.FullName%2A>, lub <xref:System.ComponentModel.ISite.Name%2A> , jeśli nie jest żadna lokacja zagnieżdżonych. Jeśli nie będzie dostępny, ta właściwość zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
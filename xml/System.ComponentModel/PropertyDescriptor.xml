<Type Name="PropertyDescriptor" FullName="System.ComponentModel.PropertyDescriptor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e3bb3099bb34704ef8c5392628794c99b8ea8645" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69326894" /></Metadata><TypeSignature Language="C#" Value="public abstract class PropertyDescriptor : System.ComponentModel.MemberDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PropertyDescriptor extends System.ComponentModel.MemberDescriptor" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.PropertyDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PropertyDescriptor&#xA;Inherits MemberDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyDescriptor abstract : System::ComponentModel::MemberDescriptor" />
  <TypeSignature Language="F#" Value="type PropertyDescriptor = class&#xA;    inherit MemberDescriptor" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MemberDescriptor</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia abstrakcję właściwości klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opis właściwości składa się z nazwy, jej atrybutów, klasy składnika, z którą skojarzona jest właściwość, i typu właściwości.  
  
 <xref:System.ComponentModel.PropertyDescriptor>zapewnia następujące właściwości i metody:  
  
-   <xref:System.ComponentModel.PropertyDescriptor.Converter%2A>zawiera właściwość <xref:System.ComponentModel.TypeConverter> dla tej właściwości.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.IsLocalizable%2A>wskazuje, czy ta właściwość powinna być zlokalizowana.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.GetEditor%2A>zwraca Edytor określonego typu.  
  
 <xref:System.ComponentModel.PropertyDescriptor>dostępne są również następujące `abstract` właściwości i metody:  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ComponentType%2A>zawiera typ składnika, z którym jest powiązana ta właściwość.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.IsReadOnly%2A>wskazuje, czy ta właściwość jest tylko do odczytu.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.PropertyType%2A>Pobiera typ właściwości.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.CanResetValue%2A>wskazuje, czy Resetowanie składnika powoduje zmianę wartości składnika.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.GetValue%2A>zwraca bieżącą wartość właściwości składnika.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ResetValue%2A>Resetuje wartość tej właściwości składnika.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.SetValue%2A>ustawia wartość składnika na inną wartość.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue%2A>wskazuje, czy wartość tej właściwości musi być utrwalona.  
  
 `abstract` Zazwyczaj elementy członkowskie są implementowane za pomocą odbicia. Aby uzyskać więcej informacji na temat odbicia, zobacz [](~/docs/framework/reflection-and-codedom/reflection.md)tematy w obszarze odbicie.  
  
   
  
## Examples  
 Poniższy przykład kodu jest skompilowany w przypadku przykładu w <xref:System.ComponentModel.PropertyDescriptorCollection> klasie. Drukuje informacje (kategoria, opis, nazwa wyświetlana) tekstu przycisku w polu tekstowym. Przyjęto założenie `textbox1` , że `button1` i zostały utworzone na formularzu.  
  
 [!code-cpp[PropertyDescriptor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyDescriptor/CPP/propertydescriptor.cpp#1)]
 [!code-csharp[PropertyDescriptor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyDescriptor/CS/propertydescriptor.cs#1)]
 [!code-vb[PropertyDescriptor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyDescriptor/VB/propertydescriptor.vb#1)]  
  
 Poniższy przykład kodu pokazuje, jak zaimplementować niestandardowy deskryptor właściwości, który udostępnia otokę tylko do odczytu wokół właściwości. Jest używany w projektancie niestandardowym w celu udostępnienia deskryptora właściwości tylko do odczytu dla <xref:System.Windows.Forms.Control.Size%2A> właściwości kontrolki. `SerializeReadOnlyPropertyDescriptor`  
  
 [!code-csharp[System.ComponentModel.PropertyDescriptor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/SerializeReadOnlyPropertyDescriptor.cs#1)]
 [!code-vb[System.ComponentModel.PropertyDescriptor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/SerializeReadOnlyPropertyDescriptor.vb#1)]  
  
 Poniższy przykład kodu przedstawia sposób korzystania z `SerializeReadOnlyPropertyDescriptor` programu w projektancie niestandardowym.  
  
 [!code-csharp[System.ComponentModel.PropertyDescriptor#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/DemoControlDesigner.cs#10)]
 [!code-vb[System.ComponentModel.PropertyDescriptor#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/DemoControlDesigner.vb#10)]  
[!code-csharp[System.ComponentModel.PropertyDescriptor#100](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/DemoControl.cs#100)]
[!code-vb[System.ComponentModel.PropertyDescriptor#100](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/DemoControl.vb#100)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.MemberDescriptor" />
    <altmember cref="T:System.Attribute" />
    <altmember cref="T:System.ComponentModel.DefaultValueAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (System.ComponentModel.MemberDescriptor descr);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.MemberDescriptor descr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.ComponentModel.MemberDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (descr As MemberDescriptor)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::ComponentModel::MemberDescriptor ^ descr);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.PropertyDescriptor : System.ComponentModel.MemberDescriptor -&gt; System.ComponentModel.PropertyDescriptor" Usage="new System.ComponentModel.PropertyDescriptor descr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="descr" Type="System.ComponentModel.MemberDescriptor" />
      </Parameters>
      <Docs>
        <param name="descr">A <see cref="T:System.ComponentModel.MemberDescriptor" /> , który zawiera nazwę właściwości i jej atrybuty.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy z nazwą i atrybutami w określonym <see cref="T:System.ComponentModel.MemberDescriptor" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.MemberDescriptor" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (System.ComponentModel.MemberDescriptor descr, Attribute[] attrs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.MemberDescriptor descr, class System.Attribute[] attrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.ComponentModel.MemberDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (descr As MemberDescriptor, attrs As Attribute())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::ComponentModel::MemberDescriptor ^ descr, cli::array &lt;Attribute ^&gt; ^ attrs);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.PropertyDescriptor : System.ComponentModel.MemberDescriptor * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="new System.ComponentModel.PropertyDescriptor (descr, attrs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="descr" Type="System.ComponentModel.MemberDescriptor" />
        <Parameter Name="attrs" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="descr">A <see cref="T:System.ComponentModel.MemberDescriptor" /> zawiera nazwę elementu członkowskiego i jego atrybuty.</param>
        <param name="attrs"><see cref="T:System.Attribute" /> Tablica zawierająca atrybuty, które mają zostać skojarzone z właściwością.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy z nazwą w określonym <see cref="T:System.ComponentModel.MemberDescriptor" /> i atrybutami <see cref="T:System.Attribute" /> w <see cref="T:System.ComponentModel.MemberDescriptor" /> i tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor dołącza atrybuty <xref:System.Attribute> tablicy do atrybutów <xref:System.ComponentModel.MemberDescriptor>w.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.MemberDescriptor" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (string name, Attribute[] attrs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class System.Attribute[] attrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.String,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, attrs As Attribute())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::String ^ name, cli::array &lt;Attribute ^&gt; ^ attrs);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.PropertyDescriptor : string * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="new System.ComponentModel.PropertyDescriptor (name, attrs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attrs" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości.</param>
        <param name="attrs">Tablica typu <see cref="T:System.Attribute" /> , który zawiera atrybuty właściwości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy z określoną nazwą i atrybutami.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="AddValueChanged">
      <MemberSignature Language="C#" Value="public virtual void AddValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.AddValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddValueChanged : obj * EventHandler -&gt; unit&#xA;override this.AddValueChanged : obj * EventHandler -&gt; unit" Usage="propertyDescriptor.AddValueChanged (component, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, dla którego ma zostać dodana procedura obsługi.</param>
        <param name="handler">Delegat, który ma zostać dodany jako odbiornik.</param>
        <summary>Umożliwia powiadamianie innych obiektów, gdy ta właściwość ulegnie zmianie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="component" />lub <paramref name="handler" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResetValue">
      <MemberSignature Language="C#" Value="public abstract bool CanResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CanResetValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool CanResetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member CanResetValue : obj -&gt; bool" Usage="propertyDescriptor.CanResetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, który ma zostać przetestowany pod kątem możliwości resetowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca czy Resetowanie obiektu zmienia jego wartość.</summary>
        <returns><see langword="true" />Jeśli Resetowanie składnika zmieni jego wartość, w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda jest implementowana poprzez odbicie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Gdy jest zastępowany w klasie pochodnej, ta metoda szuka <see cref="T:System.ComponentModel.DefaultValueAttribute" />. Jeśli zostanie znaleziony, porównuje wartość atrybutu z bieżącą wartością właściwości. Zwraca <see langword="true" /> , gdy wartość domyślna nie jest zgodna z bieżącą wartością właściwości. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, szuka metody "ShouldPersistMyProperty", która jest wymagana do zaimplementowania siebie. Jeśli zostanie znalezione, <see cref="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" /> zwraca wartość zwracaną przez "ShouldPersistMyProperty". W przeciwnym razie szuka metody "ResetMyProperty", która jest wymagana do zaimplementowania siebie. Jeśli zostanie znalezione, <see cref="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" /> zwraca. <see langword="true" /> Jeśli nie można znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, Metoda "ShouldPersistMyProperty" lub "ResetMyProperty", a następnie zwraca wartość. <see langword="false" /></para></block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="ComponentType">
      <MemberSignature Language="C#" Value="public abstract Type ComponentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ComponentType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.ComponentType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ComponentType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ ComponentType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComponentType : Type" Usage="System.ComponentModel.PropertyDescriptor.ComponentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera typ składnika, z którym jest powiązana ta właściwość.</summary>
        <value>Reprezentuje typ składnika, z którym jest powiązana ta właściwość. <see cref="T:System.Type" /> Gdy są wywoływane <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" /> metody lub,określonyobiektmożebyćwystąpieniemtegotypu.<see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta właściwość jest implementowana poprzez odbicie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Converter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.TypeConverter Converter" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.Converter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Converter As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::TypeConverter ^ Converter { System::ComponentModel::TypeConverter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Converter : System.ComponentModel.TypeConverter" Usage="System.ComponentModel.PropertyDescriptor.Converter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera konwerter typu dla tej właściwości.</summary>
        <value>, Który jest używany do <see cref="T:System.Type" /> konwersji tej właściwości. <see cref="T:System.ComponentModel.TypeConverter" /></value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : Type -&gt; obj" Usage="propertyDescriptor.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Reprezentuje typ, który ma zostać utworzony. <see cref="T:System.Type" /></param>
        <summary>Tworzy wystąpienie określonego typu.</summary>
        <returns>Nowe wystąpienie typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.PropertyDescriptor.CreateInstance%2A>szuka konstruktora, który przyjmuje określony typ. W przypadku znalezienia konstruktora, typ właściwości jest przenoszona.  
  
 Konwertery i edytory używają tej metody do tworzenia wersji składnika. Ta metoda umożliwia ponownie użycie pojedynczego składnika dla więcej niż jednego typu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">w celu uzyskania dostępu do prywatnych składowych i metadanych klas. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
        <altmember cref="T:System.Drawing.Design.UITypeEditor" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="propertyDescriptor.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany <see cref="T:System.ComponentModel.PropertyDescriptor" />.</param>
        <summary>Porównuje to z innym obiektem, aby sprawdzić, czy są one równoważne.</summary>
        <returns><see langword="true" />Jeśli wartości są równoważne; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillAttributes">
      <MemberSignature Language="C#" Value="protected override void FillAttributes (System.Collections.IList attributeList);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FillAttributes(class System.Collections.IList attributeList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.FillAttributes(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub FillAttributes (attributeList As IList)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void FillAttributes(System::Collections::IList ^ attributeList);" />
      <MemberSignature Language="F#" Value="override this.FillAttributes : System.Collections.IList -&gt; unit" Usage="propertyDescriptor.FillAttributes attributeList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeList" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeList"><see cref="T:System.Collections.IList" /> , Który wyświetla listę atrybutów w klasie nadrzędnej. Początkowo jest to puste.</param>
        <summary>Dodaje atrybuty <see cref="T:System.ComponentModel.PropertyDescriptor" /> do określonej listy atrybutów w klasie nadrzędnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku zduplikowanych atrybutów, ostatnia dodana do listy zostanie zachowana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildProperties">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties () As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties();" />
      <MemberSignature Language="F#" Value="member this.GetChildProperties : unit -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość domyślną <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />.</summary>
        <returns>Kolekcja deskryptora właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przekazuje `null` `instance` parametr i `filter` parametr.  
  
 Właściwości `instance` parametru mogą się różnić od właściwości klasy, ponieważ kontener może dodawać lub usuwać właściwości, `instance` Jeśli parametr jest zlokalizowany.  
  
 Parametr może mieszać <xref:System.Type> i<xref:System.Attribute>obiekty. `filter` Filtrowanie jest zdefiniowane przy użyciu następujących reguł:  
  
-   Obiekt jest traktowany jako symbol wieloznaczny; pasuje do dowolnej właściwości, <xref:System.Type> która ma w jej zestawie atrybutów. <xref:System.Type>  
  
-   Jeśli właściwość nie ma <xref:System.Attribute> tej samej klasy, właściwość nie zostanie uwzględniona w zwracanej tablicy.  
  
-   Jeśli atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnym dopasowaniem do uwzględnienia w zwracanej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> i jest to właściwość domyślna, zostanie ona uwzględniona w zwracanej tablicy, nawet jeśli nie ma żadnego <xref:System.Attribute> wystąpienia właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties (Attribute[] filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(class System.Attribute[] filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties (filter As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(cli::array &lt;Attribute ^&gt; ^ filter);" />
      <MemberSignature Language="F#" Value="member this.GetChildProperties : Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties filter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="filter">Tablica typu <see cref="T:System.Attribute" /> do użycia jako filtr.</param>
        <summary><see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> Zwraca przy użyciu określonej tablicy atrybutów jako filtr.</summary>
        <returns><see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> Z właściwościami, które pasują do określonych atrybutów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przekazuje `null` `instance` parametr.  
  
 Właściwości `instance` parametru mogą się różnić od właściwości klasy, ponieważ lokacja może dodawać lub usuwać właściwości, `instance` Jeśli parametr jest zlokalizowany.  
  
 Parametr może mieszać <xref:System.Type> i<xref:System.Attribute>obiekty. `filter` Filtrowanie jest zdefiniowane przy użyciu następujących reguł:  
  
-   Obiekt jest traktowany jako symbol wieloznaczny; pasuje do dowolnej właściwości, <xref:System.Type> która ma w jej zestawie atrybutów. <xref:System.Type>  
  
-   Jeśli właściwość nie ma <xref:System.Attribute> tej samej klasy, właściwość nie zostanie uwzględniona w zwracanej tablicy.  
  
-   Jeśli atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnym dopasowaniem do uwzględnienia w zwracanej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> wystąpienie i jest to właściwość domyślna, zostanie ona uwzględniona w zwracanej tablicy, nawet jeśli nie ma żadnego wystąpienia <xref:System.Attribute> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties (instance As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="member this.GetChildProperties : obj -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Składnik, dla którego mają zostać pobrane właściwości.</param>
        <summary><see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> Zwraca dla danego obiektu.</summary>
        <returns><see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> Z właściwościami dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przekazuje `null` `filter` parametr.  
  
 Właściwości `instance` parametru mogą się różnić od właściwości klasy, ponieważ lokacja może dodawać lub usuwać właściwości, `instance` Jeśli parametr jest zlokalizowany.  
  
 Parametr może mieszać <xref:System.Type> i<xref:System.Attribute>obiekty. `filter` Filtrowanie jest zdefiniowane przy użyciu następujących reguł:  
  
-   Obiekt jest traktowany jako symbol wieloznaczny; pasuje do dowolnej właściwości, <xref:System.Type> która ma w jej zestawie atrybutów. <xref:System.Type>  
  
-   Jeśli właściwość nie ma <xref:System.Attribute> tej samej klasy, właściwość nie zostanie uwzględniona w zwracanej tablicy.  
  
-   Jeśli atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnym dopasowaniem do uwzględnienia w zwracanej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> wystąpienie i jest to właściwość domyślna, zostanie ona uwzględniona w zwracanej tablicy, nawet jeśli nie ma żadnego wystąpienia <xref:System.Attribute> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetChildProperties (object instance, Attribute[] filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(object instance, class System.Attribute[] filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChildProperties (instance As Object, filter As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(System::Object ^ instance, cli::array &lt;Attribute ^&gt; ^ filter);" />
      <MemberSignature Language="F#" Value="abstract member GetChildProperties : obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection&#xA;override this.GetChildProperties : obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties (instance, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="filter" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="instance">Składnik, dla którego mają zostać pobrane właściwości.</param>
        <param name="filter">Tablica typu <see cref="T:System.Attribute" /> do użycia jako filtr.</param>
        <summary><see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> Zwraca dla danego obiektu, używając określonej tablicy atrybutów jako filtru.</summary>
        <returns><see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> Z właściwościami, które pasują do określonych atrybutów dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości `instance` parametru mogą się różnić od właściwości klasy, ponieważ lokacja może dodawać lub usuwać właściwości, `instance` Jeśli parametr jest zlokalizowany.  
  
 Parametr może mieszać <xref:System.Type> i<xref:System.Attribute>obiekty. `filter` Filtrowanie jest zdefiniowane przy użyciu następujących reguł:  
  
-   Obiekt jest traktowany jako symbol wieloznaczny; pasuje do dowolnej właściwości, <xref:System.Type> która ma w jej zestawie atrybutów. <xref:System.Type>  
  
-   Jeśli właściwość nie ma <xref:System.Attribute> tej samej klasy, właściwość nie zostanie uwzględniona w zwracanej tablicy.  
  
-   Jeśli atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnym dopasowaniem do uwzględnienia w zwracanej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> wystąpienie i jest to właściwość domyślna, zostanie ona uwzględniona w zwracanej tablicy, nawet jeśli nie ma żadnego wystąpienia <xref:System.Attribute> właściwości.  
  
 Ogólnie rzecz biorąc, właściwości podrzędne powinny być zwracane przez <xref:System.ComponentModel.TypeConverter.GetProperties%2A> implementację elementu <xref:System.ComponentModel.TypeConverter> Członkowskiego zwracanej z tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public virtual object GetEditor (Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetEditor(class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetEditor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEditor (editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetEditor(Type ^ editorBaseType);" />
      <MemberSignature Language="F#" Value="abstract member GetEditor : Type -&gt; obj&#xA;override this.GetEditor : Type -&gt; obj" Usage="propertyDescriptor.GetEditor editorBaseType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">Typ podstawowy edytora, który jest używany do odróżnienia między wieloma edytorami obsługiwanymi przez właściwość.</param>
        <summary>Pobiera Edytor określonego typu.</summary>
        <returns>Wystąpienie żądanego typu edytora lub <see langword="null" /> nie można odnaleźć edytora.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="propertyDescriptor.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego obiektu.</summary>
        <returns>Kod skrótu dla tego obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvocationTarget">
      <MemberSignature Language="C#" Value="protected override object GetInvocationTarget (Type type, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object GetInvocationTarget(class System.Type type, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetInvocationTarget(System.Type,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ GetInvocationTarget(Type ^ type, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="override this.GetInvocationTarget : Type * obj -&gt; obj" Usage="propertyDescriptor.GetInvocationTarget (type, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Object" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Obiekt docelowy wywołania.</param>
        <param name="instance">Potencjalny obiekt docelowy wywołania.</param>
        <summary>Ta metoda zwraca obiekt, który powinien być używany podczas wywoływania elementów członkowskich.</summary>
        <returns><see cref="T:System.Object" /> , Który powinien być używany podczas wywoływania elementów członkowskich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj wartość zwracana będzie taka sama jak `instance` w przekazaniu. Jeśli ktoś skojarzył inny obiekt z tym wystąpieniem lub jeśli wystąpienie jest deskryptorem typu niestandardowego, <xref:System.ComponentModel.PropertyDescriptor.GetInvocationTarget%2A> Metoda może zwrócić inną wartość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromName">
      <MemberSignature Language="C#" Value="protected Type GetTypeFromName (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Type GetTypeFromName(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetTypeFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTypeFromName (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type ^ GetTypeFromName(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.GetTypeFromName : string -&gt; Type" Usage="propertyDescriptor.GetTypeFromName typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Kwalifikowana dla zestawu nazwa typu do pobrania.</param>
        <summary>Zwraca typ przy użyciu jego nazwy.</summary>
        <returns>Jest <see cref="T:System.Type" /> to zgodne z podaną nazwą typu lub <see langword="null" /> Jeśli nie można znaleźć dopasowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby znaleźć odpowiedni typ, ta metoda najpierw sprawdza zestaw typu, który to <xref:System.ComponentModel.PropertyDescriptor> odwołanie. Jeśli nie znajdzie typu w zestawie, wywołuje <xref:System.Type.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public abstract object GetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValue (component As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ GetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member GetValue : obj -&gt; obj" Usage="propertyDescriptor.GetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik z właściwością, dla której ma zostać pobrana wartość.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera bieżącą wartość właściwości w składniku.</summary>
        <returns>Wartość właściwości danego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda jest implementowana poprzez odbicie.  
  
 Ta metoda automatycznie wywołuje metodę prezmiany, <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A>i metodę po zmianie, <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A>, z <xref:System.ComponentModel.Design.IComponentChangeService>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas przesłonięcia tej metody pobiera bieżącą wartość właściwości przez wywołanie metody "GetMyProperty", która ma być zaimplementowana. Wyjątek w tej metodzie powinien przechodzić przez.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetValueChangedHandler">
      <MemberSignature Language="C#" Value="protected internal EventHandler GetValueChangedHandler (object component);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.EventHandler GetValueChangedHandler(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetValueChangedHandler(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetValueChangedHandler (component As Object) As EventHandler" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; EventHandler ^ GetValueChangedHandler(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="member this.GetValueChangedHandler : obj -&gt; EventHandler" Usage="propertyDescriptor.GetValueChangedHandler component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, dla którego mają zostać pobrane programy obsługi zdarzeń.</param>
        <summary>Pobiera bieżący zestaw programów obsługi zdarzeń <c>ValueChanged</c> dla określonego składnika</summary>
        <returns>Połączony program obsługi zdarzeń multiemisji lub <see langword="null" /> w przypadku, gdy żadne programy obsługi zdarzeń nie są obecnie przypisane do. <paramref name="component" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalizable">
      <MemberSignature Language="C#" Value="public virtual bool IsLocalizable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocalizable" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.IsLocalizable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsLocalizable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsLocalizable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocalizable : bool" Usage="System.ComponentModel.PropertyDescriptor.IsLocalizable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ta właściwość powinna być zlokalizowana, zgodnie z <see cref="T:System.ComponentModel.LocalizableAttribute" />opisem w.</summary>
        <value><see langword="true" />Jeśli element członkowski jest oznaczony z <see cref="T:System.ComponentModel.LocalizableAttribute" /> ustawioną na <see langword="true" />; w przeciwnym razie,. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy właściwość jest oznaczona z <xref:System.ComponentModel.LocalizableAttribute> zestawem na `true` i użyta w projektancie wizualizacji, jego wartości są zapisywane w pliku zasobów. Jeśli oznaczesz Właściwość atrybutem, a następnie ustawisz właściwość w kodzie, pliki zasobów nie będą używane.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.LocalizableAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public abstract bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.ComponentModel.PropertyDescriptor.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy ta właściwość jest tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli właściwość jest tylko do odczytu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ReadOnlyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="OnValueChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnValueChanged (object component, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValueChanged(object component, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.OnValueChanged(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValueChanged (component As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValueChanged(System::Object ^ component, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValueChanged : obj * EventArgs -&gt; unit&#xA;override this.OnValueChanged : obj * EventArgs -&gt; unit" Usage="propertyDescriptor.OnValueChanged (component, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="component">Obiekt, który wywołuje zdarzenie.</param>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje zaimplementowane zdarzenie <c>ValueChanged</c> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna być wywoływana przez implementację deskryptora właściwości, gdy wartość właściwości została zmieniona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public abstract Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.ComponentModel.PropertyDescriptor.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera typ właściwości.</summary>
        <value><see cref="T:System.Type" /> Reprezentujący typ właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta właściwość jest implementowana poprzez odbicie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveValueChanged">
      <MemberSignature Language="C#" Value="public virtual void RemoveValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.RemoveValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveValueChanged : obj * EventHandler -&gt; unit&#xA;override this.RemoveValueChanged : obj * EventHandler -&gt; unit" Usage="propertyDescriptor.RemoveValueChanged (component, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">Składnik służący do usuwania programu obsługi dla.</param>
        <param name="handler">Delegat do usunięcia jako odbiornik.</param>
        <summary>Umożliwia powiadamianie innych obiektów, gdy ta właściwość ulegnie zmianie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="component" />lub <paramref name="handler" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetValue">
      <MemberSignature Language="C#" Value="public abstract void ResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResetValue (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member ResetValue : obj -&gt; unit" Usage="propertyDescriptor.ResetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik z wartością właściwości, która ma zostać przywrócona do wartości domyślnej.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, resetuje wartość tej właściwości składnika do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda jest implementowana poprzez odbicie.  
  
 Ta metoda określa wartość resetowania właściwości do wartości w następującej kolejności:  
  
1.  Istnieje właściwość shadowd dla tej właściwości.  
  
2.  <xref:System.ComponentModel.DefaultValueAttribute> Istnieje dla tej właściwości.  
  
3.  Zaimplementowano metodę "ResetMyProperty", gdzie "noproperty" jest nazwą przekazanej do niej właściwości.  
  
 Ta metoda tworzy <xref:System.ComponentModel.Design.DesignerTransaction> automatycznie w następującej kolejności:  
  
1.  Metoda wywołuje <xref:System.ComponentModel.Design.IDesignerHost.CreateTransaction%2A?displayProperty=nameWithType> metodę w celu utworzenia nowej <xref:System.ComponentModel.Design.DesignerTransaction> do reprezentowania zmian.  
  
2.  Metoda wywołuje <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A?displayProperty=nameWithType> metodę w celu wskazania, że transakcja została rozpoczęta i zmiany zostaną wykonane.  
  
3.  Metoda resetuje właściwość do wartości ustalonej przez kolejność sprawdzania tej metody.  
  
4.  Metoda wywołuje <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A?displayProperty=nameWithType> metodę w celu wskazania, że zmiany zostały wprowadzone.  
  
5.  Metoda wywołuje <xref:System.ComponentModel.Design.DesignerTransaction.Commit%2A?displayProperty=nameWithType> , aby wskazać, że transakcja została ukończona.  
  
 Celem transakcji jest wsparcie `Undo` i `Redo` funkcjonalność.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Gdy jest zastępowany w klasie pochodnej, ta metoda szuka <see cref="T:System.ComponentModel.DefaultValueAttribute" />. Jeśli znajdzie, ustawia wartość właściwości na <see cref="T:System.ComponentModel.DefaultValueAttribute" /> znalezioną. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, szuka metody "ResetMyProperty", która ma być zaimplementowana. W <see cref="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" /> przypadku znalezienia tej metody metoda wywołuje ją. Jeśli <see cref="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" /> nie można <see cref="T:System.ComponentModel.DefaultValueAttribute" /> znaleźć metody lub "ResetMyProperty", która została zaimplementowana, nie wykonuje operacji.</para></block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.ComponentModel.PropertyDescriptor.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ta właściwość powinna być serializowana, jak określono w <see cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute" />.</summary>
        <value>Jedna z <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> wartości wyliczenia, która określa, czy ta właściwość powinna być serializowana.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute" />
        <altmember cref="T:System.ComponentModel.DesignerSerializationVisibility" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public abstract void SetValue (object component, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object component, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetValue (component As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetValue(System::Object ^ component, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj -&gt; unit" Usage="propertyDescriptor.SetValue (component, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik z wartością właściwości, która ma zostać ustawiona.</param>
        <param name="value">Nowa wartość.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, ustawia wartość składnika na inną wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda jest implementowana poprzez odbicie.  
  
 Ta metoda tworzy <xref:System.ComponentModel.Design.DesignerTransaction> automatycznie w następującej kolejności:  
  
1.  Metoda wywołuje <xref:System.ComponentModel.Design.IDesignerHost.CreateTransaction%2A?displayProperty=nameWithType> metodę w celu utworzenia nowej <xref:System.ComponentModel.Design.DesignerTransaction> do reprezentowania zmian.  
  
2.  Metoda wywołuje <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A?displayProperty=nameWithType> metodę w celu wskazania, że transakcja została rozpoczęta i zmiany zostaną wykonane.  
  
3.  Metoda resetuje właściwość do wartości ustalonej przez kolejność sprawdzania tej metody.  
  
4.  Metoda wywołuje <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A?displayProperty=nameWithType> metodę w celu wskazania, że zmiany zostały wprowadzone.  
  
5.  Metoda wywołuje <xref:System.ComponentModel.Design.DesignerTransaction.Commit%2A?displayProperty=nameWithType> , aby wskazać, że transakcja została ukończona.  
  
 Celem transakcji jest wsparcie `Undo` i `Redo` funkcjonalność.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania tej metody należy ustawić wartość właściwości przez wywołanie odpowiedniej metody "SetMyProperty", która ma być zaimplementowana. Jeśli określona wartość nie jest prawidłowa, składnik powinien zgłosić wyjątek, który jest przekazywać. Należy zaprojektować Właściwość tak, aby Metoda "GetMyProperty" (zaimplementowana) była zgodna z metodą "SetMyProperty", zwracająca wartość przekazaną, gdy metoda "SetMyProperty" nie zgłasza wyjątku.</para></block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeValue">
      <MemberSignature Language="C#" Value="public abstract bool ShouldSerializeValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldSerializeValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ShouldSerializeValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ShouldSerializeValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeValue : obj -&gt; bool" Usage="propertyDescriptor.ShouldSerializeValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik zawierający właściwość, która ma zostać zbadana pod kątem trwałości.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, określa wartość wskazującą, czy wartość tej właściwości musi być utrwalona.</summary>
        <returns><see langword="true" />Jeśli właściwość powinna być utrwalona; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda jest implementowana poprzez odbicie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Gdy jest zastępowany w klasie pochodnej, ta metoda <see langword="true" /> zwraca wartość, jeśli bieżąca wartość właściwości różni się od wartości domyślnej. Szuka ona wartości domyślnej, najpierw szukając <see cref="T:System.ComponentModel.DefaultValueAttribute" />. Jeśli metoda odnajdzie ten atrybut, porównuje wartość atrybutu z bieżącą wartością właściwości. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, szuka metody "ShouldSerializeMyProperty", która ma być zaimplementowana. Jeśli zostanie znaleziona, <see cref="M:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue(System.Object)" /> wywołuje ją. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" /> metody lub "ShouldSerializeMyProperty", nie można utworzyć optymalizacji i zwraca wartość. <see langword="true" />
 
 <block subset="none" type="note"><para>  
 <see cref="T:System.ComponentModel.Design.ComponentDesigner" /> Klasa implementuje specjalną logikę serializacji dla dziedziczonych składników. Aby uzyskać więcej informacji, zobacz <see cref="T:System.ComponentModel.Design.ComponentDesigner" />.  
</para></block></para></block>
        <altmember cref="T:System.ComponentModel.Design.ComponentDesigner" />
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeEvents">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeEvents" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.SupportsChangeEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsChangeEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeEvents { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsChangeEvents : bool" Usage="System.ComponentModel.PropertyDescriptor.SupportsChangeEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy powiadomienia o zmianie wartości dla tej właściwości mogą pochodzić spoza deskryptora właściwości.</summary>
        <value><see langword="true" />Jeśli powiadomienia o zmianie wartości mogą pochodzić spoza deskryptora właściwości; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.PropertyDescriptor.SupportsChangeEvents%2A> Właściwość wskazuje, czy powiadomienia o zmianach wartości dla tej właściwości mogą pochodzić spoza deskryptora właściwości, takiego jak ze składnika, lub czy powiadomienia będą pochodzić tylko z bezpośrednich wywołań wykonanych do <xref:System.ComponentModel.PropertyDescriptor.SetValue%2A> Metoda. Na przykład składnik może zaimplementować <xref:System.ComponentModel.INotifyPropertyChanged> interfejs lub może mieć jawne `name.Changed` zdarzenie dla tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="PropertyDescriptor" FullName="System.ComponentModel.PropertyDescriptor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="35d7ebde15030c1e31d18a34bcc6ab5cabe6c767" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36701063" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PropertyDescriptor : System.ComponentModel.MemberDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PropertyDescriptor extends System.ComponentModel.MemberDescriptor" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.PropertyDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PropertyDescriptor&#xA;Inherits MemberDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyDescriptor abstract : System::ComponentModel::MemberDescriptor" />
  <TypeSignature Language="F#" Value="type PropertyDescriptor = class&#xA;    inherit MemberDescriptor" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MemberDescriptor</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia abstrakcję właściwości dla klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opis właściwości składa się z nazwy, jego atrybuty klasy składnika skojarzonego z właściwości i typ właściwości.  
  
 <xref:System.ComponentModel.PropertyDescriptor> udostępnia następujące metody i właściwości:  
  
-   <xref:System.ComponentModel.PropertyDescriptor.Converter%2A> zawiera <xref:System.ComponentModel.TypeConverter> dla tej właściwości.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.IsLocalizable%2A> Wskazuje, czy ta właściwość powinna być lokalizowany.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.GetEditor%2A> Zwraca edytora określonego typu.  
  
 <xref:System.ComponentModel.PropertyDescriptor> dostępne są także następujące `abstract` właściwości i metody:  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ComponentType%2A> zawiera typ składnika, który jest powiązany tej właściwości.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.IsReadOnly%2A> Wskazuje, czy ta właściwość jest tylko do odczytu.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.PropertyType%2A> Pobiera typ właściwości.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.CanResetValue%2A> Wskazuje, czy składnik Resetowanie zmienia wartość składnika.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.GetValue%2A> Zwraca bieżącą wartość właściwości składnika.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ResetValue%2A> Resetuje wartości dla tej właściwości składnika.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.SetValue%2A> Ustawia wartość składnika innej wartości.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue%2A> Wskazuje, czy wartość tej właściwości musi być utrwalona.  
  
 Zazwyczaj `abstract` elementy członkowskie są implementowane za pośrednictwem odbicia. Aby uzyskać więcej informacji na temat odbicia, zobacz Tematy w [odbicia](~/docs/framework/reflection-and-codedom/reflection.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod jest oparty na przykład w <xref:System.ComponentModel.PropertyDescriptorCollection> klasy. Wyświetla informacje (kategorii, opis, nazwa wyświetlana) tekst przycisku w polu tekstowym. Przy założeniu, że `button1` i `textbox1` zostały utworzone w formularzu.  
  
 [!code-cpp[PropertyDescriptor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyDescriptor/CPP/propertydescriptor.cpp#1)]
 [!code-csharp[PropertyDescriptor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyDescriptor/CS/propertydescriptor.cs#1)]
 [!code-vb[PropertyDescriptor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyDescriptor/VB/propertydescriptor.vb#1)]  
  
 Poniższy przykład kodu pokazuje, jak do zaimplementowania deskryptora właściwości niestandardowej, która zawiera tylko do odczytu otokę właściwości. `SerializeReadOnlyPropertyDescriptor` Jest używany w Projektancie niestandardowe, aby zapewniać deskryptora właściwości tylko do odczytu dla formantu <xref:System.Windows.Forms.Control.Size%2A> właściwości.  
  
 [!code-csharp[System.ComponentModel.PropertyDescriptor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/SerializeReadOnlyPropertyDescriptor.cs#1)]
 [!code-vb[System.ComponentModel.PropertyDescriptor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/SerializeReadOnlyPropertyDescriptor.vb#1)]  
  
 W poniższych przykładach kodu pokazano sposób użycia `SerializeReadOnlyPropertyDescriptor` w Projektancie niestandardowych.  
  
 [!code-csharp[System.ComponentModel.PropertyDescriptor#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/DemoControlDesigner.cs#10)]
 [!code-vb[System.ComponentModel.PropertyDescriptor#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/DemoControlDesigner.vb#10)]  
[!code-csharp[System.ComponentModel.PropertyDescriptor#100](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/DemoControl.cs#100)]
[!code-vb[System.ComponentModel.PropertyDescriptor#100](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/DemoControl.vb#100)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.MemberDescriptor" />
    <altmember cref="T:System.Attribute" />
    <altmember cref="T:System.ComponentModel.DefaultValueAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (System.ComponentModel.MemberDescriptor descr);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.MemberDescriptor descr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.ComponentModel.MemberDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (descr As MemberDescriptor)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::ComponentModel::MemberDescriptor ^ descr);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.PropertyDescriptor : System.ComponentModel.MemberDescriptor -&gt; System.ComponentModel.PropertyDescriptor" Usage="new System.ComponentModel.PropertyDescriptor descr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="descr" Type="System.ComponentModel.MemberDescriptor" />
      </Parameters>
      <Docs>
        <param name="descr">A <see cref="T:System.ComponentModel.MemberDescriptor" /> zawiera nazwę właściwości i jego atrybuty.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy o nazwie i atrybutów w określonym <see cref="T:System.ComponentModel.MemberDescriptor" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.MemberDescriptor" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (System.ComponentModel.MemberDescriptor descr, Attribute[] attrs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.MemberDescriptor descr, class System.Attribute[] attrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.ComponentModel.MemberDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (descr As MemberDescriptor, attrs As Attribute())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::ComponentModel::MemberDescriptor ^ descr, cli::array &lt;Attribute ^&gt; ^ attrs);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.PropertyDescriptor : System.ComponentModel.MemberDescriptor * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="new System.ComponentModel.PropertyDescriptor (descr, attrs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="descr" Type="System.ComponentModel.MemberDescriptor" />
        <Parameter Name="attrs" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="descr">A <see cref="T:System.ComponentModel.MemberDescriptor" /> zawierającą nazwę elementu członkowskiego i jego atrybuty.</param>
        <param name="attrs">
          <see cref="T:System.Attribute" /> Tablica zawierająca atrybuty chcesz powiązać z właściwością.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy o nazwie w określonym <see cref="T:System.ComponentModel.MemberDescriptor" /> oraz atrybutów w obu <see cref="T:System.ComponentModel.MemberDescriptor" /> i <see cref="T:System.Attribute" /> tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor dołącza atrybuty w <xref:System.Attribute> tablicy w atrybutach w <xref:System.ComponentModel.MemberDescriptor>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.MemberDescriptor" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (string name, Attribute[] attrs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class System.Attribute[] attrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.String,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, attrs As Attribute())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::String ^ name, cli::array &lt;Attribute ^&gt; ^ attrs);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.PropertyDescriptor : string * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="new System.ComponentModel.PropertyDescriptor (name, attrs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attrs" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości.</param>
        <param name="attrs">Tablica typu <see cref="T:System.Attribute" /> zawiera atrybuty.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy z określoną nazwą oraz atrybutami.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="AddValueChanged">
      <MemberSignature Language="C#" Value="public virtual void AddValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.AddValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddValueChanged : obj * EventHandler -&gt; unit&#xA;override this.AddValueChanged : obj * EventHandler -&gt; unit" Usage="propertyDescriptor.AddValueChanged (component, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">Element, aby dodać obsługę programu.</param>
        <param name="handler">Delegat do dodania jako odbiornik.</param>
        <summary>Umożliwia inne obiekty, aby otrzymać powiadomienie, gdy ta właściwość ulegnie zmianie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> lub <paramref name="handler" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResetValue">
      <MemberSignature Language="C#" Value="public abstract bool CanResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CanResetValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool CanResetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member CanResetValue : obj -&gt; bool" Usage="propertyDescriptor.CanResetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, aby sprawdzić możliwość resetowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej zwraca czy Resetowanie obiektu zmienia jego wartość.</summary>
        <returns>
          <see langword="true" /> Resetowanie składnika zmienia się wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta metoda jest implementowane za pośrednictwem odbicia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłonięcia w klasie pochodnej, ta metoda sprawdza <see cref="T:System.ComponentModel.DefaultValueAttribute" />. Jeśli zostanie znaleziony, porównuje wartości atrybutu z bieżącej wartości właściwości. Zwraca <see langword="true" /> gdy wartością domyślną jest niezgodny bieżącej wartości właściwości. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, wygląda na to dla metody "ShouldPersistMyProperty", który należy wdrożyć samodzielnie. Jeśli to zostanie znaleziony, <see cref="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" /> zwraca zwraca "ShouldPersistMyProperty". W przeciwnym razie wygląda dla metody "ResetMyProperty", który należy wdrożyć samodzielnie. Jeśli to zostanie znaleziony, <see cref="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" /> zwraca <see langword="true" />. Nie można znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, zwraca metodę "ShouldPersistMyProperty" lub "ResetMyProperty" metodę, a następnie go <see langword="false" />.</para>
        </block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="ComponentType">
      <MemberSignature Language="C#" Value="public abstract Type ComponentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ComponentType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.ComponentType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ComponentType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ ComponentType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComponentType : Type" Usage="System.ComponentModel.PropertyDescriptor.ComponentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera typ składnika, który jest powiązany tej właściwości.</summary>
        <value>A <see cref="T:System.Type" /> reprezentujący typ składnika, ta właściwość jest powiązana. Gdy <see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" /> lub <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" /> metody są wywoływane, określony obiekt może być wystąpienia tego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta właściwość jest implementowany przez odbicie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Converter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.TypeConverter Converter" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.Converter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Converter As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::TypeConverter ^ Converter { System::ComponentModel::TypeConverter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Converter : System.ComponentModel.TypeConverter" Usage="System.ComponentModel.PropertyDescriptor.Converter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera konwerter typu dla tej właściwości.</summary>
        <value>A <see cref="T:System.ComponentModel.TypeConverter" /> używany do przekonwertowania <see cref="T:System.Type" /> tej właściwości.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : Type -&gt; obj" Usage="propertyDescriptor.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ do utworzenia.</param>
        <summary>Tworzy wystąpienie określonego typu.</summary>
        <returns>Nowe wystąpienie typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.PropertyDescriptor.CreateInstance%2A> Wyszukuje konstruktora przyjmującego określonego typu. W przypadku odnalezienia konstruktora, typ właściwości jest przekazywana.  
  
 Konwertery i edytory ta metoda umożliwia utworzenie wersji składnika. Ta metoda zapewnia jeden składnik zostanie ponownie dla więcej niż jednego typu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do elementów członkowskich klasy prywatnych i metadanych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
        <altmember cref="T:System.Drawing.Design.UITypeEditor" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="propertyDescriptor.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym <see cref="T:System.ComponentModel.PropertyDescriptor" />.</param>
        <summary>Porównuje to z innym obiektem, aby sprawdzić, czy są równoważne.</summary>
        <returns>
          <see langword="true" /> Jeśli wartości są równoważne; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillAttributes">
      <MemberSignature Language="C#" Value="protected override void FillAttributes (System.Collections.IList attributeList);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FillAttributes(class System.Collections.IList attributeList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.FillAttributes(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub FillAttributes (attributeList As IList)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void FillAttributes(System::Collections::IList ^ attributeList);" />
      <MemberSignature Language="F#" Value="override this.FillAttributes : System.Collections.IList -&gt; unit" Usage="propertyDescriptor.FillAttributes attributeList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeList" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="attributeList">
          <see cref="T:System.Collections.IList" /> Który zawiera listę atrybutów w klasie nadrzędnej. Początkowo jest pusta.</param>
        <summary>Dodaje atrybuty <see cref="T:System.ComponentModel.PropertyDescriptor" /> określoną listę atrybutów w klasie nadrzędnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zduplikowane atrybuty ostatnią dodany do listy zostaną zachowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildProperties">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties () As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties();" />
      <MemberSignature Language="F#" Value="member this.GetChildProperties : unit -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca domyślne <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />.</summary>
        <returns>Kolekcja deskryptorów właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przekazuje `null` dla obu `instance` parametru i `filter` parametru.  
  
 Właściwości `instance` parametru może się różnić od właściwości klasy, ponieważ kontenera można dodawać lub usuwać właściwości, jeśli `instance` parametru jest ulokowany.  
  
 `filter` Parametru można mieszać <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowana za pomocą następujących reguł:  
  
-   A <xref:System.Type> obiektu jest traktowana jako symbol wieloznaczny; odpowiada żadnej właściwości, która ma <xref:System.Type> w jego zestaw atrybutów.  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> do tej samej klasy właściwość nie będą uwzględniane w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnego dopasowania do uwzględnienia w zwróconej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> i jest właściwością domyślną, zostanie uwzględniona w tablicy zwrócone, nawet jeśli żadne wystąpienie elementu <xref:System.Attribute> we właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties (Attribute[] filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(class System.Attribute[] filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties (filter As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(cli::array &lt;Attribute ^&gt; ^ filter);" />
      <MemberSignature Language="F#" Value="member this.GetChildProperties : Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties filter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="filter">Tablica typu <see cref="T:System.Attribute" /> do użycia jako filtr.</param>
        <summary>Zwraca <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> przy użyciu określonej tablicy atrybutów jako filtr.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwościami, które jest zgodny z określonym atrybutem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przekazuje `null` dla `instance` parametru.  
  
 Właściwości `instance` parametru może się różnić od właściwości klasy, ponieważ lokacji można dodać lub usunąć właściwości, jeśli `instance` parametru jest ulokowany.  
  
 `filter` Parametru można mieszać <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowana za pomocą następujących reguł:  
  
-   A <xref:System.Type> obiektu jest traktowana jako symbol wieloznaczny; odpowiada żadnej właściwości, która ma <xref:System.Type> w jego zestaw atrybutów.  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> do tej samej klasy właściwość nie będą uwzględniane w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnego dopasowania do uwzględnienia w zwróconej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> wystąpienia, a jest właściwością domyślną, zostanie uwzględniona w zwróconej tablicy nawet jeśli żadne wystąpienie elementu <xref:System.Attribute> we właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties (instance As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="member this.GetChildProperties : obj -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Składnik można pobrać właściwości.</param>
        <summary>Zwraca <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> dla danego obiektu.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwości dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przekazuje `null` dla `filter` parametru.  
  
 Właściwości `instance` parametru może się różnić od właściwości klasy, ponieważ lokacji można dodać lub usunąć właściwości, jeśli `instance` parametru jest ulokowany.  
  
 `filter` Parametru można mieszać <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowana za pomocą następujących reguł:  
  
-   A <xref:System.Type> obiektu jest traktowana jako symbol wieloznaczny; odpowiada żadnej właściwości, która ma <xref:System.Type> w jego zestaw atrybutów.  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> do tej samej klasy właściwość nie będą uwzględniane w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnego dopasowania do uwzględnienia w zwróconej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> wystąpienia, a jest właściwością domyślną, zostanie uwzględniona w zwróconej tablicy nawet jeśli żadne wystąpienie elementu <xref:System.Attribute> we właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetChildProperties (object instance, Attribute[] filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(object instance, class System.Attribute[] filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChildProperties (instance As Object, filter As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(System::Object ^ instance, cli::array &lt;Attribute ^&gt; ^ filter);" />
      <MemberSignature Language="F#" Value="abstract member GetChildProperties : obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection&#xA;override this.GetChildProperties : obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties (instance, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="filter" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="instance">Składnik można pobrać właściwości.</param>
        <param name="filter">Tablica typu <see cref="T:System.Attribute" /> do użycia jako filtr.</param>
        <summary>Zwraca <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> dla danego obiektu przy użyciu określonej tablicy atrybutów jako filtr.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwościami, spełniających określone atrybuty dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości `instance` parametru może się różnić od właściwości klasy, ponieważ lokacji można dodać lub usunąć właściwości, jeśli `instance` parametru jest ulokowany.  
  
 `filter` Parametru można mieszać <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowana za pomocą następujących reguł:  
  
-   A <xref:System.Type> obiektu jest traktowana jako symbol wieloznaczny; odpowiada żadnej właściwości, która ma <xref:System.Type> w jego zestaw atrybutów.  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> do tej samej klasy właściwość nie będą uwzględniane w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnego dopasowania do uwzględnienia w zwróconej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> wystąpienia, a jest właściwością domyślną, zostanie uwzględniona w zwróconej tablicy nawet jeśli żadne wystąpienie elementu <xref:System.Attribute> we właściwości.  
  
 Ogólnie rzecz biorąc, implementując, w którym ma zostać zwrócony właściwości podrzędnej <xref:System.ComponentModel.TypeConverter.GetProperties%2A> członkiem <xref:System.ComponentModel.TypeConverter> zwracane z tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public virtual object GetEditor (Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetEditor(class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetEditor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEditor (editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetEditor(Type ^ editorBaseType);" />
      <MemberSignature Language="F#" Value="abstract member GetEditor : Type -&gt; obj&#xA;override this.GetEditor : Type -&gt; obj" Usage="propertyDescriptor.GetEditor editorBaseType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">Typ podstawowy edytor, który jest używany w celu rozróżnienia wielu edytory, które obsługuje właściwości.</param>
        <summary>Pobiera edytora określonego typu.</summary>
        <returns>Wystąpienie typu żądanego Edytor lub <see langword="null" /> Jeśli nie można odnaleźć edytora.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="propertyDescriptor.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego obiektu.</summary>
        <returns>Wartość skrótu dla tego obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvocationTarget">
      <MemberSignature Language="C#" Value="protected override object GetInvocationTarget (Type type, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object GetInvocationTarget(class System.Type type, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetInvocationTarget(System.Type,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ GetInvocationTarget(Type ^ type, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="override this.GetInvocationTarget : Type * obj -&gt; obj" Usage="propertyDescriptor.GetInvocationTarget (type, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Wywołania obiektu docelowego.</param>
        <param name="instance">Potencjalne obiekt docelowy wywołania.</param>
        <summary>Ta metoda zwraca obiekt, który ma zostać użyty podczas wywoływania elementów członkowskich.</summary>
        <returns>
          <see cref="T:System.Object" /> Która powinna być używana podczas wywoływania elementów członkowskich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj zwracana wartość jest taka sama jak `instance` przekazany. Jeśli obiekt innym ktoś skojarzony z tym wystąpieniem, czy wystąpienie jest deskryptora typu niestandardowego <xref:System.ComponentModel.PropertyDescriptor.GetInvocationTarget%2A> metoda może zwracać różne wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromName">
      <MemberSignature Language="C#" Value="protected Type GetTypeFromName (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Type GetTypeFromName(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetTypeFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTypeFromName (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type ^ GetTypeFromName(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.GetTypeFromName : string -&gt; Type" Usage="propertyDescriptor.GetTypeFromName typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa kwalifikowana zestawu typ do pobrania.</param>
        <summary>Zwraca typ za pomocą jego nazwy.</summary>
        <returns>A <see cref="T:System.Type" /> odpowiadającej nazwie danego typu lub <see langword="null" /> Jeśli nie można odnaleźć dopasowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby znaleźć odpowiedniego typu, ta metoda sprawdza najpierw zestawu typu tego <xref:System.ComponentModel.PropertyDescriptor> odwołania. Jeśli nie znajdzie typ w zestawie, wywołuje metodę <xref:System.Type.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public abstract object GetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValue (component As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ GetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member GetValue : obj -&gt; obj" Usage="propertyDescriptor.GetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik razem z właściwością, dla którego można pobrać wartość.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera bieżącą wartość właściwości składnika.</summary>
        <returns>Wartość właściwości dla danego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta metoda jest implementowane za pośrednictwem odbicia.  
  
 Ta metoda automatycznie wywołuje metodę zmiany przed <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A>i po zmienić metodę, <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A>, z <xref:System.ComponentModel.Design.IComponentChangeService>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Aby zastąpić tę metodę, pobiera bieżącą wartość właściwości przez wywołanie metody "GetMyProperty", który należy wdrożyć. Wystąpił wyjątek w tej metodzie powinien przechodzić.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetValueChangedHandler">
      <MemberSignature Language="C#" Value="protected internal EventHandler GetValueChangedHandler (object component);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.EventHandler GetValueChangedHandler(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetValueChangedHandler(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetValueChangedHandler (component As Object) As EventHandler" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; EventHandler ^ GetValueChangedHandler(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="member this.GetValueChangedHandler : obj -&gt; EventHandler" Usage="propertyDescriptor.GetValueChangedHandler component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, dla którego można pobrać procedury obsługi zdarzeń.</param>
        <summary>Pobiera bieżący zestaw <c>ValueChanged</c> programy obsługi zdarzeń dla określonego składnika</summary>
        <returns>A łączyć program obsługi zdarzeń multiemisji, lub <see langword="null" /> Jeśli nie obsługi zdarzeń nie ma obecnie przypisanych do <paramref name="component" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalizable">
      <MemberSignature Language="C#" Value="public virtual bool IsLocalizable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocalizable" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.IsLocalizable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsLocalizable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsLocalizable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocalizable : bool" Usage="System.ComponentModel.PropertyDescriptor.IsLocalizable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ta właściwość powinna być lokalizowany, jak określono w <see cref="T:System.ComponentModel.LocalizableAttribute" />.</summary>
        <value>
          <see langword="true" /> Jeśli element członkowski jest oznaczony atrybutem <see cref="T:System.ComponentModel.LocalizableAttribute" /> ustawioną <see langword="true" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość jest oznaczona atrybutem <xref:System.ComponentModel.LocalizableAttribute> ustawioną `true` i używane w wizualnego projektanta, jego wartości są zapisywane w pliku zasobów. Pliki zasobów nie są używane, jeśli oznaczyć właściwości z atrybutem, a następnie ustaw właściwości w kodzie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.LocalizableAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public abstract bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.ComponentModel.PropertyDescriptor.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy ta właściwość jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość jest tylko do odczytu. w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ReadOnlyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="OnValueChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnValueChanged (object component, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValueChanged(object component, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.OnValueChanged(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValueChanged (component As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValueChanged(System::Object ^ component, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValueChanged : obj * EventArgs -&gt; unit&#xA;override this.OnValueChanged : obj * EventArgs -&gt; unit" Usage="propertyDescriptor.OnValueChanged (component, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="component">Obiekt, który wywołuje zdarzenie.</param>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <c>ValueChanged</c> zdarzeń, który zostanie wdrożony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę należy wywoływać w implementacji deskryptora właściwości, gdy zmieniono wartość właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public abstract Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.ComponentModel.PropertyDescriptor.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera typ właściwości.</summary>
        <value>A <see cref="T:System.Type" /> reprezentujący typ właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta właściwość jest implementowany przez odbicie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveValueChanged">
      <MemberSignature Language="C#" Value="public virtual void RemoveValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.RemoveValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveValueChanged : obj * EventHandler -&gt; unit&#xA;override this.RemoveValueChanged : obj * EventHandler -&gt; unit" Usage="propertyDescriptor.RemoveValueChanged (component, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">Składnik do usunięcia programu obsługi.</param>
        <param name="handler">Delegat, aby usunąć jako odbiornik.</param>
        <summary>Umożliwia inne obiekty, aby otrzymać powiadomienie, gdy ta właściwość ulegnie zmianie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> lub <paramref name="handler" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetValue">
      <MemberSignature Language="C#" Value="public abstract void ResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResetValue (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member ResetValue : obj -&gt; unit" Usage="propertyDescriptor.ResetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik z wartością właściwości, która ma być zresetowane do wartości domyślnej.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej resetuje wartości dla tej właściwości składnika do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta metoda jest implementowane za pośrednictwem odbicia.  
  
 Ta metoda określa wartość, aby zresetować właściwość w następującej kolejności:  
  
1.  Brak przesłanianej właściwości dla tej właściwości.  
  
2.  Brak <xref:System.ComponentModel.DefaultValueAttribute> dla tej właściwości.  
  
3.  Brak metody "ResetMyProperty", która jest zaimplementowana, gdzie "MyProperty" jest nazwą właściwości, które przekazujesz do niego.  
  
 Ta metoda tworzy <xref:System.ComponentModel.Design.DesignerTransaction> automatycznie w następującej kolejności:  
  
1.  Wywołania metody <xref:System.ComponentModel.Design.IDesignerHost.CreateTransaction%2A?displayProperty=nameWithType> metody, aby utworzyć nową <xref:System.ComponentModel.Design.DesignerTransaction> do reprezentowania zmiany.  
  
2.  Wywołania metody <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A?displayProperty=nameWithType> metody, aby wskazać, że transakcja została rozpoczęta, a zmiany nastąpić.  
  
3.  Metoda resetuje właściwości do wartości ustalonej według kolejności sprawdzanie, czy ta metoda.  
  
4.  Wywołania metody <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A?displayProperty=nameWithType> metody, aby wskazać, czy wystąpiły zmiany.  
  
5.  Wywołania metody <xref:System.ComponentModel.Design.DesignerTransaction.Commit%2A?displayProperty=nameWithType> aby wskazać, że transakcja jest ukończona.  
  
 Transakcja ma na celu obsługuje `Undo` i `Redo` funkcji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłonięcia w klasie pochodnej, ta metoda sprawdza <see cref="T:System.ComponentModel.DefaultValueAttribute" />. Jeśli zostanie znaleziony, ustawia wartości właściwości do <see cref="T:System.ComponentModel.DefaultValueAttribute" /> go odnaleźć. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, wygląda na to dla metody "ResetMyProperty", która należy do implementacji. Jeśli to zostanie znaleziony, <see cref="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" /> metoda wywołuje go. Jeśli <see cref="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" /> nie można odnaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" /> lub metody "ResetMyProperty", który zostanie wdrożony, nie wykonuje operację.</para>
        </block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.ComponentModel.PropertyDescriptor.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ta właściwość powinny być serializowane, jak określono w <see cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute" />.</summary>
        <value>Jeden z <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> wartości wyliczenia, które określa, czy ta właściwość powinny być serializowane.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute" />
        <altmember cref="T:System.ComponentModel.DesignerSerializationVisibility" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public abstract void SetValue (object component, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object component, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetValue (component As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetValue(System::Object ^ component, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj -&gt; unit" Usage="propertyDescriptor.SetValue (component, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, należy ustawić wartość właściwości.</param>
        <param name="value">Nowa wartość.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia wartość składnika innej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta metoda jest implementowane za pośrednictwem odbicia.  
  
 Ta metoda tworzy <xref:System.ComponentModel.Design.DesignerTransaction> automatycznie w następującej kolejności:  
  
1.  Wywołania metody <xref:System.ComponentModel.Design.IDesignerHost.CreateTransaction%2A?displayProperty=nameWithType> metody, aby utworzyć nową <xref:System.ComponentModel.Design.DesignerTransaction> do reprezentowania zmiany.  
  
2.  Wywołania metody <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A?displayProperty=nameWithType> metody, aby wskazać, że transakcja została rozpoczęta, a zmiany nastąpić.  
  
3.  Metoda resetuje właściwości do wartości ustalonej według kolejności sprawdzanie, czy ta metoda.  
  
4.  Wywołania metody <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A?displayProperty=nameWithType> metody, aby wskazać, czy wystąpiły zmiany.  
  
5.  Wywołania metody <xref:System.ComponentModel.Design.DesignerTransaction.Commit%2A?displayProperty=nameWithType> aby wskazać, że transakcja została zakończona.  
  
 Transakcja ma na celu obsługuje `Undo` i `Redo` funkcji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Aby zastąpić tę metodę, ustala wartość właściwości za pomocą odpowiedniej metody "SetMyProperty", który należy wdrożyć. Jeśli określona wartość nie jest prawidłowy, składnik powinien zgłosić wyjątek, który jest przekazywany w górę. Właściwość należy zaprojektować tak, aby metody "GetMyProperty", (tj. zostało zaimplementowane) zgodnie z metodą "SetMyProperty" zwraca wartość przekazano, gdy metoda "SetMyProperty" zgłosiła wyjątek.</para>
        </block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeValue">
      <MemberSignature Language="C#" Value="public abstract bool ShouldSerializeValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldSerializeValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ShouldSerializeValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ShouldSerializeValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeValue : obj -&gt; bool" Usage="propertyDescriptor.ShouldSerializeValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik razem z właściwością badane trwałości.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, określa wartość wskazującą, czy wartość tej właściwości musi być utrwalona.</summary>
        <returns>
          <see langword="true" /> Jeśli właściwość powinna zostać utrwalony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta metoda jest implementowane za pośrednictwem odbicia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłonięcia w klasie pochodnej, ta metoda zwraca <see langword="true" /> Jeśli bieżąca wartość właściwości jest inna niż wartość domyślną. Przy pierwszym wyszukiwanie szuka wartość domyślną <see cref="T:System.ComponentModel.DefaultValueAttribute" />. Jeśli metoda znajdzie się ten atrybut, porównuje wartości atrybutu z bieżącej wartości właściwości. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, wygląda na to dla metody "ShouldSerializeMyProperty", która należy do implementacji. Jeśli okaże się <see cref="M:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue(System.Object)" /> wywołuje go. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" /> lub metodzie "ShouldSerializeMyProperty", nie można utworzyć optymalizacji i zwraca <see langword="true" />. <block subset="none" type="note"><para><see cref="T:System.ComponentModel.Design.ComponentDesigner" /> Klasa implementuje logiki specjalne serializacji dla składników odziedziczonych. Aby uzyskać więcej informacji, zobacz <see cref="T:System.ComponentModel.Design.ComponentDesigner" />. </para></block></para>
        </block>
        <altmember cref="T:System.ComponentModel.Design.ComponentDesigner" />
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeEvents">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeEvents" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.SupportsChangeEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsChangeEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeEvents { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsChangeEvents : bool" Usage="System.ComponentModel.PropertyDescriptor.SupportsChangeEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy powiadomienia o zmianie wartości dla tej właściwości mogą pochodzić od poza deskryptora właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli powiadomienia o zmianie wartości mogą pochodzić od poza deskryptora właściwości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.PropertyDescriptor.SupportsChangeEvents%2A> Właściwość wskazuje, czy powiadomienia o zmianie wartości dla tej właściwości mogą pochodzić od poza deskryptora właściwości, takie jak ze składnika, lub czy powiadomienia będą pochodzić wyłącznie od bezpośrednie wywołania <xref:System.ComponentModel.PropertyDescriptor.SetValue%2A> metody. Na przykład mogą wdrożyć składnik <xref:System.ComponentModel.INotifyPropertyChanged> interfejsu lub mogą mieć jawnego `name.Changed` zdarzeń dla tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
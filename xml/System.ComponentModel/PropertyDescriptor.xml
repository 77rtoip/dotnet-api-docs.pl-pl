<Type Name="PropertyDescriptor" FullName="System.ComponentModel.PropertyDescriptor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d00acbfd49445fa699b63c696618abb01a27afcc" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39842699" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PropertyDescriptor : System.ComponentModel.MemberDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PropertyDescriptor extends System.ComponentModel.MemberDescriptor" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.PropertyDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PropertyDescriptor&#xA;Inherits MemberDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyDescriptor abstract : System::ComponentModel::MemberDescriptor" />
  <TypeSignature Language="F#" Value="type PropertyDescriptor = class&#xA;    inherit MemberDescriptor" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MemberDescriptor</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia abstrakcję właściwości w klasie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opis właściwości składa się z nazwy, jego atrybuty, klasa składnika, która właściwość jest skojarzona z i typ właściwości.  
  
 <xref:System.ComponentModel.PropertyDescriptor> udostępnia następujące metody i właściwości:  
  
-   <xref:System.ComponentModel.PropertyDescriptor.Converter%2A> zawiera <xref:System.ComponentModel.TypeConverter> dla tej właściwości.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.IsLocalizable%2A> Wskazuje, czy ta właściwość powinien być zlokalizowany.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.GetEditor%2A> Zwraca edytora określonego typu.  
  
 <xref:System.ComponentModel.PropertyDescriptor> udostępnia również następujące `abstract` właściwości i metod:  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ComponentType%2A> zawiera typ składnika, który ta właściwość jest powiązana.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.IsReadOnly%2A> Wskazuje, czy ta właściwość jest tylko do odczytu.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.PropertyType%2A> Pobiera typ właściwości.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.CanResetValue%2A> Wskazuje, czy zresetowanie składnika zmienia wartość składnika.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.GetValue%2A> Zwraca bieżącą wartość właściwości składnika.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ResetValue%2A> Resetuje wartość właściwości tego składnika.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.SetValue%2A> Ustawia wartość składnika na inną wartość.  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue%2A> Wskazuje, czy wartość tej właściwości musi być utrwalone.  
  
 Zazwyczaj `abstract` elementy członkowskie są implementowane za pośrednictwem odbicia. Aby uzyskać więcej informacji dotyczących odbicia, zobacz Tematy w [odbicia](~/docs/framework/reflection-and-codedom/reflection.md).  
  
   
  
## Examples  
 Poniższy przykład kodu jest oparty na przykład w <xref:System.ComponentModel.PropertyDescriptorCollection> klasy. Wyświetla informacje (kategoria, opis, nazwę wyświetlaną) tekst przycisku w polu tekstowym. Założono, że `button1` i `textbox1` zostały utworzone w formularzu.  
  
 [!code-cpp[PropertyDescriptor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyDescriptor/CPP/propertydescriptor.cpp#1)]
 [!code-csharp[PropertyDescriptor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyDescriptor/CS/propertydescriptor.cs#1)]
 [!code-vb[PropertyDescriptor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyDescriptor/VB/propertydescriptor.vb#1)]  
  
 Poniższy przykład kodu pokazuje sposób implementacji deskryptora właściwości niestandardowej, która zawiera tylko do odczytu otokę właściwości. `SerializeReadOnlyPropertyDescriptor` Są używane w Projektancie niestandardowych w celu świadczenia deskryptora właściwości tylko do odczytu dla formantu <xref:System.Windows.Forms.Control.Size%2A> właściwości.  
  
 [!code-csharp[System.ComponentModel.PropertyDescriptor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/SerializeReadOnlyPropertyDescriptor.cs#1)]
 [!code-vb[System.ComponentModel.PropertyDescriptor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/SerializeReadOnlyPropertyDescriptor.vb#1)]  
  
 W poniższych przykładach kodu pokazano sposób użycia `SerializeReadOnlyPropertyDescriptor` w Projektancie niestandardowych.  
  
 [!code-csharp[System.ComponentModel.PropertyDescriptor#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/DemoControlDesigner.cs#10)]
 [!code-vb[System.ComponentModel.PropertyDescriptor#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/DemoControlDesigner.vb#10)]  
[!code-csharp[System.ComponentModel.PropertyDescriptor#100](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/DemoControl.cs#100)]
[!code-vb[System.ComponentModel.PropertyDescriptor#100](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/DemoControl.vb#100)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.MemberDescriptor" />
    <altmember cref="T:System.Attribute" />
    <altmember cref="T:System.ComponentModel.DefaultValueAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (System.ComponentModel.MemberDescriptor descr);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.MemberDescriptor descr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.ComponentModel.MemberDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (descr As MemberDescriptor)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::ComponentModel::MemberDescriptor ^ descr);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.PropertyDescriptor : System.ComponentModel.MemberDescriptor -&gt; System.ComponentModel.PropertyDescriptor" Usage="new System.ComponentModel.PropertyDescriptor descr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="descr" Type="System.ComponentModel.MemberDescriptor" />
      </Parameters>
      <Docs>
        <param name="descr">Element <see cref="T:System.ComponentModel.MemberDescriptor" /> zawierający nazwę właściwości i jego atrybuty.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy o nazwie i atrybuty w określonym <see cref="T:System.ComponentModel.MemberDescriptor" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.MemberDescriptor" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (System.ComponentModel.MemberDescriptor descr, Attribute[] attrs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.MemberDescriptor descr, class System.Attribute[] attrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.ComponentModel.MemberDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (descr As MemberDescriptor, attrs As Attribute())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::ComponentModel::MemberDescriptor ^ descr, cli::array &lt;Attribute ^&gt; ^ attrs);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.PropertyDescriptor : System.ComponentModel.MemberDescriptor * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="new System.ComponentModel.PropertyDescriptor (descr, attrs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="descr" Type="System.ComponentModel.MemberDescriptor" />
        <Parameter Name="attrs" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="descr">A <see cref="T:System.ComponentModel.MemberDescriptor" /> zawierającą nazwę elementu członkowskiego i jego atrybuty.</param>
        <param name="attrs">
          <see cref="T:System.Attribute" /> Tablica zawiera atrybuty, którą chcesz skojarzyć z właściwością.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy o nazwie w określonym <see cref="T:System.ComponentModel.MemberDescriptor" /> i atrybuty w obu <see cref="T:System.ComponentModel.MemberDescriptor" /> i <see cref="T:System.Attribute" /> tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor dołącza atrybuty w <xref:System.Attribute> tablicy do atrybutów w <xref:System.ComponentModel.MemberDescriptor>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.MemberDescriptor" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (string name, Attribute[] attrs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class System.Attribute[] attrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.String,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, attrs As Attribute())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::String ^ name, cli::array &lt;Attribute ^&gt; ^ attrs);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.PropertyDescriptor : string * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="new System.ComponentModel.PropertyDescriptor (name, attrs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attrs" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości.</param>
        <param name="attrs">Tablica typu <see cref="T:System.Attribute" /> zawierający atrybuty właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.PropertyDescriptor" /> klasy z określoną nazwą oraz atrybutami.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="AddValueChanged">
      <MemberSignature Language="C#" Value="public virtual void AddValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.AddValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddValueChanged : obj * EventHandler -&gt; unit&#xA;override this.AddValueChanged : obj * EventHandler -&gt; unit" Usage="propertyDescriptor.AddValueChanged (component, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">Składnik do dodawania programu obsługi.</param>
        <param name="handler">Delegat do dodania jako odbiornik.</param>
        <summary>Umożliwia inne obiekty, aby otrzymywać powiadomienia, gdy ta właściwość ulegnie zmianie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> lub <paramref name="handler" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResetValue">
      <MemberSignature Language="C#" Value="public abstract bool CanResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CanResetValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool CanResetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member CanResetValue : obj -&gt; bool" Usage="propertyDescriptor.CanResetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik do testowania funkcji resetowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zwraca, czy obiekt Resetowanie zmieniania jego wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli Resetowanie składnika zmieniania jego wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda jest implementowana przy użyciu odbicia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłonięcia w klasie pochodnej, Metoda ta wyszukuje <see cref="T:System.ComponentModel.DefaultValueAttribute" />. Jeśli zostanie znaleziony, porównuje wartość atrybutu z bieżącej wartości właściwości. Zwraca <see langword="true" /> gdy wartością domyślną jest niezgodna bieżąca wartość właściwości. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, szuka dla metody "ShouldPersistMyProperty", należy zaimplementować samodzielnie. Jeśli ten zostanie znaleziony, <see cref="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" /> zwraca, zwraca "ShouldPersistMyProperty". W przeciwnym razie wygląda dla metody "ResetMyProperty", należy zaimplementować samodzielnie. Jeśli ten zostanie znaleziony, <see cref="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" /> zwraca <see langword="true" />. Nie można znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, metodę "ShouldPersistMyProperty" lub "ResetMyProperty" metodę, a następnie ją zwraca <see langword="false" />.</para>
        </block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="ComponentType">
      <MemberSignature Language="C#" Value="public abstract Type ComponentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ComponentType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.ComponentType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ComponentType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ ComponentType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComponentType : Type" Usage="System.ComponentModel.PropertyDescriptor.ComponentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera typ składnika, który ta właściwość jest powiązana z.</summary>
        <value>A <see cref="T:System.Type" /> reprezentujący typ składnika, ta właściwość jest powiązana. Gdy <see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" /> lub <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" /> metody są wywoływane, określony obiekt może być wystąpieniem tego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta właściwość jest implementowany przy użyciu odbicia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Converter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.TypeConverter Converter" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.Converter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Converter As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::TypeConverter ^ Converter { System::ComponentModel::TypeConverter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Converter : System.ComponentModel.TypeConverter" Usage="System.ComponentModel.PropertyDescriptor.Converter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera konwerter typów dla tej właściwości.</summary>
        <value>A <see cref="T:System.ComponentModel.TypeConverter" /> służący do przekonwertowania <see cref="T:System.Type" /> tej właściwości.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : Type -&gt; obj" Usage="propertyDescriptor.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ do utworzenia.</param>
        <summary>Tworzy wystąpienie określonego typu.</summary>
        <returns>Nowe wystąpienie tego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.PropertyDescriptor.CreateInstance%2A> Wyszukuje konstruktora przyjmującego określonego typu. Jeśli znajdzie konstruktora, typ właściwości jest przekazywany w.  
  
 Konwerterów i edytory ta metoda umożliwia tworzenie wersji składnika. Ta metoda umożliwia pojedynczego składnika ponowne użycie dla więcej niż jednego typu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do prywatnych składowych i metadanych. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
        <altmember cref="T:System.Drawing.Design.UITypeEditor" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="propertyDescriptor.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym <see cref="T:System.ComponentModel.PropertyDescriptor" />.</param>
        <summary>Porównuje to innym obiektem, aby sprawdzić, czy są równoważne.</summary>
        <returns>
          <see langword="true" /> Jeśli wartości są równoważne; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillAttributes">
      <MemberSignature Language="C#" Value="protected override void FillAttributes (System.Collections.IList attributeList);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FillAttributes(class System.Collections.IList attributeList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.FillAttributes(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub FillAttributes (attributeList As IList)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void FillAttributes(System::Collections::IList ^ attributeList);" />
      <MemberSignature Language="F#" Value="override this.FillAttributes : System.Collections.IList -&gt; unit" Usage="propertyDescriptor.FillAttributes attributeList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeList" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="attributeList">
          <see cref="T:System.Collections.IList" /> , Wyświetla listę atrybutów w klasie nadrzędnej. Początkowo jest pusty.</param>
        <summary>Dodaje atrybuty <see cref="T:System.ComponentModel.PropertyDescriptor" /> określoną listę atrybutów w klasie nadrzędnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku zduplikowanych atrybutów ostatni z nich ma na liście zostaną zachowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildProperties">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties () As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties();" />
      <MemberSignature Language="F#" Value="member this.GetChildProperties : unit -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca domyślny <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />.</summary>
        <returns>Kolekcja deskryptorów właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przekazuje `null` dla obu `instance` parametru i `filter` parametru.  
  
 Właściwości `instance` parametru może się różnić od właściwości klasy, ponieważ kontenera można dodawać lub usuwać właściwości, jeśli `instance` parametru jest ulokowany.  
  
 `filter` Mieszać parametr <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowany przez następujące reguły:  
  
-   A <xref:System.Type> obiektu jest traktowana jako symbol wieloznaczny; dopasowuje dowolną właściwość, która ma <xref:System.Type> w jej zestaw atrybutów.  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> tej samej klasy właściwość nie zostanie uwzględniony w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnie dopasowany do uwzględnienia w zwróconej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> i jest właściwością domyślną, zostanie uwzględniony w zwróconej tablicy, nawet jeśli żadne wystąpienie elementu <xref:System.Attribute> we właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties (Attribute[] filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(class System.Attribute[] filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties (filter As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(cli::array &lt;Attribute ^&gt; ^ filter);" />
      <MemberSignature Language="F#" Value="member this.GetChildProperties : Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties filter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="filter">Tablica typu <see cref="T:System.Attribute" /> do użycia jako filtr.</param>
        <summary>Zwraca <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> przy użyciu określonej tablicy atrybutów jako filtr.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwościami, które pasują do określonych atrybutów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przekazuje `null` dla `instance` parametru.  
  
 Właściwości `instance` parametru może się różnić od właściwości klasy, ponieważ lokacji można dodać lub usunąć właściwości, jeśli `instance` parametru jest ulokowany.  
  
 `filter` Mieszać parametr <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowany przez następujące reguły:  
  
-   A <xref:System.Type> obiektu jest traktowana jako symbol wieloznaczny; dopasowuje dowolną właściwość, która ma <xref:System.Type> w jej zestaw atrybutów.  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> tej samej klasy właściwość nie zostanie uwzględniony w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnie dopasowany do uwzględnienia w zwróconej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> wystąpienia i jest domyślną właściwością, zostanie uwzględniony w zwróconej tablicy nawet jeśli żadne wystąpienie elementu <xref:System.Attribute> we właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties (instance As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="member this.GetChildProperties : obj -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Składnik można pobrać właściwości.</param>
        <summary>Zwraca <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> dla danego obiektu.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwościami dla określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przekazuje `null` dla `filter` parametru.  
  
 Właściwości `instance` parametru może się różnić od właściwości klasy, ponieważ lokacji można dodać lub usunąć właściwości, jeśli `instance` parametru jest ulokowany.  
  
 `filter` Mieszać parametr <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowany przez następujące reguły:  
  
-   A <xref:System.Type> obiektu jest traktowana jako symbol wieloznaczny; dopasowuje dowolną właściwość, która ma <xref:System.Type> w jej zestaw atrybutów.  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> tej samej klasy właściwość nie zostanie uwzględniony w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnie dopasowany do uwzględnienia w zwróconej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> wystąpienia i jest domyślną właściwością, zostanie uwzględniony w zwróconej tablicy nawet jeśli żadne wystąpienie elementu <xref:System.Attribute> we właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetChildProperties (object instance, Attribute[] filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(object instance, class System.Attribute[] filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChildProperties (instance As Object, filter As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(System::Object ^ instance, cli::array &lt;Attribute ^&gt; ^ filter);" />
      <MemberSignature Language="F#" Value="abstract member GetChildProperties : obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection&#xA;override this.GetChildProperties : obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="propertyDescriptor.GetChildProperties (instance, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="filter" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="instance">Składnik można pobrać właściwości.</param>
        <param name="filter">Tablica typu <see cref="T:System.Attribute" /> do użycia jako filtr.</param>
        <summary>Zwraca <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> dla danego obiektu przy użyciu określonej tablicy atrybutów jako filtr.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> z właściwościami, spełniających określone atrybuty określonego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości `instance` parametru może się różnić od właściwości klasy, ponieważ lokacji można dodać lub usunąć właściwości, jeśli `instance` parametru jest ulokowany.  
  
 `filter` Mieszać parametr <xref:System.Type> i <xref:System.Attribute> obiektów. Filtrowanie jest definiowany przez następujące reguły:  
  
-   A <xref:System.Type> obiektu jest traktowana jako symbol wieloznaczny; dopasowuje dowolną właściwość, która ma <xref:System.Type> w jej zestaw atrybutów.  
  
-   Jeśli nie ma właściwości <xref:System.Attribute> tej samej klasy właściwość nie zostanie uwzględniony w zwróconej tablicy.  
  
-   Jeśli ten atrybut jest wystąpieniem <xref:System.Attribute>, właściwość musi być dokładnie dopasowany do uwzględnienia w zwróconej tablicy.  
  
-   Jeśli określisz <xref:System.Attribute> wystąpienia i jest domyślną właściwością, zostanie uwzględniony w zwróconej tablicy nawet jeśli żadne wystąpienie elementu <xref:System.Attribute> we właściwości.  
  
 Ogólnie rzecz biorąc, implementując, w którym ma zostać zwrócone właściwości podrzędnej <xref:System.ComponentModel.TypeConverter.GetProperties%2A> członkiem <xref:System.ComponentModel.TypeConverter> zwrócone w wyniku tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public virtual object GetEditor (Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetEditor(class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetEditor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEditor (editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetEditor(Type ^ editorBaseType);" />
      <MemberSignature Language="F#" Value="abstract member GetEditor : Type -&gt; obj&#xA;override this.GetEditor : Type -&gt; obj" Usage="propertyDescriptor.GetEditor editorBaseType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">Typ podstawowy edytor, który służy do rozróżnienia między wiele edytorów, które obsługuje właściwości.</param>
        <summary>Pobiera edytora określonego typu.</summary>
        <returns>Wystąpienie edytora żądanego typu, lub <see langword="null" /> Jeśli nie można znaleźć edytora.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="propertyDescriptor.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego obiektu.</summary>
        <returns>Wartość skrótu dla tego obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvocationTarget">
      <MemberSignature Language="C#" Value="protected override object GetInvocationTarget (Type type, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object GetInvocationTarget(class System.Type type, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetInvocationTarget(System.Type,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ GetInvocationTarget(Type ^ type, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="override this.GetInvocationTarget : Type * obj -&gt; obj" Usage="propertyDescriptor.GetInvocationTarget (type, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Wywołania elementu docelowego.</param>
        <param name="instance">Potencjalny element docelowy wywołania.</param>
        <summary>Ta metoda zwraca obiekt, który ma zostać użyty podczas wywoływania członków.</summary>
        <returns>
          <see cref="T:System.Object" /> Które mają być używane podczas wywoływania członków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj wartość zwracana jest taka sama jak `instance` przekazany. Jeśli ktoś skojarzony z tym wystąpieniem innego obiektu lub jeśli wystąpienie jest deskryptora typu niestandardowego <xref:System.ComponentModel.PropertyDescriptor.GetInvocationTarget%2A> metoda może zwracać różne wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromName">
      <MemberSignature Language="C#" Value="protected Type GetTypeFromName (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Type GetTypeFromName(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetTypeFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTypeFromName (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type ^ GetTypeFromName(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.GetTypeFromName : string -&gt; Type" Usage="propertyDescriptor.GetTypeFromName typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa kwalifikowanego dla zestawu typu do pobrania.</param>
        <summary>Zwraca typ przy użyciu jego nazwy.</summary>
        <returns>A <see cref="T:System.Type" /> który pasuje do nazwy typu lub <see langword="null" /> Jeśli nie zostanie znalezione dopasowanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby znaleźć odpowiedni typ, Metoda ta najpierw sprawdza zestawem typu że <xref:System.ComponentModel.PropertyDescriptor> odwołania. Jeśli nie znajdzie typ w zestawie, wywołuje metodę <xref:System.Type.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public abstract object GetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValue (component As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ GetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member GetValue : obj -&gt; obj" Usage="propertyDescriptor.GetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik z właściwością, dla którego można pobrać wartości.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, pobiera bieżącą wartość właściwości składnika.</summary>
        <returns>Wartość właściwości dla danego składnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda jest implementowana przy użyciu odbicia.  
  
 Ta metoda automatycznie wywołuje metodę wstępnego zmiany, <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A>i używane po tej operacji Zmień metodę <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A>, z <xref:System.ComponentModel.Design.IComponentChangeService>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli zastąpisz tę metodę, pobiera bieżącą wartość właściwości przez wywołanie metody "GetMyProperty", który muszą implementować. Wyjątek w tej metodzie powinny przechodzić przez.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetValueChangedHandler">
      <MemberSignature Language="C#" Value="protected internal EventHandler GetValueChangedHandler (object component);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.EventHandler GetValueChangedHandler(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetValueChangedHandler(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetValueChangedHandler (component As Object) As EventHandler" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; EventHandler ^ GetValueChangedHandler(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="member this.GetValueChangedHandler : obj -&gt; EventHandler" Usage="propertyDescriptor.GetValueChangedHandler component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, dla którego można pobrać procedury obsługi zdarzeń.</param>
        <summary>Pobiera bieżący zestaw <c>ValueChanged</c> programy obsługi zdarzeń dla określonego składnika</summary>
        <returns>A połączone programu obsługi zdarzeń multiemisji lub <see langword="null" /> Jeśli nie programów obsługi zdarzeń są obecnie przypisane do <paramref name="component" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalizable">
      <MemberSignature Language="C#" Value="public virtual bool IsLocalizable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocalizable" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.IsLocalizable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsLocalizable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsLocalizable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocalizable : bool" Usage="System.ComponentModel.PropertyDescriptor.IsLocalizable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy powinien być zlokalizowany tej właściwości, jak określono w <see cref="T:System.ComponentModel.LocalizableAttribute" />.</summary>
        <value>
          <see langword="true" /> Jeśli element członkowski jest oznaczona atrybutem <see cref="T:System.ComponentModel.LocalizableAttribute" /> równa <see langword="true" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość jest oznaczona za pomocą <xref:System.ComponentModel.LocalizableAttribute> równa `true` i używane w projektanta wizualnego, jego wartości są zapisywane w pliku zasobów. Jeśli oznaczyć właściwości za pomocą atrybutu, a następnie ustaw właściwości w kodzie, pliki zasobów nie są używane.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.LocalizableAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public abstract bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.ComponentModel.PropertyDescriptor.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy ta właściwość jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli właściwość jest tylko do odczytu. w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ReadOnlyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="OnValueChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnValueChanged (object component, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValueChanged(object component, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.OnValueChanged(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValueChanged (component As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValueChanged(System::Object ^ component, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValueChanged : obj * EventArgs -&gt; unit&#xA;override this.OnValueChanged : obj * EventArgs -&gt; unit" Usage="propertyDescriptor.OnValueChanged (component, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="component">Obiekt, który wywołuje zdarzenie.</param>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <c>ValueChanged</c> zdarzeń, które można zaimplementować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę należy wywoływać w danej implementacji deskryptora właściwości, gdy zmieniono wartość właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public abstract Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.ComponentModel.PropertyDescriptor.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera typ właściwości.</summary>
        <value>A <see cref="T:System.Type" /> reprezentujący typ właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta właściwość jest implementowany przy użyciu odbicia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveValueChanged">
      <MemberSignature Language="C#" Value="public virtual void RemoveValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.RemoveValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveValueChanged : obj * EventHandler -&gt; unit&#xA;override this.RemoveValueChanged : obj * EventHandler -&gt; unit" Usage="propertyDescriptor.RemoveValueChanged (component, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">Składnik do usunięcia programu obsługi.</param>
        <param name="handler">Delegat do usunięcia jako odbiornik.</param>
        <summary>Umożliwia inne obiekty, aby otrzymywać powiadomienia, gdy ta właściwość ulegnie zmianie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> lub <paramref name="handler" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetValue">
      <MemberSignature Language="C#" Value="public abstract void ResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResetValue (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member ResetValue : obj -&gt; unit" Usage="propertyDescriptor.ResetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik z wartością właściwości, który ma zostać zresetowane do wartości domyślnej.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zresetuje wartość tej właściwości składnika, do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda jest implementowana przy użyciu odbicia.  
  
 Ta metoda określa wartość, aby zresetować właściwość w następującej kolejności:  
  
1.  Brak przesłanianej właściwości dla tej właściwości.  
  
2.  Brak <xref:System.ComponentModel.DefaultValueAttribute> dla tej właściwości.  
  
3.  Brak metody "ResetMyProperty", który zaimplementowano, gdzie "MyProperty" jest nazwą właściwości, które przekazujesz do niego.  
  
 Ta metoda tworzy <xref:System.ComponentModel.Design.DesignerTransaction> automatycznie w następującej kolejności:  
  
1.  Wywołań metod <xref:System.ComponentModel.Design.IDesignerHost.CreateTransaction%2A?displayProperty=nameWithType> metodę, aby utworzyć nową <xref:System.ComponentModel.Design.DesignerTransaction> do reprezentowania zmiany.  
  
2.  Wywołań metod <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A?displayProperty=nameWithType> metodę w celu wskazania, że transakcja została rozpoczęta, a zmiany nastąpić.  
  
3.  Metoda powoduje zresetowanie właściwości na wartość określana przez kolejność sprawdzanie, czy ta metoda.  
  
4.  Wywołań metod <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A?displayProperty=nameWithType> metodę w celu wskazania, czy wystąpiły zmiany.  
  
5.  Wywołań metod <xref:System.ComponentModel.Design.DesignerTransaction.Commit%2A?displayProperty=nameWithType> do wskazania, że transakcja jest zakończona.  
  
 Transakcja ma na celu obsługuje `Undo` i `Redo` funkcji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłonięcia w klasie pochodnej, Metoda ta wyszukuje <see cref="T:System.ComponentModel.DefaultValueAttribute" />. Jeśli zostanie znaleziony, ustawia wartość właściwości <see cref="T:System.ComponentModel.DefaultValueAttribute" /> go odnaleźć. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, szuka należy zaimplementować metodę "ResetMyProperty". Jeśli ten zostanie znaleziony, <see cref="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" /> metoda wywołuje on. Jeśli <see cref="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" /> nie można odnaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" /> lub metodzie "ResetMyProperty", którą można implementować nie wykonuje operację.</para>
        </block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.ComponentModel.PropertyDescriptor.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ta właściwość powinna być Zserializowany, jak określono w <see cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute" />.</summary>
        <value>Jedną z <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> wartości wyliczenia, które określa, czy ta właściwość powinna być serializowana.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute" />
        <altmember cref="T:System.ComponentModel.DesignerSerializationVisibility" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public abstract void SetValue (object component, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object component, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetValue (component As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetValue(System::Object ^ component, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj -&gt; unit" Usage="propertyDescriptor.SetValue (component, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, należy ustawić wartość właściwości.</param>
        <param name="value">Nowa wartość.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia wartość składnika na inną wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda jest implementowana przy użyciu odbicia.  
  
 Ta metoda tworzy <xref:System.ComponentModel.Design.DesignerTransaction> automatycznie w następującej kolejności:  
  
1.  Wywołań metod <xref:System.ComponentModel.Design.IDesignerHost.CreateTransaction%2A?displayProperty=nameWithType> metodę, aby utworzyć nową <xref:System.ComponentModel.Design.DesignerTransaction> do reprezentowania zmiany.  
  
2.  Wywołań metod <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A?displayProperty=nameWithType> metodę w celu wskazania, że transakcja została rozpoczęta, a zmiany nastąpić.  
  
3.  Metoda powoduje zresetowanie właściwości na wartość określana przez kolejność sprawdzanie, czy ta metoda.  
  
4.  Wywołań metod <xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A?displayProperty=nameWithType> metodę w celu wskazania, czy wystąpiły zmiany.  
  
5.  Wywołań metod <xref:System.ComponentModel.Design.DesignerTransaction.Commit%2A?displayProperty=nameWithType> do wskazania, że transakcja została zakończona.  
  
 Transakcja ma na celu obsługuje `Undo` i `Redo` funkcji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłonięcia tej metody go ustawić wartość właściwości, przez wywołanie odpowiedniej metody "SetMyProperty", który muszą implementować. Jeśli określona wartość nie jest prawidłowy, składnik powinien zgłosić wyjątek, który jest przekazywany w górę. Właściwość należy projektować tak, że metoda "GetMyProperty", (które udało Ci się wdrożyć) następującej metody "SetMyProperty" zwraca wartość przekazywana, gdy metoda "SetMyProperty" nie zgłasza wyjątku.</para>
        </block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeValue">
      <MemberSignature Language="C#" Value="public abstract bool ShouldSerializeValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldSerializeValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ShouldSerializeValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ShouldSerializeValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeValue : obj -&gt; bool" Usage="propertyDescriptor.ShouldSerializeValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Składnik właściwość do badania potrzeby stanu trwałego.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, określa wartość wskazującą, czy wartość tej właściwości musi być utrwalone.</summary>
        <returns>
          <see langword="true" /> Jeśli właściwość powinna być utrwalone; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda jest implementowana przy użyciu odbicia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłonięcia w klasie pochodnej, Metoda ta zwraca <see langword="true" /> Jeśli bieżąca wartość właściwości jest inny niż jego wartość domyślną. Szuka wartość domyślną, szukając pierwszy <see cref="T:System.ComponentModel.DefaultValueAttribute" />. Jeśli metoda znajdzie tego atrybutu, porównuje wartość atrybutu z bieżącej wartości właściwości. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" />, szuka należy zaimplementować metodę "ShouldSerializeMyProperty". Jeśli zostanie znaleziony, <see cref="M:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue(System.Object)" /> je wywołuje. Jeśli ta metoda nie może znaleźć <see cref="T:System.ComponentModel.DefaultValueAttribute" /> lub metodzie "ShouldSerializeMyProperty", nie może utworzyć optymalizacje i zwraca <see langword="true" />. <block subset="none" type="note"><para><see cref="T:System.ComponentModel.Design.ComponentDesigner" /> Klasa implementuje logikę specjalne serializacji dla składników odziedziczonych. Aby uzyskać więcej informacji, zobacz <see cref="T:System.ComponentModel.Design.ComponentDesigner" />. </para></block></para>
        </block>
        <altmember cref="T:System.ComponentModel.Design.ComponentDesigner" />
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeEvents">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeEvents" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.SupportsChangeEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsChangeEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeEvents { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsChangeEvents : bool" Usage="System.ComponentModel.PropertyDescriptor.SupportsChangeEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy powiadomienia o zmianie wartości dla tej właściwości mogą pochodzić od poza deskryptora właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli powiadomienia o zmianie wartości mogą pochodzić od poza deskryptora właściwości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.PropertyDescriptor.SupportsChangeEvents%2A> Właściwość wskazuje, czy powiadomienia o zmianie wartości dla tej właściwości mogą pochodzić od poza deskryptora właściwości, takie jak ze składnika, lub czy powiadomienia będą pochodzić wyłącznie od bezpośrednich wywołań do <xref:System.ComponentModel.PropertyDescriptor.SetValue%2A> metody. Na przykład mogą wdrożyć składnik <xref:System.ComponentModel.INotifyPropertyChanged> interfejsu, lub może mieć jawnego `name.Changed` zdarzenia dla tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
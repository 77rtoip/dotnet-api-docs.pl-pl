<Type Name="AttributeCollection" FullName="System.ComponentModel.AttributeCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f4a837518ca5fa8a3211243554bd4789613cb609" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69329104" /></Metadata><TypeSignature Language="C#" Value="public class AttributeCollection : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AttributeCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.AttributeCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class AttributeCollection&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class AttributeCollection : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type AttributeCollection = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kolekcję atrybutów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.AttributeCollection> Klasa jest tylko do odczytu; nie implementuje metod w celu dodawania lub usuwania atrybutów. Aby zaimplementować te metody, należy najpierw dziedziczyć z tej klasy.  
  
 <xref:System.ComponentModel.AttributeCollection.Count%2A> Użyj właściwości, aby znaleźć liczbę atrybutów istniejących w kolekcji.  
  
 Można również użyć metod tej klasy do wysyłania zapytań do kolekcji o jej zawartości. Wywołaj <xref:System.ComponentModel.AttributeCollection.Contains%2A> metodę, aby upewnić się, że określony atrybut lub tablica atrybutów istnieje w kolekcji. Wywołaj <xref:System.ComponentModel.AttributeCollection.Matches%2A> metodę, aby sprawdzić, czy określony atrybut lub tablica atrybutów istnieje w kolekcji i czy wartości określonych atrybutów są takie same jak wartości w kolekcji.  
  
 Chociaż większość atrybutów ma wartości domyślne, wartości domyślne nie są wymagane. Jeśli atrybut nie ma wartości domyślnej, `null` jest zwracana z właściwości indeksowanej, która przyjmuje typ. Podczas definiowania własnych atrybutów można zadeklarować wartość domyślną, dostarczając konstruktora, który nie przyjmuje argumentów ani nie definiuje publicznego pola statycznego typu atrybutu o nazwie "default".  
  
   
  
## Examples  
 Pierwszy przykład kodu sprawdza, czy <xref:System.ComponentModel.BrowsableAttribute> został ustawiony w tej kolekcji. Drugi przykład kodu pobiera rzeczywistą wartość <xref:System.ComponentModel.DescriptionAttribute> dla przycisku. Oba przykłady wymagają, `button1` aby `textBox1` i zostały utworzone w formularzu. W przypadku używania atrybutów Sprawdź, czy atrybut został ustawiony, lub uzyskaj dostęp do jego wartości.  
  
 [!code-cpp[Classic AttributeCollection Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection Example/CPP/source.cpp#1)]
 [!code-csharp[Classic AttributeCollection Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection Example/CS/source.cs#1)]
 [!code-vb[Classic AttributeCollection Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection Example/VB/source.vb#1)]  
  
 [!code-cpp[Classic AttributeCollection Example#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection Example/CPP/source.cpp#2)]
 [!code-csharp[Classic AttributeCollection Example#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection Example/CS/source.cs#2)]
 [!code-vb[Classic AttributeCollection Example#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection Example/VB/source.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Attribute" />
    <altmember cref="T:System.ComponentModel.BrowsableAttribute" />
    <altmember cref="T:System.ComponentModel.DescriptionAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.AttributeCollection" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AttributeCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AttributeCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.AttributeCollection" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AttributeCollection (params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.#ctor(System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ParamArray attributes As Attribute())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AttributeCollection(... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.AttributeCollection : Attribute[] -&gt; System.ComponentModel.AttributeCollection" Usage="new System.ComponentModel.AttributeCollection attributes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="attributes">Tablica typu <see cref="T:System.Attribute" /> , który zawiera atrybuty dla tej kolekcji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.AttributeCollection" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy nowy <xref:System.ComponentModel.AttributeCollection> przy użyciu atrybutów na. `button1` Przyjęto założenie, że `button1` został utworzony w formularzu.  
  
 [!code-cpp[Classic AttributeCollection.AttributeCollection Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection.AttributeCollection Example/CPP/source.cpp#1)]
 [!code-csharp[Classic AttributeCollection.AttributeCollection Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection.AttributeCollection Example/CS/source.cs#1)]
 [!code-vb[Classic AttributeCollection.AttributeCollection Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection.AttributeCollection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributes" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="protected virtual Attribute[] Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Attribute[] Attributes" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.AttributeCollection.Attributes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property Attributes As Attribute()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property cli::array &lt;Attribute ^&gt; ^ Attributes { cli::array &lt;Attribute ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : Attribute[]" Usage="System.ComponentModel.AttributeCollection.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Attribute[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję atrybutów.</summary>
        <value>Kolekcja atrybutów.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy ta kolekcja atrybutów ma określony atrybut lub tablicę atrybutów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (Attribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Attribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.Contains(System.Attribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(Attribute ^ attribute);" />
      <MemberSignature Language="F#" Value="member this.Contains : Attribute -&gt; bool" Usage="attributeCollection.Contains attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Attribute" />
      </Parameters>
      <Docs>
        <param name="attribute"><see cref="T:System.Attribute" /> Aby znaleźć w kolekcji.</param>
        <summary>Określa, czy ta kolekcja atrybutów ma określony atrybut.</summary>
        <returns><see langword="true" />Jeśli kolekcja zawiera atrybut lub jest atrybutem domyślnym typu atrybutu; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta kolekcja ma określony atrybut, jeśli określony typ atrybutu istnieje w kolekcji i jeśli wartość określonego atrybutu jest taka sama jak wartość wystąpienia atrybutu w kolekcji.  
  
 Różnica <xref:System.ComponentModel.AttributeCollection.Matches%2A> między <xref:System.ComponentModel.AttributeCollection.Matches%2A> <xref:System.ComponentModel.AttributeCollection.Contains%2A> <xref:System.ComponentModel.AttributeCollection.Contains%2A> metodami i polega na wywołania <xref:System.Object.Equals%2A> metody w atrybucie i wywołania metody. <xref:System.Attribute.Match%2A>  
  
 W przypadku większości atrybutów te metody są takie same. W przypadku atrybutów, które mogą mieć wiele flag, <xref:System.Attribute.Match%2A> jest to zwykle zaimplementowane, aby zwracały `true` , jeśli którykolwiek z flag jest spełniony. Rozważmy na przykład atrybut powiązania danych z flagami logicznymi "SupportsSql", "SupportsOleDb" i "SupportsXml". Ten atrybut może być obecny we właściwości, która obsługuje wszystkie trzy podejścia do powiązań danych. Często zdarza się, że programista musi wiedzieć tylko wtedy, gdy konkretne podejście jest dostępne, nie wszystkie trzy. W związku z tym programista <xref:System.Attribute.Match%2A> może użyć z wystąpieniem atrybutu zawierającego tylko flagi, których potrzebuje programista.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, czy kolekcja ma <xref:System.ComponentModel.BrowsableAttribute> `true`ustawioną wartość. Przyjęto założenie `textBox1` , że `button1` i zostały utworzone w formularzu.  
  
 [!code-cpp[Classic AttributeCollection.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic AttributeCollection.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic AttributeCollection.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.Contains(System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (attributes As Attribute()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="member this.Contains : Attribute[] -&gt; bool" Usage="attributeCollection.Contains attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="attributes">Tablica typu <see cref="T:System.Attribute" /> do znalezienia w kolekcji.</param>
        <summary>Określa, czy ta kolekcja atrybutów zawiera wszystkie określone atrybuty w tablicy atrybutów.</summary>
        <returns><see langword="true" />Jeśli kolekcja zawiera wszystkie atrybuty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta kolekcja ma określoną tablicę atrybutów, jeśli wszystkie określone typy atrybutów istnieją w kolekcji i jeśli każdy atrybut w określonej tablicy jest taki sam jak atrybut w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje atrybuty w `button1` i, `textBox1` aby sprawdzić, czy atrybuty przycisku są zawarte w atrybutach pola tekstowego. Przyjęto założenie `button1` , `textBox1` że oba i zostały utworzone w formularzu.  
  
 [!code-cpp[Classic AttributeCollection.Contains1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection.Contains1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic AttributeCollection.Contains1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection.Contains1 Example/CS/source.cs#1)]
 [!code-vb[Classic AttributeCollection.Contains1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection.Contains1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="attributeCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> Do kopiowania kolekcji.</param>
        <param name="index">Indeks do uruchomienia.</param>
        <summary>Kopiuje kolekcję do tablicy, rozpoczynając od określonego indeksu.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.AttributeCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.ComponentModel.AttributeCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę atrybutów.</summary>
        <value>Liczba atrybutów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.ComponentModel.AttributeCollection.Count%2A> właściwości, aby ustawić limity pętli, która iteruje przez kolekcję obiektów. Jeśli kolekcja jest oparta na wartości zero, pamiętaj, aby użyć `Count - 1` jako górnej granicy pętli.  
  
   
  
## Examples  
 Poniższy przykład kodu używa właściwości, <xref:System.ComponentModel.AttributeCollection.Count%2A> aby drukować liczbę `button1` właściwości w polu tekstowym. Przyjęto założenie `textBox1` , że `button1` i zostały utworzone w formularzu.  
  
 [!code-cpp[Classic AttributeCollection.Count Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection.Count Example/CPP/source.cpp#1)]
 [!code-csharp[Classic AttributeCollection.Count Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection.Count Example/CS/source.cs#1)]
 [!code-vb[Classic AttributeCollection.Count Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection.Count Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly System.ComponentModel.AttributeCollection Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.ComponentModel.AttributeCollection Empty" />
      <MemberSignature Language="DocId" Value="F:System.ComponentModel.AttributeCollection.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As AttributeCollection " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::ComponentModel::AttributeCollection ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.AttributeCollection.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa pustą kolekcję, której można użyć zamiast tworzenia nowej. To pole jest tylko do odczytu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromExisting">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection FromExisting (System.ComponentModel.AttributeCollection existing, params Attribute[] newAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection FromExisting(class System.ComponentModel.AttributeCollection existing, class System.Attribute[] newAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.FromExisting(System.ComponentModel.AttributeCollection,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromExisting (existing As AttributeCollection, ParamArray newAttributes As Attribute()) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ FromExisting(System::ComponentModel::AttributeCollection ^ existing, ... cli::array &lt;Attribute ^&gt; ^ newAttributes);" />
      <MemberSignature Language="F#" Value="static member FromExisting : System.ComponentModel.AttributeCollection * Attribute[] -&gt; System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.AttributeCollection.FromExisting (existing, newAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="existing" Type="System.ComponentModel.AttributeCollection" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newAttributes" Type="System.Attribute[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="existing">, <see cref="T:System.ComponentModel.AttributeCollection" /> Z którego ma zostać utworzona kopia.</param>
        <param name="newAttributes">Tablica typu <see cref="T:System.Attribute" /> , który zawiera atrybuty dla tej kolekcji. Może być <see langword="null" />.</param>
        <summary>Tworzy nowy <see cref="T:System.ComponentModel.AttributeCollection" /> na podstawie istniejącego <see cref="T:System.ComponentModel.AttributeCollection" />.</summary>
        <returns>Nowy <see cref="T:System.ComponentModel.AttributeCollection" /> , który jest kopią programu <paramref name="existing" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli parametr jest podany, jego <xref:System.Attribute> wpisy są `existing` scalane z parametrami. `newAttributes`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="existing" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultAttribute">
      <MemberSignature Language="C#" Value="protected Attribute GetDefaultAttribute (Type attributeType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Attribute GetDefaultAttribute(class System.Type attributeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.GetDefaultAttribute(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetDefaultAttribute (attributeType As Type) As Attribute" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Attribute ^ GetDefaultAttribute(Type ^ attributeType);" />
      <MemberSignature Language="F#" Value="member this.GetDefaultAttribute : Type -&gt; Attribute" Usage="attributeCollection.GetDefaultAttribute attributeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Attribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="attributeType"><see cref="T:System.Type" /> Atrybut do pobrania.</param>
        <summary>Zwraca wartość domyślną <see cref="T:System.Attribute" /> danego <see cref="T:System.Type" />elementu.</summary>
        <returns>Wartość domyślna <see cref="T:System.Attribute" /> danego <paramref name="attributeType" />elementu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="attributeCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera moduł wyliczający dla tej kolekcji.</summary>
        <returns>Moduł wyliczający typu <see cref="T:System.Collections.IEnumerator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu Pobiera moduł wyliczający dla atrybutów `button1`. Używa modułu wyliczającego do drukowania nazw atrybutów w kolekcji. Przyjęto założenie `textBox1` , że `button1` i zostały utworzone w formularzu.  
  
 [!code-cpp[Classic AttributeCollection.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection.GetEnumerator Example/CPP/Source.cpp#1)]
 [!code-csharp[Classic AttributeCollection.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection.GetEnumerator Example/CS/source.cs#1)]
 [!code-vb[Classic AttributeCollection.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection.GetEnumerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera atrybut o określonym indeksie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual Attribute this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Attribute Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.AttributeCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(index As Integer) As Attribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Attribute ^ default[int] { Attribute ^ get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : Attribute" Usage="System.ComponentModel.AttributeCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Attribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) <see cref="T:System.ComponentModel.AttributeCollection" />.</param>
        <summary>Pobiera atrybut o określonym numerze indeksu.</summary>
        <value><see cref="T:System.Attribute" /> O określonym numerze indeksu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numer indeksu jest liczony od zera. W związku z tym należy odjąć 1 od pozycji liczbowej konkretnej <xref:System.Attribute> do <xref:System.Attribute>uzyskania dostępu. Na przykład aby uzyskać trzeci <xref:System.Attribute>, należy określić. `myColl[2]`  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.ComponentModel.AttributeCollection.Item%2A> właściwości do drukowania nazwy <xref:System.Attribute> określonej przez numer indeksu w polu tekstowym. Ponieważ numer indeksu jest liczony od zera, ten przykład kodu drukuje nazwę drugiego <xref:System.Attribute> w polu tekstowym. Założono `button1` i `textBox1` zostały utworzone w formularzu.  
  
 [!code-cpp[Classic AttributeCollection.this Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection.this Example/CPP/source.cpp#1)]
 [!code-csharp[Classic AttributeCollection.this Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection.this Example/CS/source.cs#1)]
 [!code-vb[Classic AttributeCollection.this Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection.this Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual Attribute this[Type attributeType] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Attribute Item(class System.Type)" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.AttributeCollection.Item(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(attributeType As Type) As Attribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Attribute ^ default[Type ^] { Attribute ^ get(Type ^ attributeType); };" />
      <MemberSignature Language="F#" Value="member this.Item(Type) : Attribute" Usage="System.ComponentModel.AttributeCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Attribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="attributeType"><see cref="T:System.Type" /> Elementu<see cref="T:System.Attribute" /> do pobrania z kolekcji.</param>
        <summary>Pobiera atrybut o określonym typie.</summary>
        <value><see cref="T:System.Attribute" /> Z określonym typem lub, jeśli atrybut nie istnieje, wartość domyślna dla typu atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli atrybut nie istnieje w kolekcji, ta właściwość zwraca wartość domyślną dla typu atrybutu.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera <xref:System.ComponentModel.DesignerAttribute> z kolekcji i drukuje jej wartość. Przyjęto założenie `textBox1` , że `button1` i zostały utworzone w formularzu.  
  
 Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje na temat uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[Classic AttributeCollection.this1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection.this1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic AttributeCollection.this1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection.this1 Example/CS/source.cs#1)]
 [!code-vb[Classic AttributeCollection.this1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection.this1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy określony atrybut lub tablica atrybutów jest taka sama jak atrybut lub tablica atrybutów w kolekcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public bool Matches (Attribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Matches(class System.Attribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.Matches(System.Attribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Matches(Attribute ^ attribute);" />
      <MemberSignature Language="F#" Value="member this.Matches : Attribute -&gt; bool" Usage="attributeCollection.Matches attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Attribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Wystąpienie <see cref="T:System.Attribute" /> do porównania z atrybutami w tej kolekcji.</param>
        <summary>Określa, czy określony atrybut jest taki sam jak atrybut w kolekcji.</summary>
        <returns><see langword="true" />Jeśli atrybut jest zawarty w kolekcji i ma taką samą wartość jak atrybut w kolekcji; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybut może zapewnić obsługę dopasowywania.  
  
 Różnica <xref:System.ComponentModel.AttributeCollection.Matches%2A> między <xref:System.ComponentModel.AttributeCollection.Matches%2A> <xref:System.ComponentModel.AttributeCollection.Contains%2A> <xref:System.ComponentModel.AttributeCollection.Contains%2A> metodami i polega na wywołania <xref:System.Object.Equals%2A> metody w atrybucie i wywołania metody. <xref:System.Attribute.Match%2A>  
  
 W przypadku większości atrybutów te metody są takie same. W przypadku atrybutów, które mogą mieć wiele flag, <xref:System.Attribute.Match%2A> jest to zwykle zaimplementowane, aby zwracały `true` , jeśli którykolwiek z flag jest spełniony. Rozważmy na przykład atrybut powiązania danych z flagami logicznymi "SupportsSql", "SupportsOleDb" i "SupportsXml". Ten atrybut może być obecny we właściwości, która obsługuje wszystkie trzy podejścia do powiązań danych. Często zdarza się, że programista musi wiedzieć tylko wtedy, gdy konkretne podejście jest dostępne, nie wszystkie trzy. W związku z tym programista <xref:System.Attribute.Match%2A> może użyć z wystąpieniem atrybutu zawierającego tylko flagi, których potrzebuje programista.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, czy <xref:System.ComponentModel.BrowsableAttribute> jest członkiem kolekcji i że został ustawiony na. `true` Przyjęto założenie `textBox1` , że `button1` i zostały utworzone w formularzu.  
  
 [!code-cpp[Classic AttributeCollection.Matches Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection.Matches Example/CPP/source.cpp#1)]
 [!code-csharp[Classic AttributeCollection.Matches Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection.Matches Example/CS/source.cs#1)]
 [!code-vb[Classic AttributeCollection.Matches Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection.Matches Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.BrowsableAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public bool Matches (Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Matches(class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.Matches(System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (attributes As Attribute()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Matches(cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="member this.Matches : Attribute[] -&gt; bool" Usage="attributeCollection.Matches attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="attributes">Tablica <see cref="T:System.CodeDom.MemberAttributes" /> do porównania z atrybutami w tej kolekcji.</param>
        <summary>Określa, czy atrybuty w określonej tablicy są takie same jak atrybuty w kolekcji.</summary>
        <returns><see langword="true" />Jeśli wszystkie atrybuty tablicy są zawarte w kolekcji i mają takie same wartości jak atrybuty w kolekcji; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybut może zapewnić obsługę dopasowywania.  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje atrybuty w przycisku i polu tekstowym, aby sprawdzić, czy są one zgodne. Przyjęto założenie `textBox1` , że `button1` i zostały utworzone w formularzu.  
  
 [!code-cpp[Classic AttributeCollection.Matches1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic AttributeCollection.Matches1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic AttributeCollection.Matches1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic AttributeCollection.Matches1 Example/CS/source.cs#1)]
 [!code-vb[Classic AttributeCollection.Matches1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic AttributeCollection.Matches1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.AttributeCollection.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów zawartych w kolekcji.</summary>
        <value>Liczba elementów zawartych w kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.AttributeCollection.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do kolekcji jest synchronizowany (bezpieczny wątkowo).</summary>
        <value><see langword="true" />Jeśli dostęp do kolekcji zostanie zsynchronizowany (bezpieczny wątkowo); w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.AttributeCollection.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do kolekcji.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.AttributeCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.IEnumerator" /> Zwraca wartość<see cref="T:System.Collections.IDictionary" />dla.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Dla .<see cref="T:System.Collections.IDictionary" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

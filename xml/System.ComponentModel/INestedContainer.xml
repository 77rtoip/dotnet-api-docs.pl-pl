<Type Name="INestedContainer" FullName="System.ComponentModel.INestedContainer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="583e123f6057aeb9827a161adfe0401ae17afc2f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30441957" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface INestedContainer : IDisposable, System.ComponentModel.IContainer" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract INestedContainer implements class System.ComponentModel.IContainer, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.INestedContainer" />
  <TypeSignature Language="VB.NET" Value="Public Interface INestedContainer&#xA;Implements IContainer, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class INestedContainer : IDisposable, System::ComponentModel::IContainer" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia funkcje zagnieżdżone kontenery, które logicznie zawierać zero lub więcej składników i są własnością składnika nadrzędnego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.INestedContainer> Interfejsu dodaje pojęcie składnika, do którego się <xref:System.ComponentModel.IContainer> interfejsu. Kontener zagnieżdżony jest logicznie, ale nie zawsze wizualnie zawierający zero lub więcej elementów podrzędnych i jest własnością niektórych składników nadrzędnego obiektu. Visual zawierania składnika, do którego jest często innego kontenera.  
  
 Zagnieżdżone kontenery Zezwalaj sekcje formantu, który ma być designable, bez konieczności jawnego członka serializacji zmiennej lub niestandardowego programu szeregującego dla każdego formantu podrzędnego. Zamiast tego projektanta formularzy obsługuje jeden kontener główny składników. Każdy składnik lokacji mogą mieć zagnieżdżonych kontener, który zapewnia miejsce do umieszczania dodatkowe składniki. Składnik jest zlokalizowany w kontenerze zagnieżdżonych, nazwę, którą otrzyma jest kombinacją jego podanej nazwy i nazwy jej właścicielem składnika. Ponadto składniki dodane do zagnieżdżonych kontenera mają pełny dostęp do usługi kontenera nadrzędnego, a zagnieżdżone kontener zawiera takie samo zachowanie elementu nadrzędnego w odniesieniu do dodawania nowych składników. Kontener zagnieżdżony utworzy projektanta dla każdego składnika, który zawiera, umożliwiając w ten sposób obsługi w czasie projektowania. Funkcja serializatorów standardowego kodu w zagnieżdżonych kontenerów, dlatego te składniki tylko są serializowane, jeśli ścieżka do nich można uzyskać przez przejście ze składnikami w kontenerze podstawowego.  
  
 Zagnieżdżone kontenery można znaleźć badając składnika witryny dla usług typu <xref:System.ComponentModel.INestedContainer>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.NestedContainer" />
    <altmember cref="T:System.ComponentModel.ContainerFilterService" />
    <altmember cref="M:System.ComponentModel.NestedContainer.GetService(System.Type)" />
  </Docs>
  <Members>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IComponent Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IComponent Owner" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.INestedContainer.Owner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Owner As IComponent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IComponent ^ Owner { System::ComponentModel::IComponent ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnika, do którego zagnieżdżonych kontenera.</summary>
        <value>
          <see cref="T:System.ComponentModel.IComponent" /> , Który jest właścicielem zagnieżdżonych kontenera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnika, do którego jest cech, który odróżnia zagnieżdżone kontenery z zwykłej kontenerów.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.IComponent" />
        <altmember cref="T:System.ComponentModel.IContainer" />
        <altmember cref="P:System.ComponentModel.NestedContainer.Owner" />
      </Docs>
    </Member>
  </Members>
</Type>
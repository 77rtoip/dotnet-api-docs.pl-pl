<Type Name="CustomReflectionContext" FullName="System.Reflection.Context.CustomReflectionContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2cb0994464985332742e76a283814be590106a9b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30561544" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CustomReflectionContext : System.Reflection.ReflectionContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CustomReflectionContext extends System.Reflection.ReflectionContext" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Context.CustomReflectionContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CustomReflectionContext&#xA;Inherits ReflectionContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class CustomReflectionContext abstract : System::Reflection::ReflectionContext" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Context</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.ReflectionContext</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje kontekst dostosowywalne odbicia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Context.CustomReflectionContext> Umożliwia dodać lub usunąć atrybuty niestandardowe z odbiciem obiektów lub dodać właściwości zastępczego do tych obiektów bez ponownego stosowania modelu pełną odbicia. Wartość domyślna <xref:System.Reflection.Context.CustomReflectionContext> po prostu zawija odbicia obiektów bez wprowadzania żadnych zmian, ale tworzenie podklas i zastępowanie odpowiednich metod, można dodać, usunąć, lub zmień atrybuty, które są stosowane do dowolnego odzwierciedlanego parametru lub elementu członkowskiego lub dodać nowych właściwości do odbite typu.  
  
 Załóżmy na przykład, że kod następuje Konwencji zastosowania określonego atrybutu metodami factory, ale muszą teraz współpracować kodu innych firm, który nie ma atrybutów. Można użyć <xref:System.Reflection.Context.CustomReflectionContext> określić regułę do identyfikowania obiektów, które powinny zawierać atrybuty i podaj obiekty te atrybuty widzianego w kodzie.  
  
 Aby użyć <xref:System.Reflection.Context.CustomReflectionContext> efektywnie kod, który używa odbite obiektów musi obsługiwać pojęcia Określanie kontekście odbicia, zamiast zakładając, że wszystkie odzwierciedlone obiektów skojarzonych z kontekstu w czasie wykonywania odbicia. Podaj wiele metod odbicia w .NET Framework <xref:System.Reflection.ReflectionContext> parametru w tym celu.  
  
 Aby zmodyfikować atrybuty, które są stosowane do odzwierciedlanego parametru lub elementu członkowskiego, Przesłoń <xref:System.Reflection.Context.CustomReflectionContext.GetCustomAttributes%28System.Reflection.ParameterInfo%2CSystem.Collections.Generic.IEnumerable%7BSystem.Object%7D%29> lub <xref:System.Reflection.Context.CustomReflectionContext.GetCustomAttributes%28System.Reflection.MemberInfo%2CSystem.Collections.Generic.IEnumerable%7BSystem.Object%7D%29> metody. Te metody odbite obiektu i listy atrybutów w jej bieżącym kontekście odbicia, a zwrócona lista atrybutów, które powinny mieć w kontekście odbicia niestandardowych.  
  
> [!WARNING]
>  <xref:System.Reflection.Context.CustomReflectionContext> metody nie mają do listy atrybutów obiektu odbite lub metoda bezpośrednio przez wywołanie metody <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metody w dostarczonych <xref:System.Reflection.MemberInfo> lub <xref:System.Reflection.ParameterInfo> wystąpienia, ale zamiast tego należy użyć `declaredAttributes` listę, która została przekazana jako parametr Aby <xref:System.Reflection.Context.CustomReflectionContext.GetCustomAttributes%2A> przeciążenia metody.  
  
 Aby dodać właściwości do odbite typu, Przesłoń <xref:System.Reflection.Context.CustomReflectionContext.AddProperties%2A> metody. Metoda przyjmuje parametr, który określa typ odbitych i zwraca listę dodatkowych właściwości. Należy używać <xref:System.Reflection.Context.CustomReflectionContext.CreateProperty%2A> metodą tworzenia obiektów właściwości do zwrócenia. Obiekty delegowane można określić podczas tworzenia właściwość, która będzie służyć jako metoda dostępu do właściwości i można pominąć jedną z metod dostępu do tworzenia właściwości tylko do odczytu lub w trybie tylko do zapisu. Należy zauważyć, że takie właściwości fikcyjny Brak metadanych lub zapasowego wspólnego języka pośredniego (CIL).  
  
> [!WARNING]
>  Zastanów się równości między obiektami odbite podczas pracy z konteksty odbicia, ponieważ może reprezentować ten sam obiekt odbite w wielu kontekstów. Można użyć <xref:System.Reflection.Context.CustomReflectionContext.MapType%2A> metodę, aby uzyskać wersję w kontekście konkretnego odbicia odbite obiektu.  
  
> [!WARNING]
>  A <xref:System.Reflection.Context.CustomReflectionContext> obiektu zmienia atrybuty zwróconej przez obiekt określonego odbicia, na przykład identyfikatorami uzyskanymi przez <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metody. Nie zmienia atrybutu niestandardowego danych zwróconych przez <xref:System.Reflection.MemberInfo.GetCustomAttributesData%2A> — metoda i te dwie listy nie będzie odpowiadała używania kontekstu odbicie niestandardowe.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób podklasy <xref:System.Reflection.Context.CustomReflectionContext> można dodać atrybutu niestandardowego do wszystkich członków z danego typu, których nazwy zaczynają się od "Do". Aby uruchomić ten kod, wklej go do projektu w pustej konsoli i upewnij się, że odwołanie do System.Reflection.Context.dll.  
  
 [!code-csharp[System.Reflection.Context.CustomReflectionContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.context.customreflectioncontext/cs/program.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Reflection.Context.CustomReflectionContext" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CustomReflectionContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CustomReflectionContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Reflection.Context.CustomReflectionContext" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CustomReflectionContext (System.Reflection.ReflectionContext source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Reflection.ReflectionContext source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.#ctor(System.Reflection.ReflectionContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (source As ReflectionContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CustomReflectionContext(System::Reflection::ReflectionContext ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="source" Type="System.Reflection.ReflectionContext" />
      </Parameters>
      <Docs>
        <param name="source">Odbicie kontekst do użycia jako podstawy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Reflection.Context.CustomReflectionContext" /> klasy w kontekście odbicia określony jako podstawy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperties">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.PropertyInfo&gt; AddProperties (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.PropertyInfo&gt; AddProperties(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.AddProperties(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Reflection::PropertyInfo ^&gt; ^ AddProperties(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.PropertyInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ właściwości, aby dodać.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej zapewnia zbiór dodatkowe właściwości dla określonego typu reprezentowany w tym kontekście odbicia.</summary>
        <returns>Kolekcja dodatkowe właściwości dla określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastępuje tę metodę, aby określić właściwości, które powinny zostać dodane do danego typu. Aby utworzyć właściwości, należy użyć <xref:System.Reflection.Context.CustomReflectionContext.CreateProperty%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt, który reprezentuje właściwość do dodania do typu określony przez <see cref="M:System.Reflection.Context.CustomReflectionContext.AddProperties(System.Type)" /> metody.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="protected System.Reflection.PropertyInfo CreateProperty (Type propertyType, string name, Func&lt;object,object&gt; getter, Action&lt;object,object&gt; setter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Reflection.PropertyInfo CreateProperty(class System.Type propertyType, string name, class System.Func`2&lt;object, object&gt; getter, class System.Action`2&lt;object, object&gt; setter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.CreateProperty(System.Type,System.String,System.Func{System.Object,System.Object},System.Action{System.Object,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateProperty (propertyType As Type, name As String, getter As Func(Of Object, Object), setter As Action(Of Object, Object)) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Reflection::PropertyInfo ^ CreateProperty(Type ^ propertyType, System::String ^ name, Func&lt;System::Object ^, System::Object ^&gt; ^ getter, Action&lt;System::Object ^, System::Object ^&gt; ^ setter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="getter" Type="System.Func&lt;System.Object,System.Object&gt;" />
        <Parameter Name="setter" Type="System.Action&lt;System.Object,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">Typ właściwości do utworzenia.</param>
        <param name="name">Nazwa właściwości do utworzenia.</param>
        <param name="getter">Obiekt reprezentujący wartość właściwości <see langword="get" /> metody dostępu.</param>
        <param name="setter">Obiekt reprezentujący wartość właściwości <see langword="set" /> metody dostępu.</param>
        <summary>Tworzy obiekt, który reprezentuje właściwość do dodania do typu, ma być używany z <see cref="M:System.Reflection.Context.CustomReflectionContext.AddProperties(System.Type)" /> metody.</summary>
        <returns>Obiekt, który reprezentuje właściwość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty, które są zwracane przez tę metodę nie zostały zakończone <xref:System.Reflection.PropertyInfo> obiekty i powinna być używana tylko w kontekście <xref:System.Reflection.Context.CustomReflectionContext.AddProperties%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="protected System.Reflection.PropertyInfo CreateProperty (Type propertyType, string name, Func&lt;object,object&gt; getter, Action&lt;object,object&gt; setter, System.Collections.Generic.IEnumerable&lt;Attribute&gt; propertyCustomAttributes, System.Collections.Generic.IEnumerable&lt;Attribute&gt; getterCustomAttributes, System.Collections.Generic.IEnumerable&lt;Attribute&gt; setterCustomAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Reflection.PropertyInfo CreateProperty(class System.Type propertyType, string name, class System.Func`2&lt;object, object&gt; getter, class System.Action`2&lt;object, object&gt; setter, class System.Collections.Generic.IEnumerable`1&lt;class System.Attribute&gt; propertyCustomAttributes, class System.Collections.Generic.IEnumerable`1&lt;class System.Attribute&gt; getterCustomAttributes, class System.Collections.Generic.IEnumerable`1&lt;class System.Attribute&gt; setterCustomAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.CreateProperty(System.Type,System.String,System.Func{System.Object,System.Object},System.Action{System.Object,System.Object},System.Collections.Generic.IEnumerable{System.Attribute},System.Collections.Generic.IEnumerable{System.Attribute},System.Collections.Generic.IEnumerable{System.Attribute})" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateProperty (propertyType As Type, name As String, getter As Func(Of Object, Object), setter As Action(Of Object, Object), propertyCustomAttributes As IEnumerable(Of Attribute), getterCustomAttributes As IEnumerable(Of Attribute), setterCustomAttributes As IEnumerable(Of Attribute)) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Reflection::PropertyInfo ^ CreateProperty(Type ^ propertyType, System::String ^ name, Func&lt;System::Object ^, System::Object ^&gt; ^ getter, Action&lt;System::Object ^, System::Object ^&gt; ^ setter, System::Collections::Generic::IEnumerable&lt;Attribute ^&gt; ^ propertyCustomAttributes, System::Collections::Generic::IEnumerable&lt;Attribute ^&gt; ^ getterCustomAttributes, System::Collections::Generic::IEnumerable&lt;Attribute ^&gt; ^ setterCustomAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="getter" Type="System.Func&lt;System.Object,System.Object&gt;" />
        <Parameter Name="setter" Type="System.Action&lt;System.Object,System.Object&gt;" />
        <Parameter Name="propertyCustomAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Attribute&gt;" />
        <Parameter Name="getterCustomAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Attribute&gt;" />
        <Parameter Name="setterCustomAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Attribute&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">Typ właściwości do utworzenia.</param>
        <param name="name">Nazwa właściwości do utworzenia.</param>
        <param name="getter">Obiekt reprezentujący wartość właściwości <see langword="get" /> metody dostępu.</param>
        <param name="setter">Obiekt reprezentujący wartość właściwości <see langword="set" /> metody dostępu.</param>
        <param name="propertyCustomAttributes">Kolekcja atrybutów niestandardowych, które można zastosować do właściwości.</param>
        <param name="getterCustomAttributes">Kolekcja atrybutów niestandardowych do zastosowania z właściwością <see langword="get" /> metody dostępu.</param>
        <param name="setterCustomAttributes">Kolekcja atrybutów niestandardowych do zastosowania z właściwością <see langword="set" /> metody dostępu.</param>
        <summary>Tworzy obiekt, który reprezentuje właściwość do dodania do typu, ma być używany z <see cref="M:System.Reflection.Context.CustomReflectionContext.AddProperties(System.Type)" /> — metoda i przy użyciu określonych atrybutów niestandardowych.</summary>
        <returns>Obiekt, który reprezentuje właściwość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty, które są zwracane przez tę metodę nie zostały zakończone <xref:System.Reflection.PropertyInfo> obiekty i powinna być używana tylko w kontekście <xref:System.Reflection.Context.CustomReflectionContext.AddProperties%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej zapewnia zmodyfikowane Kolekcja niestandardowych atrybutów dla określonego obiektu reprezentowany w tym kontekście odbicia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;object&gt; GetCustomAttributes (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;object&gt; declaredAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;object&gt; GetCustomAttributes(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;object&gt; declaredAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.GetCustomAttributes(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Object})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetCustomAttributes (member As MemberInfo, declaredAttributes As IEnumerable(Of Object)) As IEnumerable(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Object ^&gt; ^ GetCustomAttributes(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Object ^&gt; ^ declaredAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="declaredAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="member">Element członkowski, którego atrybutów niestandardowych, które zostaną zwrócone.</param>
        <param name="declaredAttributes">Kolekcja atrybutów elementu członkowskiego w jej bieżącym kontekście.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zawiera listę atrybutów niestandardowych dla określonego elementu członkowskiego, reprezentowany w tym kontekście odbicia.</summary>
        <returns>Kolekcja, która reprezentuje atrybuty niestandardowe określonego elementu członkowskiego w tym kontekście odbicia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;object&gt; GetCustomAttributes (System.Reflection.ParameterInfo parameter, System.Collections.Generic.IEnumerable&lt;object&gt; declaredAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;object&gt; GetCustomAttributes(class System.Reflection.ParameterInfo parameter, class System.Collections.Generic.IEnumerable`1&lt;object&gt; declaredAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.GetCustomAttributes(System.Reflection.ParameterInfo,System.Collections.Generic.IEnumerable{System.Object})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetCustomAttributes (parameter As ParameterInfo, declaredAttributes As IEnumerable(Of Object)) As IEnumerable(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Object ^&gt; ^ GetCustomAttributes(System::Reflection::ParameterInfo ^ parameter, System::Collections::Generic::IEnumerable&lt;System::Object ^&gt; ^ declaredAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Reflection.ParameterInfo" />
        <Parameter Name="declaredAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="parameter">Parametr, których atrybutów niestandardowych, które zostaną zwrócone.</param>
        <param name="declaredAttributes">Kolekcja atrybutów parametru w jej bieżącym kontekście.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zawiera listę atrybutów niestandardowych dla określonego parametru reprezentowany w tym kontekście odbicia.</summary>
        <returns>Kolekcja, która reprezentuje atrybuty niestandardowe określonego parametru w tym kontekście odbicia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapAssembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly MapAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Assembly MapAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.MapAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::Assembly ^ MapAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Zewnętrznej reprezentacja zestawu do reprezentowania w tym kontekście.</param>
        <summary>Pobiera reprezentacja, w tym kontekście odbicia zestawu, który jest reprezentowany przez obiekt z innym kontekście odbicia.</summary>
        <returns>Reprezentacja zestawu w tym kontekście odbicia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapType">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeInfo MapType (System.Reflection.TypeInfo type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.TypeInfo MapType(class System.Reflection.TypeInfo type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.MapType(System.Reflection.TypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MapType (type As TypeInfo) As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::TypeInfo ^ MapType(System::Reflection::TypeInfo ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="type">Zewnętrznej reprezentacja typu do reprezentowania w tym kontekście.</param>
        <summary>Pobiera reprezentacja, w tym kontekście odbicia typu reprezentowanego przez obiekt z innym kontekście odbicia.</summary>
        <returns>Reprezentacja typu w tym kontekście odbicia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
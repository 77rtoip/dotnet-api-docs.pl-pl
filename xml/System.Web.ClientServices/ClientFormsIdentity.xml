<Type Name="ClientFormsIdentity" FullName="System.Web.ClientServices.ClientFormsIdentity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b3f0b0d839caa85bbe26af3561725579fa017283" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36604661" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ClientFormsIdentity : IDisposable, System.Security.Principal.IIdentity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ClientFormsIdentity extends System.Object implements class System.IDisposable, class System.Security.Principal.IIdentity" />
  <TypeSignature Language="DocId" Value="T:System.Web.ClientServices.ClientFormsIdentity" />
  <TypeSignature Language="VB.NET" Value="Public Class ClientFormsIdentity&#xA;Implements IDisposable, IIdentity" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientFormsIdentity : IDisposable, System::Security::Principal::IIdentity" />
  <TypeSignature Language="F#" Value="type ClientFormsIdentity = class&#xA;    interface IIdentity&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.Principal.IIdentity</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje tożsamość użytkownika, uwierzytelniony do korzystania z usługi aplikacji klienta przy użyciu uwierzytelniania formularzy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja usług aplikacji klienta do reprezentowania uwierzytelniony użytkownik korzysta z tej klasy. Po skonfigurowaniu aplikacji umożliwiająca użycie uwierzytelniania formularzy i usług aplikacji klienta, można uwierzytelnić użytkownika przez wywołanie metody `static` <xref:System.Web.Security.Membership.ValidateUser%2A?displayProperty=nameWithType> metody. Po uwierzytelnieniu można pobrać odwołania do bieżącego <xref:System.Web.ClientServices.ClientFormsIdentity> wystąpienie za pośrednictwem <xref:System.Security.Principal.IPrincipal.Identity%2A> właściwość <xref:System.Security.Principal.IPrincipal> pobierane w drodze `static` <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> właściwości. Aby uzyskać więcej informacji, zobacz [usługi aplikacji klienta](~/docs/framework/common-client-technologies/client-application-services.md).  
  
 Zwykle będzie dostęp do <xref:System.Web.ClientServices.ClientFormsIdentity> obiekt jako <xref:System.Security.Principal.IIdentity> odwołania, aby uniknąć bezpośrednia zależność od tej klasy. Można określić, czy użytkownik jest uwierzytelniany przez sprawdzanie <xref:System.Security.Principal.IIdentity.IsAuthenticated%2A?displayProperty=nameWithType> właściwość tożsamości. Użytkownik może jednak uwierzytelniony dla systemu Windows, ale nie dla usług aplikacji klienta. Aby ustalić, czy użytkownik jest uwierzytelniany dla usług aplikacji klienta, użytkownik powinien również upewnij się, że <xref:System.Security.Principal.IIdentity.AuthenticationType%2A?displayProperty=nameWithType> wartość właściwości jest "ClientForms".  
  
 Musisz użyć jawnego <xref:System.Web.ClientServices.ClientFormsIdentity> odwołania do wywołania <xref:System.Web.ClientServices.ClientFormsIdentity.RevalidateUser%2A> metodę, która nie jest zdefiniowany przez <xref:System.Security.Principal.IIdentity> interfejsu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak dyskretnie ponownie zatwierdzać użytkownika, gdy aplikacja wyjdzie ze stanu offline przy użyciu tej klasy. W tym przykładzie <xref:System.Windows.Forms.CheckBox.CheckedChanged> obsługi zdarzeń aktualizacji w trybie offline stan pasuje do wartości pola wyboru. Jeżeli użytkownik ustawi aplikacji do trybu online, program obsługi zdarzeń próbuje ponownie sprawdź poprawność użytkownika, wywołując <xref:System.Web.ClientServices.ClientFormsIdentity.RevalidateUser%2A> metody. Jednak serwer uwierzytelniania jest niedostępny, program obsługi zdarzeń zwraca aplikacji w tryb offline.  
  
> [!NOTE]
>  <xref:System.Web.ClientServices.ClientFormsIdentity.RevalidateUser%2A> Metoda jest jedynie jako udogodnienie. Ponieważ nie ma wartości zwracanej, nie może wskazać, czy ponowna Walidacja nie powiodła się. Ponowna Walidacja może zakończyć się niepowodzeniem, na przykład, jeśli poświadczenia użytkownika zostały zmienione na serwerze. W takim przypadku można dołączać kod jawnie weryfikującą użytkowników po wywołaniu usługi nie powiedzie się. Aby uzyskać więcej informacji, zobacz sekcję ustawień dostępu do sieci Web w [wskazówki: Korzystanie z usługi aplikacji klienta](~/docs/framework/common-client-technologies/walkthrough-using-client-application-services.md).  
  
 [!code-csharp[ClientApplicationServices#315](~/samples/snippets/csharp/VS_Snippets_Winforms/ClientApplicationServices/CS/Class1.cs#315)]
 [!code-vb[ClientApplicationServices#315](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClientApplicationServices/VB/Class1.vb#315)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Web.Security.Membership.ValidateUser(System.String,System.String)" />
    <altmember cref="M:System.Web.ClientServices.ClientFormsIdentity.RevalidateUser" />
    <altmember cref="P:System.Threading.Thread.CurrentPrincipal" />
    <altmember cref="T:System.Security.Principal.IPrincipal" />
    <altmember cref="P:System.Security.Principal.IPrincipal.Identity" />
    <altmember cref="T:System.Security.Principal.IIdentity" />
    <altmember cref="P:System.Security.Principal.IIdentity.IsAuthenticated" />
    <altmember cref="P:System.Web.ClientServices.ClientFormsIdentity.IsAuthenticated" />
    <altmember cref="P:System.Web.ClientServices.ClientFormsIdentity.AuthenticationType" />
    <altmember cref="M:System.Web.ClientServices.Providers.ClientFormsAuthenticationMembershipProvider.Logout" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ClientFormsIdentity (string name, string password, System.Web.Security.MembershipProvider provider, string authenticationType, bool isAuthenticated, System.Net.CookieContainer authenticationCookies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, string password, class System.Web.Security.MembershipProvider provider, string authenticationType, bool isAuthenticated, class System.Net.CookieContainer authenticationCookies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.ClientServices.ClientFormsIdentity.#ctor(System.String,System.String,System.Web.Security.MembershipProvider,System.String,System.Boolean,System.Net.CookieContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, password As String, provider As MembershipProvider, authenticationType As String, isAuthenticated As Boolean, authenticationCookies As CookieContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ClientFormsIdentity(System::String ^ name, System::String ^ password, System::Web::Security::MembershipProvider ^ provider, System::String ^ authenticationType, bool isAuthenticated, System::Net::CookieContainer ^ authenticationCookies);" />
      <MemberSignature Language="F#" Value="new System.Web.ClientServices.ClientFormsIdentity : string * string * System.Web.Security.MembershipProvider * string * bool * System.Net.CookieContainer -&gt; System.Web.ClientServices.ClientFormsIdentity" Usage="new System.Web.ClientServices.ClientFormsIdentity (name, password, provider, authenticationType, isAuthenticated, authenticationCookies)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="provider" Type="System.Web.Security.MembershipProvider" />
        <Parameter Name="authenticationType" Type="System.String" />
        <Parameter Name="isAuthenticated" Type="System.Boolean" />
        <Parameter Name="authenticationCookies" Type="System.Net.CookieContainer" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa uwierzytelnionego użytkownika.</param>
        <param name="password">Hasło uwierzytelnionego użytkownika.</param>
        <param name="provider">Dostawca członkostwa używany do uwierzytelniania użytkownika.</param>
        <param name="authenticationType">Typ uwierzytelniania, który jest używany.</param>
        <param name="isAuthenticated">
          <see langword="true" /> Jeśli użytkownik został uwierzytelniony; w przeciwnym razie <see langword="false" />.</param>
        <param name="authenticationCookies">Pliki cookie są pobierane z usługi uwierzytelniania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.ClientServices.ClientFormsIdentity" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationCookies">
      <MemberSignature Language="C#" Value="public System.Net.CookieContainer AuthenticationCookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer AuthenticationCookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.ClientServices.ClientFormsIdentity.AuthenticationCookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AuthenticationCookies As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieContainer ^ AuthenticationCookies { System::Net::CookieContainer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationCookies : System.Net.CookieContainer" Usage="System.Web.ClientServices.ClientFormsIdentity.AuthenticationCookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję plików cookie pobranych z usługi uwierzytelniania.</summary>
        <value>Pliki cookie są pobierane z usługi uwierzytelniania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest przeznaczona do użycia w kodzie aplikacji. Nie można uzyskać wiarygodny zmodyfikować pliki cookie pobrane za pośrednictwem tej właściwości, a ich nie zawierają żadnych informacji przydatne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationType">
      <MemberSignature Language="C#" Value="public string AuthenticationType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationType" />
      <MemberSignature Language="DocId" Value="P:System.Web.ClientServices.ClientFormsIdentity.AuthenticationType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AuthenticationType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationType : string" Usage="System.Web.ClientServices.ClientFormsIdentity.AuthenticationType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ uwierzytelniania, który jest używany do uwierzytelniania użytkownika.</summary>
        <value>Typ uwierzytelniania, który jest używany do uwierzytelniania użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle będzie dostęp do <xref:System.Web.ClientServices.ClientFormsIdentity> obiekt jako <xref:System.Security.Principal.IIdentity> odwołania, aby uniknąć bezpośrednia zależność od tej klasy. Można określić, czy użytkownik jest uwierzytelniany przez sprawdzanie <xref:System.Security.Principal.IIdentity.IsAuthenticated%2A?displayProperty=nameWithType> właściwość tożsamości. Użytkownik może jednak uwierzytelniony dla systemu Windows, ale nie dla usług aplikacji klienta. Aby ustalić, czy użytkownik jest uwierzytelniany dla usług aplikacji klienta, użytkownik powinien również upewnij się, że <xref:System.Security.Principal.IIdentity.AuthenticationType%2A?displayProperty=nameWithType> wartość właściwości jest "ClientForms". Aby uzyskać więcej informacji, zobacz <xref:System.Web.ClientServices.ClientFormsIdentity> Przegląd klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać tej właściwości, za pomocą <xref:System.Security.Principal.IIdentity> odwołanie do określenia, czy użytkownik jest obecnie uwierzytelniony dla usług aplikacji klienta. W przykładzie założono, że aplikacja jest w domyślnej konfiguracji, których użytkownicy nie muszą Zaloguj się ponownie podczas uwierzytelniania wygasa plik cookie. W przeciwnym razie <xref:System.Net.WebException> może wskazywać, że logowanie użytkownika wygasło. Aby uzyskać więcej informacji, zobacz [porady: Konfigurowanie usługi aplikacji klienta](~/docs/framework/common-client-technologies/how-to-configure-client-application-services.md).  
  
 [!code-csharp[ClientApplicationServices#312](~/samples/snippets/csharp/VS_Snippets_Winforms/ClientApplicationServices/CS/Class1.cs#312)]
 [!code-vb[ClientApplicationServices#312](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClientApplicationServices/VB/Class1.vb#312)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.Principal.IIdentity" />
        <altmember cref="P:System.Security.Principal.IIdentity.IsAuthenticated" />
        <altmember cref="P:System.Security.Principal.IIdentity.AuthenticationType" />
        <altmember cref="P:System.Web.ClientServices.ClientFormsIdentity.IsAuthenticated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Web.ClientServices.ClientFormsIdentity" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.ClientServices.ClientFormsIdentity.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="clientFormsIdentity.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Web.ClientServices.ClientFormsIdentity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Web.ClientServices.ClientFormsIdentity.Dispose%2A> po zakończeniu przy użyciu <xref:System.Web.ClientServices.ClientFormsIdentity>. <xref:System.Web.ClientServices.ClientFormsIdentity.Dispose%2A> Pozostawia metody <xref:System.Web.ClientServices.ClientFormsIdentity> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Web.ClientServices.ClientFormsIdentity.Dispose%2A>, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Web.ClientServices.ClientFormsIdentity> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.Web.ClientServices.ClientFormsIdentity> klasy. Aby uzyskać więcej informacji, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.Web.ClientServices.ClientFormsIdentity.Dispose%2A> przed zwolnieniem ostatniego odwołania do <xref:System.Web.ClientServices.ClientFormsIdentity>. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.Web.ClientServices.ClientFormsIdentity> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.ClientServices.ClientFormsIdentity.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="clientFormsIdentity.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Web.ClientServices.ClientFormsIdentity" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Web.ClientServices.ClientFormsIdentity> odwołania. Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" /> należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose(Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia Resources](~/docs/standard/garbage-collection/unmanaged.md) niezarządzane i [zastąpienie metody Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.ClientServices.ClientFormsIdentity.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Web.ClientServices.ClientFormsIdentity.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy użytkownik został uwierzytelniony.</summary>
        <value>
          <see langword="true" /> Jeśli użytkownik został uwierzytelniony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle będzie dostęp do <xref:System.Web.ClientServices.ClientFormsIdentity> obiekt jako <xref:System.Security.Principal.IIdentity> odwołania, aby uniknąć bezpośrednia zależność od tej klasy. Można określić, czy użytkownik jest uwierzytelniany przez sprawdzanie <xref:System.Security.Principal.IIdentity.IsAuthenticated%2A?displayProperty=nameWithType> właściwość tożsamości. Użytkownik może jednak uwierzytelniony dla systemu Windows, ale nie dla usług aplikacji klienta. Aby ustalić, czy użytkownik jest uwierzytelniany dla usług aplikacji klienta, użytkownik powinien również upewnij się, że <xref:System.Security.Principal.IIdentity.AuthenticationType%2A?displayProperty=nameWithType> wartość właściwości jest "ClientForms". Aby uzyskać więcej informacji, zobacz <xref:System.Web.ClientServices.ClientFormsIdentity> Przegląd klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać tej właściwości, za pomocą <xref:System.Security.Principal.IIdentity> odwołanie do określenia, czy użytkownik jest obecnie uwierzytelniony dla usług aplikacji klienta. W przykładzie założono, że aplikacja jest w domyślnej konfiguracji, których użytkownicy nie muszą Zaloguj się ponownie podczas uwierzytelniania wygasa plik cookie. W przeciwnym razie <xref:System.Net.WebException> może wskazywać, że logowanie użytkownika wygasło. Aby uzyskać więcej informacji, zobacz [porady: Konfigurowanie usługi aplikacji klienta](~/docs/framework/common-client-technologies/how-to-configure-client-application-services.md).  
  
 [!code-csharp[ClientApplicationServices#312](~/samples/snippets/csharp/VS_Snippets_Winforms/ClientApplicationServices/CS/Class1.cs#312)]
 [!code-vb[ClientApplicationServices#312](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClientApplicationServices/VB/Class1.vb#312)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Thread.CurrentPrincipal" />
        <altmember cref="T:System.Security.Principal.IPrincipal" />
        <altmember cref="P:System.Security.Principal.IPrincipal.Identity" />
        <altmember cref="T:System.Security.Principal.IIdentity" />
        <altmember cref="P:System.Security.Principal.IIdentity.IsAuthenticated" />
        <altmember cref="P:System.Security.Principal.IIdentity.AuthenticationType" />
        <altmember cref="P:System.Web.ClientServices.ClientFormsIdentity.AuthenticationType" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Web.ClientServices.ClientFormsIdentity.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Web.ClientServices.ClientFormsIdentity.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę użytkownika.</summary>
        <value>Nazwa użytkownika.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Provider">
      <MemberSignature Language="C#" Value="public System.Web.Security.MembershipProvider Provider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Security.MembershipProvider Provider" />
      <MemberSignature Language="DocId" Value="P:System.Web.ClientServices.ClientFormsIdentity.Provider" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Provider As MembershipProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Security::MembershipProvider ^ Provider { System::Web::Security::MembershipProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Provider : System.Web.Security.MembershipProvider" Usage="System.Web.ClientServices.ClientFormsIdentity.Provider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.MembershipProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dostawcę członkostwa, który jest używany do uwierzytelniania użytkownika.</summary>
        <value>Dostawca członkostwa, który jest używany do uwierzytelniania użytkownika.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RevalidateUser">
      <MemberSignature Language="C#" Value="public void RevalidateUser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RevalidateUser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.ClientServices.ClientFormsIdentity.RevalidateUser" />
      <MemberSignature Language="VB.NET" Value="Public Sub RevalidateUser ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RevalidateUser();" />
      <MemberSignature Language="F#" Value="member this.RevalidateUser : unit -&gt; unit" Usage="clientFormsIdentity.RevalidateUser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dyskretnie uwierzytelnia użytkownika przy użyciu buforowanych poświadczeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z uwierzytelniania formularzy do sprawdzania z bieżącym użytkownikiem <xref:System.Web.ClientServices.ClientFormsIdentity> klasy przechowuje poświadczenia użytkowników, tak długo, jak aplikacja jest uruchomiona. Jednak użytkownik jest uwierzytelniany tylko do momentu wygaśnięcia pliku cookie uwierzytelniania. Po wygaśnięciu pliku cookie, użytkownik musi mieć przywróconą ważność dostępu zdalnego ról lub usługi ustawień sieci Web. Można użyć **Zaawansowane ustawienia dla usług** okno dialogowe, aby skonfigurować aplikację do automatycznie ponownie zatwierdzać użytkownika, zgodnie z opisem w [porady: Konfigurowanie usługi aplikacji klienta](~/docs/framework/common-client-technologies/how-to-configure-client-application-services.md). Jednak jeśli konfigurujesz aplikacji uwzględnić datę ważności pliku cookie, możesz można programowo ponownie sprawdź poprawność użytkownika przez wywołanie metody <xref:System.Web.ClientServices.ClientFormsIdentity.RevalidateUser%2A> metody. Ta metoda jest również przydatne podczas przełączania z trybu offline do trybu online, ponieważ aplikacja został zamknięty podczas działa w trybie offline.  
  
> [!NOTE]
>  <xref:System.Web.ClientServices.ClientFormsIdentity.RevalidateUser%2A> Metoda jest jedynie jako udogodnienie. Ponieważ nie ma wartości zwracanej, nie może wskazać, czy ponowna Walidacja nie powiodła się. Ponowna Walidacja może zakończyć się niepowodzeniem, na przykład, jeśli poświadczenia użytkownika zostały zmienione na serwerze. W takim przypadku można dołączać kod jawnie weryfikującą użytkowników po wywołaniu usługi nie powiedzie się. Aby uzyskać więcej informacji, zobacz sekcję ustawień dostępu do sieci Web w [wskazówki: Korzystanie z usługi aplikacji klienta](~/docs/framework/common-client-technologies/walkthrough-using-client-application-services.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazano, jak użyć tej metody do dyskretnej ponownie zatwierdzać użytkownika, gdy aplikacja wyjdzie ze stanu w trybie offline. W tym przykładzie <xref:System.Windows.Forms.CheckBox.CheckedChanged> obsługi zdarzeń aktualizacji w trybie offline stan pasuje do wartości pola wyboru. Jeżeli użytkownik ustawi aplikacji do trybu online, program obsługi zdarzeń próbuje ponownie sprawdź poprawność użytkownika. Jednak serwer uwierzytelniania jest niedostępny, program obsługi zdarzeń zwraca aplikacji w tryb offline.  
  
 [!code-csharp[ClientApplicationServices#315](~/samples/snippets/csharp/VS_Snippets_Winforms/ClientApplicationServices/CS/Class1.cs#315)]
 [!code-vb[ClientApplicationServices#315](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClientApplicationServices/VB/Class1.vb#315)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.ClientServices.ConnectivityStatus" />
        <altmember cref="P:System.Web.ClientServices.ConnectivityStatus.IsOffline" />
      </Docs>
    </Member>
  </Members>
</Type>
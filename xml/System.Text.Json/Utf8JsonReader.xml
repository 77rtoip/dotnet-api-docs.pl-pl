<Type Name="Utf8JsonReader" FullName="System.Text.Json.Utf8JsonReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a451999ec7e4d837eb22652c047781c5decd940" /><Meta Name="ms.sourcegitcommit" Value="cb4d218ffd5a459a5f921fe1d945c682d1e09aca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/16/2019" /><Meta Name="ms.locfileid" Value="69540539" /></Metadata><TypeSignature Language="C#" Value="public struct Utf8JsonReader" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Utf8JsonReader extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.Utf8JsonReader" />
  <TypeSignature Language="VB.NET" Value="Public Structure Utf8JsonReader" />
  <TypeSignature Language="C++ CLI" Value="public value class Utf8JsonReader" />
  <TypeSignature Language="F#" Value="type Utf8JsonReader = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="e9a0c-101">Zapewnia interfejs API o wysokiej wydajności tylko do odczytu w przypadku tekstu JSON zakodowanego w formacie UTF-8.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-101">Provides a high-performance API for forward-only, read-only access to UTF-8 encoded JSON text.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-102">`Utf8JsonReader`przetwarza tekst sekwencyjnie bez buforowania i domyślnie jest zgodny ze [specyfikacją RFC JSON](https://tools.ietf.org/html/rfc8259).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-102">`Utf8JsonReader` processes the text sequentially with no caching and by default adheres strictly to the [JSON RFC](https://tools.ietf.org/html/rfc8259).</span></span>

<span data-ttu-id="e9a0c-103">Gdy `Utf8JsonReader` napotka nieprawidłowy kod JSON, <xref:System.Text.Json.JsonException> generuje on podstawowe informacje o błędzie, np. numer wiersza i położenie bajtów w wierszu.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-103">When `Utf8JsonReader` encounters invalid JSON, it throws a <xref:System.Text.Json.JsonException> with basic error information like line number and byte position on the line.</span></span>

<span data-ttu-id="e9a0c-104">Ponieważ ten typ jest strukturą ref, nie obsługuje bezpośrednio asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-104">Since this type is a ref struct, it doesn't directly support async.</span></span> <span data-ttu-id="e9a0c-105">Jednak zapewnia obsługę współużytkowania wątkowości, aby odczytywać niekompletne dane i kontynuować odczytywanie po przedstawieniu większej ilości danych.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-105">However, it does provide support for reentrancy to read incomplete data and to continue reading once more data is presented.</span></span>

<span data-ttu-id="e9a0c-106">Aby można było ustawić maksymalną głębokość podczas odczytywania lub zezwalania na pomijanie komentarzy, Utwórz wystąpienie <xref:System.Text.Json.JsonReaderState> i przekaż je do czytnika.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-106">To be able to set max depth while reading OR allow skipping comments, create an instance of <xref:System.Text.Json.JsonReaderState> and pass it to the reader.</span></span>

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (System.Buffers.ReadOnlySequence&lt;byte&gt; jsonData, System.Text.Json.JsonReaderOptions options = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; jsonData, valuetype System.Text.Json.JsonReaderOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Text.Json.JsonReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySequence(Of Byte), Optional options As JsonReaderOptions = null)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : System.Buffers.ReadOnlySequence&lt;byte&gt; * System.Text.Json.JsonReaderOptions -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.Buffers.ReadOnlySequence&lt;System.Byte&gt;" />
        <Parameter Name="options" Type="System.Text.Json.JsonReaderOptions" />
      </Parameters>
      <Docs>
        <param name="jsonData"><span data-ttu-id="e9a0c-107">Zakodowany tekst JSON w formacie UTF-8.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-107">The UTF-8 encoded JSON text to process.</span></span></param>
        <param name="options"><span data-ttu-id="e9a0c-108">Obiekt, który definiuje dostosowane zachowanie <see cref="T:System.Text.Json.Utf8JsonReader" /> , które różni się od specyfikacji RFC JSON (na przykład jak obsługiwać komentarze lub maksymalną głębokość dozwoloną podczas czytania).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-108">An object that defines customized behavior of the <see cref="T:System.Text.Json.Utf8JsonReader" /> that differs from the JSON RFC (for example how to handle comments or maximum depth allowed when reading).</span></span> <span data-ttu-id="e9a0c-109">Domyślnie <see cref="T:System.Text.Json.Utf8JsonReader" /> następujące komentarze w formacie JSON RFC są prawidłowe, a maksymalna głębokość to 64.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-109">By default, the <see cref="T:System.Text.Json.Utf8JsonReader" /> follows the JSON RFC strictly; comments within the JSON are invalid, and the maximum depth is 64.</span></span></param>
        <summary><span data-ttu-id="e9a0c-110">Inicjuje nowe wystąpienie <see cref="T:System.Text.Json.Utf8JsonReader" /> struktury, które przetwarza sekwencję tekstu zakodowanego w formacie UTF-8 przy użyciu określonych opcji.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-110">Initializes a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> structure that processes a read-only sequence of UTF-8 encoded text using the specified options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-111">Ponieważ ten typ jest strukturą ref, jest to typ tylko stosu, a wszystkie ograniczenia dotyczące struktur ref mają zastosowanie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-111">Since this type is a ref struct, it is a stack-only type, and all the limitations of ref structs apply to it.</span></span>

<span data-ttu-id="e9a0c-112">W tym konstruktorze przyjęto założenie, że cały `jsonData`ładunek JSON jest zawarty w <xref:System.Text.Json.Utf8JsonReader.IsFinalBlock?displayProperty=nameWithType> `true`. jest to  = odpowiednik.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-112">This constructor assumes that the entire JSON payload is contained in `jsonData`; it is equivalent to <xref:System.Text.Json.Utf8JsonReader.IsFinalBlock?displayProperty=nameWithType> = `true`.</span></span>
              
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (ReadOnlySpan&lt;byte&gt; jsonData, System.Text.Json.JsonReaderOptions options = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; jsonData, valuetype System.Text.Json.JsonReaderOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Text.Json.JsonReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySpan(Of Byte), Optional options As JsonReaderOptions = null)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : ReadOnlySpan&lt;byte&gt; * System.Text.Json.JsonReaderOptions -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="options" Type="System.Text.Json.JsonReaderOptions" />
      </Parameters>
      <Docs>
        <param name="jsonData"><span data-ttu-id="e9a0c-113">Zakodowany tekst JSON w formacie UTF-8.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-113">The UTF-8 encoded JSON text to process.</span></span></param>
        <param name="options"><span data-ttu-id="e9a0c-114">Obiekt, który definiuje dostosowane zachowanie <see cref="T:System.Text.Json.Utf8JsonReader" /> , które różni się od specyfikacji RFC JSON (na przykład jak obsługiwać komentarze lub maksymalną głębokość dozwoloną podczas czytania).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-114">An object that defines customized behavior of the <see cref="T:System.Text.Json.Utf8JsonReader" /> that differs from the JSON RFC (for example how to handle comments or maximum depth allowed when reading).</span></span> <span data-ttu-id="e9a0c-115">Domyślnie <see cref="T:System.Text.Json.Utf8JsonReader" /> następujące komentarze w formacie JSON RFC są prawidłowe, a maksymalna głębokość to 64.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-115">By default, the <see cref="T:System.Text.Json.Utf8JsonReader" /> follows the JSON RFC strictly; comments within the JSON are invalid, and the maximum depth is 64.</span></span></param>
        <summary><span data-ttu-id="e9a0c-116">Inicjuje nowe wystąpienie <see cref="T:System.Text.Json.Utf8JsonReader" /> struktury, które przetwarza w trybie tylko do odczytu tekst zakodowany UTF-8 przy użyciu określonych opcji.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-116">Initializes a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> structure that processes a read-only span of UTF-8 encoded text using the specified options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-117">Ponieważ ten typ jest strukturą ref, jest to typ tylko stosu, a wszystkie ograniczenia dotyczące struktur ref mają zastosowanie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-117">Since this type is a ref struct, it is a stack-only type, and all the limitations of ref structs apply to it.</span></span>

<span data-ttu-id="e9a0c-118">W tym konstruktorze przyjęto założenie, że cały `jsonData`ładunek JSON jest zawarty w <xref:System.Text.Json.Utf8JsonReader.IsFinalBlock?displayProperty=nameWithType> `true`. jest to  = odpowiednik.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-118">This constructor assumes that the entire JSON payload is contained in `jsonData`; it is equivalent to <xref:System.Text.Json.Utf8JsonReader.IsFinalBlock?displayProperty=nameWithType> = `true`.</span></span>
              
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (System.Buffers.ReadOnlySequence&lt;byte&gt; jsonData, bool isFinalBlock, System.Text.Json.JsonReaderState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; jsonData, bool isFinalBlock, valuetype System.Text.Json.JsonReaderState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySequence(Of Byte), isFinalBlock As Boolean, state As JsonReaderState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Utf8JsonReader(System::Buffers::ReadOnlySequence&lt;System::Byte&gt; jsonData, bool isFinalBlock, System::Text::Json::JsonReaderState state);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : System.Buffers.ReadOnlySequence&lt;byte&gt; * bool * System.Text.Json.JsonReaderState -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, isFinalBlock, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.Buffers.ReadOnlySequence&lt;System.Byte&gt;" />
        <Parameter Name="isFinalBlock" Type="System.Boolean" />
        <Parameter Name="state" Type="System.Text.Json.JsonReaderState" />
      </Parameters>
      <Docs>
        <param name="jsonData"><span data-ttu-id="e9a0c-119">Zakodowany tekst JSON w formacie UTF-8.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-119">The UTF-8 encoded JSON text to process.</span></span></param>
        <param name="isFinalBlock"><span data-ttu-id="e9a0c-120"><see langword="true" />Jeśli sekwencja wejściowa zawiera wszystkie dane do przetworzenia; <see langword="false" /> tylko zakres wejściowy zawiera dane częściowe zawierające więcej danych do wykonania.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-120"><see langword="true" /> if the input sequence contains the entire data to process; <see langword="false" /> only the input span contains partial data with more data to follow.</span></span></param>
        <param name="state"><span data-ttu-id="e9a0c-121">Obiekt, który zawiera stan czytnika.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-121">An object that contains the reader state.</span></span> <span data-ttu-id="e9a0c-122">Jeśli jest to pierwsze wywołanie konstruktora, należy przekazać stan domyślny.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-122">If this is the first call to the constructor, pass in a default state.</span></span> <span data-ttu-id="e9a0c-123">W przeciwnym razie Przechwyć stan z poprzedniego wystąpienia <see cref="T:System.Text.Json.Utf8JsonReader" /> i przekaż go ponownie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-123">Otherwise, capture the state from the previous instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> and pass that back.</span></span></param>
        <summary><span data-ttu-id="e9a0c-124">Inicjuje nowe wystąpienie <see cref="T:System.Text.Json.Utf8JsonReader" /> struktury, które przetwarza sekwencję tylko do odczytu zakodowanego tekstu UTF-8 i wskazuje, czy dane wejściowe zawierają cały tekst do przetworzenia.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-124">Initializes a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> structure that processes a read-only sequence of UTF-8 encoded text and indicates whether the input contains all the text to process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-125">Ponieważ ten typ jest strukturą ref, jest to typ tylko stosu, a wszystkie ograniczenia dotyczące struktur ref mają zastosowanie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-125">Since this type is a ref struct, it is a stack-only type, and all the limitations of ref structs apply to it.</span></span>
<span data-ttu-id="e9a0c-126">Jest to powód, dla którego Konstruktor akceptuje <xref:System.Text.Json.JsonReaderState>.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-126">This is the reason why the constructor accepts a <xref:System.Text.Json.JsonReaderState>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (ReadOnlySpan&lt;byte&gt; jsonData, bool isFinalBlock, System.Text.Json.JsonReaderState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; jsonData, bool isFinalBlock, valuetype System.Text.Json.JsonReaderState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySpan(Of Byte), isFinalBlock As Boolean, state As JsonReaderState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Utf8JsonReader(ReadOnlySpan&lt;System::Byte&gt; jsonData, bool isFinalBlock, System::Text::Json::JsonReaderState state);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : ReadOnlySpan&lt;byte&gt; * bool * System.Text.Json.JsonReaderState -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, isFinalBlock, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isFinalBlock" Type="System.Boolean" />
        <Parameter Name="state" Type="System.Text.Json.JsonReaderState" />
      </Parameters>
      <Docs>
        <param name="jsonData"><span data-ttu-id="e9a0c-127">Zakodowany tekst JSON w formacie UTF-8.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-127">The UTF-8 encoded JSON text to process.</span></span></param>
        <param name="isFinalBlock"><span data-ttu-id="e9a0c-128"><see langword="true" />Jeśli sekwencja wejściowa zawiera wszystkie dane do przetworzenia; <see langword="false" /> Jeśli zakres wejściowy zawiera dane częściowe zawierające więcej danych do wykonania.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-128"><see langword="true" /> if the input sequence contains the entire data to process; <see langword="false" /> if the input span contains partial data with more data to follow.</span></span></param>
        <param name="state"><span data-ttu-id="e9a0c-129">Obiekt, który zawiera stan czytnika.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-129">An object that contains the reader state.</span></span> <span data-ttu-id="e9a0c-130">Jeśli jest to pierwsze wywołanie konstruktora, powinno ono odzwierciedlać stan domyślny; w przeciwnym razie należy przechwycić stan z poprzedniego wystąpienia <see cref="T:System.Text.Json.Utf8JsonReader" /> wystąpienia i przekazać go ponownie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-130">If it's the first call to the constructor, it should reflect a default state; otherwise, it should capture the state from the previous instance instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> and pass that back.</span></span></param>
        <summary><span data-ttu-id="e9a0c-131">Inicjuje nowe wystąpienie <see cref="T:System.Text.Json.Utf8JsonReader" /> struktury, które przetwarza zakres danych szyfrowanych tylko do odczytu w formacie UTF-8 i wskazuje, czy dane wejściowe zawierają cały tekst do przetworzenia.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-131">Initializes a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> structure that processes a read-only span of UTF-8 encoded text and indicates whether the input contains all the text to process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-132">Ponieważ ten typ jest strukturą ref, jest to typ tylko stosu, a wszystkie ograniczenia dotyczące struktur ref mają zastosowanie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-132">Since this type is a ref struct, it is a stack-only type, and all the limitations of ref structs apply to it.</span></span>
<span data-ttu-id="e9a0c-133">Jest to powód, dla którego Konstruktor akceptuje <xref:System.Text.Json.JsonReaderState>.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-133">This is the reason why the constructor accepts a <xref:System.Text.Json.JsonReaderState>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BytesConsumed">
      <MemberSignature Language="C#" Value="public long BytesConsumed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 BytesConsumed" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.BytesConsumed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesConsumed As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long BytesConsumed { long get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesConsumed : int64" Usage="System.Text.Json.Utf8JsonReader.BytesConsumed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9a0c-134">Pobiera łączną liczbę bajtów zużytych do tej pory dla tego wystąpienia <see cref="T:System.Text.Json.Utf8JsonReader" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-134">Gets the total number of bytes consumed so far by this instance of the <see cref="T:System.Text.Json.Utf8JsonReader" />.</span></span></summary>
        <value><span data-ttu-id="e9a0c-135">Całkowita liczba bajtów zużytych do tej pory.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-135">The total number of bytes consumed so far.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDepth">
      <MemberSignature Language="C#" Value="public int CurrentDepth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.CurrentDepth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentDepth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDepth : int" Usage="System.Text.Json.Utf8JsonReader.CurrentDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9a0c-136">Pobiera głębokość bieżącego tokenu.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-136">Gets the depth of the current token.</span></span></summary>
        <value><span data-ttu-id="e9a0c-137">Głębokość bieżącego tokenu.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-137">The depth of the current token.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-138">`CurrentDepth` Właściwość śledzi głębokość rekursywną zagnieżdżonych obiektów lub tablic w ramach przetworzonej do tej pory tekstu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-138">The `CurrentDepth` property tracks the recursive depth of the nested objects or arrays within the JSON text processed so far.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentState">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonReaderState CurrentState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonReaderState CurrentState" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.CurrentState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentState As JsonReaderState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonReaderState CurrentState { System::Text::Json::JsonReaderState get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentState : System.Text.Json.JsonReaderState" Usage="System.Text.Json.Utf8JsonReader.CurrentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonReaderState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9a0c-139">Pobiera bieżący <see cref="T:System.Text.Json.Utf8JsonReader" /> stan do przekazania <see cref="T:System.Text.Json.Utf8JsonReader" /> do konstruktora o większej ilości danych.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-139">Gets the current <see cref="T:System.Text.Json.Utf8JsonReader" /> state to pass to a <see cref="T:System.Text.Json.Utf8JsonReader" /> constructor with more data.</span></span></summary>
        <value><span data-ttu-id="e9a0c-140">Bieżący stan czytnika.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-140">The current reader state.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-141">W przeciwieństwie <xref:System.Text.Json.Utf8JsonReader>do, który jest strukturą ref, stan może być przechodzący przez granice asynchroniczne/oczekujące.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-141">Unlike the <xref:System.Text.Json.Utf8JsonReader>, which is a ref struct, the state can survive across async/await boundaries.</span></span> <span data-ttu-id="e9a0c-142">Ten typ jest wymagany w celu zapewnienia obsługi odczytywania więcej danych asynchronicznie przed kontynuowaniem nowego wystąpienia <xref:System.Text.Json.Utf8JsonReader>.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-142">This type is required to provide support for reading in more data asynchronously before continuing with a new instance of the <xref:System.Text.Json.Utf8JsonReader>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public bool GetBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetBoolean();" />
      <MemberSignature Language="F#" Value="member this.GetBoolean : unit -&gt; bool" Usage="utf8JsonReader.GetBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-143">Odczytuje następną wartość tokenu JSON ze źródła jako <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-143">Reads the next JSON token value from the source as a <see cref="T:System.Boolean" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-144"><see langword="true" /><see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> jeśli jest ;<see cref="F:System.Text.Json.JsonTokenType.True" /> <see langword="false" /> Jeśli jest.<see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> <see cref="F:System.Text.Json.JsonTokenType.False" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-144"><see langword="true" /> if the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.True" />; <see langword="false" /> if the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.False" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-145">Wartość tokenu JSON nie jest wartością logiczną ( <see cref="F:System.Text.Json.JsonTokenType.True" /> czyli lub <see cref="F:System.Text.Json.JsonTokenType.False" />).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-145">The value of the JSON token isn't a boolean value (that is, <see cref="F:System.Text.Json.JsonTokenType.True" /> or <see cref="F:System.Text.Json.JsonTokenType.False" />).</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public byte GetByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8 GetByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetByte" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByte () As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Byte GetByte();" />
      <MemberSignature Language="F#" Value="member this.GetByte : unit -&gt; byte" Usage="utf8JsonReader.GetByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-146">Analizuje bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.Byte" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-146">Parses the current JSON token value from the source as a <see cref="T:System.Byte" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-147">Wartość zakodowanego tokenu UTF-8.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-147">The value of the UTF-8 encoded token.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-148">Wartość tokenu JSON nie <see cref="F:System.Text.Json.JsonTokenType.Number" />jest.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-148">The value of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-149">Format liczbowy wartości tokenu JSON jest niepoprawny (na przykład zawiera wartość ułamkową lub jest zapisywana w notacji wykładniczej).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-149">The numeric format of the JSON token value is incorrect (for example, it contains a fractional value or is written in scientific notation).</span></span>
          
<span data-ttu-id="e9a0c-150">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-150">-or-</span></span>

<span data-ttu-id="e9a0c-151">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.Byte.MinValue" /> lub większą od. <see cref="F:System.Byte.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-151">The JSON token value represents a number less than <see cref="F:System.Byte.MinValue" /> or greater than <see cref="F:System.Byte.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytesFromBase64">
      <MemberSignature Language="C#" Value="public byte[] GetBytesFromBase64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytesFromBase64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetBytesFromBase64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytesFromBase64 () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytesFromBase64();" />
      <MemberSignature Language="F#" Value="member this.GetBytesFromBase64 : unit -&gt; byte[]" Usage="utf8JsonReader.GetBytesFromBase64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-152">Analizuje bieżącą wartość tokenu JSON ze źródła i Dekoduje ciąg JSON zakodowany w formacie base64 jako tablicę bajtów.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-152">Parses the current JSON token value from the source and decodes the Base64 encoded JSON string as a byte array.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-153">Tablica bajtów reprezentująca bieżącą wartość tokenu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-153">The byte array that represents the current JSON token value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-154">Typ tokenu JSON nie <see cref="F:System.Text.Json.JsonTokenType.String" />jest.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-154">The type of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-155">Wartość nie jest zakodowana jako tekst Base64, dlatego nie można zdekodować jej do bajtów.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-155">The value is not encoded as Base64 text, so it can't be decoded to bytes.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetComment">
      <MemberSignature Language="C#" Value="public string GetComment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetComment" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComment () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComment();" />
      <MemberSignature Language="F#" Value="member this.GetComment : unit -&gt; string" Usage="utf8JsonReader.GetComment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-156">Analizuje bieżącą wartość tokenu JSON ze źródła jako komentarz, transkodowanego jako <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-156">Parses the current JSON token value from the source as a comment, transcoded it as a <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-157">Komentarz reprezentujący bieżącą wartość tokenu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-157">The comment that represents the current JSON token value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-158">Token JSON nie jest komentarzem.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-158">The JSON token is not a comment.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public DateTime GetDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetDateTime();" />
      <MemberSignature Language="F#" Value="member this.GetDateTime : unit -&gt; DateTime" Usage="utf8JsonReader.GetDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-159">Odczytuje następną wartość tokenu JSON ze źródła i analizuje ją w <see cref="T:System.DateTime" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-159">Reads the next JSON token value from the source and parses it to a <see cref="T:System.DateTime" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-160">Data i godzina, jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-160">The date and time, if the entire UTF-8 encoded token value can be successfully parsed.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-161">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.String" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-161">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-162">Wartość tokenu JSON ma nieobsługiwany format.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-162">The JSON token value is in an unsupported format.</span></span> <span data-ttu-id="e9a0c-163">Obsługiwane są tylko podzbiór formatów ISO 8601.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-163">Only a subset of ISO 8601 formats are supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeOffset">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetDateTimeOffset();" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeOffset : unit -&gt; DateTimeOffset" Usage="utf8JsonReader.GetDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-164">Odczytuje następną wartość tokenu JSON ze źródła i analizuje ją w <see cref="T:System.DateTimeOffset" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-164">Reads the next JSON token value from the source and parses it to a <see cref="T:System.DateTimeOffset" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-165">Wartość daty i godziny, jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-165">The date and time value, if the entire UTF-8 encoded token value can be successfully parsed.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-166">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.String" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-166">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-167">Wartość tokenu JSON ma nieobsługiwany format.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-167">The JSON token value is in an unsupported format.</span></span> <span data-ttu-id="e9a0c-168">Obsługiwane są tylko podzbiór formatów ISO 8601.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-168">Only a subset of ISO 8601 formats are supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public decimal GetDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Decimal GetDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Decimal GetDecimal();" />
      <MemberSignature Language="F#" Value="member this.GetDecimal : unit -&gt; decimal" Usage="utf8JsonReader.GetDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-169">Odczytuje następną wartość tokenu JSON ze źródła i analizuje ją w <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-169">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Decimal" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-170">Wartość tokenu zakodowanego UTF-8 przeanalizowana na <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-170">The UTF-8 encoded token value parsed to a <see cref="T:System.Decimal" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-171">Metoda zgłasza wyjątek, jeśli cała nie można wartość tokenu zakodowana w formacie UTF-8 zostanie przeanalizowana <xref:System.Decimal> na wartość. `GetDecimal`</span><span class="sxs-lookup"><span data-stu-id="e9a0c-171">The `GetDecimal` method throws an exception if the entire UTF-8 encoded token value cannnot be parsed to a <xref:System.Decimal> value.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-172">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-172">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-173">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.Decimal.MinValue" /> lub większą od. <see cref="F:System.Decimal.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-173">The JSON token value represents a number less than <see cref="F:System.Decimal.MinValue" /> or greater than <see cref="F:System.Decimal.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public double GetDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDouble" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetDouble();" />
      <MemberSignature Language="F#" Value="member this.GetDouble : unit -&gt; double" Usage="utf8JsonReader.GetDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-174">Odczytuje następną wartość tokenu JSON ze źródła i analizuje ją w <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-174">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-175">Wartość tokenu zakodowanego UTF-8 przeanalizowana na <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-175">The UTF-8 encoded token value parsed to a <see cref="T:System.Double" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-176">Metoda zgłasza wyjątek, jeśli cała nie można wartość tokenu zakodowana w formacie UTF-8 zostanie przeanalizowana <xref:System.Double> na wartość. `GetDouble`</span><span class="sxs-lookup"><span data-stu-id="e9a0c-176">The `GetDouble` method throws an exception if the entire UTF-8 encoded token value cannnot be parsed to a <xref:System.Double> value.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-177">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-177">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-178">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.Double.MinValue" /> lub większą od. <see cref="F:System.Double.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-178">The JSON token value represents a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public Guid GetGuid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Guid GetGuid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetGuid" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGuid () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid GetGuid();" />
      <MemberSignature Language="F#" Value="member this.GetGuid : unit -&gt; Guid" Usage="utf8JsonReader.GetGuid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-179">Odczytuje następną wartość tokenu JSON ze źródła i analizuje ją w <see cref="T:System.Guid" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-179">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Guid" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-180">Wartość identyfikatora GUID, jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-180">The GUID value, if the entire UTF-8 encoded token value can be successfully parsed.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-181">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.String" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-181">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-182">Wartość tokenu JSON ma nieobsługiwany format dla identyfikatora GUID.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-182">The JSON token value is in an unsupported format for a Guid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public short GetInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int16 GetInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt16" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt16 () As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; short GetInt16();" />
      <MemberSignature Language="F#" Value="member this.GetInt16 : unit -&gt; int16" Usage="utf8JsonReader.GetInt16 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-183">Analizuje bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.Int16" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-183">Parses the current JSON token value from the source as a <see cref="T:System.Int16" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-184">Wartość tokenu zakodowanego UTF-8 przeanalizowana na <see cref="T:System.Int16" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-184">The UTF-8 encoded token value parsed to an <see cref="T:System.Int16" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-185">Wartość tokenu JSON nie <see cref="F:System.Text.Json.JsonTokenType.Number" />jest.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-185">The value of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-186">Format liczbowy wartości tokenu JSON jest niepoprawny (na przykład zawiera wartość ułamkową lub jest zapisywana w notacji wykładniczej).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-186">The numeric format of the JSON token value is incorrect (for example, it contains a fractional value or is written in scientific notation).</span></span>
          
<span data-ttu-id="e9a0c-187">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-187">-or-</span></span>

<span data-ttu-id="e9a0c-188">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.Int16.MinValue" /> lub większą od. <see cref="F:System.Int16.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-188">The JSON token value represents a number less than <see cref="F:System.Int16.MinValue" /> or greater than <see cref="F:System.Int16.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public int GetInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetInt32();" />
      <MemberSignature Language="F#" Value="member this.GetInt32 : unit -&gt; int" Usage="utf8JsonReader.GetInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-189">Odczytuje następną wartość tokenu JSON ze źródła i analizuje ją do <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-189">Reads the next JSON token value from the source and parses it to an <see cref="T:System.Int32" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-190">Wartość tokenu zakodowanego UTF-8 przeanalizowana na <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-190">The UTF-8 encoded token value parsed to an <see cref="T:System.Int32" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-191">Metoda zgłasza wyjątek, jeśli cała nie można wartość tokenu zakodowana w formacie UTF-8 zostanie przeanalizowana <xref:System.Int32> na wartość. `GetInt32`</span><span class="sxs-lookup"><span data-stu-id="e9a0c-191">The `GetInt32` method throws an exception if the entire UTF-8 encoded token value cannnot be parsed to a <xref:System.Int32> value.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-192">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-192">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-193">Wartość tokenu JSON jest w nieprawidłowym formacie liczbowym.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-193">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="e9a0c-194">Na przykład zawiera wartość dziesiętną lub jest zapisywana w notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-194">For example, it contains a decimal or is written in scientific notation.</span></span>
            
<span data-ttu-id="e9a0c-195">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-195">-or-</span></span>

<span data-ttu-id="e9a0c-196">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.Int32.MinValue" /> lub większą od. <see cref="F:System.Int32.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-196">The JSON token value represents a number less than <see cref="F:System.Int32.MinValue" /> or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public long GetInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetInt64();" />
      <MemberSignature Language="F#" Value="member this.GetInt64 : unit -&gt; int64" Usage="utf8JsonReader.GetInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-197">Odczytuje następną wartość tokenu JSON ze źródła i analizuje ją do <see cref="T:System.Int64" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-197">Reads the next JSON token value from the source and parses it to an <see cref="T:System.Int64" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-198">Wartość tokenu zakodowanego UTF-8 przeanalizowana na <see cref="T:System.Int64" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-198">The UTF-8 encoded token value parsed to an <see cref="T:System.Int64" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-199">Metoda zgłasza wyjątek, jeśli cała nie można wartość tokenu zakodowana w formacie UTF-8 zostanie przeanalizowana <xref:System.Int64> na wartość. `GetInt64`</span><span class="sxs-lookup"><span data-stu-id="e9a0c-199">The `GetInt64` method throws an exception if the entire UTF-8 encoded token value cannnot be parsed to a <xref:System.Int64> value.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-200">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-200">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-201">Wartość tokenu JSON jest w nieprawidłowym formacie liczbowym.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-201">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="e9a0c-202">Na przykład zawiera wartość dziesiętną lub jest zapisywana w notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-202">For example, it contains a decimal or is written in scientific notation.</span></span>
            
<span data-ttu-id="e9a0c-203">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-203">-or-</span></span>

<span data-ttu-id="e9a0c-204">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.Int64.MinValue" /> lub większą od. <see cref="F:System.Int64.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-204">The JSON token value represents a number less than <see cref="F:System.Int64.MinValue" /> or greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetSByte">
      <MemberSignature Language="C#" Value="public sbyte GetSByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int8 GetSByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetSByte" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSByte () As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::SByte GetSByte();" />
      <MemberSignature Language="F#" Value="member this.GetSByte : unit -&gt; sbyte" Usage="utf8JsonReader.GetSByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-205">Analizuje bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.SByte" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-205">Parses the current JSON token value from the source as an <see cref="T:System.SByte" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-206">Wartość tokenu zakodowanego UTF-8 przeanalizowana na <see cref="T:System.SByte" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-206">The UTF-8 encoded token value parsed to an <see cref="T:System.SByte" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-207">Wartość tokenu JSON nie <see cref="F:System.Text.Json.JsonTokenType.Number" />jest.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-207">The value of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-208">Format liczbowy wartości tokenu JSON jest niepoprawny (na przykład zawiera wartość ułamkową lub jest zapisywana w notacji wykładniczej).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-208">The numeric format of the JSON token value is incorrect (for example, it contains a fractional value or is written in scientific notation).</span></span>
          
<span data-ttu-id="e9a0c-209">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-209">-or-</span></span>

<span data-ttu-id="e9a0c-210">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.SByte.MinValue" /> lub większą od. <see cref="F:System.SByte.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-210">The JSON token value represents a number less than <see cref="F:System.SByte.MinValue" /> or greater than <see cref="F:System.SByte.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetSingle">
      <MemberSignature Language="C#" Value="public float GetSingle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 GetSingle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetSingle" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSingle () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float GetSingle();" />
      <MemberSignature Language="F#" Value="member this.GetSingle : unit -&gt; single" Usage="utf8JsonReader.GetSingle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-211">Odczytuje następną wartość tokenu JSON ze źródła i analizuje ją w <see cref="T:System.Single" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-211">Reads the next JSON token value from the source and parses it to a <see cref="T:System.Single" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-212">Wartość tokenu zakodowanego UTF-8 przeanalizowana na <see cref="T:System.Single" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-212">The UTF-8 encoded token value parsed to a <see cref="T:System.Single" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-213">Metoda zgłasza wyjątek, jeśli cała nie można wartość tokenu zakodowana w formacie UTF-8 zostanie przeanalizowana <xref:System.Single> na wartość. `GetSingle`</span><span class="sxs-lookup"><span data-stu-id="e9a0c-213">The `GetSingle` method throws an exception if the entire UTF-8 encoded token value cannnot be parsed to a <xref:System.Single> value.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-214">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-214">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-215">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.Single.MinValue" /> lub większą od. <see cref="F:System.Single.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-215">The JSON token value represents a number less than <see cref="F:System.Single.MinValue" /> or greater than <see cref="F:System.Single.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString();" />
      <MemberSignature Language="F#" Value="member this.GetString : unit -&gt; string" Usage="utf8JsonReader.GetString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-216">Odczytuje następną wartość tokenu JSON ze źródła, w niezmienionym kodzie i poddanej kodowi jako ciąg.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-216">Reads the next JSON token value from the source, unescaped, and transcoded as a string.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-217">Wartość tokenu przeanalizowana na ciąg lub <see langword="null" /> Jeśli <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> jest <see cref="F:System.Text.Json.JsonTokenType.Null" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-217">The token value parsed to a string, or <see langword="null" /> if <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.Null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-218">Wartość tokenu JSON nie jest ciągiem (to nie <see cref="F:System.Text.Json.JsonTokenType.String" /> jest ani lub <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-218">The JSON token value isn't a string (that is, not a <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span></span>

<span data-ttu-id="e9a0c-219">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-219">-or-</span></span>

<span data-ttu-id="e9a0c-220">Ciąg JSON zawiera nieprawidłowe bajty UTF-8 lub nieprawidłowe surogaty UTF-16.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-220">The JSON string contains invalid UTF-8 bytes or invalid UTF-16 surrogates.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt16">
      <MemberSignature Language="C#" Value="public ushort GetUInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int16 GetUInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt16" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt16 () As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt16 GetUInt16();" />
      <MemberSignature Language="F#" Value="member this.GetUInt16 : unit -&gt; uint16" Usage="utf8JsonReader.GetUInt16 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-221">Analizuje bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.UInt16" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-221">Parses the current JSON token value from the source as a <see cref="T:System.UInt16" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-222">Wartość tokenu zakodowanego UTF-8 przeanalizowana na <see cref="T:System.UInt16" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-222">The UTF-8 encoded token value parsed to a <see cref="T:System.UInt16" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-223">Wartość tokenu JSON nie <see cref="F:System.Text.Json.JsonTokenType.Number" />jest.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-223">The value of the JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-224">Format liczbowy wartości tokenu JSON jest niepoprawny (na przykład zawiera wartość ułamkową lub jest zapisywana w notacji wykładniczej).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-224">The numeric format of the JSON token value is incorrect (for example, it contains a fractional value or is written in scientific notation).</span></span>
          
<span data-ttu-id="e9a0c-225">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-225">-or-</span></span>

<span data-ttu-id="e9a0c-226">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.UInt16.MinValue" /> lub większą od. <see cref="F:System.UInt16.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-226">The JSON token value represents a number less than <see cref="F:System.UInt16.MinValue" /> or greater than <see cref="F:System.UInt16.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetUInt32">
      <MemberSignature Language="C#" Value="public uint GetUInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int32 GetUInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt32 () As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt32 GetUInt32();" />
      <MemberSignature Language="F#" Value="member this.GetUInt32 : unit -&gt; uint32" Usage="utf8JsonReader.GetUInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-227">Odczytuje następną wartość tokenu JSON ze źródła i analizuje ją w <see cref="T:System.UInt32" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-227">Reads the next JSON token value from the source and parses it to a <see cref="T:System.UInt32" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-228">Wartość tokenu zakodowanego UTF-8 przeanalizowana na <see cref="T:System.UInt32" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-228">The UTF-8 encoded token value parsed to a <see cref="T:System.UInt32" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-229">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-229">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-230">Wartość tokenu JSON jest w nieprawidłowym formacie liczbowym.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-230">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="e9a0c-231">Na przykład zawiera wartość dziesiętną lub jest zapisywana w notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-231">For example, it contains a decimal or is written in scientific notation.</span></span>

<span data-ttu-id="e9a0c-232">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-232">-or-</span></span>

<span data-ttu-id="e9a0c-233">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.UInt32.MinValue" /> lub większą od. <see cref="F:System.UInt32.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-233">The JSON token value represents a number less than <see cref="F:System.UInt32.MinValue" /> or greater than <see cref="F:System.UInt32.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt64">
      <MemberSignature Language="C#" Value="public ulong GetUInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int64 GetUInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt64 () As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt64 GetUInt64();" />
      <MemberSignature Language="F#" Value="member this.GetUInt64 : unit -&gt; uint64" Usage="utf8JsonReader.GetUInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-234">Odczytuje następną wartość tokenu JSON ze źródła i analizuje ją w <see cref="T:System.UInt64" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-234">Reads the next JSON token value from the source and parses it to a <see cref="T:System.UInt64" />.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-235">Wartość tokenu zakodowanego UTF-8 przeanalizowana na <see cref="T:System.UInt64" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-235">The UTF-8 encoded token value parsed to a <see cref="T:System.UInt64" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-236">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-236">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="e9a0c-237">Wartość tokenu JSON jest w nieprawidłowym formacie liczbowym.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-237">The JSON token value is of the incorrect numeric format.</span></span> <span data-ttu-id="e9a0c-238">Na przykład zawiera wartość dziesiętną lub jest zapisywana w notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-238">For example, it contains a decimal or is written in scientific notation.</span></span>
            
<span data-ttu-id="e9a0c-239">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-239">-or-</span></span>

<span data-ttu-id="e9a0c-240">Wartość tokenu JSON reprezentuje liczbę mniejszą <see cref="F:System.UInt64.MinValue" /> lub większą od. <see cref="F:System.UInt64.MaxValue" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-240">The JSON token value represents a number less than <see cref="F:System.UInt64.MinValue" /> or greater than <see cref="F:System.UInt64.MaxValue" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="HasValueSequence">
      <MemberSignature Language="C#" Value="public bool HasValueSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValueSequence" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.HasValueSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValueSequence As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValueSequence { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValueSequence : bool" Usage="System.Text.Json.Utf8JsonReader.HasValueSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9a0c-241">Pobiera wartość wskazującą Właściwość <c>Value</c> , która ma zostać użyta do pobrania wartości tokenu.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-241">Gets a value that indicates which <c>Value</c> property to use to get the token value.</span></span></summary>
        <value><span data-ttu-id="e9a0c-242"><see langword="true" />Jeśli <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> należy użyć, aby uzyskać wartość tokenu; <see langword="false" /> Jeśli<see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> zamiast tego należy użyć.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-242"><see langword="true" /> if <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> should be used to get the token value; <see langword="false" /> if <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> should be used instead.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-243">Jeśli `HasValueSequence` jest `false` ,<xref:System.Text.Json.Utf8JsonReader.ValueSequence> jest puste.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-243">If `HasValueSequence` is `false`, <xref:System.Text.Json.Utf8JsonReader.ValueSequence> is empty.</span></span> <span data-ttu-id="e9a0c-244">W związku z tym należy odczytać wartość tokenu <xref:System.Text.Json.Utf8JsonReader.ValueSpan> przy użyciu właściwości.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-244">Therefore, read the token value using the <xref:System.Text.Json.Utf8JsonReader.ValueSpan> property.</span></span>

<span data-ttu-id="e9a0c-245">W przypadku danych wejściowych w `ReadOnlySpan<byte>`, to zawsze zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-245">For input data within a `ReadOnlySpan<byte>`, this always returns `false`.</span></span> <span data-ttu-id="e9a0c-246">W przypadku danych wejściowych w `ReadOnlySequence<byte>`ramach, to zwraca `true` tylko wtedy, gdy wartość tokenu mieści się w przedziale więcej niż jeden segment i dlatego nie może być reprezentowana jako zakres.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-246">For input data within a `ReadOnlySequence<byte>`, this only returns `true` if the token value straddles more than a single segment and hence can't be represented as a span.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalBlock">
      <MemberSignature Language="C#" Value="public bool IsFinalBlock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinalBlock" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinalBlock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinalBlock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFinalBlock : bool" Usage="System.Text.Json.Utf8JsonReader.IsFinalBlock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9a0c-247">Pobiera tryb tego wystąpienia, <see cref="T:System.Text.Json.Utf8JsonReader" /> który wskazuje, czy zostały dostarczone wszystkie dane JSON, czy też jest więcej danych.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-247">Gets the mode of this instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> which indicates whether all the JSON data was provided or there is more data to come.</span></span></summary>
        <value><span data-ttu-id="e9a0c-248"><see langword="true" />Jeśli czytelnik został skonstruowany z zakresem wejściowym lub sekwencją zawierającą całe dane JSON do przetworzenia; <see langword="false" /> jeśli czytelnik został skonstruowany z zakresem wejściowym lub sekwencją, która może zawierać częściowe dane JSON zawierające więcej danych do wykonania.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-248"><see langword="true" /> if the reader was constructed with the input span or sequence containing the entire JSON data to process; <see langword="false" /> if the reader was constructed with an input span or sequence that may contain partial JSON data with more data to follow.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public SequencePosition Position { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.SequencePosition Position" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.Position" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Position As SequencePosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property SequencePosition Position { SequencePosition get(); };" />
      <MemberSignature Language="F#" Value="member this.Position : SequencePosition" Usage="System.Text.Json.Utf8JsonReader.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SequencePosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9a0c-249">Pobiera bieżącą <see cref="T:System.SequencePosition" /> wartość w ramach dostarczonego bajtu&gt; ReadOnlySequence&lt;wejściowego UTF-8 lub <see cref="T:System.SequencePosition" /> wartość domyślną <see cref="T:System.Text.Json.Utf8JsonReader" /> , jeśli struktura została skonstruowana przy użyciu bajtu ReadOnlySpan&lt;&gt;.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-249">Gets the current <see cref="T:System.SequencePosition" /> within the provided UTF-8 encoded input ReadOnlySequence&lt;byte&gt; or a default <see cref="T:System.SequencePosition" /> if the <see cref="T:System.Text.Json.Utf8JsonReader" /> struct was constructed with a ReadOnlySpan&lt;byte&gt;.</span></span></summary>
        <value><span data-ttu-id="e9a0c-250"><see cref="T:System.SequencePosition" /> Bieżący w ramach dostarczonego bajtu <see cref="T:System.Text.Json.Utf8JsonReader" /> <see cref="T:System.SequencePosition" /> &gt; ReadOnlySequence&lt;wejściowego UTF-8 lub wartość domyślna, jeśli struktura została skonstruowana przy&lt;użyciu&gt;bajtu ReadOnlySpan.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-250">The current <see cref="T:System.SequencePosition" /> within the provided UTF-8 encoded input ReadOnlySequence&lt;byte&gt; or a default <see cref="T:System.SequencePosition" /> if the <see cref="T:System.Text.Json.Utf8JsonReader" /> struct was constructed with a ReadOnlySpan&lt;byte&gt;.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Read();" />
      <MemberSignature Language="F#" Value="member this.Read : unit -&gt; bool" Usage="utf8JsonReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-251">Odczytuje następny token JSON ze źródła danych wejściowych.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-251">Reads the next JSON token from the input source.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-252"><see langword="true" />Jeśli token został odczytany pomyślnie; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-252"><see langword="true" /> if the token was read successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Text.Json.JsonException"><span data-ttu-id="e9a0c-253">Napotkano nieprawidłowy token JSON zgodnie ze specyfikacją RFC JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-253">An invalid JSON token according to the JSON RFC is encountered.</span></span>
        
<span data-ttu-id="e9a0c-254">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-254">-or-</span></span>

<span data-ttu-id="e9a0c-255">Bieżąca głębokość przekracza limit cykliczny określony przez maksymalną głębokość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-255">The current depth exceeds the recursive limit set by the maximum depth.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Skip();" />
      <MemberSignature Language="F#" Value="member this.Skip : unit -&gt; unit" Usage="utf8JsonReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-256">Pomija elementy podrzędne bieżącego tokenu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-256">Skips the children of the current JSON token.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-257">Gdy <xref:System.Text.Json.Utf8JsonReader.TokenType> jest<xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>, czytnik najpierw przenosi do wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-257">When <xref:System.Text.Json.Utf8JsonReader.TokenType> is <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>, the reader first moves to the property value.</span></span>

<span data-ttu-id="e9a0c-258">Gdy <xref:System.Text.Json.Utf8JsonReader.TokenType> (pierwotnie lub po przejściu) to <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithtype> lub <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>, czytnik postępuje do dopasowania <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> lub <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-258">When <xref:System.Text.Json.Utf8JsonReader.TokenType> (originally, or after advancing) is <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithtype> or  <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>, the reader advances to the matching <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>.</span></span>
            
<span data-ttu-id="e9a0c-259">Dla wszystkich innych typów tokenów czytnik nie jest przenoszony.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-259">For all other token types, the reader does not move.</span></span> <span data-ttu-id="e9a0c-260">Po następnym wywołaniu <xref:System.Text.Json.Utf8JsonReader.Read>, czytnik będzie miał następną wartość (gdy w tablicy), następną nazwę właściwości (w obiekcie) lub końcowym tokenem tablicy/obiektu.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-260">After the next call to <xref:System.Text.Json.Utf8JsonReader.Read>, the reader will be at the next value (when in an array), the next property name (when in an object), or the end array/object token.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-261">Czytelnik otrzymał dane częściowe z większą ilością danych, które należy wykonać (oznacza <see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> to <see langword="false" />, czy).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-261">The reader was given partial data with more data to follow (that is, <see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> is <see langword="false" />).</span></span></exception>
        <exception cref="T:System.Text.Json.JsonException"><span data-ttu-id="e9a0c-262">Podczas pomijania napotkano nieprawidłowy token JSON, zgodnie z dokumentem RFC JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-262">An invalid JSON token was encountered while skipping, according to the JSON RFC.</span></span>

<span data-ttu-id="e9a0c-263">—lub—</span><span class="sxs-lookup"><span data-stu-id="e9a0c-263">-or-</span></span>

<span data-ttu-id="e9a0c-264">Bieżąca głębokość przekracza limit cykliczny określony przez maksymalną głębokość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-264">The current depth exceeds the recursive limit set by the maximum depth.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TokenStartIndex">
      <MemberSignature Language="C#" Value="public long TokenStartIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 TokenStartIndex" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.TokenStartIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenStartIndex As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long TokenStartIndex { long get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenStartIndex : int64" Usage="System.Text.Json.Utf8JsonReader.TokenStartIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9a0c-265">Pobiera indeks, który zaczyna się od ostatniego przetworzonego tokenu JSON (w ramach danego tekstu wejściowego w formacie UTF-8), pomijając wszystkie białe znaki.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-265">Gets the index that the last processed JSON token starts at (within the given UTF-8 encoded input text), skipping any white space.</span></span></summary>
        <value><span data-ttu-id="e9a0c-266">Początkowy indeks ostatniego przetworzonego tokenu JSON w ramach danego tekstu wejściowego w formacie UTF-8.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-266">The starting index of the last processed JSON token within the given UTF-8 encoded input text.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-267">W przypadku ciągów JSON (w tym nazw właściwości) ta wartość wskazuje przed cudzysłowem początkowym.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-267">For JSON strings (including property names), this value points to before the start quote.</span></span>

<span data-ttu-id="e9a0c-268">W przypadku komentarzy ta wartość wskazuje przed pierwszym ogranicznikiem komentarza (czyli "/").</span><span class="sxs-lookup"><span data-stu-id="e9a0c-268">For comments, this value points to before the first comment delimiter (that is, '/').</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonTokenType TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonTokenType TokenType" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenType As JsonTokenType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonTokenType TokenType { System::Text::Json::JsonTokenType get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : System.Text.Json.JsonTokenType" Usage="System.Text.Json.Utf8JsonReader.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonTokenType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9a0c-269">Pobiera typ ostatniego przetworzonego tokenu JSON w zakodowanym tekście JSON w formacie UTF-8.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-269">Gets the type of the last processed JSON token in the UTF-8 encoded JSON text.</span></span></summary>
        <value><span data-ttu-id="e9a0c-270">Typ ostatniego przetworzonego tokenu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-270">The type of the last processed JSON token.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetByte">
      <MemberSignature Language="C#" Value="public bool TryGetByte (out byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetByte([out] unsigned int8&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetByte(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetByte (ByRef value As Byte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetByte([Runtime::InteropServices::Out] System::Byte % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetByte :  -&gt; bool" Usage="utf8JsonReader.TryGetByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-271">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-271">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-272">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.Byte" /> a i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-272">Tries to parse the current JSON token value from the source as a <see cref="T:System.Byte" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-273"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.Byte" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-273"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Byte" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-274">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-274">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetBytesFromBase64">
      <MemberSignature Language="C#" Value="public bool TryGetBytesFromBase64 (out byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetBytesFromBase64([out] unsigned int8[]&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetBytesFromBase64(System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetBytesFromBase64 (ByRef value As Byte()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetBytesFromBase64([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetBytesFromBase64 :  -&gt; bool" Usage="utf8JsonReader.TryGetBytesFromBase64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-275">Gdy ta metoda zwraca, zawiera zdekodowaną reprezentację binarnego tekstu Base64.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-275">When this method returns, contains the decoded binary representation of the Base64 text.</span></span></param>
        <summary><span data-ttu-id="e9a0c-276">Próbuje analizować bieżącą wartość tokenu JSON ze źródła i Dekoduje ciąg JSON zakodowany w formacie base64 jako tablicę bajtową i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-276">Tries to parse the current JSON token value from the source and decodes the Base64 encoded JSON string as a byte array and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-277"><see langword="true" />Jeśli cała wartość tokenu jest zakodowana jako prawidłowy tekst base64 i można ją pomyślnie zdekodować do bajtów; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-277"><see langword="true" /> if the entire token value is encoded as valid Base64 text and can be successfully decoded to bytes; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-278">Token JSON nie <see cref="F:System.Text.Json.JsonTokenType.String" />jest.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-278">The JSON token is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDateTime">
      <MemberSignature Language="C#" Value="public bool TryGetDateTime (out DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDateTime([out] valuetype System.DateTime&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDateTime(System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDateTime (ByRef value As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDateTime([Runtime::InteropServices::Out] DateTime % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDateTime :  -&gt; bool" Usage="utf8JsonReader.TryGetDateTime value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-279">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-279">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-280">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.DateTime" /> a i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-280">Tries to parse the current JSON token value from the source as a <see cref="T:System.DateTime" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-281"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.DateTime" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-281"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.DateTime" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-282">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.String" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-282">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDateTimeOffset">
      <MemberSignature Language="C#" Value="public bool TryGetDateTimeOffset (out DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDateTimeOffset([out] valuetype System.DateTimeOffset&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDateTimeOffset(System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDateTimeOffset (ByRef value As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDateTimeOffset([Runtime::InteropServices::Out] DateTimeOffset % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDateTimeOffset :  -&gt; bool" Usage="utf8JsonReader.TryGetDateTimeOffset value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTimeOffset" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-283">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-283">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-284">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.DateTimeOffset" /> a i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-284">Tries to parse the current JSON token value from the source as a <see cref="T:System.DateTimeOffset" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-285"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.DateTimeOffset" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-285"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.DateTimeOffset" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-286">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.String" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-286">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDecimal">
      <MemberSignature Language="C#" Value="public bool TryGetDecimal (out decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDecimal([out] valuetype System.Decimal&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDecimal(System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDecimal (ByRef value As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDecimal([Runtime::InteropServices::Out] System::Decimal % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDecimal :  -&gt; bool" Usage="utf8JsonReader.TryGetDecimal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-287">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-287">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-288">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.Decimal" /> a i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-288">Tries to parse the current JSON token value from the source as a <see cref="T:System.Decimal" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-289"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.Decimal" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-289"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Decimal" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-290">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-290">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetDouble">
      <MemberSignature Language="C#" Value="public bool TryGetDouble (out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDouble([out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDouble(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDouble (ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDouble([Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDouble :  -&gt; bool" Usage="utf8JsonReader.TryGetDouble value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-291">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-291">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-292">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.Double" /> a i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-292">Tries to parse the current JSON token value from the source as a <see cref="T:System.Double" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-293"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.Double" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-293"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Double" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-294">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-294">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetGuid">
      <MemberSignature Language="C#" Value="public bool TryGetGuid (out Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetGuid([out] valuetype System.Guid&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetGuid(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetGuid (ByRef value As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetGuid([Runtime::InteropServices::Out] Guid % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetGuid :  -&gt; bool" Usage="utf8JsonReader.TryGetGuid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Guid" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-295">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-295">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-296">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.Guid" /> a i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-296">Tries to parse the current JSON token value from the source as a <see cref="T:System.Guid" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-297"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.Guid" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-297"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Guid" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-298">Ta metoda analizuje <xref:System.Guid> tylko wartości z łącznikami i bez otaczających ich Dekoracj.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-298">This method only parses <xref:System.Guid> values with hyphens and without any surrounding decorations.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-299">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.String" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-299">The value of the JSON token isn't a <see cref="F:System.Text.Json.JsonTokenType.String" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetInt16">
      <MemberSignature Language="C#" Value="public bool TryGetInt16 (out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt16([out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt16(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt16 (ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt16([Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt16 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-300">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-300">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-301">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.Int16" /> i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-301">Tries to parse the current JSON token value from the source as an <see cref="T:System.Int16" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-302"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.Int16" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-302"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Int16" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-303">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-303">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetInt32">
      <MemberSignature Language="C#" Value="public bool TryGetInt32 (out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt32([out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt32(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt32 (ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt32([Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt32 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-304">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-304">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-305">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.Int32" /> i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-305">Tries to parse the current JSON token value from the source as an <see cref="T:System.Int32" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-306"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.Int32" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-306"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.Int32" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-307">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-307">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetInt64">
      <MemberSignature Language="C#" Value="public bool TryGetInt64 (out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt64([out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt64(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt64 (ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt64([Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt64 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-308">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-308">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-309">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.Int64" /> i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-309">Tries to parse the current JSON token value from the source as an <see cref="T:System.Int64" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-310"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.Int64" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-310"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.Int64" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-311">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-311">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetSByte">
      <MemberSignature Language="C#" Value="public bool TryGetSByte (out sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetSByte([out] int8&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetSByte(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetSByte (ByRef value As SByte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetSByte([Runtime::InteropServices::Out] System::SByte % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetSByte :  -&gt; bool" Usage="utf8JsonReader.TryGetSByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-312">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-312">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-313">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.SByte" /> i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-313">Tries to parse the current JSON token value from the source as an <see cref="T:System.SByte" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-314"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.SByte" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-314"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.SByte" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-315">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-315">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetSingle">
      <MemberSignature Language="C#" Value="public bool TryGetSingle (out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetSingle([out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetSingle(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetSingle (ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetSingle([Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetSingle :  -&gt; bool" Usage="utf8JsonReader.TryGetSingle value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-316">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-316">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-317">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.Single" /> a i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-317">Tries to parse the current JSON token value from the source as a <see cref="T:System.Single" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-318"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.Single" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-318"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.Single" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-319">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-319">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt16">
      <MemberSignature Language="C#" Value="public bool TryGetUInt16 (out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt16([out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt16(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt16 (ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt16([Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt16 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-320">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-320">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-321">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.UInt16" /> a i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-321">Tries to parse the current JSON token value from the source as a <see cref="T:System.UInt16" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-322"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.UInt16" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-322"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt16" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-323">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-323">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt32">
      <MemberSignature Language="C#" Value="public bool TryGetUInt32 (out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt32([out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt32(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt32 (ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt32([Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt32 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-324">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-324">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-325">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.UInt32" /> a i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-325">Tries to parse the current JSON token value from the source as a <see cref="T:System.UInt32" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-326"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.UInt32" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-326"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt32" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-327">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-327">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt64">
      <MemberSignature Language="C#" Value="public bool TryGetUInt64 (out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt64([out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt64(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt64 (ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt64([Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt64 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e9a0c-328">Gdy ta metoda zwraca, zawiera przeanalizowana wartość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-328">When this method returns, contains the parsed value.</span></span></param>
        <summary><span data-ttu-id="e9a0c-329">Próbuje przeanalizować bieżącą wartość tokenu JSON ze źródła jako <see cref="T:System.UInt64" /> a i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-329">Tries to parse the current JSON token value from the source as a <see cref="T:System.UInt64" /> and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-330"><see langword="true" />Jeśli cała wartość tokenu zakodowanego w formacie UTF-8 może zostać pomyślnie przeanalizowana <see cref="T:System.UInt64" /> na wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-330"><see langword="true" /> if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt64" /> value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-331">Wartość tokenu JSON nie jest <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-331">The JSON token value isn't a <see cref="F:System.Text.Json.JsonTokenType.Number" />.</span></span></exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TrySkip">
      <MemberSignature Language="C#" Value="public bool TrySkip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySkip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TrySkip" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySkip () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySkip();" />
      <MemberSignature Language="F#" Value="member this.TrySkip : unit -&gt; bool" Usage="utf8JsonReader.TrySkip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9a0c-332">Próbuje pominąć elementy podrzędne bieżącego tokenu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-332">Tries to skip the children of the current JSON token.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-333"><see langword="true" />Jeśli wystąpiły wystarczające dane dla elementów podrzędnych, które mają zostać pominięte pomyślnie; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-333"><see langword="true" /> if there was enough data for the children to be skipped successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-334">Jeśli czytnik nie ma wystarczającej ilości danych, aby całkowicie pominąć elementy podrzędne bieżącego tokenu, zostanie zresetowany do stanu, w którym był on przed wywołaniem metody.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-334">If the reader did not have enough data to completely skip the children of the current token, it will be reset to the state it was in before the method was called.</span></span>
              
<span data-ttu-id="e9a0c-335">Gdy <xref:System.Text.Json.Utf8JsonReader.TokenType> jest<xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>, czytnik najpierw przenosi do wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-335">When <xref:System.Text.Json.Utf8JsonReader.TokenType> is <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>, the reader first moves to the property value.</span></span>

<span data-ttu-id="e9a0c-336">Gdy <xref:System.Text.Json.Utf8JsonReader.TokenType> (pierwotnie lub po przejściu) to <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithType> lub <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>, czytnik postępuje do dopasowania <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> lub <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-336">When <xref:System.Text.Json.Utf8JsonReader.TokenType> (originally, or after advancing) is <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>, the reader advances to the matching <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>.</span></span>
            
<span data-ttu-id="e9a0c-337">Dla wszystkich innych typów tokenów czytnik nie jest przenoszony.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-337">For all other token types, the reader does not move.</span></span> <span data-ttu-id="e9a0c-338">Po następnym wywołaniu <xref:System.Text.Json.Utf8JsonReader.Read>, czytnik będzie miał następną wartość (gdy w tablicy), następną nazwę właściwości (w obiekcie) lub końcowym tokenem tablicy/obiektu.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-338">After the next call to <xref:System.Text.Json.Utf8JsonReader.Read>, the reader will be at the next value (when in an array), the next property name (when in an object), or the end array/object token.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.Text.Json.JsonException"><span data-ttu-id="e9a0c-339">Podczas pomijania napotkano nieprawidłowy token JSON, zgodnie z dokumentem RFC JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-339">An invalid JSON token was encountered while skipping, according to the JSON RFC.</span></span>
          
<span data-ttu-id="e9a0c-340">oraz</span><span class="sxs-lookup"><span data-stu-id="e9a0c-340">-or -</span></span>

<span data-ttu-id="e9a0c-341">Bieżąca głębokość przekracza limit cykliczny określony przez maksymalną głębokość.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-341">The current depth exceeds the recursive limit set by the maximum depth.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ValueSequence">
      <MemberSignature Language="C#" Value="public System.Buffers.ReadOnlySequence&lt;byte&gt; ValueSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; ValueSequence" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.ValueSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSequence As ReadOnlySequence(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Buffers::ReadOnlySequence&lt;System::Byte&gt; ValueSequence { System::Buffers::ReadOnlySequence&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSequence : System.Buffers.ReadOnlySequence&lt;byte&gt;" Usage="System.Text.Json.Utf8JsonReader.ValueSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Buffers.ReadOnlySequence&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9a0c-342">Pobiera wartość ostatniego przetworzonego tokenu jako <see cref="T:System.ReadOnlySpan`1" /> wycinka wejściowego ładunku.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-342">Gets the value of the last processed token as a <see cref="T:System.ReadOnlySpan`1" /> slice of the input payload.</span></span> <span data-ttu-id="e9a0c-343">Jeśli kod JSON znajduje się w obrębie <see cref="T:System.Buffers.ReadOnlySequence`1" /> i wycinek reprezentujący wartość tokenu mieści się w pojedynczym segmencie, a <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> następnie zawiera wartość z wycinka, ponieważ może być reprezentowana jako zakres.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-343">If the JSON is provided within a <see cref="T:System.Buffers.ReadOnlySequence`1" /> and the slice that represents the token value fits in a single segment, then <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> contains the sliced value since it can be represented as a span.</span></span> <span data-ttu-id="e9a0c-344">W przeciwnym razie zawiera wartość tokenu. <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-344">Otherwise, <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> contains the token value.</span></span></summary>
        <value><span data-ttu-id="e9a0c-345">Sekwencja bajtów tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-345">A byte read-only sequence.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks


<span data-ttu-id="e9a0c-346">Jeśli <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> jest `false` ,`ValueSequence` jest puste.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-346">If <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `false`, `ValueSequence` is empty.</span></span> <span data-ttu-id="e9a0c-347">W związku z tym `ValueSequence` tylko <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> dostęp `true`, jeśli jest.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-347">Therefore, only access `ValueSequence` if <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `true`.</span></span>
<span data-ttu-id="e9a0c-348">W przeciwnym razie do wartości tokenu należy uzyskać dostęp <xref:System.Text.Json.Utf8JsonReader.ValueSpan>z.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-348">Otherwise, the token value must be accessed from <xref:System.Text.Json.Utf8JsonReader.ValueSpan>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSpan">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;byte&gt; ValueSpan { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; ValueSpan" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.ValueSpan" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSpan As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;System::Byte&gt; ValueSpan { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSpan : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Json.Utf8JsonReader.ValueSpan" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9a0c-349">Pobiera wartość ostatniego przetworzonego tokenu jako wycinek ReadOnlySpan&lt;bajtowego&gt; ładunku wejściowego.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-349">Gets the value of the last processed token as a ReadOnlySpan&lt;byte&gt; slice of the input payload.</span></span> <span data-ttu-id="e9a0c-350">Jeśli kod JSON jest dostarczany w ReadOnlySequence&lt;bajcie&gt; , a plasterek reprezentujący wartość tokenu mieści się w pojedynczym segmencie, a następnie <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> zawiera wartość z wycinka, ponieważ może być reprezentowana jako zakres.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-350">If the JSON is provided within a ReadOnlySequence&lt;byte&gt; and the slice that represents the token value fits in a single segment, then <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> contains the sliced value since it can be represented as a span.</span></span> <span data-ttu-id="e9a0c-351">W przeciwnym razie zawiera wartość tokenu. <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-351">Otherwise, the <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> contains the token value.</span></span></summary>
        <value><span data-ttu-id="e9a0c-352">Zakres tylko do odczytu bajtów.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-352">A read-only span of bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-353">Jeśli <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> jest `true` ,<xref:System.Text.Json.Utf8JsonReader.ValueSpan> jest puste.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-353">If <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `true`, <xref:System.Text.Json.Utf8JsonReader.ValueSpan> is empty.</span></span> <span data-ttu-id="e9a0c-354">W związku z tym `ValueSpan` tylko <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> dostęp `false`, jeśli jest.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-354">Therefore, only access `ValueSpan` if <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> is `false`.</span></span>
<span data-ttu-id="e9a0c-355">W przeciwnym razie do wartości tokenu należy uzyskać dostęp <xref:System.Text.Json.Utf8JsonReader.ValueSequence>z.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-355">Otherwise, the token value must be accessed from <xref:System.Text.Json.Utf8JsonReader.ValueSequence>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ValueTextEquals">
      <Docs>
        <summary><span data-ttu-id="e9a0c-356">Porównuje określony tekst do niezmienionej wartości tokenu JSON w źródle i zwraca wartość wskazującą, czy są one zgodne.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-356">Compares the specified text to the unescaped JSON token value in the source and returns a value that indicates whether they match.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="e9a0c-357">Jeśli tekst wyszukiwania jest nieprawidłowym tekstem UTF-8, metoda zwraca `false` , ponieważ nie można było wykonać nieprawidłowego kodowania UTF-8 w ładunku JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-357">If the look-up text is invalid UTF-8 text, the method returns `false` since you can't have invalid UTF-8 within the JSON payload.</span></span>

<span data-ttu-id="e9a0c-358">Porównanie wartości tokenu JSON w źródle i tekstu odnośnika jest wykonywane przez pierwsze anulowanie ucieczki wartości JSON w źródle, jeśli jest to wymagane.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-358">The comparison of the JSON token value in the source and the lookup text is done by first unescaping the JSON value in source, if required.</span></span> <span data-ttu-id="e9a0c-359">Tekst wyszukiwania jest dopasowywany w postaci, w jakiej jest, bez żadnych modyfikacji.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-359">The look-up text is matched as is, without any modification.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (ReadOnlySpan&lt;byte&gt; utf8Text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (utf8Text As ReadOnlySpan(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(ReadOnlySpan&lt;System::Byte&gt; utf8Text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : ReadOnlySpan&lt;byte&gt; -&gt; bool" Usage="utf8JsonReader.ValueTextEquals utf8Text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8Text"><span data-ttu-id="e9a0c-360">Tekst zakodowany w formacie UTF-8 do porównania.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-360">The UTF-8 encoded text to compare against.</span></span></param>
        <summary><span data-ttu-id="e9a0c-361">Porównuje tekst zakodowany w formacie UTF-8 w zakresie bajtów tylko do odczytu do niezmienionej wartości tokenu JSON w źródle i zwraca wartość wskazującą, czy są one zgodne.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-361">Compares the UTF-8 encoded text in a read-only byte span to the unescaped JSON token value in the source and returns a value that indicates whether they match.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-362"><see langword="true" />Jeśli wartość tokenu JSON w źródle jest zgodna z zakodowanym tekstem wyszukiwania w formacie UTF-8; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-362"><see langword="true" /> if the JSON token value in the source matches the UTF-8 encoded lookup text; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-363">Jeśli tekst odnośnika jest nieprawidłowym tekstem UTF-8, Metoda `false` zwraca, ponieważ nie można było mieć nieprawidłowego UTF-8 w ładunku JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-363">If the lookup text is invalid UTF-8 text, the method returns `false` since you can't have invalid UTF-8 within the JSON payload.</span></span>
              
<span data-ttu-id="e9a0c-364">Porównanie wartości tokenu JSON w źródle i tekstu odnośnika jest wykonywane przez pierwsze anulowanie ucieczki wartości JSON w źródle, jeśli jest to wymagane.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-364">The comparison of the JSON token value in the source and the lookup text is done by first unescaping the JSON value in source, if required.</span></span> <span data-ttu-id="e9a0c-365">Tekst wyszukiwania jest dopasowywany w postaci, w jakiej jest, bez żadnych modyfikacji.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-365">The lookup text is matched as is, without any modifications to it.</span></span>
              
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-366">Token JSON, który nie jest ciągiem (oznacza to, że nie <see cref="F:System.Text.Json.JsonTokenType.String" /> jest lub <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-366">The JSON token that is not a string (that is, it is not <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (ReadOnlySpan&lt;char&gt; text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(valuetype System.ReadOnlySpan`1&lt;char&gt; text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (text As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(ReadOnlySpan&lt;char&gt; text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="utf8JsonReader.ValueTextEquals text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="e9a0c-367">Tekst zakodowany w formacie UTF-8 do porównania.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-367">The UTF-8 encoded text to compare against.</span></span></param>
        <summary><span data-ttu-id="e9a0c-368">Porównuje tekst zakodowany w formacie UTF-8 w znakach tylko do odczytu do niezmienionej wartości tokenu JSON w źródle i zwraca wartość wskazującą, czy są one zgodne.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-368">Compares the UTF-8 encoded text in a read-only character span to the unescaped JSON token value in the source and returns a value that indicates whether they match.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-369"><see langword="true" />Jeśli wartość tokenu JSON w źródle jest zgodna z zakodowanym tekstem wyszukiwania w formacie UTF-8; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-369"><see langword="true" /> if the JSON token value in the source matches the UTF-8 encoded lookup text; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-370">W przypadku nieprawidłowego lub niekompletnego tekstu w formacie UTF-16 (czyli niesparowanych surogatów) Metoda zwraca `false` , ponieważ nie można było wykonać nieprawidłowego kodowania UTF-16 w ramach ładunku JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-370">If the lookup text is invalid or incomplete UTF-16 text (that is, unpaired surrogates), the method returns `false` since you can't have invalid UTF-16 within the JSON payload.</span></span>
              
<span data-ttu-id="e9a0c-371">Porównanie wartości tokenu JSON w źródle i tekstu odnośnika jest wykonywane przez pierwsze anulowanie ucieczki wartości JSON w źródle, jeśli jest to wymagane.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-371">The comparison of the JSON token value in the source and the lookup text is done by first unescaping the JSON value in source, if required.</span></span> <span data-ttu-id="e9a0c-372">Tekst wyszukiwania jest dopasowywany w postaci, w jakiej jest, bez żadnych modyfikacji.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-372">The lookup text is matched as is, without any modifications to it.</span></span>
              
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-373">Token JSON, który nie jest ciągiem (oznacza to, że nie <see cref="F:System.Text.Json.JsonTokenType.String" /> jest lub <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-373">The JSON token that is not a string (that is, it is not <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : string -&gt; bool" Usage="utf8JsonReader.ValueTextEquals text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="e9a0c-374">Tekst do porównania.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-374">The text to compare against.</span></span></param>
        <summary><span data-ttu-id="e9a0c-375">Porównuje tekst w zakresie znaku z niezmienionym tokenem JSON w źródle i zwraca wartość wskazującą, czy są one zgodne.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-375">Compares the text in a character span to the unescaped JSON token value in the source and returns a value that indicates whether they match.</span></span></summary>
        <returns><span data-ttu-id="e9a0c-376"><see langword="true" />Jeśli wartość tokenu JSON w źródle pasuje do tekstu odnośnika; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="e9a0c-376"><see langword="true" /> if the JSON token value in the source matches the lookup text; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e9a0c-377">Jeśli tekst odnośnika jest nieprawidłowym tekstem UTF-8, Metoda `false` zwraca, ponieważ nie można było mieć nieprawidłowego UTF-8 w ładunku JSON.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-377">If the lookup text is invalid UTF-8 text, the method returns `false` since you can't have invalid UTF-8 within the JSON payload.</span></span>
              
<span data-ttu-id="e9a0c-378">Porównanie wartości tokenu JSON w źródle i tekstu odnośnika jest wykonywane przez pierwsze anulowanie ucieczki wartości JSON w źródle, jeśli jest to wymagane.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-378">The comparison of the JSON token value in the source and the lookup text is done by first unescaping the JSON value in source, if required.</span></span> <span data-ttu-id="e9a0c-379">Tekst wyszukiwania jest dopasowywany w postaci, w jakiej jest, bez żadnych modyfikacji.</span><span class="sxs-lookup"><span data-stu-id="e9a0c-379">The lookup text is matched as is, without any modifications to it.</span></span>
              
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9a0c-380">Token JSON, który nie jest ciągiem (oznacza to, że nie <see cref="F:System.Text.Json.JsonTokenType.String" /> jest lub <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span><span class="sxs-lookup"><span data-stu-id="e9a0c-380">The JSON token that is not a string (that is, it is not <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>

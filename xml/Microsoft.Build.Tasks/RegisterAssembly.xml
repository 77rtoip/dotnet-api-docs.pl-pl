<Type Name="RegisterAssembly" FullName="Microsoft.Build.Tasks.RegisterAssembly">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f49ff95af30fdc89da0fc9702367687ed6d210ab" /><Meta Name="ms.sourcegitcommit" Value="81833381d2d0b5a8c55f71b43f00769fd38298af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/17/2019" /><Meta Name="ms.locfileid" Value="69570353" /></Metadata><TypeSignature Language="C#" Value="public class RegisterAssembly : Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension, System.Runtime.InteropServices.ITypeLibExporterNotifySink" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RegisterAssembly extends Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension implements class System.Runtime.InteropServices.ITypeLibExporterNotifySink" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Tasks.RegisterAssembly" />
  <TypeSignature Language="VB.NET" Value="Public Class RegisterAssembly&#xA;Inherits AppDomainIsolatedTaskExtension&#xA;Implements ITypeLibExporterNotifySink" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegisterAssembly : Microsoft::Build::Tasks::AppDomainIsolatedTaskExtension, System::Runtime::InteropServices::ITypeLibExporterNotifySink" />
  <TypeSignature Language="F#" Value="type RegisterAssembly = class&#xA;    inherit AppDomainIsolatedTaskExtension&#xA;    interface ITypeLibExporterNotifySink" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build.Tasks.v4.0</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build.Tasks</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build.Tasks.v3.5</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices.ITypeLibExporterNotifySink</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementuje zadanie <c>RegisterAssembly —</c> . Użyj elementu <c>RegisterAssembly —</c> w pliku projektu, aby utworzyć i wykonać to zadanie. Informacje dotyczące użycia i parametrów znajdują się w temacie [RegisterAssembly — Task](https://msdn.microsoft.com/library/ba5f19ac-6764-4d28-9b79-a86de58f8987).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Framework64/\<version >/RegisterAssemblyTask nie może rozpoznać biblioteki obiektów COM zarejestrowanych jako składniki 32-bitowe. Struktura/\<wersja >/RegisterAssemblyTask nie może rozpoznać biblioteki obiektów COM zarejestrowanych jako składniki 64-bitowe.  
  
 Jeśli na przykład zarejestrujesz bibliotekę obiektów COM o nazwie ClassLibrary1 jako składniki 32-bitowe na komputerze 64-bitowym, uruchom program Visual Studio i zmienisz element docelowy na x64, kompilacja zakończy się niepowodzeniem z powodu następującego błędu:  
  
 `ClassLibrary1.dll is not a valid assembly`  
  
 ]]></format>
    </remarks>
    <forInternalUseOnly />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegisterAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Tasks.RegisterAssembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegisterAssembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v3.5</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:Microsoft.Build.Tasks.RegisterAssembly" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Assemblies">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Framework.ITaskItem[] Assemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Framework.ITaskItem[] Assemblies" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Tasks.RegisterAssembly.Assemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property Assemblies As ITaskItem()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Microsoft::Build::Framework::ITaskItem ^&gt; ^ Assemblies { cli::array &lt;Microsoft::Build::Framework::ITaskItem ^&gt; ^ get(); void set(cli::array &lt;Microsoft::Build::Framework::ITaskItem ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Assemblies : Microsoft.Build.Framework.ITaskItem[] with get, set" Usage="Microsoft.Build.Tasks.RegisterAssembly.Assemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v3.5</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.Build.Framework.Required</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Framework.ITaskItem[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zestawy, które mają być zarejestrowane w modelu COM.</summary>
        <value>Zestawy, które mają być zarejestrowane w modelu COM.</value>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="AssemblyListFile">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Framework.ITaskItem AssemblyListFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Framework.ITaskItem AssemblyListFile" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Tasks.RegisterAssembly.AssemblyListFile" />
      <MemberSignature Language="VB.NET" Value="Public Property AssemblyListFile As ITaskItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Framework::ITaskItem ^ AssemblyListFile { Microsoft::Build::Framework::ITaskItem ^ get(); void set(Microsoft::Build::Framework::ITaskItem ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyListFile : Microsoft.Build.Framework.ITaskItem with get, set" Usage="Microsoft.Build.Tasks.RegisterAssembly.AssemblyListFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v3.5</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Framework.ITaskItem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o stanie między zadaniem <c>RegisterAssembly —</c> a zadaniem [UnregisterAssembly —](https://msdn.microsoft.com/library/04f549dd-3591-4dda-9c3a-cf6ede9df2c3) . Zapobiega to wyrejestrowaniu przez zadanie <c>UnregisterAssembly —</c> zestawu, którego nie można zarejestrować w zadaniu <c>RegisterAssembly —</c> .</summary>
        <value>Informacje o stanie niezbędne dla zadania <c>UnregisterAssembly —</c> , aby wykonać odpowiednie czyszczenie.</value>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="CreateCodeBase">
      <MemberSignature Language="C#" Value="public bool CreateCodeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CreateCodeBase" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Tasks.RegisterAssembly.CreateCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Property CreateCodeBase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CreateCodeBase { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CreateCodeBase : bool with get, set" Usage="Microsoft.Build.Tasks.RegisterAssembly.CreateCodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v3.5</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość logiczną określającą, czy zadanie tworzy w rejestrze wpis w bazie kodu, który określa ścieżkę pliku dla zestawu, który nie jest zainstalowany w globalnej pamięci podręcznej zestawów.</summary>
        <value><see langword="true" />Jeśli zadanie tworzy wpis w bazie kodu w rejestrze; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy określać tej opcji, jeśli później instalowany będzie zestaw, który jest rejestrowany w globalnej pamięci podręcznej zestawów.  
  
 ]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public override bool Execute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Execute() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Tasks.RegisterAssembly.Execute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Execute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Execute();" />
      <MemberSignature Language="F#" Value="override this.Execute : unit -&gt; bool" Usage="registerAssembly.Execute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v3.5</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonuje zadanie <c>RegisterAssembly —</c> .</summary>
        <returns><see langword="true" />Jeśli wykonywanie zadania zakończyło się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="ReportEvent">
      <MemberSignature Language="C#" Value="public void ReportEvent (System.Runtime.InteropServices.ExporterEventKind kind, int code, string msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReportEvent(valuetype System.Runtime.InteropServices.ExporterEventKind kind, int32 code, string msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Tasks.RegisterAssembly.ReportEvent(System.Runtime.InteropServices.ExporterEventKind,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportEvent (kind As ExporterEventKind, code As Integer, msg As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReportEvent(System::Runtime::InteropServices::ExporterEventKind kind, int code, System::String ^ msg);" />
      <MemberSignature Language="F#" Value="abstract member ReportEvent : System.Runtime.InteropServices.ExporterEventKind * int * string -&gt; unit&#xA;override this.ReportEvent : System.Runtime.InteropServices.ExporterEventKind * int * string -&gt; unit" Usage="registerAssembly.ReportEvent (kind, code, msg)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices.ITypeLibExporterNotifySink.ReportEvent(System.Runtime.InteropServices.ExporterEventKind,System.Int32,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v3.5</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Runtime.InteropServices.ExporterEventKind" />
        <Parameter Name="code" Type="System.Int32" />
        <Parameter Name="msg" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="kind">Opisuje wywołania zwrotne, które Eksporter biblioteki typów wykonuje podczas eksportowania biblioteki typów.</param>
        <param name="code">Kod błędu zdarzenia eksportu.</param>
        <param name="msg">Komunikat dotyczący zdarzenia eksportu.</param>
        <summary>Metoda wywołania zwrotnego służąca do raportowania zdarzeń eksportu biblioteki typów.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="ResolveRef">
      <MemberSignature Language="C#" Value="public object ResolveRef (System.Reflection.Assembly assemblyToResolve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ResolveRef(class System.Reflection.Assembly assemblyToResolve) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Tasks.RegisterAssembly.ResolveRef(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveRef (assemblyToResolve As Assembly) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ResolveRef(System::Reflection::Assembly ^ assemblyToResolve);" />
      <MemberSignature Language="F#" Value="abstract member ResolveRef : System.Reflection.Assembly -&gt; obj&#xA;override this.ResolveRef : System.Reflection.Assembly -&gt; obj" Usage="registerAssembly.ResolveRef assemblyToResolve" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices.ITypeLibExporterNotifySink.ResolveRef(System.Reflection.Assembly)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v3.5</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyToResolve" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assemblyToResolve">Zestaw, dla którego mają zostać znalezione biblioteki typów.</param>
        <summary>Metoda wywołania zwrotnego służąca do znajdowania biblioteki typów dla określonego zestawu.</summary>
        <returns><see langword="null" />we wszystkich przypadkach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rejestruje błąd wskazujący, że określony zestaw nie jest zarejestrowany dla współdziałania modelu COM we wszystkich przypadkach.  
  
 ]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="TypeLibFiles">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Framework.ITaskItem[] TypeLibFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Framework.ITaskItem[] TypeLibFiles" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Tasks.RegisterAssembly.TypeLibFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property TypeLibFiles As ITaskItem()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Microsoft::Build::Framework::ITaskItem ^&gt; ^ TypeLibFiles { cli::array &lt;Microsoft::Build::Framework::ITaskItem ^&gt; ^ get(); void set(cli::array &lt;Microsoft::Build::Framework::ITaskItem ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TypeLibFiles : Microsoft.Build.Framework.ITaskItem[] with get, set" Usage="Microsoft.Build.Tasks.RegisterAssembly.TypeLibFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v4.0</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build.Tasks.v3.5</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.Build.Framework.Output</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Framework.ITaskItem[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bibliotekę typów do wygenerowania na podstawie określonego zestawu.</summary>
        <value>Biblioteka typów do wygenerowania z określonego zestawu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wygenerowana biblioteka typów zawiera definicje dostępnych typów zdefiniowanych w ramach zestawu. Biblioteka typów jest generowana tylko wtedy, gdy jeden z następujących warunków jest spełniony:  
  
-   Biblioteka typów o tej nazwie nie istnieje w tej lokalizacji.  
  
-   Biblioteka typów istnieje, ale jest starsza niż przekazanie zestawu.  
  
 Jeśli biblioteka typów jest nowsza niż przekazanie zestawu, nowy nie zostanie utworzony, ale zestaw nadal będzie zarejestrowany.  
  
 Jeśli ta właściwość jest określona, musi mieć taką samą liczbę elementów jak <xref:Microsoft.Build.Tasks.RegisterAssembly.Assemblies%2A> właściwość lub zadanie zakończy się niepowodzeniem. Jeśli żadne dane wejściowe nie są określone, zadanie zostanie domyślnie przyłączone do nazwy zestawu i zmienione rozszerzenie elementu na. tlb.  
  
 ]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="ImmutableHashSet&lt;T&gt;" FullName="System.Collections.Immutable.ImmutableHashSet&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5e4e29e88e2cab97763559460919bf5a723309f1" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39951161" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ImmutableHashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Collections.ICollection, System.Collections.Immutable.IImmutableSet&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ImmutableHashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Immutable.ImmutableHashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ImmutableHashSet(Of T)&#xA;Implements ICollection, ICollection(Of T), IEnumerable(Of T), IImmutableSet(Of T), IReadOnlyCollection(Of T), ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class ImmutableHashSet sealed : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Collections::ICollection, System::Collections::Immutable::IImmutableSet&lt;T&gt;" />
  <TypeSignature Language="F#" Value="type ImmutableHashSet&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface ISet&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IImmutableSet&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Immutable</AssemblyName>
    <AssemblyVersion>1.2.0.0</AssemblyVersion>
    <AssemblyVersion>1.2.1.0</AssemblyVersion>
    <AssemblyVersion>1.2.2.0</AssemblyVersion>
    <AssemblyVersion>1.2.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Immutable.IImmutableSet&lt;T&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Immutable.ImmutableHashSetDebuggerProxy`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Typ elementów w zestawie wyznaczania wartości skrótu.</typeparam>
    <summary>Reprezentuje zestaw niezmienne, nieuporządkowane wyznaczania wartości skrótu.  
  
 **Pakiet NuGet**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see> (<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#Remarks">o kolekcjach niezmienialnych oraz instrukcje dotyczące instalowania</see>)</summary>
    <remarks>To be added.</remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Add(T item);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T -&gt; System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;" Usage="immutableHashSet.Add item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Element do dodania do zestawu.</param>
        <summary>Dodaje określony element do zestawu wyznaczania wartości skrótu.</summary>
        <returns>Zestaw wyznaczania wartości skrótu, który zawiera wartość dodaną i wszelkie wartości wcześniej w posiadaniu <see cref="T:System.Collections.Immutable.ImmutableHashSet`1" /> obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;" Usage="immutableHashSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera zestaw pusty niezmienne wyznaczania wartości skrótu, który ma tego samego sortowania i kolejność semantykę, jak to wystąpienie.</summary>
        <returns>Zestaw pusty wyznaczania wartości skrótu, który ma tego samego sortowania i kolejność semantykę, jak to wystąpienie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="immutableHashSet.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w zestawie niezmienne wyznaczania wartości skrótu.</param>
        <summary>Określa, czy ten zestaw niezmienne wyznaczania wartości skrótu zawiera określony element.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="item" /> znajduje się w <see cref="T:System.Collections.Immutable.ImmutableHashSet`1" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów w zestawie niezmienne wyznaczania wartości skrótu.</summary>
        <value>Liczba elementów w zestawie wyznaczania wartości skrótu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="F:System.Collections.Immutable.ImmutableHashSet`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As ImmutableHashSet(Of T) " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;" Usage="System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera skrót niezmienne ustawione dla tego typu, który używa domyślnego <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Except">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Except (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Except(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Except(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Except (other As IEnumerable(Of T)) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="member this.Except : seq&lt;'T&gt; -&gt; System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;" Usage="immutableHashSet.Except other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja elementów chcesz usunąć ten zestaw.</param>
        <summary>Usuwa elementy z określonej kolekcji z bieżącego zestawu niezmienne wyznaczania wartości skrótu.</summary>
        <returns>A nowego zestawu z elementami usunięte; lub oryginalnego zestawu, jeśli żaden z elementów w zestawie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Immutable.ImmutableHashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As ImmutableHashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;.Enumerator" Usage="immutableHashSet.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>Moduł wyliczający, który może służyć do iterowania po kolekcji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Intersect (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Intersect(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Intersect (other As IEnumerable(Of T)) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="member this.Intersect : seq&lt;'T&gt; -&gt; System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;" Usage="immutableHashSet.Intersect other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Tworzy zestaw niezmienne wyznaczania wartości skrótu, który zawiera elementy, które istnieją w tym zestawie i określonego zestawu.</summary>
        <returns>Nowy zestaw niezmienne zawiera wszystkie elementy, które istnieją w obu zestawach.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący zestaw niezmienne wyznaczania wartości skrótu jest pusty.</summary>
        <value>
          <see langword="true" /> Jeśli to wystąpienie jest puste. w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="immutableHashSet.IsProperSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Określa, czy bieżący zestaw niezmienne wyznaczania wartości skrótu jest właściwe () podzbiór określonej kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość bieżącego jest podzbiorem odpowiednie określonej kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący zestaw jest podzestawem odpowiednie `other`, `other` musi mieć co najmniej jeden element, który nie ma bieżącego zestawu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="immutableHashSet.IsProperSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Określa, czy bieżący zestaw niezmienne wyznaczania wartości skrótu jest właściwe nadzbiorem (strict) określonej kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość bieżącego jest podzbiorem odpowiednie określonej kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący zestaw jest podzestawem odpowiednie `other`, bieżący zestaw musi mieć co najmniej jeden element, `other` nie ma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="immutableHashSet.IsSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Określa, czy bieżący zestaw niezmienne wyznaczania wartości skrótu jest podzbiorem określonej kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący zestaw jest podzbiorem określonej kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="immutableHashSet.IsSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Określa, czy bieżący zestaw niezmienne wyznaczania wartości skrótu jest nadzbiorem określonej kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący zestaw jest nadzbiorem określonej kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyComparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; KeyComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; KeyComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.KeyComparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyComparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ KeyComparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyComparer : System.Collections.Generic.IEqualityComparer&lt;'T&gt;" Usage="System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;.KeyComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który jest używany do uzyskania kody skrótów kluczy i sprawdź równość wartości w zestawie niezmienne wyznaczania wartości skrótu.</summary>
        <value>Moduł porównujący używane do uzyskania kody skrótów kluczy i sprawdź równości.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Overlaps : seq&lt;'T&gt; -&gt; bool&#xA;override this.Overlaps : seq&lt;'T&gt; -&gt; bool" Usage="immutableHashSet.Overlaps other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Określa, czy bieżący zestaw niezmienne wyznaczania wartości skrótu nakłada się na określonej kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżącego zestawu i określonej kolekcji mają co najmniej jeden element wspólnej; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Remove(T item);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'T -&gt; System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;" Usage="immutableHashSet.Remove item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Element do usunięcia.</param>
        <summary>Usuwa określony element z tego zestawu niezmienne wyznaczania wartości skrótu.</summary>
        <returns>Nowy zbiór z określonego elementu usunięty lub bieżącego zestawu, jeśli element nie zostanie znaleziony w zestawie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SetEquals : seq&lt;'T&gt; -&gt; bool&#xA;override this.SetEquals : seq&lt;'T&gt; -&gt; bool" Usage="immutableHashSet.SetEquals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Określa, czy bieżący zestaw niezmienne wyznaczania wartości skrótu i określonej kolekcji i zawierają te same elementy.</summary>
        <returns>
          <see langword="true" /> Jeśli te zestawy są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExcept">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; SymmetricExcept (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; SymmetricExcept(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SymmetricExcept (other As IEnumerable(Of T)) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ SymmetricExcept(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="member this.SymmetricExcept : seq&lt;'T&gt; -&gt; System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;" Usage="immutableHashSet.SymmetricExcept other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Tworzy zestaw niezmienne wyznaczania wartości skrótu, który zawiera tylko te elementy, które znajdują się w bieżącym zestawie lub w określonej kolekcji, ale nie oba.</summary>
        <returns>Nowy zestaw, który zawiera elementy, które są obecne tylko w bieżącym zestawie lub w określonej kolekcji, ale nie oba.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania do zestawu.</param>
        <summary>Dodaje element do zestawu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.ICollection%601> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Zestaw jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of T).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Clear() = System::Collections::Generic::ICollection&lt;T&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z tego zestawu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.ICollection%601> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Zestaw jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As T(), arrayIndex As Integer) Implements ICollection(Of T).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex) = System::Collections::Generic::ICollection&lt;T&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest lokalizacją docelową elementów kopiowanych z zestawu. Tablica musi mieć indeksowane zaczynające od zera.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy zestawu do tablicy, zaczynając od określonego indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.ICollection%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zobacz <see cref="T:System.Collections.Generic.ICollection`1" /> interfejsu.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;T&gt;.Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;T&gt;.Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (item As T) As Boolean Implements ICollection(Of T).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;T&gt;.Remove(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do usunięcia z zestawu.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z zestawu.</summary>
        <returns>
          <see langword="true" /> Jeśli element został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.ICollection%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>Moduł wyliczający, który iteruje po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.IEnumerable%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ISet&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="bool ISet&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ISet&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ISet&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As T) As Boolean Implements ISet(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ISet&lt;T&gt;.Add(T item) = System::Collections::Generic::ISet&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Element do dodania do kolekcji.</param>
        <summary>Dodaje element do bieżącego zestawu i zwraca wartość wskazującą, czy element został pomyślnie dodany.</summary>
        <returns>
          <see langword="true" /> Jeśli element jest dodawany do zestawu; <see langword="false" /> Jeśli element znajduje się już w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.ISet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ISet&lt;T&gt;.ExceptWith">
      <MemberSignature Language="C#" Value="void ISet&lt;T&gt;.ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ISet&lt;T&gt;.ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ISet&lt;T&gt;#ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Sub ExceptWith (other As IEnumerable(Of T)) Implements ISet(Of T).ExceptWith" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ISet&lt;T&gt;.ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Generic::ISet&lt;T&gt;::ExceptWith;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja elementów do usunięcia.</param>
        <summary>Usuwa wszystkie elementy w określonej kolekcji z bieżącego zestawu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.ISet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ISet&lt;T&gt;.IntersectWith">
      <MemberSignature Language="C#" Value="void ISet&lt;T&gt;.IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ISet&lt;T&gt;.IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ISet&lt;T&gt;#IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Sub IntersectWith (other As IEnumerable(Of T)) Implements ISet(Of T).IntersectWith" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ISet&lt;T&gt;.IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Generic::ISet&lt;T&gt;::IntersectWith;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącą kolekcją.</param>
        <summary>Modyfikuje bieżącego zestawu, tak aby zawierała tylko te elementy, które znajdują się również w określonej kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.ISet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ISet&lt;T&gt;.SymmetricExceptWith">
      <MemberSignature Language="C#" Value="void ISet&lt;T&gt;.SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ISet&lt;T&gt;.SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ISet&lt;T&gt;#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Sub SymmetricExceptWith (other As IEnumerable(Of T)) Implements ISet(Of T).SymmetricExceptWith" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ISet&lt;T&gt;.SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Generic::ISet&lt;T&gt;::SymmetricExceptWith;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Modyfikuje bieżącego zestawu, tak aby zawierała tylko te elementy, które znajdują się w bieżącym zestawie lub w określonej kolekcji, ale nie oba.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.ISet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ISet&lt;T&gt;.UnionWith">
      <MemberSignature Language="C#" Value="void ISet&lt;T&gt;.UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ISet&lt;T&gt;.UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ISet&lt;T&gt;#UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Sub UnionWith (other As IEnumerable(Of T)) Implements ISet(Of T).UnionWith" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ISet&lt;T&gt;.UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Generic::ISet&lt;T&gt;::UnionWith;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Modyfikuje bieżącego zestawu tak, że bieżący zestaw zawiera wszystkie elementy, które znajdują się w jednym lub w określonej kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.ISet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest lokalizacją docelową elementów kopiowanych z zestawu. Tablica musi mieć indeksowane zaczynające od zera.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy zestawu do tablicy, zaczynając od określonego indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.ICollection%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zobacz <see cref="T:System.Collections.ICollection" /> interfejsu.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zobacz <see cref="T:System.Collections.ICollection" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który wykonuje iterację przez zestaw.</summary>
        <returns>Moduł wyliczający, który może służyć do iteracji przez zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.IEnumerable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As T) As IImmutableSet(Of T) Implements IImmutableSet(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Add(T item) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Element do dodania.</param>
        <summary>Dodaje określony element do tego zestawu niezmienne.</summary>
        <returns>A nowego zestawu z elementem dodane lub tego ustawienia, jeśli element znajduje się już w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Clear">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Function Clear () As IImmutableSet(Of T) Implements IImmutableSet(Of T).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Clear() = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera pusty zestaw, który ma tego samego sortowania i kolejność semantykę, jak to wystąpienie.</summary>
        <returns>Pusty zestaw, który ma tego samego sortowania lub porządkowanie semantykę, jak to wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Except">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Except (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Except(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Except(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Function Except (other As IEnumerable(Of T)) As IImmutableSet(Of T) Implements IImmutableSet(Of T).Except" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Except(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Except;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Except(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja elementów chcesz usunąć ten zestaw.</param>
        <summary>Usuwa elementy z określonej kolekcji z bieżącego zestawu.</summary>
        <returns>A nowego zestawu z elementami usunięte; lub oryginalnego zestawu, jeśli żaden z elementów w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Intersect">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Intersect (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Intersect(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Intersect(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Function Intersect (other As IEnumerable(Of T)) As IImmutableSet(Of T) Implements IImmutableSet(Of T).Intersect" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Intersect(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Intersect;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Tworzy zestaw niezmienne, który zawiera elementy, które istnieją w tym zestawie i określonego zestawu.</summary>
        <returns>Nowy zestaw niezmienne zawiera wszystkie elementy, które istnieją w obu zestawach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Remove">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (item As T) As IImmutableSet(Of T) Implements IImmutableSet(Of T).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Remove(T item) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Element do usunięcia.</param>
        <summary>Usuwa określony element z tego zestawu niezmienne.</summary>
        <returns>Nowy zbiór z określonego elementu usunięty lub bieżącego zestawu, jeśli element nie zostanie znaleziony w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.SymmetricExcept">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.SymmetricExcept (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.SymmetricExcept(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#SymmetricExcept(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Function SymmetricExcept (other As IEnumerable(Of T)) As IImmutableSet(Of T) Implements IImmutableSet(Of T).SymmetricExcept" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.SymmetricExcept(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::SymmetricExcept;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja do porównania z bieżącym zestawie.</param>
        <summary>Tworzy zestaw niezmienne, który zawiera tylko te elementy, które znajdują się w bieżącym zestawie lub w określonej kolekcji, ale nie oba.</summary>
        <returns>Nowy zestaw, który zawiera elementy, które są obecne tylko w bieżącym zestawie lub w określonej kolekcji, ale nie oba.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Union">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Union (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Union(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Union(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Function Union (other As IEnumerable(Of T)) As IImmutableSet(Of T) Implements IImmutableSet(Of T).Union" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Union(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Union;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Union(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja dodawania elementów z.</param>
        <summary>Tworzy nowy zestaw niezmienne, która zawiera wszystkie elementy, które znajdują się w bieżącym zestawie lub w określonej kolekcji.</summary>
        <returns>Nowy zestaw niezmienne z elementami dodane; lub oryginalnego zestawu, jeśli wszystkie elementy zostały już w zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowany na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBuilder">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt;.Builder ToBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1/Builder&lt;!T&gt; ToBuilder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.ToBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Function ToBuilder () As ImmutableHashSet(Of T).Builder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt;::Builder ^ ToBuilder();" />
      <MemberSignature Language="F#" Value="member this.ToBuilder : unit -&gt; System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;.Builder" Usage="immutableHashSet.ToBuilder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;+Builder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy zestaw niezmienne wyznaczania wartości skrótu, ma tę samą zawartość, jak ten zestaw, który można efektywnie można zmutować w wielu operacjach przy użyciu standardowych interfejsów modyfikowalna.</summary>
        <returns>Zestaw z samą zawartością, co ten zestaw, który można efektywnie można zmutować w wielu operacjach przy użyciu standardowych interfejsów modyfikowalna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest operacją O(1) i powoduje alokację pojedynczego pamięci (małego). Modyfikowalną kolekcję, która jest zwracana nie jest bezpieczny dla wątków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'T *  -&gt; bool&#xA;override this.TryGetValue : 'T *  -&gt; bool" Usage="immutableHashSet.TryGetValue (equalValue, actualValue)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.TryGetValue(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue">Wartość do wyszukania.</param>
        <param name="actualValue">Wartość z zestawu, który nie można odnaleźć lub oryginalnej wartości, jeśli wyszukiwanie nie zwróciło Brak dopasowania.</param>
        <summary>Wyszukuje zestaw dla danej wartości i zwraca wartość równą, którą znajdzie, jeśli istnieje.</summary>
        <returns>Wartość wskazująca, czy wyszukiwanie zakończyło się pomyślnie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może to być przydatne, gdy chcesz ponownie użyć poprzednio zapisanego odwołania zamiast nowo skonstruowany (udostępnianie więcej odwołań mogła zaistnieć) lub wartość, na który ma bardziej kompletne dane, niż wartość masz obecnie, mimo że ich funkcje porównania wskazują, że są one takie same.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Union (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Union(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Union(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Union (other As IEnumerable(Of T)) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="member this.Union : seq&lt;'T&gt; -&gt; System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;" Usage="immutableHashSet.Union other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Kolekcja dodawania elementów z.</param>
        <summary>Tworzy nowy zestaw niezmienne wyznaczania wartości skrótu, która zawiera wszystkie elementy, które znajdują się w bieżącym zestawie lub w określonej kolekcji.</summary>
        <returns>Nowy skrót niezmiennego zestawu przy użyciu elementy dodane; lub oryginalnego zestawu, jeśli wszystkie elementy zostały już w zestawie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithComparer">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; WithComparer (System.Collections.Generic.IEqualityComparer&lt;T&gt; equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; WithComparer(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.WithComparer(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithComparer (equalityComparer As IEqualityComparer(Of T)) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ WithComparer(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="member this.WithComparer : System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Immutable.ImmutableHashSet&lt;'T&gt;" Usage="immutableHashSet.WithComparer equalityComparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalityComparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="equalityComparer">Moduł porównujący równość do użycia.</param>
        <summary>Pobiera wystąpienie elementu zestawu niezmienne wyznaczania wartości skrótu, który używa moduł porównujący równość określony dla jego metody wyszukiwania.</summary>
        <returns>Wystąpienie tego zestawu niezmienne wyznaczania wartości skrótu, który używa danego modułu porównującego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ImmutableHashSet&lt;T&gt;" FullName="System.Collections.Immutable.ImmutableHashSet&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5004e8716d781712df8ca6ed28bdc7387b516000" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30440688" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ImmutableHashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Collections.ICollection, System.Collections.Immutable.IImmutableSet&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ImmutableHashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Immutable.ImmutableHashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ImmutableHashSet(Of T)&#xA;Implements ICollection, ICollection(Of T), IEnumerable(Of T), IImmutableSet(Of T), IReadOnlyCollection(Of T), ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class ImmutableHashSet sealed : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Collections::ICollection, System::Collections::Immutable::IImmutableSet&lt;T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Immutable</AssemblyName>
    <AssemblyVersion>1.2.0.0</AssemblyVersion>
    <AssemblyVersion>1.2.1.0</AssemblyVersion>
    <AssemblyVersion>1.2.2.0</AssemblyVersion>
    <AssemblyVersion>1.2.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Immutable.IImmutableSet&lt;T&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T">
      <span data-ttu-id="0fea6-101">Typ elementów w zestawie wyznaczania wartości skrótu.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0fea6-101">The type of elements in the hash set.</span>
      </span>
    </typeparam>
    <summary>
      <span data-ttu-id="0fea6-102">Reprezentuje zestaw niezmienne, nieuporządkowaną wyznaczania wartości skrótu.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0fea6-102">Represents an immutable, unordered hash set.</span>
      </span>
      <span data-ttu-id="0fea6-103">**Pakiet NuGet**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see> (<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#Remarks">o kolekcjach niezmienialnych oraz instrukcje dotyczące instalowania</see>)</span>
      <span class="sxs-lookup">
        <span data-stu-id="0fea6-103">**NuGet package**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see> (<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#Remarks">about immutable collections and how to install</see>)</span>
      </span>
    </summary>
    <remarks>To be added.</remarks>
    <threadsafe>
      <span data-ttu-id="0fea6-104">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0fea6-104">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Add(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="0fea6-105">Element do dodania do zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-105">The element to add to the set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-106">Dodaje określony element do zestawu wyznaczania wartości skrótu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-106">Adds the specified element to the hash set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-107">Zestaw wyznaczania wartości skrótu, który zawiera wartości dodanej oraz wszelkie wartości wcześniej posiadaniu <see cref="T:System.Collections.Immutable.ImmutableHashSet`1" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-107">A hash set that contains the added value and any values previously held by the  <see cref="T:System.Collections.Immutable.ImmutableHashSet`1" /> object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-108">Pobiera zestaw pusty niezmienne wyznaczania wartości skrótu, który ma tego samego sortowania i kolejność semantyki jako tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-108">Retrieves an empty immutable hash set that has the same sorting and ordering semantics as this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-109">Zestaw pusty wyznaczania wartości skrótu, który ma tego samego sortowania i kolejność semantyki jako tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-109">An empty hash set that has the same sorting and ordering semantics as this instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="0fea6-110">Obiekt do zlokalizowania w zestawie niezmienne wyznaczania wartości skrótu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-110">The object to locate in the immutable hash set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-111">Określa, czy ten zestaw niezmienne skrótu zawiera określony element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-111">Determines whether this immutable hash set contains the specified element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-112">
            <see langword="true" /> Jeśli <paramref name="item" /> znajduje się w <see cref="T:System.Collections.Immutable.ImmutableHashSet`1" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-112">
              <see langword="true" /> if <paramref name="item" /> is found in the <see cref="T:System.Collections.Immutable.ImmutableHashSet`1" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-113">Pobiera liczbę elementów w zestawie niezmienne wyznaczania wartości skrótu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-113">Gets the number of elements in the immutable hash set.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0fea6-114">Liczba elementów w zestawie wyznaczania wartości skrótu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-114">The number of elements in the hash set.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="F:System.Collections.Immutable.ImmutableHashSet`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As ImmutableHashSet(Of T) " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Empty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-115">Pobiera skrót niezmienne, ustaw dla tego typu, który używa domyślnej <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-115">Gets an immutable hash set for this type that uses the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Except">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Except (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Except(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Except(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Except (other As IEnumerable(Of T)) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-116">Kolekcja elementów do usunięcia z tego zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-116">The collection of items to remove from this set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-117">Usuwa elementy w określonej kolekcji z bieżącego zestawu niezmienne wyznaczania wartości skrótu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-117">Removes the elements in the specified collection from the current immutable hash set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-118">A nowy zestaw z elementami usunięte; lub oryginalnego zestawu, jeśli żaden z elementów nie był w zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-118">A new set with the items removed; or the original set if none of the items were in the set.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Immutable.ImmutableHashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As ImmutableHashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-119">Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-119">Returns an enumerator that iterates through the collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-120">Moduł wyliczający, który może służyć do iterowania po kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-120">An enumerator that can be used to iterate through the collection.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Intersect (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Intersect(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Intersect (other As IEnumerable(Of T)) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-121">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-121">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-122">Tworzy zestaw niezmienne wyznaczania wartości skrótu, który zawiera elementy, które istnieją w tym zestawie i określonego zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-122">Creates an immutable hash set that contains elements that exist in both this set and the specified set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-123">Nowy zestaw niezmienne zawiera wszystkie elementy, które istnieją w obu zestawach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-123">A new immutable set that contains any elements that exist in both sets.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-124">Pobiera wartość wskazującą, czy bieżący zestaw niezmienne wyznaczania wartości skrótu jest pusty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-124">Gets a value that indicates whether the current immutable hash set is empty.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0fea6-125">
            <see langword="true" /> Jeśli to wystąpienie jest puste. w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-125">
              <see langword="true" /> if this instance is empty; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-126">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-126">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-127">Określa, czy bieżący zestaw niezmienne wyznaczania wartości skrótu jest właściwy (strict) podzbiór określonej kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-127">Determines whether the current immutable hash set is a proper (strict) subset of a specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-128">
            <see langword="true" /> Jeśli bieżący jest podzbiorem prawidłowego określonej kolekcji; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-128">
              <see langword="true" /> if the current set is a proper subset of the specified collection; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-129">Jeśli bieżący zestaw jest właściwy podzbiór `other`, `other` musi mieć co najmniej jeden element, który nie ma bieżącego zestawu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-129">If the current set is a proper subset of `other`, `other` must have at least one element that the current set does not have.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-130">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-130">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-131">Określa, czy bieżący zestaw niezmienne wyznaczania wartości skrótu jest właściwy nadzbiór (strict) określonej kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-131">Determines whether the current immutable hash set is a proper (strict) superset of a specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-132">
            <see langword="true" /> Jeśli bieżący jest podzbiorem prawidłowego określonej kolekcji; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-132">
              <see langword="true" /> if the current set is a proper superset of the specified collection; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-133">Jeśli bieżący zestaw jest nadzbiorem prawidłowego `other`, bieżący zestaw musi mieć co najmniej jeden element który `other` nie ma.</span><span class="sxs-lookup"><span data-stu-id="0fea6-133">If the current set is a proper superset of `other`, the current set must have at least one element that `other` does not have.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-134">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-134">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-135">Określa, czy bieżący zestaw niezmienne wyznaczania wartości skrótu jest podzbiorem określonej kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-135">Determines whether the current immutable hash set is a subset of a specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-136">
            <see langword="true" /> Jeśli bieżący zestaw jest podzbiorem określonej kolekcji; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-136">
              <see langword="true" /> if the current set is a subset of the specified collection; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-137">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-137">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-138">Określa, czy bieżący zestaw niezmienne wyznaczania wartości skrótu jest nadzbiorem określonej kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-138">Determines whether the current immutable hash set is a superset of a specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-139">
            <see langword="true" /> Jeśli bieżący zestaw jest nadzbiorem określonej kolekcji; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-139">
              <see langword="true" /> if the current set is a superset of the specified collection; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyComparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; KeyComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; KeyComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.KeyComparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyComparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ KeyComparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-140">Pobiera obiekt, który jest używany do uzyskania skrótu kluczy i sprawdź równości wartości w zestawie niezmienne wyznaczania wartości skrótu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-140">Gets the object that is used to obtain hash codes for the keys and to check the equality of values in the immutable hash set.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0fea6-141">Moduł porównujący używane do uzyskania skrótu kluczy i sprawdź równości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-141">The comparer used to obtain hash codes for the keys and check equality.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-142">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-142">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-143">Określa, czy bieżący zestaw niezmienne skrótu nakłada się na określonej kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-143">Determines whether the current immutable hash set overlaps with the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-144">
            <see langword="true" /> Jeśli co najmniej jeden element wspólnej; udziału bieżącego zestawu i określonej kolekcji w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-144">
              <see langword="true" /> if the current set and the specified collection share at least one common element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Remove(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="0fea6-145">Element do usunięcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-145">The element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-146">Usuwa określony element z tego zestawu niezmienne wyznaczania wartości skrótu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-146">Removes the specified element from this immutable hash set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-147">Nowy zbiór z określonego elementu usunięte lub ustawić bieżącej, jeśli element nie może odnaleźć w zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-147">A new set with the specified element removed, or the current set if the element cannot be found in the set.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-148">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-148">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-149">Określa, czy w bieżącym zestawie skrótu niezmienne i określonej kolekcji zawierają te same elementy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-149">Determines whether the current immutable hash set and the specified collection contain the same elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-150">
            <see langword="true" /> Jeśli te zestawy są równe; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-150">
              <see langword="true" /> if the sets are equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExcept">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; SymmetricExcept (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; SymmetricExcept(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SymmetricExcept (other As IEnumerable(Of T)) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ SymmetricExcept(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-151">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-151">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-152">Tworzy zestaw niezmienne wyznaczania wartości skrótu, który zawiera tylko elementy, które znajdują się w bieżącym zestawie lub w określonej kolekcji, ale nie oba.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-152">Creates an immutable hash set that contains only elements that are present either in the current set or in the specified collection, but not both.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-153">Nowy zestaw zawiera elementy, które znajdują się tylko w bieżącym zestawie lub w określonej kolekcji, ale nie oba.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-153">A new set that contains the elements that are present only in the current set or in the specified collection, but not both.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="0fea6-154">Obiekt do dodania do zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-154">The object to add to the set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-155">Dodaje element do zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-155">Adds an item to the set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-156">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-156">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-157">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.ICollection%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-157">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.ICollection%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="0fea6-158">Zestaw jest przeznaczony tylko do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-158">The set is read-only.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of T).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Clear() = System::Collections::Generic::ICollection&lt;T&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-159">Usuwa wszystkie elementy z tego zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-159">Removes all items from this set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-160">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-160">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-161">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.ICollection%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-161">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.ICollection%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="0fea6-162">Zestaw jest przeznaczony tylko do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-162">The set is read-only.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As T(), arrayIndex As Integer) Implements ICollection(Of T).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex) = System::Collections::Generic::ICollection&lt;T&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="0fea6-163">Jednowymiarowa tablica, która jest miejscem docelowym elementów kopiowanych z zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-163">The one-dimensional array that is the destination of the elements copied from the set.</span>
          </span>
          <span data-ttu-id="0fea6-164">Tablica musi mieć indeksowane zaczynające od zera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-164">The array must have zero-based indexing.</span>
          </span>
        </param>
        <param name="arrayIndex">
          <span data-ttu-id="0fea6-165">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-165">The zero-based index in <c>array</c> at which copying begins.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-166">Kopiuje elementy zestawu do tablicy, zaczynając od określonego indeksu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-166">Copies the elements of the set to an array, starting at a particular index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-167">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-167">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-168">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.ICollection%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-168">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.ICollection%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-169">Zobacz <see cref="T:System.Collections.Generic.ICollection`1" /> interfejsu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-169">See the <see cref="T:System.Collections.Generic.ICollection`1" /> interface.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;T&gt;.Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;T&gt;.Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (item As T) As Boolean Implements ICollection(Of T).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;T&gt;.Remove(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="0fea6-170">Obiekt, który ma zostać usunięty z zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-170">The object to remove from the set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-171">Usuwa pierwsze wystąpienie określonego obiektu z zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-171">Removes the first occurrence of a specific object from the set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-172">
            <see langword="true" /> Jeśli element został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-172">
              <see langword="true" /> if the element is successfully removed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-173">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-173">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-174">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.ICollection%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-174">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.ICollection%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-175">Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-175">Returns an enumerator that iterates through the collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-176">Moduł wyliczający, który iteruje po kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-176">An enumerator that iterates through the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-177">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-177">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-178">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.IEnumerable%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-178">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.IEnumerable%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ISet&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="bool ISet&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ISet&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ISet&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As T) As Boolean Implements ISet(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ISet&lt;T&gt;.Add(T item) = System::Collections::Generic::ISet&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="0fea6-179">Element do dodania do kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-179">The element to add to the collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-180">Dodaje element do bieżącego zestawu i zwraca wartość wskazującą, czy element został pomyślnie dodany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-180">Adds an element to the current set and returns a value that indicates whether the element was successfully added.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-181">
            <see langword="true" /> Jeśli element zostanie dodany do zestawu; <see langword="false" /> Jeśli element jest już w zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-181">
              <see langword="true" /> if the element is added to the set; <see langword="false" /> if the element is already in the set.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-182">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-182">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-183">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.ISet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-183">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ISet&lt;T&gt;.ExceptWith">
      <MemberSignature Language="C#" Value="void ISet&lt;T&gt;.ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ISet&lt;T&gt;.ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ISet&lt;T&gt;#ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Sub ExceptWith (other As IEnumerable(Of T)) Implements ISet(Of T).ExceptWith" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ISet&lt;T&gt;.ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Generic::ISet&lt;T&gt;::ExceptWith;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-184">Kolekcja elementów do usunięcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-184">The collection of items to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-185">Usuwa wszystkie elementy w określonej kolekcji z bieżącego zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-185">Removes all elements in the specified collection from the current set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-186">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-186">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-187">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.ISet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-187">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ISet&lt;T&gt;.IntersectWith">
      <MemberSignature Language="C#" Value="void ISet&lt;T&gt;.IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ISet&lt;T&gt;.IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ISet&lt;T&gt;#IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Sub IntersectWith (other As IEnumerable(Of T)) Implements ISet(Of T).IntersectWith" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ISet&lt;T&gt;.IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Generic::ISet&lt;T&gt;::IntersectWith;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-188">Kolekcja do porównania z bieżącą kolekcją.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-188">The collection to compare to the current collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-189">Zmienia bieżący zestaw tak, aby zawierał tylko elementy, które również znajdują się w określonej kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-189">Modifies the current set so that it contains only elements that are also in a specified collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-190">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-190">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-191">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.ISet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-191">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ISet&lt;T&gt;.SymmetricExceptWith">
      <MemberSignature Language="C#" Value="void ISet&lt;T&gt;.SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ISet&lt;T&gt;.SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ISet&lt;T&gt;#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Sub SymmetricExceptWith (other As IEnumerable(Of T)) Implements ISet(Of T).SymmetricExceptWith" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ISet&lt;T&gt;.SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Generic::ISet&lt;T&gt;::SymmetricExceptWith;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-192">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-192">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-193">Zmienia bieżący zestaw tak, aby zawierał tylko elementy, które znajdują się w bieżącym zestawie lub w określonej kolekcji, ale nie oba.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-193">Modifies the current set so that it contains only elements that are present either in the current set or in the specified collection, but not both.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-194">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-194">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-195">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.ISet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-195">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ISet&lt;T&gt;.UnionWith">
      <MemberSignature Language="C#" Value="void ISet&lt;T&gt;.UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ISet&lt;T&gt;.UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Generic#ISet&lt;T&gt;#UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Sub UnionWith (other As IEnumerable(Of T)) Implements ISet(Of T).UnionWith" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ISet&lt;T&gt;.UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Generic::ISet&lt;T&gt;::UnionWith;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-196">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-196">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-197">Modyfikuje bieżącego zestawu, tak aby zawierała bieżący zestaw wszystkich elementów, które znajdują się w jednej lub w określonej kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-197">Modifies the current set so that it contains all elements that are present in either the current set or in the specified collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-198">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-198">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-199">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.ISet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-199">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="0fea6-200">Jednowymiarowa tablica, która jest miejscem docelowym elementów kopiowanych z zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-200">The one-dimensional array that is the destination of the elements copied from the set.</span>
          </span>
          <span data-ttu-id="0fea6-201">Tablica musi mieć indeksowane zaczynające od zera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-201">The array must have zero-based indexing.</span>
          </span>
        </param>
        <param name="arrayIndex">
          <span data-ttu-id="0fea6-202">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-202">The zero-based index in <c>array</c> at which copying begins.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-203">Kopiuje elementy zestawu do tablicy, zaczynając od określonego indeksu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-203">Copies the elements of the set to an array, starting at a particular index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-204">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-204">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-205">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Generic.ICollection%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-205">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Generic.ICollection%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-206">Zobacz <see cref="T:System.Collections.ICollection" /> interfejsu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-206">See the <see cref="T:System.Collections.ICollection" /> interface.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-207">Zobacz <see cref="T:System.Collections.ICollection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-207">See <see cref="T:System.Collections.ICollection" />.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-208">Zwraca moduł wyliczający, który iteruje po zestaw.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-208">Returns an enumerator that iterates through a set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-209">Moduł wyliczający, który może służyć do iterowania po zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-209">An enumerator that can be used to iterate through the set.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-210">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-210">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-211">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.IEnumerable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-211">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As T) As IImmutableSet(Of T) Implements IImmutableSet(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Add(T item) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="0fea6-212">Element do dodania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-212">The element to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-213">Dodaje określony element do tego zestawu niezmienialny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-213">Adds the specified element to this immutable set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-214">A nowy zestaw z elementem dodane lub tego zestawu, jeśli element jest już w zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-214">A new set with the element added, or this set if the element is already in the set.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-215">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-215">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-216">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-216">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Immutable.IImmutableSet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Clear">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Function Clear () As IImmutableSet(Of T) Implements IImmutableSet(Of T).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Clear() = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-217">Pobiera pusty zestaw, który ma tego samego sortowania i kolejność semantyki jako tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-217">Retrieves an empty set that has the same sorting and ordering semantics as this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-218">Pusty zestaw, który ma tego samego sortowania lub porządkowanie semantyki jako tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-218">An empty set that has the same sorting or ordering semantics as this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-219">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-219">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-220">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-220">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Immutable.IImmutableSet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Except">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Except (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Except(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Except(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Function Except (other As IEnumerable(Of T)) As IImmutableSet(Of T) Implements IImmutableSet(Of T).Except" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Except(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Except;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Except(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-221">Kolekcja elementów do usunięcia z tego zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-221">The collection of items to remove from this set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-222">Usuwa elementy w określonej kolekcji z bieżącego zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-222">Removes the elements in the specified collection from the current set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-223">A nowy zestaw z elementami usunięte; lub oryginalnego zestawu, jeśli żaden z elementów nie był w zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-223">A new set with the items removed; or the original set if none of the items were in the set.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-224">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-224">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-225">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-225">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Immutable.IImmutableSet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Intersect">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Intersect (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Intersect(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Intersect(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Function Intersect (other As IEnumerable(Of T)) As IImmutableSet(Of T) Implements IImmutableSet(Of T).Intersect" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Intersect(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Intersect;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-226">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-226">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-227">Tworzy niezmienne zestaw, który zawiera elementy, które istnieją w tym zestawie i określonego zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-227">Creates an immutable set that contains elements that exist in both this set and the specified set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-228">Nowy zestaw niezmienne zawiera wszystkie elementy, które istnieją w obu zestawach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-228">A new immutable set that contains any elements that exist in both sets.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-229">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-229">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-230">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-230">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Immutable.IImmutableSet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Remove">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (item As T) As IImmutableSet(Of T) Implements IImmutableSet(Of T).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Remove(T item) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="0fea6-231">Element do usunięcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-231">The element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-232">Usuwa określony element z tego zestawu niezmienialny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-232">Removes the specified element from this immutable set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-233">Nowy zbiór z określonego elementu usunięte lub ustawić bieżącej, jeśli element nie może odnaleźć w zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-233">A new set with the specified element removed, or the current set if the element cannot be found in the set.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-234">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-234">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-235">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-235">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Immutable.IImmutableSet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.SymmetricExcept">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.SymmetricExcept (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.SymmetricExcept(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#SymmetricExcept(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Function SymmetricExcept (other As IEnumerable(Of T)) As IImmutableSet(Of T) Implements IImmutableSet(Of T).SymmetricExcept" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.SymmetricExcept(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::SymmetricExcept;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-236">Kolekcja do porównania z bieżącym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-236">The collection to compare to the current set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-237">Tworzy niezmienne zestaw, który zawiera tylko elementy, które znajdują się w bieżącym zestawie lub w określonej kolekcji, ale nie oba.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-237">Creates an immutable set that contains only elements that are present either in the current set or in the specified collection, but not both.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-238">Nowy zestaw zawiera elementy, które znajdują się tylko w bieżącym zestawie lub w określonej kolekcji, ale nie oba.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-238">A new set that contains the elements that are present only in the current set or in the specified collection, but not both.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-239">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-239">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-240">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-240">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Immutable.IImmutableSet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableSet&lt;T&gt;.Union">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableSet&lt;T&gt; IImmutableSet&lt;T&gt;.Union (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; System.Collections.Immutable.IImmutableSet&lt;T&gt;.Union(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.System#Collections#Immutable#IImmutableSet&lt;T&gt;#Union(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Function Union (other As IEnumerable(Of T)) As IImmutableSet(Of T) Implements IImmutableSet(Of T).Union" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ System.Collections.Immutable.IImmutableSet&lt;T&gt;.Union(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other) = System::Collections::Immutable::IImmutableSet&lt;T&gt;::Union;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.Union(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-241">Dodawania elementów z kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-241">The collection to add elements from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-242">Tworzy nowy zestaw niezmienne, który zawiera wszystkie elementy, które znajdują się w bieżącym zestawie lub w określonej kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-242">Creates a new immutable set that contains all elements that are present in either the current set or in the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-243">Nowy zestaw niezmienne z elementami dodane; lub oryginalnego zestawu, jeśli wszystkie elementy zostały już w zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-243">A new immutable set with the items added; or the original set if all the items were already in the set.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-244">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-244">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="0fea6-245">Można go używać tylko wtedy, gdy <xref:System.Collections.Immutable.ImmutableHashSet%601> wystąpienia jest rzutowane na <xref:System.Collections.Immutable.IImmutableSet%601> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="0fea6-245">It can be used only when the <xref:System.Collections.Immutable.ImmutableHashSet%601> instance is cast to an <xref:System.Collections.Immutable.IImmutableSet%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBuilder">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt;.Builder ToBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1/Builder&lt;!T&gt; ToBuilder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.ToBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Function ToBuilder () As ImmutableHashSet(Of T).Builder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt;::Builder ^ ToBuilder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;+Builder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0fea6-246">Tworzy zestaw niezmienne wyznaczania wartości skrótu, ma tę samą zawartość jako tego zestawu, który może wydajnie ulegać mutacjom przez wiele operacji za pomocą standardowych interfejsów modyfikowalne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-246">Creates an immutable hash set that has the same contents as this set and can be efficiently mutated across multiple operations by using standard mutable interfaces.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-247">Zestaw o tej samej treści tego zestawu, które można skutecznie ulegać mutacjom przez wiele operacji za pomocą standardowych interfejsów modyfikowalne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-247">A set with the same contents as this set that can be efficiently mutated across multiple operations by using standard mutable interfaces.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-248">To jest operacją O(1) i powoduje tylko alokacji pojedynczego pamięci (małe).</span><span class="sxs-lookup"><span data-stu-id="0fea6-248">This is an O(1) operation and results in only a single (small) memory allocation.</span></span> <span data-ttu-id="0fea6-249">Modyfikowalną kolekcję, która jest zwracana nie jest bezpieczne dla wątków.</span><span class="sxs-lookup"><span data-stu-id="0fea6-249">The mutable collection that is returned is not thread safe.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableSet`1.TryGetValue(`0,`0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue">
          <span data-ttu-id="0fea6-250">Wartość do wyszukania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-250">The value to search for.</span>
          </span>
        </param>
        <param name="actualValue">
          <span data-ttu-id="0fea6-251">Wartość z zestawu, którego nie można odnaleźć lub oryginalnej wartości, jeśli wyszukiwanie nie zwróciło Brak dopasowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-251">The value from the set that the search found, or the original value if the search yielded no match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-252">Wyszukuje zestawu dla danej wartości i zwraca wartość równa znalezione, ile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-252">Searches the set for a given value and returns the equal value it finds, if any.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-253">Wartość wskazująca, czy wyszukiwanie zakończyła się powodzeniem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-253">A value indicating whether the search was successful.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fea6-254">Może to być przydatne, jeśli chcesz ponownie użyć zamiast nowo utworzone wcześniej przechowywanych odwołanie (dzięki czemu udostępnianie więcej odwołań może wystąpić) lub odszukać wartość, która zawiera bardziej szczegółowy danych niż aktualnie zainstalowana, wartość, mimo że ich funkcji porównania wskazują, że są one takie same.</span><span class="sxs-lookup"><span data-stu-id="0fea6-254">This can be useful when you want to reuse a previously stored reference instead of a newly constructed one (so that more sharing of references can occur) or to look up a value that has more complete data than the value you currently have, although their comparer functions indicate they are equal.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; Union (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; Union(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.Union(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Union (other As IEnumerable(Of T)) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="0fea6-255">Dodawania elementów z kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-255">The collection to add elements from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-256">Tworzy nowy zestaw niezmienne wyznaczania wartości skrótu, który zawiera wszystkie elementy, które znajdują się w bieżącym zestawie lub w określonej kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-256">Creates a new immutable hash set that contains all elements that are present in either the current set or in the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-257">Nowy skrót niezmienne Ustaw elementy dodane; lub oryginalnego zestawu, jeśli wszystkie elementy zostały już w zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-257">A new immutable hash set with the items added; or the original set if all the items were already in the set.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithComparer">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableHashSet&lt;T&gt; WithComparer (System.Collections.Generic.IEqualityComparer&lt;T&gt; equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableHashSet`1&lt;!T&gt; WithComparer(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableHashSet`1.WithComparer(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithComparer (equalityComparer As IEqualityComparer(Of T)) As ImmutableHashSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableHashSet&lt;T&gt; ^ WithComparer(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ equalityComparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableHashSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalityComparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="equalityComparer">
          <span data-ttu-id="0fea6-258">Moduł porównujący równości do użycia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-258">The equality comparer to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0fea6-259">Pobiera wystąpienie elementu zestawu niezmienne wyznaczania wartości skrótu, który używa porównania równości określony dla metody wyszukiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-259">Gets an instance of the immutable hash set that uses the specified equality comparer for its search methods.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0fea6-260">Wystąpienie tego zestawu niezmienne wyznaczania wartości skrótu, który używa danej porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0fea6-260">An instance of this immutable hash set that uses the given comparer.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
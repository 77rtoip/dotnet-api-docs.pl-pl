<Type Name="IImmutableList&lt;T&gt;" FullName="System.Collections.Immutable.IImmutableList&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2a9bfa657b0bdfd38761dbc47d9f0d26e9496fb0" />
    <Meta Name="ms.sourcegitcommit" Value="d0bb31ec8354fa58c62c2a646057eec11d3e2150" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/17/2018" />
    <Meta Name="ms.locfileid" Value="36644883" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IImmutableList&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IImmutableList`1&lt;T&gt; implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Immutable.IImmutableList`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface IImmutableList(Of T)&#xA;Implements IEnumerable(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public interface class IImmutableList : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;" />
  <TypeSignature Language="F#" Value="type IImmutableList&lt;'T&gt; = interface&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IReadOnlyList&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Immutable</AssemblyName>
    <AssemblyVersion>1.2.0.0</AssemblyVersion>
    <AssemblyVersion>1.2.1.0</AssemblyVersion>
    <AssemblyVersion>1.2.2.0</AssemblyVersion>
    <AssemblyVersion>1.2.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T">Typ elementów na liście.</typeparam>
    <summary>Reprezentuje listę elementów, których nie można zmodyfikować.  
  
 **Pakiet NuGet**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see> (<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#Remarks">o kolekcjach niezmienialnych oraz instrukcje dotyczące instalowania</see>)</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po dodaniu lub usunięciu elementów z <xref:System.Collections.Immutable.IImmutableList%601>, tworzona jest kopia oryginalnej listy wprowadzania zmian, stosowane... Przyrostowe zmiany listy udostępnianie tak dużej ilości pamięci, jak to możliwe z wcześniejszymi wersjami listy i Włącz wyrzucania elementów bezużytecznych wyczyścić listę unikatowych dane, które jest już wywoływane.  
  
 Aby utworzyć nową listę, należy użyć metody tworzenia.  
  
 <xref:System.Collections.Immutable.IImmutableList%601> Nie ma publicznego konstruktora, ponieważ spowoduje to utworzenie pustej listy niezmienne. Należy utworzyć nową listę przy użyciu metody tworzenia. Można dodać nowe elementy na kopię oryginalnego przy użyciu listy <xref:System.Collections.Immutable.ImmutableList%601.Add%2A>, i <xref:System.Collections.Immutable.ImmutableList%601.AddRange%2A> metody.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; Add (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; Add(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (value As T) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ Add(T value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.Add value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do dodania do listy.</param>
        <summary>Tworzy kopię listy, a następnie dodaje określony obiekt do końca listy skopiowany.</summary>
        <returns>Nowa lista z obiektem dodane lub tej listy, jeśli obiekt jest już na liście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddRange (items As IEnumerable(Of T)) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ items);" />
      <MemberSignature Language="F#" Value="abstract member AddRange : seq&lt;'T&gt; -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.AddRange items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="items">Obiekty, które można dodać do listy.</param>
        <summary>Tworzy kopię listy, a następnie dodaje określone obiekty na końcu skopiowanego listy.</summary>
        <returns>Nowa lista z elementami dodane lub tej listy, jeśli elementy już istnieje na liście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy listę przy użyciu wszystkich elementów, które są usuwane, ale przy użyciu tego samego sortowania i kolejność semantyką jako tej listy.</summary>
        <returns>Pusta lista, który ma tego samego sortowania i kolejność semantykę, jak to wystąpienie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count, System.Collections.Generic.IEqualityComparer&lt;T&gt; equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item, int32 index, int32 count, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer, equalityComparer As IEqualityComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T * int * int * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; int" Usage="iImmutableList.IndexOf (item, index, count, equalityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="equalityComparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Immutable.IImmutableList`1" />. Ta wartość może być null dla typów odwołań.</param>
        <param name="index">Liczony od zera indes początkowy wyszukiwania. 0 (zero) jest prawidłowa w pustej listy.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="equalityComparer">Moduł porównujący równość, który służy do lokalizowania <c>elementu</c>.</param>
        <summary>Wyszukuje określonego obiektu i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Immutable.IImmutableList`1" /> , rozpoczyna się od określonego indeksu i zawiera określonej liczby elementów.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="item" /> w zakresie elementów w <see cref="T:System.Collections.Immutable.IImmutableList`1" /> rozpoczynająca się w <paramref name="index" /> i zawiera <paramref name="count" /> liczby elementów, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; Insert (int index, T element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; Insert(int32 index, !T element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, element As T) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ Insert(int index, T element);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.Insert (index, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="element" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w której mają zostać wstawione wartości.</param>
        <param name="element">Obiekt do wstawienia.</param>
        <summary>Wstawia określony element pod określonym indeksem na liście niezmienne.</summary>
        <returns>Nowa lista niezmienne zawiera określony element.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertRange (index As Integer, items As IEnumerable(Of T)) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ items);" />
      <MemberSignature Language="F#" Value="abstract member InsertRange : int * seq&lt;'T&gt; -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.InsertRange (index, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym należy dodać nowe elementy.</param>
        <param name="items">Elementy do wstawienia.</param>
        <summary>Wstawia określony elementy pod określonym indeksem na liście niezmienne.</summary>
        <returns>Nowa lista niezmienne zawiera określone elementy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count, System.Collections.Generic.IEqualityComparer&lt;T&gt; equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(!T item, int32 index, int32 count, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer, equalityComparer As IEqualityComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : 'T * int * int * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; int" Usage="iImmutableList.LastIndexOf (item, index, count, equalityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="equalityComparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania na liście. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłowa w pustej listy.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="equalityComparer">Moduł porównujący równość, aby dopasować <c>elementu</c>.</param>
        <summary>Wyszukuje określonego obiektu i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Immutable.IImmutableList`1" /> zawierający określoną liczbę elementów i kończy się pod określonym indeksem.</summary>
        <returns>Zwraca <see cref="T:System.Int32" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; Remove (T value, System.Collections.Generic.IEqualityComparer&lt;T&gt; equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; Remove(!T value, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (value As T, equalityComparer As IEqualityComparer(Of T)) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ Remove(T value, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.Remove (value, equalityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="equalityComparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do usunięcia z listy.</param>
        <param name="equalityComparer">Moduł porównujący równość, który służy do lokalizowania <c>wartość</c>.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z tej listy niezmienne.</summary>
        <returns>Zwraca nową listę z określonym obiektem usunięte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAll : Predicate&lt;'T&gt; -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegat definiujący warunki elementów do usunięcia.</param>
        <summary>Usuwa wszystkie elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns>Nowa lista niezmienne z usunięte elementy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (index As Integer) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu do usunięcia.</param>
        <summary>Usuwa element pod określonym indeksem niezmienne listy.</summary>
        <returns>Nowa lista z elementem, który został usunięty.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; RemoveRange (System.Collections.Generic.IEnumerable&lt;T&gt; items, System.Collections.Generic.IEqualityComparer&lt;T&gt; equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; RemoveRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; items, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveRange (items As IEnumerable(Of T), equalityComparer As IEqualityComparer(Of T)) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ RemoveRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ items, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="abstract member RemoveRange : seq&lt;'T&gt; * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.RemoveRange (items, equalityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="equalityComparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="items">Obiekty, które można usunąć z listy.</param>
        <param name="equalityComparer">Moduł porównujący równość służące do określenia, czy <c>elementów</c> pasować do żadnych obiektów na liście.</param>
        <summary>Usuwa określony obiekt z listy.</summary>
        <returns>Nowa lista niezmienne z określonych obiektów usunięte, jeśli <paramref name="items" /> dopasowane obiektów na liście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveRange (index As Integer, count As Integer) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member RemoveRange : int * int -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks początkowy zakresu elementów do usunięcia.</param>
        <param name="count">Liczba elementów do usunięcia.</param>
        <summary>Usuwa zakres elementów z <see cref="T:System.Collections.Immutable.IImmutableList`1" />.</summary>
        <returns>Nowa lista niezmienne z usunięte elementy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; Replace (T oldValue, T newValue, System.Collections.Generic.IEqualityComparer&lt;T&gt; equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; Replace(!T oldValue, !T newValue, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As T, newValue As T, equalityComparer As IEqualityComparer(Of T)) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ Replace(T oldValue, T newValue, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="abstract member Replace : 'T * 'T * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.Replace (oldValue, newValue, equalityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="T" />
        <Parameter Name="newValue" Type="T" />
        <Parameter Name="equalityComparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="oldValue">Element, który ma zostać zastąpione.</param>
        <param name="newValue">Element, aby zastąpić pierwsze wystąpienie <c>oldValue</c> z</param>
        <param name="equalityComparer">Moduł porównujący równość na potrzeby dopasowywania <c>oldValue</c>.</param>
        <summary>Zwraca nową listę z pierwszym pasującym elemencie na liście zastąpione określony element.</summary>
        <returns>Nowa lista, która zawiera <paramref name="newValue" />, nawet jeśli <paramref name="oldvalue" /> jest taka sama jak <paramref name="newValue" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> nie istnieje na liście.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableList&lt;T&gt; SetItem (int index, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableList`1&lt;!T&gt; SetItem(int32 index, !T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableList`1.SetItem(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetItem (index As Integer, value As T) As IImmutableList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableList&lt;T&gt; ^ SetItem(int index, T value);" />
      <MemberSignature Language="F#" Value="abstract member SetItem : int * 'T -&gt; System.Collections.Immutable.IImmutableList&lt;'T&gt;" Usage="iImmutableList.SetItem (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja na liście elementu do zamiany.</param>
        <param name="value">Element, aby zastąpić stary element z.</param>
        <summary>Zamienia określony element elementu z listy na określonej pozycji.</summary>
        <returns>Nowa lista zawiera nowy element, nawet jeśli element w określonej lokalizacji jest taka sama jak nowy element.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
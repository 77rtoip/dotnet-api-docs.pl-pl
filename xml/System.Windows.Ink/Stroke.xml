<Type Name="Stroke" FullName="System.Windows.Ink.Stroke">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5176cd84a5c3fe065d0973e60bc3ad7681df4a7f" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69174559" /></Metadata><TypeSignature Language="C#" Value="public class Stroke : System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Stroke extends System.Object implements class System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Ink.Stroke" />
  <TypeSignature Language="VB.NET" Value="Public Class Stroke&#xA;Implements INotifyPropertyChanged" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stroke : System::ComponentModel::INotifyPropertyChanged" />
  <TypeSignature Language="F#" Value="type Stroke = class&#xA;    interface INotifyPropertyChanged" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.INotifyPropertyChanged</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje pojedynczy pociągnięcia odręcznego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Ink.Stroke> jest obiektem danych, który jest zbierany z urządzenia wskazującego, na przykład piórem lub myszą. Program może być tworzony i manipulowany programowo i może być prezentowany wizualnie w elemencie z włączoną obsługą atramentu, <xref:System.Windows.Controls.InkCanvas>na przykład. <xref:System.Windows.Ink.Stroke> A <xref:System.Windows.Ink.Stroke> zawiera informacje na temat jego pozycji i wyglądu. Właściwość jest kolekcją obiektów, która <xref:System.Windows.Ink.Stroke>określa położenie. <xref:System.Windows.Input.StylusPoint> <xref:System.Windows.Ink.Stroke.StylusPoints%2A> <xref:System.Windows.Ink.DrawingAttributes> Właściwość określa wygląd obrysu.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Ink.StrokeCollection" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Ink.Stroke" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stroke (System.Windows.Input.StylusPointCollection stylusPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.StylusPointCollection stylusPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.#ctor(System.Windows.Input.StylusPointCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stylusPoints As StylusPointCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stroke(System::Windows::Input::StylusPointCollection ^ stylusPoints);" />
      <MemberSignature Language="F#" Value="new System.Windows.Ink.Stroke : System.Windows.Input.StylusPointCollection -&gt; System.Windows.Ink.Stroke" Usage="new System.Windows.Ink.Stroke stylusPoints" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stylusPoints" Type="System.Windows.Input.StylusPointCollection" />
      </Parameters>
      <Docs>
        <param name="stylusPoints"><see cref="T:System.Windows.Input.StylusPointCollection" /> Reprezentuje .<see cref="T:System.Windows.Ink.Stroke" /></param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Ink.Stroke" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć <xref:System.Windows.Ink.Stroke> obiekt <xref:System.Windows.Input.StylusPointCollection> z i <xref:System.Windows.Ink.DrawingAttributes> . W <xref:System.Windows.Controls.InkPresenter> tym przykładzie przyjęto założenie, `myInkPresenter`że istnieje wywołana.  
  
 [!code-csharp[StrokeSnippets#2](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#2)]
 [!code-vb[StrokeSnippets#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stylusPoints" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="stylusPoints" />jest puste.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stroke (System.Windows.Input.StylusPointCollection stylusPoints, System.Windows.Ink.DrawingAttributes drawingAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.StylusPointCollection stylusPoints, class System.Windows.Ink.DrawingAttributes drawingAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.#ctor(System.Windows.Input.StylusPointCollection,System.Windows.Ink.DrawingAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stroke(System::Windows::Input::StylusPointCollection ^ stylusPoints, System::Windows::Ink::DrawingAttributes ^ drawingAttributes);" />
      <MemberSignature Language="F#" Value="new System.Windows.Ink.Stroke : System.Windows.Input.StylusPointCollection * System.Windows.Ink.DrawingAttributes -&gt; System.Windows.Ink.Stroke" Usage="new System.Windows.Ink.Stroke (stylusPoints, drawingAttributes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stylusPoints" Type="System.Windows.Input.StylusPointCollection" />
        <Parameter Name="drawingAttributes" Type="System.Windows.Ink.DrawingAttributes" />
      </Parameters>
      <Docs>
        <param name="stylusPoints"><see cref="T:System.Windows.Input.StylusPointCollection" /> Reprezentuje .<see cref="T:System.Windows.Ink.Stroke" /></param>
        <param name="drawingAttributes">Obiekt, który określa wygląd <see cref="T:System.Windows.Ink.Stroke" />elementu. <see cref="T:System.Windows.Ink.DrawingAttributes" /></param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Ink.Stroke" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć <xref:System.Windows.Ink.Stroke> obiekt <xref:System.Windows.Input.StylusPointCollection> z i <xref:System.Windows.Ink.DrawingAttributes> .  W <xref:System.Windows.Controls.InkPresenter> tym przykładzie przyjęto założenie, `myInkPresenter`że istnieje wywołana.  
  
 [!code-csharp[StrokeSnippets#2](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#2)]
 [!code-vb[StrokeSnippets#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stylusPoints" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="drawingAtrributes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="stylusPoints" />jest puste.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddPropertyData">
      <MemberSignature Language="C#" Value="public void AddPropertyData (Guid propertyDataId, object propertyData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPropertyData(valuetype System.Guid propertyDataId, object propertyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.AddPropertyData(System.Guid,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPropertyData (propertyDataId As Guid, propertyData As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPropertyData(Guid propertyDataId, System::Object ^ propertyData);" />
      <MemberSignature Language="F#" Value="member this.AddPropertyData : Guid * obj -&gt; unit" Usage="stroke.AddPropertyData (propertyDataId, propertyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyDataId" Type="System.Guid" />
        <Parameter Name="propertyData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="propertyDataId">Unikatowy identyfikator właściwości.</param>
        <param name="propertyData">Wartość właściwości niestandardowej. <paramref name="propertyData" />musi być <see cref="T:System.Char" />typu, <see cref="T:System.UInt16" /> ,<see cref="T:System.UInt32" /> ,,<see cref="T:System.Double" />,, ,<see cref="T:System.Int64" />,, ,<see cref="T:System.DateTime" />,, <see cref="T:System.UInt64" /> <see cref="T:System.Int16" /> <see cref="T:System.Byte" /> <see cref="T:System.Int32" /> <see cref="T:System.Single" /> <see cref="T:System.Boolean" /> lub<see cref="T:System.String" />Tablicatych typów danych, z wyjątkiem <see cref="T:System.String" />, co jest niedozwolone. <see cref="T:System.Decimal" /></param>
        <summary>Dodaje właściwość niestandardową do <see cref="T:System.Windows.Ink.Stroke" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przydatna, <xref:System.Windows.Ink.Stroke>Jeśli konieczne jest przechowywanie dodatkowych informacji w programie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodać niestandardową właściwość do <xref:System.Windows.Ink.Stroke> obiektu.  
  
 [!code-csharp[StrokeSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#3)]
 [!code-vb[StrokeSnippets#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument nie jest jednym z dozwolonych typów danych wymienionych <see langword="Parameters" /> w sekcji. <paramref name="propertyData" /></exception>
        <altmember cref="M:System.Windows.Ink.Stroke.ContainsPropertyData(System.Guid)" />
        <altmember cref="M:System.Windows.Ink.Stroke.GetPropertyData(System.Guid)" />
        <altmember cref="M:System.Windows.Ink.Stroke.RemovePropertyData(System.Guid)" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Ink.Stroke Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Ink.Stroke Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Stroke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Ink::Stroke ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Windows.Ink.Stroke&#xA;override this.Clone : unit -&gt; System.Windows.Ink.Stroke" Usage="stroke.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.Stroke</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca głęboką kopię istniejącego <see cref="T:System.Windows.Ink.Stroke" /> obiektu.</summary>
        <returns>Nowy <see cref="T:System.Windows.Ink.Stroke" /> obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości obiektu, który jest dokładną kopią innego obiektu, mają takie same wartości jak właściwości oryginalnego obiektu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje, jak uzyskać kopię bieżącego <xref:System.Windows.Ink.Stroke> obiektu.  
  
 [!code-csharp[StrokeSnippets#5](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#5)]
 [!code-vb[StrokeSnippets#5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsPropertyData">
      <MemberSignature Language="C#" Value="public bool ContainsPropertyData (Guid propertyDataId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsPropertyData(valuetype System.Guid propertyDataId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.ContainsPropertyData(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsPropertyData (propertyDataId As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsPropertyData(Guid propertyDataId);" />
      <MemberSignature Language="F#" Value="member this.ContainsPropertyData : Guid -&gt; bool" Usage="stroke.ContainsPropertyData propertyDataId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyDataId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="propertyDataId">Unikatowy identyfikator właściwości.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Windows.Ink.Stroke" /> obiekt zawiera określoną właściwość niestandardową.</summary>
        <returns>Zwraca <see langword="true" /> czy właściwość niestandardową istnieje; w przeciwnym <see langword="false" />razie zwraca wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak ustalić, czy <xref:System.Windows.Ink.Stroke> obiekt ma właściwość niestandardową.  
  
 [!code-csharp[StrokeSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#3)]
 [!code-vb[StrokeSnippets#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Ink.Stroke.AddPropertyData(System.Guid,System.Object)" />
        <altmember cref="M:System.Windows.Ink.Stroke.GetPropertyData(System.Guid)" />
        <altmember cref="M:System.Windows.Ink.Stroke.RemovePropertyData(System.Guid)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Draw">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Media.DrawingContext" />Renderuje <see cref="T:System.Windows.Ink.Stroke" /> obiekt na podstawie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public void Draw (System.Windows.Media.DrawingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Draw(class System.Windows.Media.DrawingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.Draw(System.Windows.Media.DrawingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Draw (context As DrawingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Draw(System::Windows::Media::DrawingContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.Draw : System.Windows.Media.DrawingContext -&gt; unit" Usage="stroke.Draw context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Media.DrawingContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Windows.Media.DrawingContext" /> Obiekt, na którym będzie renderowany pociągnięcie.</param>
        <summary>Renderuje <see cref="T:System.Windows.Media.DrawingContext" />obiekt na podstawie określonego. <see cref="T:System.Windows.Ink.Stroke" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak narysować <xref:System.Windows.Ink.Stroke> obiekt za <xref:System.Windows.Media.DrawingContext>pomocą.  
  
 [!code-csharp[DrawTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawTransform/CSharp/Program.cs#1)]
 [!code-vb[DrawTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawTransform/VisualBasic/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public void Draw (System.Windows.Media.DrawingContext drawingContext, System.Windows.Ink.DrawingAttributes drawingAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Draw(class System.Windows.Media.DrawingContext drawingContext, class System.Windows.Ink.DrawingAttributes drawingAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.Draw(System.Windows.Media.DrawingContext,System.Windows.Ink.DrawingAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Draw(System::Windows::Media::DrawingContext ^ drawingContext, System::Windows::Ink::DrawingAttributes ^ drawingAttributes);" />
      <MemberSignature Language="F#" Value="member this.Draw : System.Windows.Media.DrawingContext * System.Windows.Ink.DrawingAttributes -&gt; unit" Usage="stroke.Draw (drawingContext, drawingAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawingContext" Type="System.Windows.Media.DrawingContext" />
        <Parameter Name="drawingAttributes" Type="System.Windows.Ink.DrawingAttributes" />
      </Parameters>
      <Docs>
        <param name="drawingContext"><see cref="T:System.Windows.Media.DrawingContext" /> Obiekt, na którym będzie renderowany pociągnięcie.</param>
        <param name="drawingAttributes"><see cref="T:System.Windows.Ink.DrawingAttributes" /> Obiekt definiujący atrybuty rysowanego pociągnięcia.</param>
        <summary>Renderuje <see cref="T:System.Windows.Media.DrawingContext" /> <see cref="T:System.Windows.Ink.DrawingAttributes" />obiekt na podstawie określonego i. <see cref="T:System.Windows.Ink.Stroke" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak narysować <xref:System.Windows.Ink.Stroke> obiekt za <xref:System.Windows.Media.DrawingContext> pomocą i <xref:System.Windows.Ink.DrawingAttributes>.  
  
 [!code-csharp[DrawTransform#2](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawTransform/CSharp/Program.cs#2)]
 [!code-vb[DrawTransform#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawTransform/VisualBasic/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawCore">
      <MemberSignature Language="C#" Value="protected virtual void DrawCore (System.Windows.Media.DrawingContext drawingContext, System.Windows.Ink.DrawingAttributes drawingAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DrawCore(class System.Windows.Media.DrawingContext drawingContext, class System.Windows.Ink.DrawingAttributes drawingAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.DrawCore(System.Windows.Media.DrawingContext,System.Windows.Ink.DrawingAttributes)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DrawCore(System::Windows::Media::DrawingContext ^ drawingContext, System::Windows::Ink::DrawingAttributes ^ drawingAttributes);" />
      <MemberSignature Language="F#" Value="abstract member DrawCore : System.Windows.Media.DrawingContext * System.Windows.Ink.DrawingAttributes -&gt; unit&#xA;override this.DrawCore : System.Windows.Media.DrawingContext * System.Windows.Ink.DrawingAttributes -&gt; unit" Usage="stroke.DrawCore (drawingContext, drawingAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawingContext" Type="System.Windows.Media.DrawingContext" />
        <Parameter Name="drawingAttributes" Type="System.Windows.Ink.DrawingAttributes" />
      </Parameters>
      <Docs>
        <param name="drawingContext"><see cref="T:System.Windows.Media.DrawingContext" /> Obiekt, na którym będzie renderowany pociągnięcie.</param>
        <param name="drawingAttributes"><see cref="T:System.Windows.Ink.DrawingAttributes" /> Obiekt definiujący atrybuty rysowanego pociągnięcia.</param>
        <summary>Renderuje <see cref="T:System.Windows.Media.DrawingContext" />naokreślonym przy użyciu określonego <see cref="T:System.Windows.Ink.DrawingAttributes" />. <see cref="T:System.Windows.Ink.Stroke" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp <xref:System.Windows.Ink.Stroke> metodę, aby wykonać niestandardowe Rysowanie w przypadku dziedziczenia z klasy. <xref:System.Windows.Ink.Stroke.DrawCore%2A>  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak narysować okrąg w każdej <xref:System.Windows.Input.StylusPoint> <xref:System.Windows.Ink.Stroke>z nich. Jeśli właściwość jest ustawiona na `true`, <xref:System.Windows.Ink.Stroke.GetBezierStylusPoints%2A> jest używana do uzyskania punktów pióra. <xref:System.Windows.Ink.DrawingAttributes.FitToCurve%2A> W przeciwnym razie właściwość jest używana. <xref:System.Windows.Ink.Stroke.StylusPoints%2A>  
  
 [!code-csharp[StrokeSnippets#23](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyStroke.cs#23)]
 [!code-vb[StrokeSnippets#23](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyStroke.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawingAttributes">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.DrawingAttributes DrawingAttributes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Ink.DrawingAttributes DrawingAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Ink.Stroke.DrawingAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Property DrawingAttributes As DrawingAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Ink::DrawingAttributes ^ DrawingAttributes { System::Windows::Ink::DrawingAttributes ^ get(); void set(System::Windows::Ink::DrawingAttributes ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DrawingAttributes : System.Windows.Ink.DrawingAttributes with get, set" Usage="System.Windows.Ink.Stroke.DrawingAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.DrawingAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Ink.DrawingAttributes" /> <see cref="T:System.Windows.Ink.Stroke" /> obiekt dla obiektu.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te atrybuty, takie jak kolor i szerokość, są stosowane do <xref:System.Windows.Ink.Stroke> obiektu w trakcie jego rysowania.  
  
 Zmiana <xref:System.Windows.Ink.Stroke.DrawingAttributes%2A> powoduje, <xref:System.Windows.Ink.Stroke.DrawingAttributesChanged> że zdarzenie zostanie wyzwolone.  
  
   
  
## Examples  
 Poniższy przykład ustawia, <xref:System.Windows.Ink.Stroke.DrawingAttributes%2A> aby ustawić kolor na zielony.  
  
 [!code-csharp[StrokeSnippets#7](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#7)]
 [!code-vb[StrokeSnippets#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ustawiona wartość to <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Ink.Stroke.OnDrawingAttributesChanged(System.Windows.Ink.PropertyDataChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawingAttributesChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Ink.PropertyDataChangedEventHandler DrawingAttributesChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Ink.PropertyDataChangedEventHandler DrawingAttributesChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Ink.Stroke.DrawingAttributesChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event DrawingAttributesChanged As PropertyDataChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Ink::PropertyDataChangedEventHandler ^ DrawingAttributesChanged;" />
      <MemberSignature Language="F#" Value="member this.DrawingAttributesChanged : System.Windows.Ink.PropertyDataChangedEventHandler " Usage="member this.DrawingAttributesChanged : System.Windows.Ink.PropertyDataChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.PropertyDataChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="P:System.Windows.Ink.Stroke.DrawingAttributes" /> zmianie skojarzonego <see cref="T:System.Windows.Ink.Stroke" /> z obiektem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Ink.PropertyDataChangedEventArgs> Zawiera informacje o modyfikowanej właściwości. Można porównać <xref:System.Windows.Ink.PropertyDataChangedEventArgs.PropertyGuid%2A> właściwość z <xref:System.Windows.Ink.DrawingAttributeIds> członkami, aby zobaczyć, która wartość została zmieniona.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodać procedurę obsługi dla tego zdarzenia.  
  
 [!code-csharp[StrokeSnippets#8](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#8)]
 [!code-vb[StrokeSnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Ink.Stroke.DrawingAttributes" />
        <altmember cref="E:System.Windows.Ink.Stroke.DrawingAttributesReplaced" />
        <altmember cref="M:System.Windows.Ink.Stroke.OnDrawingAttributesChanged(System.Windows.Ink.PropertyDataChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawingAttributesReplaced">
      <MemberSignature Language="C#" Value="public event System.Windows.Ink.DrawingAttributesReplacedEventHandler DrawingAttributesReplaced;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Ink.DrawingAttributesReplacedEventHandler DrawingAttributesReplaced" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Ink.Stroke.DrawingAttributesReplaced" />
      <MemberSignature Language="VB.NET" Value="Public Event DrawingAttributesReplaced As DrawingAttributesReplacedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Ink::DrawingAttributesReplacedEventHandler ^ DrawingAttributesReplaced;" />
      <MemberSignature Language="F#" Value="member this.DrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventHandler " Usage="member this.DrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.DrawingAttributesReplacedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zostaną zastąpione atrybuty <see cref="T:System.Windows.Ink.Stroke" /> rysowania obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak dodać procedurę obsługi dla tego zdarzenia.  
  
 [!code-csharp[StrokeSnippets#9](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#9)]
 [!code-vb[StrokeSnippets#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Ink.Stroke.DrawingAttributes" />
        <altmember cref="M:System.Windows.Ink.Stroke.OnDrawingAttributesReplaced(System.Windows.Ink.DrawingAttributesReplacedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetBezierStylusPoints">
      <MemberSignature Language="C#" Value="public System.Windows.Input.StylusPointCollection GetBezierStylusPoints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Input.StylusPointCollection GetBezierStylusPoints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetBezierStylusPoints" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBezierStylusPoints () As StylusPointCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Input::StylusPointCollection ^ GetBezierStylusPoints();" />
      <MemberSignature Language="F#" Value="member this.GetBezierStylusPoints : unit -&gt; System.Windows.Input.StylusPointCollection" Usage="stroke.GetBezierStylusPoints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPointCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca punkty pióra, <see cref="T:System.Windows.Ink.Stroke" /> których używa <see cref="P:System.Windows.Ink.DrawingAttributes.FitToCurve" /> , <see langword="true" />gdy jest.</summary>
        <returns>A <see cref="T:System.Windows.Input.StylusPointCollection" /> , który zawiera punkty pióra wzdłuż kręgosłupa <see cref="T:System.Windows.Ink.Stroke" /> gdy <see cref="P:System.Windows.Ink.DrawingAttributes.FitToCurve" /> jest<see langword="true" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Ink.Stroke.DrawingAttributes%2A> <xref:System.Windows.Ink.DrawingAttributes.FitToCurve%2A> <xref:System.Windows.Ink.Stroke> `true`Metoda zwraca nowy <xref:System.Windows.Input.StylusPointCollection> , który zawiera punkty pióra, których używa, gdy właściwość właściwości jest ustawiona na. <xref:System.Windows.Ink.Stroke.GetBezierStylusPoints%2A>  Aby uzyskać punkty pióra, które są używane <xref:System.Windows.Ink.DrawingAttributes.FitToCurve%2A> , gdy jest `false`ustawiony na, <xref:System.Windows.Ink.Stroke.StylusPoints%2A> Użyj właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak narysować okrąg w każdej <xref:System.Windows.Input.StylusPoint> <xref:System.Windows.Ink.Stroke>z nich. Jeśli właściwość jest ustawiona na `true`, <xref:System.Windows.Ink.Stroke.GetBezierStylusPoints%2A> jest używana do uzyskania punktów pióra. <xref:System.Windows.Ink.DrawingAttributes.FitToCurve%2A> W przeciwnym razie właściwość jest używana. <xref:System.Windows.Ink.Stroke.StylusPoints%2A>  
  
 [!code-csharp[StrokeSnippets#23](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyStroke.cs#23)]
 [!code-vb[StrokeSnippets#23](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyStroke.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Rect GetBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Windows.Rect GetBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetBounds" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBounds () As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Rect GetBounds();" />
      <MemberSignature Language="F#" Value="abstract member GetBounds : unit -&gt; System.Windows.Rect&#xA;override this.GetBounds : unit -&gt; System.Windows.Rect" Usage="stroke.GetBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera pole ograniczenia dla <see cref="T:System.Windows.Ink.Stroke" /> obiektu.</summary>
        <returns>Struktura definiująca pole ograniczenia <see cref="T:System.Windows.Ink.Stroke" /> dla obiektu. <see cref="T:System.Windows.Rect" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje, jak uzyskać prostokąt graniczny dla <xref:System.Windows.Ink.Stroke> obiektu.  
  
 [!code-csharp[StrokeSnippets#11](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#11)]
 [!code-vb[StrokeSnippets#11](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetClipResult">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca segmenty bieżącej <see cref="T:System.Windows.Ink.Stroke" /> , które znajdują się w określonym obszarze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetClipResult">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection GetClipResult (System.Collections.Generic.IEnumerable&lt;System.Windows.Point&gt; lassoPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Ink.StrokeCollection GetClipResult(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Point&gt; lassoPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetClipResult(System.Collections.Generic.IEnumerable{System.Windows.Point})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClipResult (lassoPoints As IEnumerable(Of Point)) As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Ink::StrokeCollection ^ GetClipResult(System::Collections::Generic::IEnumerable&lt;System::Windows::Point&gt; ^ lassoPoints);" />
      <MemberSignature Language="F#" Value="member this.GetClipResult : seq&lt;System.Windows.Point&gt; -&gt; System.Windows.Ink.StrokeCollection" Usage="stroke.GetClipResult lassoPoints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lassoPoints" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.Point&gt;" />
      </Parameters>
      <Docs>
        <param name="lassoPoints">Punkty określające, gdzie ma być przycinania.</param>
        <summary>Zwraca segmenty bieżącej <see cref="T:System.Windows.Ink.Stroke" /> , które znajdują się w określonych granicach.</summary>
        <returns>A <see cref="T:System.Windows.Ink.StrokeCollection" /> , który zawiera kopie segmentów bieżącego <see cref="T:System.Windows.Ink.Stroke" /> , które znajdują się w określonych granicach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca, która zawiera pociągnięcia, które <xref:System.Windows.Ink.Stroke> reprezentują segmenty, które znajdują `lassoPoints`się w. <xref:System.Windows.Ink.StrokeCollection> <xref:System.Windows.Ink.Stroke.GetClipResult%2A> <xref:System.Windows.Ink.Stroke.GetClipResult%2A>nie zmienia oryginalnego <xref:System.Windows.Ink.Stroke>.  
  
 Metoda łączy pierwszy i ostatni punkt w `lassoPoints` , aby utworzyć Lasso. <xref:System.Windows.Ink.Stroke.GetClipResult%2A>  
  
   
  
## Examples  
 Poniższy przykład usuwa atrament, który znajduje się poza określonymi granicami.  
  
 [!code-csharp[HitTestSample#6](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestSample/CSharp/Program.cs#6)]
 [!code-vb[HitTestSample#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestSample/VisualBasic/Module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetClipResult">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection GetClipResult (System.Windows.Rect bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Ink.StrokeCollection GetClipResult(valuetype System.Windows.Rect bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetClipResult(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClipResult (bounds As Rect) As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Ink::StrokeCollection ^ GetClipResult(System::Windows::Rect bounds);" />
      <MemberSignature Language="F#" Value="member this.GetClipResult : System.Windows.Rect -&gt; System.Windows.Ink.StrokeCollection" Usage="stroke.GetClipResult bounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="bounds">Obiekt <see cref="T:System.Windows.Rect" /> , który określa obszar do wycinania.</param>
        <summary>Zwraca segmenty bieżącej <see cref="T:System.Windows.Ink.Stroke" /> , które znajdują się w określonym prostokącie.</summary>
        <returns>A <see cref="T:System.Windows.Ink.StrokeCollection" /> , który zawiera kopie segmentów bieżącego <see cref="T:System.Windows.Ink.Stroke" /> , które znajdują się <paramref name="bounds" />w granicach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca, która zawiera pociągnięcia, które <xref:System.Windows.Ink.Stroke> reprezentują segmenty, które znajdują `bounds`się w. <xref:System.Windows.Ink.StrokeCollection> <xref:System.Windows.Ink.Stroke.GetClipResult%2A> <xref:System.Windows.Ink.Stroke.GetClipResult%2A>nie zmienia oryginalnego <xref:System.Windows.Ink.Stroke>.  
  
   
  
## Examples  
 Poniższy przykład usuwa atrament, który znajduje się poza określonymi granicami.  
  
 [!code-csharp[HitTestSample#5](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestSample/CSharp/Program.cs#5)]
 [!code-vb[HitTestSample#5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestSample/VisualBasic/Module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEraseResult">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca segmenty bieżącej <see cref="T:System.Windows.Ink.Stroke" /> po wymazaniu <see cref="T:System.Windows.Ink.Stroke" /> elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEraseResult">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection GetEraseResult (System.Collections.Generic.IEnumerable&lt;System.Windows.Point&gt; lassoPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Ink.StrokeCollection GetEraseResult(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Point&gt; lassoPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetEraseResult(System.Collections.Generic.IEnumerable{System.Windows.Point})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEraseResult (lassoPoints As IEnumerable(Of Point)) As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Ink::StrokeCollection ^ GetEraseResult(System::Collections::Generic::IEnumerable&lt;System::Windows::Point&gt; ^ lassoPoints);" />
      <MemberSignature Language="F#" Value="member this.GetEraseResult : seq&lt;System.Windows.Point&gt; -&gt; System.Windows.Ink.StrokeCollection" Usage="stroke.GetEraseResult lassoPoints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lassoPoints" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.Point&gt;" />
      </Parameters>
      <Docs>
        <param name="lassoPoints">Tablica typu <see cref="T:System.Windows.Point" /> , która określa obszar do wymazania.</param>
        <summary>Zwraca segmenty bieżącego <see cref="T:System.Windows.Ink.Stroke" /> , które znajdują się poza określonymi granicami.</summary>
        <returns>A <see cref="T:System.Windows.Ink.StrokeCollection" /> , który zawiera segmenty bieżącej <see cref="T:System.Windows.Ink.Stroke" /> , które znajdują się poza określonymi granicami.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca, która zawiera pociągnięcia, które <xref:System.Windows.Ink.Stroke> reprezentują segmenty, które znajdują się `lassoPoints`poza. <xref:System.Windows.Ink.Stroke.GetEraseResult%2A> <xref:System.Windows.Ink.StrokeCollection> <xref:System.Windows.Ink.Stroke.GetEraseResult%2A>nie zmienia oryginalnego <xref:System.Windows.Ink.Stroke>.  
  
 Metoda łączy pierwszy i ostatni punkt w `lassoPoints` , aby utworzyć Lasso. <xref:System.Windows.Ink.Stroke.GetClipResult%2A>  
  
   
  
## Examples  
 Poniższy przykład usuwa atrament znajdujący się w określonych granicach.  
  
 [!code-csharp[HitTestSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestSample/CSharp/Program.cs#1)]
 [!code-vb[HitTestSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestSample/VisualBasic/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEraseResult">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection GetEraseResult (System.Windows.Rect bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Ink.StrokeCollection GetEraseResult(valuetype System.Windows.Rect bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetEraseResult(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEraseResult (bounds As Rect) As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Ink::StrokeCollection ^ GetEraseResult(System::Windows::Rect bounds);" />
      <MemberSignature Language="F#" Value="member this.GetEraseResult : System.Windows.Rect -&gt; System.Windows.Ink.StrokeCollection" Usage="stroke.GetEraseResult bounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="bounds">Obiekt <see cref="T:System.Windows.Rect" /> , który określa obszar do wymazania.</param>
        <summary>Zwraca segmenty bieżącego <see cref="T:System.Windows.Ink.Stroke" /> , które znajdują się poza określonym prostokątem.</summary>
        <returns>Zawiera segmenty bieżącego <see cref="T:System.Windows.Ink.Stroke" /> , które znajdują się poza granicami określonego <see cref="T:System.Windows.Rect" />elementu. <see cref="T:System.Windows.Ink.StrokeCollection" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca, która zawiera pociągnięcia, które <xref:System.Windows.Ink.Stroke> reprezentują segmenty, które znajdują się `bounds`poza. <xref:System.Windows.Ink.Stroke.GetEraseResult%2A> <xref:System.Windows.Ink.StrokeCollection> <xref:System.Windows.Ink.Stroke.GetEraseResult%2A>nie zmienia oryginalnego <xref:System.Windows.Ink.Stroke>.  
  
   
  
## Examples  
 Poniższy przykład usuwa atrament znajdujący się w określonych granicach.  
  
 [!code-csharp[HitTestSample#4](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestSample/CSharp/Program.cs#4)]
 [!code-vb[HitTestSample#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestSample/VisualBasic/Module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEraseResult">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection GetEraseResult (System.Collections.Generic.IEnumerable&lt;System.Windows.Point&gt; eraserPath, System.Windows.Ink.StylusShape eraserShape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Ink.StrokeCollection GetEraseResult(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Point&gt; eraserPath, class System.Windows.Ink.StylusShape eraserShape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetEraseResult(System.Collections.Generic.IEnumerable{System.Windows.Point},System.Windows.Ink.StylusShape)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEraseResult (eraserPath As IEnumerable(Of Point), eraserShape As StylusShape) As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Ink::StrokeCollection ^ GetEraseResult(System::Collections::Generic::IEnumerable&lt;System::Windows::Point&gt; ^ eraserPath, System::Windows::Ink::StylusShape ^ eraserShape);" />
      <MemberSignature Language="F#" Value="member this.GetEraseResult : seq&lt;System.Windows.Point&gt; * System.Windows.Ink.StylusShape -&gt; System.Windows.Ink.StrokeCollection" Usage="stroke.GetEraseResult (eraserPath, eraserShape)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eraserPath" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.Point&gt;" />
        <Parameter Name="eraserShape" Type="System.Windows.Ink.StylusShape" />
      </Parameters>
      <Docs>
        <param name="eraserPath">Tablica typu <see cref="T:System.Windows.Point" /> , która określa ścieżkę, która jest <see cref="T:System.Windows.Ink.Stroke" />odcięta.</param>
        <param name="eraserShape">A <see cref="T:System.Windows.Ink.StylusShape" /> , który określa kształt gumki.</param>
        <summary>Zwraca segmenty bieżącego <see cref="T:System.Windows.Ink.Stroke" /> , gdy jest on oddzielony przez wyznaczony ścieżki przy użyciu określonego <see cref="T:System.Windows.Ink.StylusShape" />elementu.</summary>
        <returns>A <see cref="T:System.Windows.Ink.StrokeCollection" /> , który zawiera kopie segmentów bieżącego <see cref="T:System.Windows.Ink.Stroke" /> , gdy zostanie odcięta przez określoną ścieżkę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda używa `eraserShape` do trafień testu<xref:System.Windows.Ink.StrokeCollection> pociągnięcia i zwraca, który reprezentuje segmenty odprzecinane. `eraserPath` <xref:System.Windows.Ink.Stroke.GetEraseResult%2A> <xref:System.Windows.Ink.Stroke.GetEraseResult%2A>nie zmienia oryginalnego <xref:System.Windows.Ink.Stroke>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak wymazać pismo odręczne, które przecina określoną ścieżkę.  
  
 [!code-csharp[HitTestSample#2](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestSample/CSharp/Program.cs#2)]
 [!code-vb[HitTestSample#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestSample/VisualBasic/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeometry">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Media.Geometry" /> Pobiera bieżącą<see cref="T:System.Windows.Ink.Stroke" />wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeometry">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry GetGeometry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Geometry GetGeometry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetGeometry" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGeometry () As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Geometry ^ GetGeometry();" />
      <MemberSignature Language="F#" Value="member this.GetGeometry : unit -&gt; System.Windows.Media.Geometry" Usage="stroke.GetGeometry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Media.Geometry" /> Pobiera bieżącą<see cref="T:System.Windows.Ink.Stroke" />wartość.</summary>
        <returns><see cref="T:System.Windows.Media.Geometry" /> Reprezentuje .<see cref="T:System.Windows.Ink.Stroke" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody, aby <xref:System.Windows.Media.PathGeometry> uzyskać <xref:System.Windows.Ink.Stroke>dostosowanie kształtu. <xref:System.Windows.Ink.Stroke.GetGeometry%2A> Rozważ buforowanie <xref:System.Windows.Media.Geometry> , aby uniknąć wywoływania <xref:System.Windows.Ink.Stroke.GetGeometry%2A> wielu razy, co może mieć wpływ na wydajność.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGeometry">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry GetGeometry (System.Windows.Ink.DrawingAttributes drawingAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Geometry GetGeometry(class System.Windows.Ink.DrawingAttributes drawingAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetGeometry(System.Windows.Ink.DrawingAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Geometry ^ GetGeometry(System::Windows::Ink::DrawingAttributes ^ drawingAttributes);" />
      <MemberSignature Language="F#" Value="member this.GetGeometry : System.Windows.Ink.DrawingAttributes -&gt; System.Windows.Media.Geometry" Usage="stroke.GetGeometry drawingAttributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawingAttributes" Type="System.Windows.Ink.DrawingAttributes" />
      </Parameters>
      <Docs>
        <param name="drawingAttributes"><see cref="T:System.Windows.Ink.DrawingAttributes" /> Określa<see cref="T:System.Windows.Media.Geometry" />,że .<see cref="T:System.Windows.Ink.Stroke" /></param>
        <summary>Pobiera bieżącą <see cref="T:System.Windows.Ink.Stroke" /> wartość przy użyciu określonego <see cref="T:System.Windows.Ink.DrawingAttributes" />. <see cref="T:System.Windows.Media.Geometry" /></summary>
        <returns><see cref="T:System.Windows.Media.Geometry" /> Reprezentuje .<see cref="T:System.Windows.Ink.Stroke" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Ink.Stroke.GetGeometry%2A> Metoda używawłaściwości<xref:System.Windows.Ink.DrawingAttributes.Height%2A> ,,<xref:System.Windows.Ink.DrawingAttributes.FitToCurve%2A>, i<xref:System.Windows.Ink.DrawingAttributes.StylusTipTransform%2A>w celu określenia .<xref:System.Windows.Media.Geometry> <xref:System.Windows.Ink.DrawingAttributes.StylusTip%2A> <xref:System.Windows.Ink.DrawingAttributes.Width%2A> `drawingAttributes` Rozważ buforowanie <xref:System.Windows.Media.Geometry> , aby uniknąć wywoływania <xref:System.Windows.Ink.Stroke.GetGeometry%2A> wielu razy, co może mieć wpływ na wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak narysować okrąg w każdej <xref:System.Windows.Input.StylusPoint> <xref:System.Windows.Ink.Stroke>z nich. Jeśli właściwość jest ustawiona na `true`, <xref:System.Windows.Ink.Stroke.GetBezierStylusPoints%2A> jest używana do uzyskania punktów pióra. <xref:System.Windows.Ink.DrawingAttributes.FitToCurve%2A> W przeciwnym razie właściwość jest używana. <xref:System.Windows.Ink.Stroke.StylusPoints%2A>  
  
 [!code-csharp[StrokeSnippets#23](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyStroke.cs#23)]
 [!code-vb[StrokeSnippets#23](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyStroke.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyData">
      <MemberSignature Language="C#" Value="public object GetPropertyData (Guid propertyDataId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPropertyData(valuetype System.Guid propertyDataId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetPropertyData(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyData (propertyDataId As Guid) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPropertyData(Guid propertyDataId);" />
      <MemberSignature Language="F#" Value="member this.GetPropertyData : Guid -&gt; obj" Usage="stroke.GetPropertyData propertyDataId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyDataId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="propertyDataId">Unikatowy identyfikator właściwości.</param>
        <summary>Pobiera dane właściwości dla określonego identyfikatora GUID.</summary>
        <returns><see langword="object" /> Zawierający dane właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje sposób pobierania właściwości <xref:System.Windows.Ink.Stroke> niestandardowej obiektu.  
  
 [!code-csharp[StrokeSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#3)]
 [!code-vb[StrokeSnippets#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="propertyDataId" />nie jest skojarzony z właściwością <see cref="T:System.Windows.Ink.Stroke" />niestandardową.</exception>
        <altmember cref="M:System.Windows.Ink.Stroke.AddPropertyData(System.Guid,System.Object)" />
        <altmember cref="M:System.Windows.Ink.Stroke.ContainsPropertyData(System.Guid)" />
        <altmember cref="M:System.Windows.Ink.Stroke.GetPropertyDataIds" />
        <altmember cref="M:System.Windows.Ink.Stroke.RemovePropertyData(System.Guid)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyDataIds">
      <MemberSignature Language="C#" Value="public Guid[] GetPropertyDataIds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Guid[] GetPropertyDataIds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.GetPropertyDataIds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyDataIds () As Guid()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;Guid&gt; ^ GetPropertyDataIds();" />
      <MemberSignature Language="F#" Value="member this.GetPropertyDataIds : unit -&gt; Guid[]" Usage="stroke.GetPropertyDataIds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera identyfikatory GUID wszelkich właściwości niestandardowych skojarzonych z <see cref="T:System.Windows.Ink.Stroke" /> obiektem.</summary>
        <returns>Tablica <see cref="T:System.Guid" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak uzyskać identyfikatory GUID właściwości niestandardowych pędzla.  
  
 [!code-csharp[DrawTransform#3](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawTransform/CSharp/Program.cs#3)]
 [!code-vb[DrawTransform#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawTransform/VisualBasic/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Ink.Stroke.AddPropertyData(System.Guid,System.Object)" />
        <altmember cref="M:System.Windows.Ink.Stroke.ContainsPropertyData(System.Guid)" />
        <altmember cref="M:System.Windows.Ink.Stroke.GetPropertyData(System.Guid)" />
        <altmember cref="M:System.Windows.Ink.Stroke.RemovePropertyData(System.Guid)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTest">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca czy <see cref="T:System.Windows.Ink.Stroke" /> przecinają się lub znajduje się w określonym obszarze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć metod, <xref:System.Windows.Ink.Stroke.HitTest%2A> aby określić, <xref:System.Windows.Ink.Stroke> czy przecinają się pewien punkt, czy też znajduje się w określonym zakresie.  
  
 Poniższe metody sprawdzają, <xref:System.Windows.Ink.Stroke> czy jest przecinane.  
  
-   <xref:System.Windows.Ink.Stroke.HitTest%28System.Windows.Point%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Ink.Stroke.HitTest%28System.Windows.Point%2CSystem.Double%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Ink.Stroke.HitTest%28System.Collections.Generic.IEnumerable%7BSystem.Windows.Point%7D%2CSystem.Windows.Ink.StylusShape%29?displayProperty=nameWithType>  
  
 Poniższe metody sprawdzają, <xref:System.Windows.Ink.Stroke> czy są otoczone.  
  
-   <xref:System.Windows.Ink.Stroke.HitTest%28System.Collections.Generic.IEnumerable%7BSystem.Windows.Point%7D%2CSystem.Int32%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Ink.Stroke.HitTest%28System.Windows.Rect%2CSystem.Int32%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public bool HitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.HitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HitTest(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.HitTest : System.Windows.Point -&gt; bool" Usage="stroke.HitTest point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Test <see cref="T:System.Windows.Point" /> do trafienia.</param>
        <summary>Zwraca wartość wskazującą, czy bieżąca <see cref="T:System.Windows.Ink.Stroke" /> przecina się z określonym punktem.</summary>
        <returns><see langword="true" />Jeśli <paramref name="point" /> przecina bieżący obrys; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zachowuje się tak samo, jak w przypadku <xref:System.Windows.Ink.Stroke.HitTest%28System.Windows.Point%2CSystem.Double%29> przeciążonej metody `diameter` , gdy wynosi 1.  
  
   
  
## Examples  
 Poniższy przykład zmienia kolor <xref:System.Windows.Ink.Stroke> , jeśli przecina określony obszar.  
  
 [!code-csharp[HitTestSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestSample/CSharp/Program.cs#3)]
 [!code-vb[HitTestSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestSample/VisualBasic/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public bool HitTest (System.Collections.Generic.IEnumerable&lt;System.Windows.Point&gt; lassoPoints, int percentageWithinLasso);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HitTest(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Point&gt; lassoPoints, int32 percentageWithinLasso) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.HitTest(System.Collections.Generic.IEnumerable{System.Windows.Point},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function HitTest (lassoPoints As IEnumerable(Of Point), percentageWithinLasso As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HitTest(System::Collections::Generic::IEnumerable&lt;System::Windows::Point&gt; ^ lassoPoints, int percentageWithinLasso);" />
      <MemberSignature Language="F#" Value="member this.HitTest : seq&lt;System.Windows.Point&gt; * int -&gt; bool" Usage="stroke.HitTest (lassoPoints, percentageWithinLasso)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lassoPoints" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.Point&gt;" />
        <Parameter Name="percentageWithinLasso" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lassoPoints">Tablica typu <see cref="T:System.Windows.Point" /> , która reprezentuje granice obszaru do testu trafień.</param>
        <param name="percentageWithinLasso">Wartość procentowa długości <see cref="T:System.Windows.Ink.Stroke" />, która musi znajdować się w <paramref name="lassoPoints" /> <see cref="T:System.Windows.Ink.Stroke" /> , aby można ją było uważać za trafienie.</param>
        <summary>Zwraca wartość wskazującą, czy bieżąca <see cref="T:System.Windows.Ink.Stroke" /> znajduje się w określonym zakresie.</summary>
        <returns><see langword="true" />Jeśli bieżące pociągnięcie znajduje się w określonych granicach; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda łączy pierwszy i ostatni punkt w `lassoPoints` , aby utworzyć Lasso. <xref:System.Windows.Ink.Stroke.HitTest%2A>  
  
   
  
## Examples  
 Poniższy przykład renderuje pociągnięcia purpurowe, jeśli co najmniej 80% pociągnięcia znajduje się w granicach `myPoints`.  
  
 [!code-csharp[HitTestSample#7](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestSample/CSharp/Program.cs#7)]
 [!code-vb[HitTestSample#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestSample/VisualBasic/Module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public bool HitTest (System.Collections.Generic.IEnumerable&lt;System.Windows.Point&gt; path, System.Windows.Ink.StylusShape stylusShape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HitTest(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Point&gt; path, class System.Windows.Ink.StylusShape stylusShape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.HitTest(System.Collections.Generic.IEnumerable{System.Windows.Point},System.Windows.Ink.StylusShape)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HitTest(System::Collections::Generic::IEnumerable&lt;System::Windows::Point&gt; ^ path, System::Windows::Ink::StylusShape ^ stylusShape);" />
      <MemberSignature Language="F#" Value="member this.HitTest : seq&lt;System.Windows.Point&gt; * System.Windows.Ink.StylusShape -&gt; bool" Usage="stroke.HitTest (path, stylusShape)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.Point&gt;" />
        <Parameter Name="stylusShape" Type="System.Windows.Ink.StylusShape" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka <paramref name="stylusShape" /> następująca dla testowania trafień</param>
        <param name="stylusShape">Kształt <paramref name="path" /> , z którym ma zostać trafiony test.</param>
        <summary>Zwraca czy określona ścieżka przecina się <see cref="T:System.Windows.Ink.Stroke" /> przy użyciu określonego. <see cref="T:System.Windows.Ink.StylusShape" /></summary>
        <returns><see langword="true" />Jeśli <paramref name="stylusShape" /> przecina bieżący obrys; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda używa `stylusShape` do trafienia testu pociągnięcia. `eraserPath` <xref:System.Windows.Ink.Stroke.HitTest%2A>  
  
   
  
## Examples  
 Poniższy kod renderuje skok purpurowy, jeśli obrys przecina ścieżkę `myPoints`.  
  
 [!code-csharp[HitTestSample#9](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestSample/CSharp/Program.cs#9)]
 [!code-vb[HitTestSample#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestSample/VisualBasic/Module1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public bool HitTest (System.Windows.Point point, double diameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HitTest(valuetype System.Windows.Point point, float64 diameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.HitTest(System.Windows.Point,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HitTest(System::Windows::Point point, double diameter);" />
      <MemberSignature Language="F#" Value="member this.HitTest : System.Windows.Point * double -&gt; bool" Usage="stroke.HitTest (point, diameter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="diameter" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="point"><see cref="T:System.Windows.Point" /> Definiuje środek obszaru do testowania trafień.</param>
        <param name="diameter">Średnica obszaru do przetestowania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżąca <see cref="T:System.Windows.Ink.Stroke" /> przecina się z określonym obszarem.</summary>
        <returns><see langword="true" />Jeśli określony obszar przecina bieżący obrys; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład zmienia kolor <xref:System.Windows.Ink.Stroke> , jeśli przecina określony obszar.  
  
 [!code-csharp[HitTestSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestSample/CSharp/Program.cs#3)]
 [!code-vb[HitTestSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestSample/VisualBasic/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public bool HitTest (System.Windows.Rect bounds, int percentageWithinBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HitTest(valuetype System.Windows.Rect bounds, int32 percentageWithinBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.HitTest(System.Windows.Rect,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function HitTest (bounds As Rect, percentageWithinBounds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HitTest(System::Windows::Rect bounds, int percentageWithinBounds);" />
      <MemberSignature Language="F#" Value="member this.HitTest : System.Windows.Rect * int -&gt; bool" Usage="stroke.HitTest (bounds, percentageWithinBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Windows.Rect" />
        <Parameter Name="percentageWithinBounds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bounds">Element <see cref="T:System.Windows.Rect" /> reprezentujący granice obszaru do testu trafień.</param>
        <param name="percentageWithinBounds">Wartość procentowa długości <see cref="T:System.Windows.Ink.Stroke" />, która musi znajdować się w <paramref name="percentageWithinBounds" /> <see cref="T:System.Windows.Ink.Stroke" /> , aby można ją było uważać za trafienie.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Windows.Ink.Stroke" /> znajduje się w granicach określonego prostokąta.</summary>
        <returns><see langword="true" />Jeśli bieżące pociągnięcie znajduje się w <paramref name="bounds" />granicach; w przeciwnym razie,. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład renderuje pociągnięcia purpurowe, jeśli co najmniej 80% pociągnięcia znajduje się <xref:System.Windows.Rect>w.  
  
 [!code-csharp[HitTestSample#8](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestSample/CSharp/Program.cs#8)]
 [!code-vb[HitTestSample#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestSample/VisualBasic/Module1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event EventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Ink.Stroke.Invalidated" />
      <MemberSignature Language="VB.NET" Value="Public Event Invalidated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Invalidated;" />
      <MemberSignature Language="F#" Value="member this.Invalidated : EventHandler " Usage="member this.Invalidated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Windows.Ink.Stroke" /> zmieni się wygląd.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługuje zdarzenie i wywołuje<xref:System.Windows.Ink.Stroke.DrawCore%2A> metodę. <xref:System.Windows.Ink.Stroke.Invalidated> <xref:System.Windows.Controls.InkPresenter> Jeśli dziedziczysz z <xref:System.Windows.Ink.Stroke> klasy, a wygląd obrysu jest oparty na stanie niestandardowym, należy <xref:System.Windows.Ink.Stroke.OnInvalidated%2A> wywołać metodę, aby zgłosić <xref:System.Windows.Ink.Stroke.Invalidated> zdarzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDrawingAttributesChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawingAttributesChanged (System.Windows.Ink.PropertyDataChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawingAttributesChanged(class System.Windows.Ink.PropertyDataChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.OnDrawingAttributesChanged(System.Windows.Ink.PropertyDataChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawingAttributesChanged (e As PropertyDataChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawingAttributesChanged(System::Windows::Ink::PropertyDataChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawingAttributesChanged : System.Windows.Ink.PropertyDataChangedEventArgs -&gt; unit&#xA;override this.OnDrawingAttributesChanged : System.Windows.Ink.PropertyDataChangedEventArgs -&gt; unit" Usage="stroke.OnDrawingAttributesChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Ink.PropertyDataChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Ink.PropertyDataChangedEventArgs" /> Obiekt, który zawiera dane zdarzenia.</param>
        <summary>Umożliwia klasom pochodnym Modyfikowanie domyślnego zachowania <see cref="E:System.Windows.Ink.Stroke.DrawingAttributesChanged" /> zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas zastępowania tej metody w klasie pochodnej należy wywołać <xref:System.Windows.Ink.Stroke.OnDrawingAttributesChanged%2A> metodę klasy bazowej, tak aby zarejestrowane Delegaty otrzymywały zdarzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDrawingAttributesReplaced">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawingAttributesReplaced (System.Windows.Ink.DrawingAttributesReplacedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawingAttributesReplaced(class System.Windows.Ink.DrawingAttributesReplacedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.OnDrawingAttributesReplaced(System.Windows.Ink.DrawingAttributesReplacedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawingAttributesReplaced (e As DrawingAttributesReplacedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawingAttributesReplaced(System::Windows::Ink::DrawingAttributesReplacedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventArgs -&gt; unit&#xA;override this.OnDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventArgs -&gt; unit" Usage="stroke.OnDrawingAttributesReplaced e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Ink.DrawingAttributesReplacedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Ink.DrawingAttributesReplacedEventArgs" /> Obiekt, który zawiera dane zdarzenia.</param>
        <summary>Umożliwia klasom pochodnym Modyfikowanie domyślnego zachowania <see cref="E:System.Windows.Ink.Stroke.DrawingAttributesReplaced" /> zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas zastępowania tej metody w klasie pochodnej należy wywołać <xref:System.Windows.Ink.Stroke.OnDrawingAttributesReplaced%2A> metodę klasy bazowej, tak aby zarejestrowane Delegaty otrzymywały zdarzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.OnInvalidated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInvalidated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInvalidated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInvalidated : EventArgs -&gt; unit&#xA;override this.OnInvalidated : EventArgs -&gt; unit" Usage="stroke.OnInvalidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Ink.Stroke.Invalidated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dziedziczysz z <xref:System.Windows.Ink.Stroke> klasy, a wygląd obrysu jest oparty na stanie niestandardowym, należy <xref:System.Windows.Ink.Stroke.OnInvalidated%2A> wywołać metodę, aby zgłosić <xref:System.Windows.Ink.Stroke.Invalidated> zdarzenie. Obsługuje zdarzenie i wywołuje<xref:System.Windows.Ink.Stroke.DrawCore%2A> metodę. <xref:System.Windows.Ink.Stroke.Invalidated> <xref:System.Windows.Controls.InkPresenter>  
  
   
  
## Examples  
 Poniższy przykład rysuje <xref:System.Windows.Ink.Stroke> jako pełne pociągnięcia lub jako <xref:System.Windows.Input.StylusPoint> serie obiektów `Mode` , w zależności od właściwości. Przykład wywołuje <xref:System.Windows.Ink.Stroke.OnInvalidated%2A> metodę, która z kolei <xref:System.Windows.Ink.Stroke.DrawCore%2A> wywołuje, gdzie rysowany jest obrys.  
  
 [!code-csharp[StrokeSnippets#24](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/CustomRenderedStroke.cs#24)]
 [!code-vb[StrokeSnippets#24](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/CustomRenderedStroke.vb#24)]  
[!code-csharp[StrokeSnippets#25](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/CustomRenderedStroke.cs#25)]
[!code-vb[StrokeSnippets#25](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/CustomRenderedStroke.vb#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.ComponentModel.PropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(class System.ComponentModel.PropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::ComponentModel::PropertyChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="stroke.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, które opisują modyfikowaną właściwość, a także stare i nowe wartości.</param>
        <summary>Występuje po <see cref="T:System.Windows.Ink.Stroke" /> zmianie właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyDataChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyDataChanged (System.Windows.Ink.PropertyDataChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyDataChanged(class System.Windows.Ink.PropertyDataChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.OnPropertyDataChanged(System.Windows.Ink.PropertyDataChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyDataChanged (e As PropertyDataChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyDataChanged(System::Windows::Ink::PropertyDataChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyDataChanged : System.Windows.Ink.PropertyDataChangedEventArgs -&gt; unit&#xA;override this.OnPropertyDataChanged : System.Windows.Ink.PropertyDataChangedEventArgs -&gt; unit" Usage="stroke.OnPropertyDataChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Ink.PropertyDataChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Ink.PropertyDataChangedEventArgs" /> Obiekt, który zawiera dane zdarzenia.</param>
        <summary>Umożliwia klasom pochodnym Modyfikowanie domyślnego zachowania <see cref="E:System.Windows.Ink.Stroke.PropertyDataChanged" /> zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas zastępowania tej metody w klasie pochodnej należy wywołać <xref:System.Windows.Ink.Stroke.OnPropertyDataChanged%2A> metodę klasy bazowej, tak aby zarejestrowane Delegaty otrzymywały zdarzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusPointsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusPointsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusPointsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.OnStylusPointsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusPointsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusPointsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusPointsChanged : EventArgs -&gt; unit&#xA;override this.OnStylusPointsChanged : EventArgs -&gt; unit" Usage="stroke.OnStylusPointsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Ink.Stroke.StylusPointsChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusPointsReplaced">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusPointsReplaced (System.Windows.Ink.StylusPointsReplacedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusPointsReplaced(class System.Windows.Ink.StylusPointsReplacedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.OnStylusPointsReplaced(System.Windows.Ink.StylusPointsReplacedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusPointsReplaced (e As StylusPointsReplacedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusPointsReplaced(System::Windows::Ink::StylusPointsReplacedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusPointsReplaced : System.Windows.Ink.StylusPointsReplacedEventArgs -&gt; unit&#xA;override this.OnStylusPointsReplaced : System.Windows.Ink.StylusPointsReplacedEventArgs -&gt; unit" Usage="stroke.OnStylusPointsReplaced e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Ink.StylusPointsReplacedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Ink.StylusPointsReplacedEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Ink.Stroke.StylusPointsReplaced" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyDataChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Ink.PropertyDataChangedEventHandler PropertyDataChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Ink.PropertyDataChangedEventHandler PropertyDataChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Ink.Stroke.PropertyDataChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event PropertyDataChanged As PropertyDataChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Ink::PropertyDataChangedEventHandler ^ PropertyDataChanged;" />
      <MemberSignature Language="F#" Value="member this.PropertyDataChanged : System.Windows.Ink.PropertyDataChangedEventHandler " Usage="member this.PropertyDataChanged : System.Windows.Ink.PropertyDataChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.PropertyDataChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmienią się właściwości <see cref="T:System.Windows.Ink.Stroke" /> niestandardowe obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak dodać procedurę obsługi dla tego zdarzenia.  
  
 [!code-csharp[StrokeSnippets#20](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#20)]
 [!code-vb[StrokeSnippets#20](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Ink.Stroke.AddPropertyData(System.Guid,System.Object)" />
        <altmember cref="M:System.Windows.Ink.Stroke.RemovePropertyData(System.Guid)" />
        <altmember cref="M:System.Windows.Ink.Stroke.OnPropertyDataChanged(System.Windows.Ink.PropertyDataChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemovePropertyData">
      <MemberSignature Language="C#" Value="public void RemovePropertyData (Guid propertyDataId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemovePropertyData(valuetype System.Guid propertyDataId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.RemovePropertyData(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemovePropertyData (propertyDataId As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemovePropertyData(Guid propertyDataId);" />
      <MemberSignature Language="F#" Value="member this.RemovePropertyData : Guid -&gt; unit" Usage="stroke.RemovePropertyData propertyDataId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyDataId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="propertyDataId">Unikatowy identyfikator właściwości.</param>
        <summary>Usuwa właściwość niestandardową z <see cref="T:System.Windows.Ink.Stroke" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje sposób usuwania właściwości niestandardowej z <xref:System.Windows.Ink.Stroke> obiektu.  
  
 [!code-csharp[StrokeSnippets#30](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#30)]
 [!code-vb[StrokeSnippets#30](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Ink.Stroke.AddPropertyData(System.Guid,System.Object)" />
        <altmember cref="M:System.Windows.Ink.Stroke.ContainsPropertyData(System.Guid)" />
        <altmember cref="M:System.Windows.Ink.Stroke.GetPropertyData(System.Guid)" />
      </Docs>
    </Member>
    <Member MemberName="StylusPoints">
      <MemberSignature Language="C#" Value="public System.Windows.Input.StylusPointCollection StylusPoints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPointCollection StylusPoints" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Ink.Stroke.StylusPoints" />
      <MemberSignature Language="VB.NET" Value="Public Property StylusPoints As StylusPointCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::StylusPointCollection ^ StylusPoints { System::Windows::Input::StylusPointCollection ^ get(); void set(System::Windows::Input::StylusPointCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StylusPoints : System.Windows.Input.StylusPointCollection with get, set" Usage="System.Windows.Ink.Stroke.StylusPoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPointCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca punkty <see cref="T:System.Windows.Ink.Stroke" />pióra.</summary>
        <value>Zawiera punkty pióra, które reprezentują bieżący <see cref="T:System.Windows.Ink.Stroke" />. <see cref="T:System.Windows.Input.StylusPointCollection" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać punkty pióra, które są używane, <xref:System.Windows.Ink.DrawingAttributes.FitToCurve%2A> gdy właściwość <xref:System.Windows.Ink.Stroke.DrawingAttributes%2A> właściwości jest <xref:System.Windows.Ink.Stroke.GetBezierStylusPoints%2A> ustawiona na `true`, użyj metody.  
  
> [!NOTE]
>  Przypisana do właściwości musi zawierać co najmniej jeden <xref:System.Windows.Input.StylusPoint> element. <xref:System.Windows.Ink.Stroke.StylusPoints%2A> <xref:System.Windows.Input.StylusPointCollection>  Jeśli <xref:System.Windows.Input.StylusPointCollection> spróbujesz przypisać pusty do <xref:System.Windows.Ink.Stroke.StylusPoints%2A>lub usunąć wszystkie <xref:System.Windows.Input.StylusPoint> obiekty z <xref:System.Windows.Ink.Stroke.StylusPoints%2A>, wystąpi wyjątek.  
  
   
  
## Examples  
 Poniższy przykład jest częścią zastąpienia <xref:System.Windows.Ink.Stroke> , która rysuje koło na każdym z nich. <xref:System.Windows.Input.StylusPoint> Jeśli właściwość jest ustawiona na `true`, <xref:System.Windows.Ink.Stroke.GetBezierStylusPoints%2A> jest używana do uzyskania punktów pióra. <xref:System.Windows.Ink.DrawingAttributes.FitToCurve%2A> W przeciwnym razie właściwość jest używana. <xref:System.Windows.Ink.Stroke.StylusPoints%2A>  
  
 [!code-csharp[StrokeSnippets#23](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyStroke.cs#23)]
 [!code-vb[StrokeSnippets#23](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyStroke.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusPointsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StylusPointsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StylusPointsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Ink.Stroke.StylusPointsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event StylusPointsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StylusPointsChanged;" />
      <MemberSignature Language="F#" Value="member this.StylusPointsChanged : EventHandler " Usage="member this.StylusPointsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Ink.Stroke.StylusPoints" /> właściwość zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, <xref:System.Windows.Ink.Stroke.StylusPointsChanged> jak obsłużyć zdarzenie.  
  
 [!code-csharp[StrokeSnippets#28](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#28)]
 [!code-vb[StrokeSnippets#28](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusPointsReplaced">
      <MemberSignature Language="C#" Value="public event System.Windows.Ink.StylusPointsReplacedEventHandler StylusPointsReplaced;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Ink.StylusPointsReplacedEventHandler StylusPointsReplaced" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Ink.Stroke.StylusPointsReplaced" />
      <MemberSignature Language="VB.NET" Value="Public Event StylusPointsReplaced As StylusPointsReplacedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Ink::StylusPointsReplacedEventHandler ^ StylusPointsReplaced;" />
      <MemberSignature Language="F#" Value="member this.StylusPointsReplaced : System.Windows.Ink.StylusPointsReplacedEventHandler " Usage="member this.StylusPointsReplaced : System.Windows.Ink.StylusPointsReplacedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StylusPointsReplacedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="P:System.Windows.Ink.Stroke.StylusPoints" /> gdy właściwość zostanie przypisana nowa <see cref="T:System.Windows.Input.StylusPointCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, <xref:System.Windows.Ink.Stroke.StylusPointsReplaced> jak obsłużyć zdarzenie.  
  
 [!code-csharp[StrokeSnippets#29](~/samples/snippets/csharp/VS_Snippets_Wpf/StrokeSnippets/CSharp/MyBorder.cs#29)]
 [!code-vb[StrokeSnippets#29](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StrokeSnippets/VisualBasic/MyBorder.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.INotifyPropertyChanged.PropertyChanged">
      <MemberSignature Language="C#" Value="event System.ComponentModel.PropertyChangedEventHandler System.ComponentModel.INotifyPropertyChanged.PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Ink.Stroke.System#ComponentModel#INotifyPropertyChanged#PropertyChanged" />
      <MemberSignature Language="VB.NET" Value="Custom Event PropertyChanged As PropertyChangedEventHandler Implements System.ComponentModel.INotifyPropertyChanged" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie wartości każdej <see cref="T:System.Windows.Ink.Stroke" /> właściwości.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public virtual void Transform (System.Windows.Media.Matrix transformMatrix, bool applyToStylusTip);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Transform(valuetype System.Windows.Media.Matrix transformMatrix, bool applyToStylusTip) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Ink.Stroke.Transform(System.Windows.Media.Matrix,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Transform (transformMatrix As Matrix, applyToStylusTip As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Transform(System::Windows::Media::Matrix transformMatrix, bool applyToStylusTip);" />
      <MemberSignature Language="F#" Value="abstract member Transform : System.Windows.Media.Matrix * bool -&gt; unit&#xA;override this.Transform : System.Windows.Media.Matrix * bool -&gt; unit" Usage="stroke.Transform (transformMatrix, applyToStylusTip)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transformMatrix" Type="System.Windows.Media.Matrix" />
        <Parameter Name="applyToStylusTip" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="transformMatrix"><see cref="T:System.Windows.Media.Matrix" /> Obiekt definiujący transformację.</param>
        <param name="applyToStylusTip"><see langword="true" />Aby zastosować transformację do końcówki pióra; w przeciwnym razie. <see langword="false" /></param>
        <summary>Wykonuje przekształcenie na podstawie określonego <see cref="T:System.Windows.Media.Matrix" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Matrix> Obiekt reprezentuje macierz 3x3ą używaną do transformacji w przestrzeni dwuwymiarowej. Każdy punkt pociągnięcia jest przekształcany przez dostarczoną macierz. Na przykład jeśli oryginalna wartość punktu. X to 100, pierwotna wartość punktu. Y to 55, a macierz transformacji. Skala (0,5, 0,5), Nowa wartość punkt. X to 50, a nowa wartość punktu. Y to 27,5.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób przekształcania <xref:System.Windows.Ink.Stroke> obiektu.  
  
 [!code-csharp[DrawTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawTransform/CSharp/Program.cs#1)]
 [!code-vb[DrawTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawTransform/VisualBasic/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="GCSettings" FullName="System.Runtime.GCSettings">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c4e6511b3a60ed4625e4f18f4cb44b2bf4445fd5" />
    <Meta Name="ms.sourcegitcommit" Value="6ee2e6b2c5d7c5bd66feeb362d29e65fdf858836" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/15/2018" />
    <Meta Name="ms.locfileid" Value="51690523" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GCSettings" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GCSettings extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.GCSettings" />
  <TypeSignature Language="VB.NET" Value="Public Class GCSettings" />
  <TypeSignature Language="C++ CLI" Value="public ref class GCSettings abstract sealed" />
  <TypeSignature Language="F#" Value="type GCSettings = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Określa ustawienia kolekcji wyrzucania elementów dla bieżącego procesu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.GCSettings.IsServerGC%2A> właściwości w celu określenia, czy serwer wyrzucania elementów bezużytecznych jest włączone dla bieżącego procesu.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="IsServerGC">
      <MemberSignature Language="C#" Value="public static bool IsServerGC { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsServerGC" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.IsServerGC" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsServerGC As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsServerGC { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServerGC : bool" Usage="System.Runtime.GCSettings.IsServerGC" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy serwer wyrzucania elementów bezużytecznych jest włączone.</summary>
        <value>
          <see langword="true" /> Jeśli serwer wyrzucania elementów bezużytecznych jest włączone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uzyskać informacje o serwerze wyrzucanie elementów bezużytecznych, zobacz sekcję "Stacji roboczej i wyrzucania elementów bezużytecznych dla serwera" w [podstawowe informacje dotyczące wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/fundamentals.md).  
  
 Jeśli nie włączono serwer wyrzucania elementów bezużytecznych, wyrzucania elementów bezużytecznych dla stacji roboczych jest włączona (z lub bez kolekcji współbieżnych). Serwer wyrzucania elementów bezużytecznych jest dostępna tylko na komputerach wieloprocesorowych.  
  
 Niezarządzany host mogą żądać serwer wyrzucania elementów bezużytecznych, a żądanie hosta zastąpienia ustawień pliku konfiguracji. Jeśli host nie określa typ wyrzucania elementów bezużytecznych, można użyć ustawienia pliku konfiguracyjnego, aby określić serwer wyrzucania elementów bezużytecznych. To ustawienie jest prawidłowy tylko w pliku konfiguracyjnym aplikacji, nie ma w pliku konfiguracji komputera (zobacz [konfigurowania aplikacji](~/docs/framework/configure-apps/index.md)). Poniższy przykład pokazuje zawartość przykładowy plik konfiguracji aplikacji, która umożliwia wyrzucanie elementów bezużytecznych serwera.  
  
```  
<configuration>  
  <runtime>  
    <gcServer enabled="true" />  
  </runtime>  
</configuration>  
```  
  
   
  
## Examples  
 Poniższy przykład wskazuje, czy komputer-host używa serwera lub stacji roboczej wyrzucania elementów bezużytecznych.  
  
 [!code-csharp[Environment.IsServerGC#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.IsServerGC/CS/isg.cs#1)]
 [!code-vb[Environment.IsServerGC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.IsServerGC/VB/isg.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LargeObjectHeapCompactionMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.LargeObjectHeapCompactionMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LargeObjectHeapCompactionMode As GCLargeObjectHeapCompactionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { System::Runtime::GCLargeObjectHeapCompactionMode get(); void set(System::Runtime::GCLargeObjectHeapCompactionMode value); };" />
      <MemberSignature Language="F#" Value="member this.LargeObjectHeapCompactionMode : System.Runtime.GCLargeObjectHeapCompactionMode with get, set" Usage="System.Runtime.GCSettings.LargeObjectHeapCompactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.GCLargeObjectHeapCompactionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy blokowanie pełnego odzyskiwania pamięci kompaktuje stos dużych obiektów (LOH).</summary>
        <value>Jedna z wartości wyliczenia, które wskazuje, czy blokowanie pełnego odzyskiwania pamięci kompaktuje LOH.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 LOH jest używana do przydzielania pamięci dla dużych obiektów (takich jak tablice), które wymagają więcej niż rozmiarze 85 000 bajtów. Ze względu na wpływ na wydajność kopiowania dużych bloków pamięci moduł zbierający elementy bezużyteczne zazwyczaj wrzucając LOH, który obejmuje utworzenie listy lokalizacji pamięci, która była zajęta przez obiekty martwe i które mogą być ponownie używane do zaspokojenia przyszłe żądania dotyczące Alokacja pamięci dla dużych obiektów. Jednak w aplikacjach, które rozbudowane użytkowania LOH do przechowywania obiektów przejściowy, pamięci, że fragmentacji może niekorzystnie wpłynąć na wydajność. W tym przypadku jest możliwe użycie <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> właściwość kompaktowanie zamiast po prostu odchylenia LOH podczas wyrzucania elementów bezużytecznych.  
  
 Wartość domyślna <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> właściwość <xref:System.Runtime.GCLargeObjectHeapCompactionMode.Default?displayProperty=nameWithType>, co oznacza, że LOH nie jest kompaktowana podczas wyrzucania elementów bezużytecznych. W przypadku przypisania wartości właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>LOH jest kompaktowana podczas następnego pełnego blokowania wyrzucania elementów bezużytecznych i wartość właściwości jest resetowana do <xref:System.Runtime.GCLargeObjectHeapCompactionMode.Default?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nie blokują tle wyrzucania elementów bezużytecznych. Oznacza to, że jeśli ustawisz <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, wszelkie generowania tła 2 kolekcje, które występują, następnie nie compact LOH. Tylko pierwszy blokowania generacji 2 kompaktuje LOH.  
  
 Po <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> właściwość jest ustawiona na <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, dalej blokowania pełnego odzyskiwania pamięci (i kompaktowania LOH) występuje na nieokreślony czas w przyszłości. Możesz od razu kompaktowanie LOH, przy użyciu kodu, jak pokazano poniżej:  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.GCLargeObjectHeapCompactionMode" />
      </Docs>
    </Member>
    <Member MemberName="LatencyMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.GCLatencyMode LatencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.GCLatencyMode LatencyMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.LatencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LatencyMode As GCLatencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::GCLatencyMode LatencyMode { System::Runtime::GCLatencyMode get(); void set(System::Runtime::GCLatencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.LatencyMode : System.Runtime.GCLatencyMode with get, set" Usage="System.Runtime.GCSettings.LatencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.GCLatencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący tryb opóźnienie do wyrzucania elementów bezużytecznych.</summary>
        <value>Jedna z wartości wyliczenia, które określa tryb opóźnienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W aplikacji można zmniejszyć poziom ingerencję operacji wyrzucania elementów bezużytecznych, ustawiając <xref:System.Runtime.GCLatencyMode> do <xref:System.Runtime.GCLatencyMode.LowLatency> podczas krytyczne operacje. Po ukończeniu takich operacji, wróć do wyższych trybie opóźnienia tak, aby więcej obiektów można odzyskać, aby zwiększyć ilość pamięci.  
  
 Zazwyczaj, ustaw wartość <xref:System.Runtime.GCSettings.LatencyMode%2A> właściwości, aby zdefiniować moduł zbierający elementy bezużyteczne opóźnienie trybu. Jednak nie GC region opóźnienia w trybie nie można ustawić, przypisując <xref:System.Runtime.GCLatencyMode.NoGCRegion?displayProperty=nameWithType> wartość wyliczenia do <xref:System.Runtime.GCSettings.LatencyMode%2A> właściwości. Zamiast tego należy wywołać <xref:System.GC.TryStartNoGCRegion%2A?displayProperty=nameWithType> wywołać metodę, aby rozpocząć nie GC region opóźnienia w trybie, a <xref:System.GC.EndNoGCRegion%2A?displayProperty=nameWithType> do jej zakończenia.  
  
 Zobacz [tryby opóźnienia](~/docs/standard/garbage-collection/latency.md) dyskusję na temat wpływu ustawienia konfiguracji środowiska uruchomieniowego do wyrzucania elementów bezużytecznych na wartość domyślną <xref:System.Runtime.GCLatencyMode> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Runtime.GCSettings.LatencyMode" /> Właściwości jest równa nieprawidłową wartość.  
  
—lub— 
<see cref="P:System.Runtime.GCSettings.LatencyMode" /> Nie można ustawić właściwości <see cref="F:System.Runtime.GCLatencyMode.NoGCRegion" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Tryby opóźnienia</related>
      </Docs>
    </Member>
  </Members>
</Type>
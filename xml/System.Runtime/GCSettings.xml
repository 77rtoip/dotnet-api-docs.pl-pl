<Type Name="GCSettings" FullName="System.Runtime.GCSettings">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0baf797ee3c7130da2de1bdbad1affd3838bdcef" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30567187" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GCSettings" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GCSettings extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.GCSettings" />
  <TypeSignature Language="VB.NET" Value="Public Class GCSettings" />
  <TypeSignature Language="C++ CLI" Value="public ref class GCSettings abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Określa ustawienia kolekcji odzyskiwanie dla bieżącego procesu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.GCSettings.IsServerGC%2A> właściwości w celu określenia, czy odzyskiwanie pamięci na serwerze jest włączone dla bieżącego procesu.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="IsServerGC">
      <MemberSignature Language="C#" Value="public static bool IsServerGC { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsServerGC" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.IsServerGC" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsServerGC As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsServerGC { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest włączone odzyskiwanie pamięci na serwerze.</summary>
        <value>
          <see langword="true" /> Jeśli odzyskiwanie pamięci na serwerze jest włączone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby dowiedzieć się, odzyskiwanie pamięci na serwerze, zobacz sekcję "Stacji roboczej i odzyskiwanie pamięci na serwerze" w [podstawowe informacje dotyczące wyrzucania elementów bezużytecznych](~/docs/standard/garbage-collection/fundamentals.md).  
  
 Jeśli odzyskiwanie pamięci na serwerze nie jest włączona, stacji roboczej wyrzucanie elementów bezużytecznych jest włączona (z lub bez kolekcji współbieżnych). Odzyskiwanie pamięci na serwerze jest dostępna tylko na komputerach wieloprocesorowych.  
  
 Niezarządzane hosta mogą żądać odzyskiwanie pamięci na serwerze, a żądanie hosta zastępuje ustawienia pliku konfiguracji. Jeśli host nie określa typ operacji wyrzucania elementów bezużytecznych, służy ustawienie pliku konfiguracji do określenia odzyskiwanie pamięci na serwerze. To ustawienie jest prawidłowe tylko w pliku konfiguracyjnym aplikacji nie znajduje się w pliku konfiguracji komputera (zobacz [konfigurowania aplikacji](http://msdn.microsoft.com/library/86bd26d3-737e-4484-9782-19b17f34cd1f)). W poniższym przykładzie przedstawiono zawartość pliku konfiguracji aplikacji przykładowej, który umożliwia odzyskiwanie pamięci na serwerze.  
  
```  
<configuration>  
  <runtime>  
    <gcServer enabled="true" />  
  </runtime>  
</configuration>  
```  
  
   
  
## Examples  
 Poniższy przykład wskazuje, czy komputer jest używany serwer lub stacji roboczej wyrzucanie elementów bezużytecznych.  
  
 [!code-csharp[Environment.IsServerGC#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.IsServerGC/CS/isg.cs#1)]
 [!code-vb[Environment.IsServerGC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.IsServerGC/VB/isg.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LargeObjectHeapCompactionMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.LargeObjectHeapCompactionMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LargeObjectHeapCompactionMode As GCLargeObjectHeapCompactionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { System::Runtime::GCLargeObjectHeapCompactionMode get(); void set(System::Runtime::GCLargeObjectHeapCompactionMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.GCLargeObjectHeapCompactionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Obsługiwane w programie .NET Framework 4.5.1 i nowszych wersjach]  
  
 Pobiera lub ustawia wartość wskazującą, czy pełny blokowania wyrzucanie elementów bezużytecznych kompaktuje sterty dużego obiektu (LOH).</summary>
        <value>Jedna z wartości wyliczenia, które wskazuje, czy pełny blokowania wyrzucanie elementów bezużytecznych kompaktuje LOH.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 LOH służy do przydzielania pamięci dla dużych obiektów (np. tablice), które wymagają więcej niż 85,000 bajtów. Ze względu na jego wpływ na wydajność kopiowania dużych bloków pamięci moduł zbierający elementy bezużyteczne zwykle wachlarzy LOH, która obejmuje utworzenie listy lokalizacji pamięci, które zostały zajmowany przez obiekty martwy i które mogą być ponownie używane do obsługi przyszłych żądań dla Alokacja pamięci dla dużych obiektów. Jednak w aplikacjach, które szeroką gamę stosowania LOH do przechowywania obiektów przejściowy, pamięci, których fragmentacji może niekorzystnie wpłynąć na wydajność. W takim przypadku jest możliwość użycia <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> właściwości kompaktowania zamiast po prostu odchylenia LOH podczas wyrzucania elementów bezużytecznych.  
  
 Wartość domyślna <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> właściwość jest <xref:System.Runtime.GCLargeObjectHeapCompactionMode.Default?displayProperty=nameWithType>, co oznacza, że LOH nie jest kompaktowanie podczas odzyskiwania. Jeśli przypisania wartości właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>LOH jest kompaktowanie podczas następnego pełnego blokowania wyrzucania elementów bezużytecznych i wartość właściwości jest resetowany do <xref:System.Runtime.GCLargeObjectHeapCompactionMode.Default?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nie blokują wyrzucania tła. Oznacza to, że jeśli ustawisz <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> właściwości <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, wszelkie generowania tła 2 kolekcje, które występują w wyniku tego nie compact LOH. Tylko pierwszy blokowania generacji 2 kolekcji kompaktuje LOH.  
  
 Po <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> właściwość jest ustawiona na <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, następnego pełnego blokowania wyrzucanie elementów bezużytecznych (i kompaktowanie LOH) występuje w czasie przyszłych nieokreślony. LOH można compact natychmiastowe przy użyciu kodu podobne do poniższych:  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.GCLargeObjectHeapCompactionMode" />
      </Docs>
    </Member>
    <Member MemberName="LatencyMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.GCLatencyMode LatencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.GCLatencyMode LatencyMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.LatencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LatencyMode As GCLatencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::GCLatencyMode LatencyMode { System::Runtime::GCLatencyMode get(); void set(System::Runtime::GCLatencyMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.GCLatencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący tryb opóźnienia wyrzucanie elementów bezużytecznych.</summary>
        <value>Jedna z wartości wyliczenia, które określa tryb opóźnienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można zmniejszyć poziom intrusiveness wyrzucanie elementów bezużytecznych w aplikacji, ustawiając <xref:System.Runtime.GCLatencyMode> do <xref:System.Runtime.GCLatencyMode.LowLatency> podczas operacji krytyczne. Po zakończeniu tych operacji powrócić do wyższych trybu opóźnienia, dzięki czemu będzie można odzyskać więcej obiektów, aby zwiększyć ilość pamięci.  
  
 Zwykle, ustaw wartość <xref:System.Runtime.GCSettings.LatencyMode%2A> właściwości, aby zdefiniować moduł garbage collector trybie opóźnienia. Jednak nie można ustawić nie GC region opóźnienia tryb przypisując <xref:System.Runtime.GCLatencyMode.NoGCRegion?displayProperty=nameWithType> wartości wyliczenia <xref:System.Runtime.GCSettings.LatencyMode%2A> właściwości. Zamiast tego należy wywołać <xref:System.GC.TryStartNoGCRegion%2A?displayProperty=nameWithType> wywołanie metody, aby rozpocząć nie GC region opóźnienia w trybie, a <xref:System.GC.EndNoGCRegion%2A?displayProperty=nameWithType> do jego zakończenia.  
  
 Zobacz [tryby opóźnienia](~/docs/standard/garbage-collection/latency.md) omówienie wpływ wartość domyślną ustawienia konfiguracji środowiska uruchomieniowego wyrzucanie elementów bezużytecznych <xref:System.Runtime.GCLatencyMode> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Runtime.GCSettings.LatencyMode" /> Właściwość ma ustawioną wartość jest nieprawidłowa.  
  
 —lub—  
  
 <see cref="P:System.Runtime.GCSettings.LatencyMode" /> Nie można ustawić właściwości <see cref="F:System.Runtime.GCLatencyMode.NoGCRegion" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
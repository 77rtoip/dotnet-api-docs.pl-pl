<Type Name="WorkflowApplication" FullName="System.Activities.WorkflowApplication">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a306551266053970f49f8a237037d8cb9dfdf4c8" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69343657" /></Metadata><TypeSignature Language="C#" Value="public sealed class WorkflowApplication : System.Activities.Hosting.WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowApplication extends System.Activities.Hosting.WorkflowInstance" />
  <TypeSignature Language="DocId" Value="T:System.Activities.WorkflowApplication" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowApplication&#xA;Inherits WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowApplication sealed : System::Activities::Hosting::WorkflowInstance" />
  <TypeSignature Language="F#" Value="type WorkflowApplication = class&#xA;    inherit WorkflowInstance" />
  <AssemblyInfo>
    <AssemblyName>System.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Activities.Hosting.WorkflowInstance</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Dostarcza hosta dla pojedynczego wystąpienia przepływu pracy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activities.WorkflowApplication> Klasa dostarcza hosta dla pojedynczego wystąpienia przepływu pracy. Jest to serwer proxy do rzeczywistego wystąpienia przepływu pracy, który jest zarządzany przez środowisko uruchomieniowe przepływu pracy. Użytkownicy mogą nakazać środowisko uruchomieniowe przepływu pracy w celu wykonywania akcji w wystąpieniu przepływu pracy przez wywołanie odpowiednich metod <xref:System.Activities.WorkflowApplication> w obiekcie. <xref:System.Activities.WorkflowApplication> Jeśli żądana akcja jest nieprawidłowa, zostanie zgłoszony wyjątek.  
  
 Korzystając <xref:System.Activities.WorkflowApplication> z programu, można wykonać następujące zadania:  
  
1.  Utwórz nowe wystąpienie przepływu pracy lub Załaduj wystąpienie przepływu pracy z magazynu wystąpień.  
  
2.  Podaj rozszerzenia, które mają być używane przez działania w ramach wystąpienia przepływu pracy.  
  
3.  Kontroluj wykonywanie wystąpienia przepływu pracy.  
  
4.  Wznów zakładkę utworzoną przez działanie w ramach wystąpienia przepływu pracy.  
  
5.  Utrwalanie lub zwalnianie wystąpienia przepływu pracy.  
  
6.  Powiadomienia o zdarzeniach cyklu życia wystąpienia przepływu pracy.  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po zakończeniu przepływu pracy następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.Activities.WorkflowApplication" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication workflowDefinition" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Definicja przepływu pracy.</param>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.Activities.WorkflowApplication" /> klasy z określoną definicją przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest zbudowane przy użyciu definicji przepływu pracy składającej się z `DiceRoll` pojedynczego działania. <xref:System.Activities.WorkflowApplication> `DiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po zakończeniu przepływu pracy dane wyjściowe są pobierane w programie <xref:System.Activities.WorkflowApplication.Completed%2A> obsługi, a w konsoli są wyświetlane następujące dane wyjściowe.  
  
```Output  
Workflow aae3fb48-7229-4737-b969-d63e131b96b3 Completed.   
The two dice are 1 and 5.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#21](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Activities.WorkflowIdentity definitionIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Activities.WorkflowIdentity definitionIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Activities.WorkflowIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, definitionIdentity As WorkflowIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Activities::WorkflowIdentity ^ definitionIdentity);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Activities.WorkflowIdentity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, definitionIdentity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Definicja przepływu pracy.</param>
        <param name="definitionIdentity">Tożsamość definicji.</param>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.Activities.WorkflowApplication" /> klasy z określoną definicją przepływu pracy i tożsamością definicji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, inputs As IDictionary(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, inputs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Definicja przepływu pracy.</param>
        <param name="inputs">Wartości argumentów zdefiniowanych w działaniu głównym definicji przepływu pracy, które są poprzedzone przez nazwę argumentu.</param>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.Activities.WorkflowApplication" /> klasy, która używa określonych wartości definicji przepływu pracy i argumentów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest tworzone przy użyciu definicji przepływu pracy składającej się z `Divide` pojedynczego działania, które przyjmuje dwa argumenty wejściowe, i słownik argumentów wejściowych zawierających dwie wartości, które mają być przekazane przez nazwę argumentu. <xref:System.Activities.WorkflowApplication> Zdarzenia cyklu życia przepływu pracy są obsługiwane, a przepływ pracy jest wywoływany z wywołaniem <xref:System.Activities.WorkflowApplication.Run%2A>do. Po zakończeniu przepływu pracy następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Workflow 8dc844c1-bbf8-4b21-a9a2-05f89e416055 Completed  
500 / 36 = 13 Remainder 32  
Workflow 8dc844c1-bbf8-4b21-a9a2-05f89e416055 Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, System.Activities.WorkflowIdentity definitionIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, class System.Activities.WorkflowIdentity definitionIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object},System.Activities.WorkflowIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, inputs As IDictionary(Of String, Object), definitionIdentity As WorkflowIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, System::Activities::WorkflowIdentity ^ definitionIdentity);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; * System.Activities.WorkflowIdentity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, inputs, definitionIdentity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Definicja przepływu pracy.</param>
        <param name="inputs">Tożsamość definicji.</param>
        <param name="definitionIdentity">Wartości argumentów zdefiniowanych w działaniu głównym definicji przepływu pracy, które są poprzedzone przez nazwę argumentu.</param>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.Activities.WorkflowApplication" /> klasy, która używa określonych wartości definicji przepływu pracy i argumentów oraz tożsamości definicji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powiadamia środowisko uruchomieniowe przepływu pracy, że to wystąpienie przepływu pracy powinno zostać przerwane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy przepływ pracy hostowany przez <xref:System.Activities.WorkflowApplication> jest przerywany <xref:System.Activities.WorkflowApplication.Aborted%2A> , <xref:System.Activities.WorkflowApplication.Completed%2A> program obsługi jest wywoływany, a procedura obsługi nie zostanie wywołana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="workflowApplication.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia środowisko uruchomieniowe przepływu pracy, że to wystąpienie przepływu pracy powinno zostać przerwane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy przepływ pracy hostowany przez <xref:System.Activities.WorkflowApplication> jest przerywany <xref:System.Activities.WorkflowApplication.Aborted%2A> , <xref:System.Activities.WorkflowApplication.Completed%2A> program obsługi jest wywoływany, a procedura obsługi nie zostanie wywołana.  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po uruchomieniu <xref:System.Activities.WorkflowApplication.Abort%2A> przepływu pracy jest wywoływana. Gdy przepływ pracy zostanie przerwany, następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow 3b76d562-516a-4a52-b17c-0f2ce531ad93 Idle.   
Workflow 3b76d562-516a-4a52-b17c-0f2ce531ad93 Aborted  
Exception: System.Activities.WorkflowApplicationAbortedException  
The workflow has been aborted.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#11](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (string reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(string reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Abort(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (reason As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::String ^ reason);" />
      <MemberSignature Language="F#" Value="override this.Abort : string -&gt; unit" Usage="workflowApplication.Abort reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="reason">Powód przerwania żądania.</param>
        <summary>Powiadamia środowisko uruchomieniowe przepływu pracy, że to wystąpienie przepływu pracy powinno zostać przerwane z określonego powodu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy przepływ pracy hostowany przez <xref:System.Activities.WorkflowApplication> jest przerywany <xref:System.Activities.WorkflowApplication.Aborted%2A> , <xref:System.Activities.WorkflowApplication.Completed%2A> program obsługi jest wywoływany, a procedura obsługi nie zostanie wywołana.  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po uruchomieniu <xref:System.Activities.WorkflowApplication.Abort%2A> przepływu pracy jest wywoływana. Gdy przepływ pracy zostanie przerwany, następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow 607b042e-98db-4bbe-abe8-f4d750feec41 Idle.   
Workflow 607b042e-98db-4bbe-abe8-f4d750feec41 Aborted  
Exception: System.Activities.WorkflowApplicationAbortedException  
The reason for aborting the workflow.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#11](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Aborted">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt; Aborted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationAbortedEventArgs&gt; Aborted" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Aborted" />
      <MemberSignature Language="VB.NET" Value="Public Property Aborted As Action(Of WorkflowApplicationAbortedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ Aborted { Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Aborted : Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Aborted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Action`1" /> , który jest wywoływany, gdy wystąpienie przepływu pracy zostanie przerwane.</summary>
        <value>Akcja, która jest wywoływana, gdy wystąpienie przepływu pracy zostało przerwane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy przepływ pracy hostowany przez <xref:System.Activities.WorkflowApplication> jest przerywany <xref:System.Activities.WorkflowApplication.Aborted%2A> , <xref:System.Activities.WorkflowApplication.Completed%2A> program obsługi jest wywoływany, a procedura obsługi nie zostanie wywołana.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, <xref:System.Activities.WorkflowApplicationAbortedEventArgs> czy przekazano <xref:System.Activities.WorkflowApplication.Aborted%2A> do procedury obsługi <xref:System.Activities.WorkflowApplication> wystąpienia i wyświetla informacje o tym, dlaczego przepływ pracy został przerwany.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#5](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInitialInstanceValues">
      <MemberSignature Language="C#" Value="public void AddInitialInstanceValues (System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,object&gt; writeOnlyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInitialInstanceValues(class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, object&gt; writeOnlyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.AddInitialInstanceValues(System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInitialInstanceValues (writeOnlyValues As IDictionary(Of XName, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInitialInstanceValues(System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Object ^&gt; ^ writeOnlyValues);" />
      <MemberSignature Language="F#" Value="member this.AddInitialInstanceValues : System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, obj&gt; -&gt; unit" Usage="workflowApplication.AddInitialInstanceValues writeOnlyValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writeOnlyValues" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="writeOnlyValues">Wartości metadanych do uwzględnienia w pierwszej trwałości.</param>
        <summary>Określa wartości metadanych wystąpienia, które są uwzględnione w pierwszej trwałości nowego wystąpienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginCancel">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anuluje przepływ pracy asynchronicznie przy <see cref="T:System.IAsyncResult" /> użyciu wzorca projektowego asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginCancel (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginCancel(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCancel(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginCancel (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginCancel(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginCancel : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginCancel (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji anulowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Anuluje wystąpienie przepływu pracy asynchronicznie przy użyciu <see cref="T:System.AsyncCallback" /> określonego i dostarczonego przez użytkownika stanu.</summary>
        <returns>Odwołanie do asynchronicznej operacji anulowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy operacja anulowania zakończyła się <xref:System.Activities.WorkflowApplication.EndCancel%2A>pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndCancel%2A>może być wywoływana z wnętrza lub poza `callback` metodę. Jeśli <xref:System.Activities.WorkflowApplication.EndCancel%2A> jest wywoływana przed ukończeniem operacji anulowania, zostaje ona zablokowana do momentu zakończenia operacji anulowania. Domyślnie operacja Cancel musi zakończyć się w ciągu 30 sekund lub <xref:System.TimeoutException> od. <xref:System.Activities.WorkflowApplication.EndCancel%2A>  
  
 Ta metoda anuluje przepływ pracy asynchronicznie przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginCancel (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginCancel(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCancel(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginCancel (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginCancel(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginCancel : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginCancel (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym operacja anulowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji anulowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Anuluje wystąpienie przepływu pracy asynchronicznie przy użyciu określonego interwału limitu czasu <see cref="T:System.AsyncCallback" />, i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do asynchronicznej operacji anulowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy operacja anulowania zakończyła się <xref:System.Activities.WorkflowApplication.EndCancel%2A>pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndCancel%2A>może być wywoływana z wnętrza lub spoza metody określonej w `callback` parametrze. Jeśli <xref:System.Activities.WorkflowApplication.EndCancel%2A> jest wywoływana przed ukończeniem operacji anulowania, zostaje ona zablokowana do momentu zakończenia operacji anulowania. Jeśli operacja anulowania nie zostanie zakończona w interwale określonym przez `timeOut` parametr <xref:System.TimeoutException> , zostanie zgłoszony z <xref:System.Activities.WorkflowApplication.EndCancel%2A>.  
  
 Ta metoda anuluje przepływ pracy asynchronicznie przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginCreateDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy domyślnego właściciela wystąpienia asynchronicznie przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektowego asynchronicznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginCreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginCreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginCreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginCreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="definitionIdentity">Tożsamość definicji.</param>
        <param name="identityFilter">Filtr tożsamości.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Tworzy domyślnego właściciela wystąpienia asynchronicznie za pomocą <see cref="T:System.IAsyncResult" /> asynchronicznego wzorca projektowego z określonym magazynem wystąpień, tożsamości definicji, filtru tożsamości, wywołania zwrotnego i stanu.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginCreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginCreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginCreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginCreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="definitionIdentity">Tożsamość definicji.</param>
        <param name="identityFilter">Filtr tożsamości.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Tworzy domyślnego właściciela wystąpienia asynchronicznie za pomocą <see cref="T:System.IAsyncResult" /> asynchronicznego wzorca projektowego z określonym magazynem wystąpień, tożsamości definicji, filtru tożsamości, interwału limitu czasu, wywołania zwrotnego i stanu.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginDeleteDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa domyślnego właściciela wystąpienia asynchronicznie przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektowego asynchronicznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginDeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginDeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginDeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginDeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner (instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Usuwa domyślnego właściciela wystąpienia asynchronicznie za pomocą <see cref="T:System.IAsyncResult" /> asynchronicznego wzorca projektowego z określonym magazynem wystąpień, wywołaniem zwrotnym i stanem.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginDeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginDeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginDeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginDeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner (instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Usuwa domyślnego właściciela wystąpienia asynchronicznie przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektu asynchronicznego z określonym magazynem wystąpień, interwału limitu czasu, wywołania zwrotnego i stanu.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginGetInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera właściciela wystąpienia asynchronicznie przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektowego asynchronicznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginGetInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetInstance (instanceId, instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identyfikator wystąpienia.</param>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Pobiera właściciela wystąpienia asynchronicznie za pomocą <see cref="T:System.IAsyncResult" /> asynchronicznego wzorca projektowego z określonym identyfikatorem wystąpienia, magazynem wystąpień, wywołaniem zwrotnym i stanem.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetInstance (instanceId, instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identyfikator wystąpienia.</param>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Pobiera właściciela wystąpienia asynchronicznie za pomocą <see cref="T:System.IAsyncResult" /> asynchronicznego wzorca projektowego z określonym identyfikatorem wystąpienia, magazynem wystąpień, interwałem limitu czasu, wywołaniem zwrotnym i stanem.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginGetRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera właściciela wystąpienia możliwy do uruchomienia asynchronicznie przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektowego asynchronicznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetRunnableInstance (instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Pobiera właściciela wystąpienia możliwy do uruchomienia asynchronicznie za pomocą <see cref="T:System.IAsyncResult" /> asynchronicznego wzorca projektowego z określonym magazynem wystąpień, wywołaniem zwrotnym i stanem.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetRunnableInstance (instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Pobiera właściciela wystąpienia możliwy do uruchomienia asynchronicznie przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektu asynchronicznego z określonym magazynem wystąpień, interwału limitu czasu, wywołania zwrotnego i stanu.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoad">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje przepływ pracy asynchronicznie z magazynu wystąpień przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektowego asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Ładuje przepływ pracy asynchronicznie z magazynu wystąpień przy użyciu <see cref="T:System.IAsyncResult" /> asynchronicznego wzorca projektowego z określonym wystąpieniem, wywołaniem zwrotnym i stanem.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (Guid instanceId, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(valuetype System.Guid instanceId, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Guid,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instanceId As Guid, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(Guid instanceId, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Guid * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instanceId, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Globalnie unikatowy identyfikator 128-bitowy dla wystąpienia przepływu pracy.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Ładuje przepływ pracy asynchronicznie z magazynu wystąpień przy użyciu określonego identyfikatora wystąpienia, metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Stan operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, updateMap, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie.</param>
        <param name="updateMap">Mapa aktualizacji.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Ładuje przepływ pracy asynchronicznie z magazynu wystąpień przy użyciu <see cref="T:System.IAsyncResult" /> asynchronicznego wzorca projektowego z określonym wystąpieniem, mapą aktualizacji, wywołaniem zwrotnym i stanem.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Ładuje przepływ pracy asynchronicznie z magazynu wystąpień przy użyciu <see cref="T:System.IAsyncResult" /> asynchronicznego wzorca projektowego z określonym wystąpieniem, interwałem limitu czasu, wywołaniem zwrotnym i stanem.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (Guid instanceId, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(valuetype System.Guid instanceId, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Guid,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instanceId As Guid, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(Guid instanceId, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Guid * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instanceId, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Globalnie unikatowy identyfikator 128-bitowy dla wystąpienia przepływu pracy.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Ładuje przepływ pracy asynchronicznie z magazynu wystąpień przy użyciu określonego identyfikatora wystąpienia, okresu limitu czasu, metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Stan operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, updateMap, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie.</param>
        <param name="updateMap">Mapa aktualizacji.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji rozpoczęcia ładowania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Ładuje przepływ pracy asynchronicznie z magazynu wystąpień przy użyciu <see cref="T:System.IAsyncResult" /> asynchronicznego wzorca projektowego z określonym wystąpieniem, mapą aktualizacji, interwałem limitu czasu, wywołaniem zwrotnym i stanem.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoadRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje proces asynchroniczny ładowania wystąpienia przepływu pracy możliwy do uruchomienia z <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie możliwy do uruchomienia to wystąpienie, dla którego upłynął limit czasu czasomierza lub blokady wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoadRunnableInstance (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoadRunnableInstance(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoadRunnableInstance(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoadRunnableInstance (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoadRunnableInstance(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoadRunnableInstance : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoadRunnableInstance (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji zawierający informacje o operacji asynchronicznej.</param>
        <summary>Inicjuje operację ładowania wystąpienia przepływu pracy możliwy do uruchomienia z <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />elementu.</summary>
        <returns>Odwołanie do operacji asynchronicznej</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie możliwy do uruchomienia to wystąpienie, dla którego upłynął limit czasu czasomierza lub blokady wystąpienia.  
  
 Aby określić, czy operacja ładowania zakończyła się <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>pomyślnie, wywołaj. <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>może być wywoływana z wnętrza lub poza `callback` metodę. Jeśli <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> jest wywoływana przed zakończeniem operacji wznawiania, zostanie ona zablokowana do momentu zakończenia operacji wznawiania. Domyślnie operacja Resume musi zakończyć się w ciągu 30 sekund lub w przeciwnym razie <xref:System.TimeoutException> jest zgłaszany <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>z.  
  
 Ta metoda ładuje przepływ pracy asynchronicznie przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoadRunnableInstance (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoadRunnableInstance(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoadRunnableInstance(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoadRunnableInstance (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoadRunnableInstance(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoadRunnableInstance : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoadRunnableInstance (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym operacja ładowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji zawierający informacje o operacji asynchronicznej.</param>
        <summary>Inicjuje operację ładowania wystąpienia przepływu pracy możliwy do uruchomienia z <see cref="P:System.Activities.WorkflowApplication.InstanceStore" /> użyciem określonego interwału limitu czasu.</summary>
        <returns>Odwołanie do operacji asynchronicznej</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie możliwy do uruchomienia to wystąpienie, dla którego upłynął limit czasu czasomierza lub blokady wystąpienia.  
  
 Aby określić, czy operacja ładowania zakończyła się <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>pomyślnie, wywołaj. <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>może być wywoływana z wnętrza lub poza `callback` metodę. Jeśli <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> jest wywoływana przed zakończeniem operacji wznawiania, zostanie ona zablokowana do momentu zakończenia operacji wznawiania. Jeśli operacja ładowania nie zostanie zakończona w określonym limicie czasu, <xref:System.TimeoutException> z. <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>  
  
 Ta metoda ładuje przepływ pracy asynchronicznie przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPersist">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Utrwala wystąpienie przepływu pracy w magazynie wystąpień asynchronicznie przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektowego asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPersist">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPersist (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPersist(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginPersist(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPersist (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPersist(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginPersist : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginPersist (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji utrwalania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Utrwala wystąpienie przepływu pracy w magazynie wystąpień asynchronicznie przy użyciu określonej metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do asynchronicznej operacji utrwalania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy operacja utrwalania zakończyła <xref:System.Activities.WorkflowApplication.EndPersist%2A>się pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndPersist%2A>może być wywoływana z wnętrza lub poza metodę, do której odwołuje `callback` się parametr. Jeśli <xref:System.Activities.WorkflowApplication.EndPersist%2A> jest wywoływana przed ukończeniem operacji utrwalania, zostanie ona zablokowana do momentu zakończenia operacji utrwalania. Jeśli operacja utrwalania nie zakończy się w ciągu 30 sekund <xref:System.TimeoutException> , zgłaszany <xref:System.Activities.WorkflowApplication.EndPersist%2A>jest z.  
  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
 Ta metoda utrzymuje przepływ pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginPersist">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPersist (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPersist(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginPersist(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPersist (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPersist(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginPersist : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginPersist (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym operacja utrwalania musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji utrwalania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Utrwala wystąpienie przepływu pracy w magazynie wystąpień asynchronicznie przy użyciu określonego interwału limitu czasu, metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do asynchronicznej operacji utrwalania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy operacja utrwalania zakończyła <xref:System.Activities.WorkflowApplication.EndPersist%2A>się pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndPersist%2A>może być wywoływana z wnętrza lub poza metodę, do której odwołuje `callback` się parametr. Jeśli <xref:System.Activities.WorkflowApplication.EndPersist%2A> jest wywoływana przed ukończeniem operacji utrwalania, zostanie ona zablokowana do momentu zakończenia operacji utrwalania. Jeśli operacja utrwalania nie zostanie zakończona w określonym interwale limitu czasu, <xref:System.TimeoutException> z. <xref:System.Activities.WorkflowApplication.EndPersist%2A>  
  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
 Ta metoda utrwala wystąpienie przepływu pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginResumeBookmark">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje zainicjowanie operacji asynchronicznej w celu wznowienia zakładki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (System.Activities.Bookmark bookmark, object value, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.Activities.Bookmark,System.Object,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : System.Activities.Bookmark * obj * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmark, value, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Zakładka, która ma zostać wznowiona.</param>
        <param name="value">Obiekt przeszedł jako parametr do metody, która jest wywoływana, gdy zakładka zostanie wznowiona.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji wznawiania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Powoduje zainicjowanie operacji wznawiania zakładki przy użyciu określonej wartości, metody wywołania zwrotnego i stanu.</summary>
        <returns>Odwołanie do operacji wznawiania zakładki asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy operacja wznowienia zakończyła <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>się pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>może być wywoływana z wnętrza lub poza `callback` metodę. Jeśli <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> jest wywoływana przed zakończeniem operacji wznawiania, zostanie ona zablokowana do momentu zakończenia operacji wznawiania. Domyślnie operacja Resume musi zakończyć się w ciągu 30 sekund lub w przeciwnym razie <xref:System.TimeoutException> jest zgłaszany <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>z.  
  
 Ta metoda służy do asynchronicznego wznawiania zakładki przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (string bookmarkName, object value, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(string bookmarkName, object value, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.String,System.Object,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginResumeBookmark (bookmarkName As String, value As Object, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : string * obj * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmarkName, value, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Nazwa zakładki, która ma zostać wznowiona.</param>
        <param name="value">Obiekt przeszedł jako parametr do metody, która jest wywoływana, gdy zakładka zostanie wznowiona.</param>
        <param name="callback">Metoda, która jest wywoływana po zakończeniu operacji asynchronicznej.</param>
        <param name="state">Stan wykonywania przepływu pracy, który został zachowany przez wątek wywołujący przed rozpoczęciem operacji asynchronicznej.</param>
        <summary>Powoduje zainicjowanie operacji asynchronicznej w celu wznowienia zakładki o określonej nazwie przy użyciu określonej wartości, metody wywołania zwrotnego i stanu. Zakładka, która ma zostać wznowiona, została wcześniej utworzona przez działanie w ramach wystąpienia przepływu pracy.</summary>
        <returns>Wynik operacji wznowienia zakładki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik zakładki wskazuje, czy operacja wznawiania zakończyła się powodzeniem, czy niepowodzeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : System.Activities.Bookmark * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmark, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Zakładka, która ma zostać wznowiona.</param>
        <param name="value">Obiekt przeszedł jako parametr do metody, która jest wywoływana, gdy zakładka zostanie wznowiona.</param>
        <param name="timeout">Interwał, w którym operacja wznawiania musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji wznawiania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Powoduje zainicjowanie operacji wznawiania zakładki przy użyciu określonej wartości, interwału limitu czasu, metody wywołania zwrotnego i stanu.</summary>
        <returns>Odwołanie do operacji wznawiania zakładki asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy operacja wznowienia zakończyła <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>się pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>może być wywoływana z wnętrza lub poza `callback` metodę. Jeśli <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> jest wywoływana przed zakończeniem operacji wznawiania, zostanie ona zablokowana do momentu zakończenia operacji wznawiania. Jeśli operacja wznowienia nie zostanie zakończona w określonym limicie czasu a <xref:System.TimeoutException> zostanie zgłoszony z. <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>  
  
 Ta metoda służy do asynchronicznego wznawiania zakładki przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (string bookmarkName, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(string bookmarkName, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.String,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginResumeBookmark (bookmarkName As String, value As Object, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : string * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmarkName, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Nazwa zakładki, która ma zostać wznowiona.</param>
        <param name="value">Obiekt przeszedł jako parametr do metody, która jest wywoływana, gdy zakładka zostanie wznowiona.</param>
        <param name="timeout">Przedział czasu, w którym należy wznowić zakładkę.</param>
        <param name="callback">Metoda, która jest wywoływana po zakończeniu operacji asynchronicznej.</param>
        <param name="state">Stan wykonywania przepływu pracy, który został zapisany przez wątek wywołujący przed rozpoczęciem operacji asynchronicznej.</param>
        <summary>Powoduje zainicjowanie operacji asynchronicznej w celu wznowienia zakładki o określonej nazwie przy użyciu określonej wartości, interwału limitu czasu, metody wywołania zwrotnego i stanu. Zakładka, która ma zostać wznowiona, została wcześniej utworzona przez działanie w ramach wystąpienia przepływu pracy.</summary>
        <returns>Wynik operacji wznowienia zakładki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik zakładki wskazuje, czy operacja wznawiania zakończyła się powodzeniem, czy niepowodzeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginRun">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia lub wznawia wystąpienie przepływu pracy asynchronicznie przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektowego asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginRun">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginRun (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginRun(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginRun(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginRun (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginRun(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginRun : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginRun (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji wznawiania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Uruchamia lub wznawia wystąpienie przepływu pracy asynchronicznie przy użyciu określonej metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do asynchronicznej operacji przebiegu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy operacja uruchamiania zakończyła się <xref:System.Activities.WorkflowApplication.EndRun%2A>pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndRun%2A>może być wywoływana z wnętrza lub poza metodę, do której odwołuje `callback` się parametr. Jeśli <xref:System.Activities.WorkflowApplication.EndRun%2A> jest wywoływana przed zakończeniem operacji wznawiania, zostanie ona zablokowana do momentu zakończenia operacji wznawiania. Domyślnie operacja Resume musi zakończyć się w ciągu 30 sekund lub <xref:System.TimeoutException> od. <xref:System.Activities.WorkflowApplication.EndRun%2A>  
  
 Ta metoda uruchamia lub wznawia przepływ pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRun">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginRun (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginRun(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginRun(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginRun (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginRun(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginRun : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginRun (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym operacja wznawiania musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu operacji wznawiania.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Uruchamia lub wznawia wystąpienie przepływu pracy asynchronicznie przy użyciu określonego interwału limitu czasu, metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do asynchronicznej operacji przebiegu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy operacja uruchamiania zakończyła się <xref:System.Activities.WorkflowApplication.EndRun%2A>pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndRun%2A>może być wywoływana z wnętrza lub poza odwołaniem metody w `callback` parametrze. Jeśli <xref:System.Activities.WorkflowApplication.EndRun%2A> jest wywoływana przed zakończeniem operacji wznawiania, zostanie ona zablokowana do momentu zakończenia operacji wznawiania. Jeśli operacja wznowienia nie zostanie zakończona w określonym limicie czasu a <xref:System.TimeoutException> zostanie zgłoszony z. <xref:System.Activities.WorkflowApplication.EndRun%2A>  
  
 Ta metoda uruchamia lub wznawia przepływ pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginTerminate">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy wystąpienie przepływu pracy asynchronicznie przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektu asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (Exception reason, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(class System.Exception reason, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.Exception,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As Exception, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(Exception ^ reason, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : Exception * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Przyczyna zakończenia wystąpienia przepływu pracy.</param>
        <param name="callback">Metoda, która ma być wywoływana po <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> zakończeniu operacji.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Kończy wystąpienie przepływu pracy asynchronicznie przy użyciu określonego wyjątku, metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do bieżącej <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda planuje zakończenie wystąpienia przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu zakończenia, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> dojścia.  
  
 Aby określić, czy <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> operacja zakończyła się <xref:System.Activities.WorkflowApplication.EndTerminate%2A>pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndTerminate%2A>może być wywoływana z wnętrza lub poza metodę, do której odwołuje `callback` się parametr. Jeśli <xref:System.Activities.WorkflowApplication.EndTerminate%2A> jest wywoływana <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> przed zakończeniem operacji <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> , jest blokowana do momentu zakończenia operacji. Domyślnie <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> operacja musi zakończyć się w ciągu 30 sekund <xref:System.TimeoutException> lub od <xref:System.Activities.WorkflowApplication.EndTerminate%2A>.  
  
 Ta metoda przerywa przepływ pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (string reason, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(string reason, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(System::String ^ reason, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Przyczyna zakończenia wystąpienia przepływu pracy.</param>
        <param name="callback">Metoda, która ma być wywoływana po <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> zakończeniu operacji.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Kończy wystąpienie przepływu pracy asynchronicznie przy użyciu określonego komunikatu o błędzie, metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do bieżącej <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda planuje zakończenie wystąpienia przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu zakończenia, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> dojścia.  
  
 Aby określić, czy <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> operacja zakończyła się <xref:System.Activities.WorkflowApplication.EndTerminate%2A>pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndTerminate%2A>może być wywoływana z wnętrza lub poza odwołaniem metody w `callback` parametrze. Jeśli <xref:System.Activities.WorkflowApplication.EndTerminate%2A> jest wywoływana <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> przed zakończeniem operacji <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> , jest blokowana do momentu zakończenia operacji. Domyślnie <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> operacja musi zakończyć się w ciągu 30 sekund <xref:System.TimeoutException> lub od <xref:System.Activities.WorkflowApplication.EndTerminate%2A>.  
  
 Ta metoda przerywa wystąpienie przepływu pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (Exception reason, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(class System.Exception reason, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.Exception,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As Exception, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(Exception ^ reason, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : Exception * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Przyczyna zakończenia wystąpienia przepływu pracy.</param>
        <param name="timeout">Interwał, w którym <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> operacja musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> zakończeniu operacji.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Kończy wystąpienie przepływu pracy asynchronicznie przy użyciu określonego wyjątku, interwału limitu czasu, metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do bieżącej <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda planuje zakończenie wystąpienia przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu zakończenia, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> dojścia.  
  
 Aby określić, czy <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> operacja zakończyła się <xref:System.Activities.WorkflowApplication.EndTerminate%2A>pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndTerminate%2A>może być wywoływana z wnętrza lub poza `callback` metodę. Jeśli <xref:System.Activities.WorkflowApplication.EndTerminate%2A> jest wywoływana <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> przed zakończeniem operacji <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> , jest blokowana do momentu zakończenia operacji. Jeśli operacja nie zostanie zakończona w określonym przedziale czasu a <xref:System.TimeoutException> zostanie zgłoszony. <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> To lub wszelkie inne wyjątki występujące podczas <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> procesu są generowane z programu. <xref:System.Activities.WorkflowApplication.EndTerminate%2A>  
  
 Ta metoda przerywa przepływ pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (string reason, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(string reason, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.String,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As String, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(System::String ^ reason, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : string * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Przyczyna zakończenia wystąpienia przepływu pracy.</param>
        <param name="timeout">Interwał, w którym <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> operacja musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> zakończeniu operacji.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Kończy wystąpienie przepływu pracy asynchronicznie przy użyciu określonego komunikatu o błędzie, interwału limitu czasu, metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do operacji asynchronicznej <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda planuje zakończenie wystąpienia przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu zakończenia, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> dojścia.  
  
 Aby określić, czy <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> operacja zakończyła się <xref:System.Activities.WorkflowApplication.EndTerminate%2A>pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndTerminate%2A>może być wywoływana z wnętrza lub poza odwołaniem metody w `callback` parametrze. Jeśli <xref:System.Activities.WorkflowApplication.EndTerminate%2A> jest wywoływana <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> przed zakończeniem operacji <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> , jest blokowana do momentu zakończenia operacji. Jeśli operacja nie zakończy się w określonym limicie czasu a <xref:System.TimeoutException> zostanie zgłoszony z <xref:System.Activities.WorkflowApplication.EndTerminate%2A>. <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>  
  
 Ta metoda przerywa wystąpienie przepływu pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginUnload">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Utrzymuje i usuwa wystąpienie przepływu pracy asynchronicznie przy użyciu <see cref="T:System.IAsyncResult" /> wzorca projektowego asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginUnload">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginUnload (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginUnload(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginUnload(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginUnload (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginUnload(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginUnload : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginUnload (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda, która ma być wywoływana po <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" /> zakończeniu operacji.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Utrzymuje i usuwa wystąpienie przepływu pracy asynchronicznie przy użyciu określonej metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do operacji asynchronicznej <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy <xref:System.Activities.WorkflowApplication.BeginUnload%2A> operacja zakończyła się <xref:System.Activities.WorkflowApplication.EndUnload%2A>pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndUnload%2A>może być wywoływana z wnętrza lub poza odwołaniem metody w `callback` parametrze. Jeśli <xref:System.Activities.WorkflowApplication.EndUnload%2A> jest wywoływana <xref:System.Activities.WorkflowApplication.BeginUnload%2A> przed zakończeniem operacji <xref:System.Activities.WorkflowApplication.BeginUnload%2A> , jest blokowana do momentu zakończenia operacji. Domyślnie <xref:System.Activities.WorkflowApplication.BeginUnload%2A> operacja musi zakończyć się w ciągu 30 sekund <xref:System.TimeoutException> lub od <xref:System.Activities.WorkflowApplication.EndUnload%2A>.  
  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
 Ta metoda utrzymuje i usuwa wystąpienie przepływu pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUnload">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginUnload (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginUnload(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginUnload(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginUnload (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginUnload(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginUnload : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginUnload (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> operacja musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" /> zakończeniu operacji.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Utrzymuje i usuwa wystąpienie przepływu pracy asynchronicznie przy użyciu określonego interwału limitu czasu, metody wywołania zwrotnego i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do operacji asynchronicznej <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy <xref:System.Activities.WorkflowApplication.BeginUnload%2A> operacja zakończyła się <xref:System.Activities.WorkflowApplication.EndUnload%2A>pomyślnie, wywołaj metodę. <xref:System.Activities.WorkflowApplication.EndUnload%2A>może być wywoływana z wnętrza lub poza odwołaniem metody w `callback` parametrze. Jeśli <xref:System.Activities.WorkflowApplication.EndUnload%2A> jest wywoływana <xref:System.Activities.WorkflowApplication.BeginUnload%2A> przed zakończeniem operacji <xref:System.Activities.WorkflowApplication.BeginUnload%2A> , jest blokowana do momentu zakończenia operacji. Jeśli operacja nie zakończy się w określonym limicie czasu a <xref:System.TimeoutException> zostanie zgłoszony z <xref:System.Activities.WorkflowApplication.EndUnload%2A>. <xref:System.Activities.WorkflowApplication.BeginUnload%2A>  
  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
 Ta metoda utrzymuje i zwalnia wystąpienie przepływu pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Cancel">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anuluje wystąpienie przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do planowania anulowania wystąpienia przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu anulowania, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> dojścia.  
  
 Domyślnie operacja anulowania musi zakończyć się w ciągu 30 sekund lub w wyniku <xref:System.TimeoutException> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Cancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel();" />
      <MemberSignature Language="F#" Value="member this.Cancel : unit -&gt; unit" Usage="workflowApplication.Cancel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje wystąpienie przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do planowania anulowania wystąpienia przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu anulowania, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> procedury obsługi.  
  
 Domyślnie operacja anulowania musi zakończyć się w ciągu 30 sekund lub w wyniku <xref:System.TimeoutException> .  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po uruchomieniu <xref:System.Activities.WorkflowApplication.Cancel%2A> przepływu pracy jest wywoływana. Gdy przepływ pracy zostanie anulowany, następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Idle.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Canceled  
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#13](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Cancel(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Cancel : TimeSpan -&gt; unit" Usage="workflowApplication.Cancel timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym operacja anulowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Anuluje wystąpienie przepływu pracy przy użyciu określonego interwału limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do planowania anulowania wystąpienia przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu anulowania, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> procedury obsługi.  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po uruchomieniu <xref:System.Activities.WorkflowApplication.Cancel%2A> przepływu pracy jest wywoływana. Gdy przepływ pracy zostanie anulowany, następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Idle.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Canceled  
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#13](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completed">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt; Completed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationCompletedEventArgs&gt; Completed" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Completed" />
      <MemberSignature Language="VB.NET" Value="Public Property Completed As Action(Of WorkflowApplicationCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ Completed { Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Completed : Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Completed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Action`1" /> , która jest wywoływana po zakończeniu wystąpienia przepływu pracy.</summary>
        <value>Akcja, która jest wywoływana po zakończeniu wystąpienia przepływu pracy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu sprawdza, <xref:System.Activities.WorkflowApplicationCompletedEventArgs> czy przeszedł <xref:System.Activities.WorkflowApplication.Completed%2A> do procedury obsługi <xref:System.Activities.WorkflowApplication> wystąpienia i wyświetla informacje o ukończeniu przepływu pracy.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#4](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy domyślnego właściciela wystąpienia dla przepływu pracy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void CreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.CreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter);" />
      <MemberSignature Language="F#" Value="static member CreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter -&gt; unit" Usage="System.Activities.WorkflowApplication.CreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="definitionIdentity">Tożsamość definicji przepływu pracy.</param>
        <param name="identityFilter">Filtr tożsamości.</param>
        <summary>Tworzy domyślnego właściciela wystąpienia przepływu pracy przy użyciu określonego magazynu wystąpienia, tożsamości definicji i filtru tożsamości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void CreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.CreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member CreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * TimeSpan -&gt; unit" Usage="System.Activities.WorkflowApplication.CreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="definitionIdentity">Tożsamość definicji przepływu pracy.</param>
        <param name="identityFilter">Filtr tożsamości.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana.</param>
        <summary>Tworzy domyślnego właściciela wystąpienia przepływu pracy przy użyciu określonego magazynu wystąpienia, tożsamości definicji i filtru tożsamości oraz interwału limitu czasu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa domyślnego właściciela wystąpienia przepływu pracy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void DeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member DeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore -&gt; unit" Usage="System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner instanceStore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <summary>Usuwa domyślnego właściciela wystąpienia przepływu pracy z określonym magazynem wystąpień.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void DeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member DeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; unit" Usage="System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner (instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana.</param>
        <summary>Usuwa domyślnego właściciela wystąpienia przepływu pracy z określonym magazynem wystąpień i interwałem limitu czasu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public void EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndCancel (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndCancel : IAsyncResult -&gt; unit" Usage="workflowApplication.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Asynchroniczna operacja anulowania.</param>
        <summary>Czeka na zakończenie oczekującej asynchronicznej operacji anulowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Activities.WorkflowApplication.BeginCancel%2A> operacja zakończyła się pomyślnie. Jeśli wywoływana przed zakończeniem operacji anulowania, zostaje ona zablokowana do momentu zakończenia operacji anulowania.  
  
 Ta metoda służy do kończenia asynchronicznej operacji anulowania <xref:System.IAsyncResult> przy użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void EndCreateDefaultInstanceOwner (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCreateDefaultInstanceOwner(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndCreateDefaultInstanceOwner(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCreateDefaultInstanceOwner (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCreateDefaultInstanceOwner(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndCreateDefaultInstanceOwner : IAsyncResult -&gt; unit" Usage="System.Activities.WorkflowApplication.EndCreateDefaultInstanceOwner asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Wynik asynchroniczny.</param>
        <summary>Czeka na ukończenie tworzenia domyślnego właściciela wystąpienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void EndDeleteDefaultInstanceOwner (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndDeleteDefaultInstanceOwner(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndDeleteDefaultInstanceOwner(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndDeleteDefaultInstanceOwner (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndDeleteDefaultInstanceOwner(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndDeleteDefaultInstanceOwner : IAsyncResult -&gt; unit" Usage="System.Activities.WorkflowApplication.EndDeleteDefaultInstanceOwner asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Wynik asynchroniczny.</param>
        <summary>Czeka na zakończenie usuwania domyślnego właściciela wystąpienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance EndGetInstance (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance EndGetInstance(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndGetInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndGetInstance (asyncResult As IAsyncResult) As WorkflowApplicationInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ EndGetInstance(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndGetInstance : IAsyncResult -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.EndGetInstance asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Wynik asynchroniczny.</param>
        <summary>Czeka na zakończenie pobierania wystąpienia.</summary>
        <returns>Wynik operacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance EndGetRunnableInstance (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance EndGetRunnableInstance(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndGetRunnableInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndGetRunnableInstance (asyncResult As IAsyncResult) As WorkflowApplicationInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ EndGetRunnableInstance(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndGetRunnableInstance : IAsyncResult -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.EndGetRunnableInstance asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Wynik asynchroniczny.</param>
        <summary>Czeka na zakończenie asynchronicznego pobierania operacji wystąpienia możliwy do uruchomienia.</summary>
        <returns>Wynik operacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoad">
      <MemberSignature Language="C#" Value="public void EndLoad (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoad(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndLoad(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoad (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoad(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndLoad : IAsyncResult -&gt; unit" Usage="workflowApplication.EndLoad result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Asynchroniczna operacja ładowania.</param>
        <summary>Czeka na zakończenie oczekującej asynchronicznej operacji ładowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda jest wywoływana przed ukończeniem operacji ładowania, zostaje ona zablokowana do momentu zakończenia operacji ładowania.  
  
 Ta metoda kończy asynchroniczne ładowanie operacji przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void EndLoadRunnableInstance (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadRunnableInstance(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndLoadRunnableInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadRunnableInstance (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadRunnableInstance(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndLoadRunnableInstance : IAsyncResult -&gt; unit" Usage="workflowApplication.EndLoadRunnableInstance result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do asynchronicznej operacji ładowania.</param>
        <summary>Czeka na zakończenie operacji asynchronicznego ładowania wystąpienia możliwy do uruchomienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Activities.WorkflowApplication.BeginLoadRunnableInstance%2A> operacja zakończyła się pomyślnie. Jeśli wywoływana przed zakończeniem operacji ładowania, zostaje ona zablokowana do momentu zakończenia operacji.  
  
 Ta metoda ładuje przepływy pracy asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndPersist">
      <MemberSignature Language="C#" Value="public void EndPersist (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndPersist(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndPersist(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndPersist (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndPersist(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndPersist : IAsyncResult -&gt; unit" Usage="workflowApplication.EndPersist result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Asynchroniczna operacja utrwalania.</param>
        <summary>Czeka na zakończenie oczekującej asynchronicznej operacji utrwalania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Activities.WorkflowApplication.BeginPersist%2A> operacja zakończyła się pomyślnie. Jeśli wywoływana przed ukończeniem operacji utrwalania, zostanie ona zablokowana do momentu ukończenia operacji utrwalania.  
  
 Ta metoda wykonuje asynchroniczną operację utrwalania przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult EndResumeBookmark (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult EndResumeBookmark(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndResumeBookmark(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndResumeBookmark (result As IAsyncResult) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult EndResumeBookmark(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndResumeBookmark : IAsyncResult -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.EndResumeBookmark result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołanie do operacji wznawiania zakładki asynchronicznej.</param>
        <summary>Czeka na zakończenie operacji wznowienia zakładki.</summary>
        <returns>Jedna z wartości wyliczenia, która wskazuje wyniki operacji wznowienia zakładki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Activities.WorkflowApplication.BeginResumeBookmark%2A> operacja zakończyła się pomyślnie. Jeśli wywoływana przed zakończeniem operacji ładowania, zostaje ona zablokowana do momentu zakończenia operacji.  
  
 Ta metoda służy do asynchronicznego wznawiania zakładki przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRun">
      <MemberSignature Language="C#" Value="public void EndRun (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndRun(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndRun(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndRun (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndRun(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndRun : IAsyncResult -&gt; unit" Usage="workflowApplication.EndRun result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Operacja przebiegu asynchronicznego.</param>
        <summary>Czeka na zakończenie oczekującej operacji asynchronicznego przebiegu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:System.Activities.WorkflowApplication.BeginRun%2A> operacja zakończyła się pomyślnie. Jeśli wywoływana przed zakończeniem operacji wznawiania, zostanie ona zablokowana do momentu zakończenia operacji wznawiania.  
  
 Ta metoda wykonuje asynchroniczną operację przebiegu przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndTerminate">
      <MemberSignature Language="C#" Value="public void EndTerminate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndTerminate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndTerminate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndTerminate (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndTerminate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndTerminate : IAsyncResult -&gt; unit" Usage="workflowApplication.EndTerminate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Asynchroniczna operacja przerwania.</param>
        <summary>Czeka na zakończenie oczekującej asynchronicznej operacji przerwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może zostać wywołana w celu ustalenia, <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> czy operacja zakończyła się pomyślnie. Jeśli wywoływana przed zakończeniem operacji zakończenia, zostaje ona zablokowana do momentu zakończenia operacji.  
  
 Ta metoda służy do kończenia <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> operacji asynchronicznej <xref:System.IAsyncResult> przy użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndUnload">
      <MemberSignature Language="C#" Value="public void EndUnload (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndUnload(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndUnload(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndUnload (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndUnload(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndUnload : IAsyncResult -&gt; unit" Usage="workflowApplication.EndUnload result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Asynchroniczna operacja zwolnienia.</param>
        <summary>Czeka na zakończenie oczekującej asynchronicznej operacji zwolnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może zostać wywołana w celu ustalenia, <xref:System.Activities.WorkflowApplication.BeginUnload%2A> czy operacja zakończyła się pomyślnie. Jeśli wywoływana przed ukończeniem operacji zwalniania, zostanie ona zablokowana do momentu zakończenia operacji.  
  
 Ta metoda służy do kończenia <xref:System.Activities.WorkflowApplication.BeginUnload%2A> operacji asynchronicznej <xref:System.IAsyncResult> przy użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As WorkflowInstanceExtensionManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::Hosting::WorkflowInstanceExtensionManager ^ Extensions { System::Activities::Hosting::WorkflowInstanceExtensionManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.Activities.Hosting.WorkflowInstanceExtensionManager" Usage="System.Activities.WorkflowApplication.Extensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Hosting.WorkflowInstanceExtensionManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję rozszerzeń dla bieżącego wystąpienia przepływu pracy.</summary>
        <value>Kolekcja obiektów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBookmarks">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję zakładek dla wystąpienia przepływu pracy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBookmarks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetBookmarks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBookmarks () As ReadOnlyCollection(Of BookmarkInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Activities::Hosting::BookmarkInfo ^&gt; ^ GetBookmarks();" />
      <MemberSignature Language="F#" Value="member this.GetBookmarks : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;" Usage="workflowApplication.GetBookmarks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję zakładek dla wystąpienia przepływu pracy.</summary>
        <returns>Kolekcja zakładek tylko do odczytu dla wystąpienia przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta operacja nie <xref:System.TimeoutException> zostanie wykonana w ciągu 30 sekund, zostanie zgłoszony.  
  
   
  
## Examples  
 Poniższy przykład tworzy przepływ pracy, który używa `ReadLine` działania, które <xref:System.Activities.Bookmark>tworzy. Przepływ pracy jest uruchamiany, a gdy <xref:System.Activities.Bookmark> zostanie utworzony, a przepływ pracy jest bezczynny, <xref:System.Activities.WorkflowApplication.GetBookmarks%2A> jest wywoływany. Po zakończeniu przepływu pracy następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
What is your name?   
BookmarkName: UserName - OwnerDisplayName: ReadLine  
Steve  
Hello, Steve  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#14](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBookmarks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetBookmarks(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBookmarks (timeout As TimeSpan) As ReadOnlyCollection(Of BookmarkInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Activities::Hosting::BookmarkInfo ^&gt; ^ GetBookmarks(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.GetBookmarks : TimeSpan -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;" Usage="workflowApplication.GetBookmarks timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym ta metoda musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <summary>Zwraca kolekcję zakładek dla wystąpienia przepływu pracy przy użyciu określonego interwału limitu czasu.</summary>
        <returns>Kolekcja zakładek tylko do odczytu dla wystąpienia przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy przepływ pracy, który używa `ReadLine` działania, które <xref:System.Activities.Bookmark>tworzy. Przepływ pracy jest uruchamiany, a gdy <xref:System.Activities.Bookmark> zostanie utworzony, a przepływ pracy jest bezczynny, <xref:System.Activities.WorkflowApplication.GetBookmarks%2A> jest wywoływany. Po zakończeniu przepływu pracy następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
What is your name?   
BookmarkName: UserName - OwnerDisplayName: ReadLine  
Steve  
Hello, Steve  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#14](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wystąpienie przepływu pracy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member GetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetInstance (instanceId, instanceStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identyfikator wystąpienia.</param>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <summary>Pobiera wystąpienie przepływu pracy przy użyciu określonego identyfikatora wystąpienia i magazynu wystąpień.</summary>
        <returns>Pobrane wystąpienie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member GetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetInstance (instanceId, instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identyfikator wystąpienia.</param>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana.</param>
        <summary>Pobiera wystąpienie przepływu pracy przy użyciu określonego identyfikatora wystąpienia, magazynu wystąpień i interwału limitu czasu.</summary>
        <returns>Odwołanie do operacji asynchronicznej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wystąpienie możliwy do uruchomienia przepływu pracy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member GetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetRunnableInstance instanceStore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy</param>
        <summary>Pobiera wystąpienie możliwy do uruchomienia przepływu pracy z określonym magazynem wystąpień.</summary>
        <returns>Wystąpienie możliwy do uruchomienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member GetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetRunnableInstance (instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana.</param>
        <summary>Pobiera wystąpienie możliwy do uruchomienia przepływu pracy z określonym magazynem wystąpień i interwałem limitu czasu.</summary>
        <returns>Wystąpienie możliwy do uruchomienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public override Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Id" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Activities.WorkflowApplication.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera 128-bitowy identyfikator GUID bieżącego wystąpienia aplikacji przepływu pracy.</summary>
        <value>128-bitowy identyfikator GUID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Activities.WorkflowApplication> wystąpienie, a następnie <xref:System.Activities.WorkflowApplication.Id%2A> wyświetla wartość konsoli programu.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#28](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt; Idle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationIdleEventArgs&gt; Idle" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Property Idle As Action(Of WorkflowApplicationIdleEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ Idle { Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Idle : Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Idle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Action`1" /> , która jest wywoływana, gdy bieżące wystąpienie przepływu pracy staje się bezczynna.</summary>
        <value>Akcja, która jest wykonywana, gdy wystąpienie przepływu pracy stanie się bezczynne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu sprawdza, <xref:System.Activities.WorkflowApplicationIdleEventArgs> czy przeszedł <xref:System.Activities.WorkflowApplication.Idle%2A> do procedury obsługi <xref:System.Activities.WorkflowApplication> wystąpienia. W tym przykładzie przepływ pracy, który przejdzie <xref:System.Activities.Bookmark> do bezczynności `EnterGuess`, ma jedną z nazwami, `ReadInt`należącymi do działania o nazwie. Ten przykład kodu jest oparty na [sposobie: Uruchom przepływ pracy](~/docs/framework/windows-workflow-foundation/how-to-run-a-workflow.md), który jest częścią [samouczka &#91;wprowadzenie .NET Framework 4,5&#93;](~/docs/framework/windows-workflow-foundation/getting-started-tutorial.md). <xref:System.Activities.WorkflowApplication.Idle%2A> Jeśli program obsługi w tym kroku jest modyfikowany tak, aby zawierał kod z tego przykładu, wyświetlane są następujące dane wyjściowe.  
  
```Output  
BookmarkName: EnterGuess - OwnerDisplayName: ReadInt  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceStore">
      <MemberSignature Language="C#" Value="public System.Runtime.DurableInstancing.InstanceStore InstanceStore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.DurableInstancing.InstanceStore InstanceStore" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.InstanceStore" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceStore As InstanceStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::DurableInstancing::InstanceStore ^ InstanceStore { System::Runtime::DurableInstancing::InstanceStore ^ get(); void set(System::Runtime::DurableInstancing::InstanceStore ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceStore : System.Runtime.DurableInstancing.InstanceStore with get, set" Usage="System.Activities.WorkflowApplication.InstanceStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.DurableInstancing.InstanceStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który zapewnia dostęp do utrwalonego stanu bieżącego wystąpienia aplikacji przepływu pracy.</summary>
        <value>Magazyn wystąpień.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie obiektu WorkflowApplication, a następnie konfiguruje <xref:System.Activities.WorkflowApplication.InstanceStore%2A> <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>przy użyciu. Ten przykład kodu jest częścią [metody: Utwórz i Uruchom długotrwały przepływ pracy](~/docs/framework/windows-workflow-foundation/how-to-create-and-run-a-long-running-workflow.md), który jest częścią [samouczka &#91;wprowadzenie .NET Framework 4,5&#93;](~/docs/framework/windows-workflow-foundation/getting-started-tutorial.md).  
  
 [!code-csharp[CFX_WorkflowApplicationExample#28](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje wystąpienie przepływu pracy z magazynu wystąpień.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance -&gt; unit" Usage="workflowApplication.Load instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie.</param>
        <summary>Ładuje wystąpienie przepływu pracy z magazynu wystąpienia z określonym wystąpieniem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instanceId As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.Load : Guid -&gt; unit" Usage="workflowApplication.Load instanceId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">Globalnie unikatowy identyfikator 128-bitowy dla wystąpienia przepływu pracy.</param>
        <summary>Ładuje określone wystąpienie przepływu pracy do pamięci z magazynu wystąpień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wywołuje wywołanie <xref:System.Activities.WorkflowApplication.Load%2A> w celu załadowania utrwalonego wystąpienia <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>przepływu pracy z elementu. Ten przykład pochodzi z `LoadAndCompleteInstance` metody w przykładzie utrwalania [aplikacji przepływu pracy](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) .  
  
 [!code-csharp[CFX_WorkflowApplicationExample#27](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap -&gt; unit" Usage="workflowApplication.Load (instance, updateMap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie.</param>
        <param name="updateMap">Mapa aktualizacji.</param>
        <summary>Ładuje wystąpienie przepływu pracy z magazynu wystąpień z określonym wystąpieniem i mapy aktualizacji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instance, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana.</param>
        <summary>Ładuje wystąpienie przepływu pracy z magazynu wystąpień z określonym wystąpieniem i interwałem limitu czasu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (Guid instanceId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(valuetype System.Guid instanceId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Guid,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instanceId As Guid, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(Guid instanceId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : Guid * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instanceId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceId">Globalnie unikatowy identyfikator 128-bitowy dla wystąpienia przepływu pracy.</param>
        <param name="timeout">Interwał, w którym operacja ładowania musi zostać zakończona przed anulowaniem operacji ładowania i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Ładuje określone wystąpienie przepływu pracy do pamięci z magazynu wystąpień przy użyciu określonego interwału limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wywołuje wywołanie <xref:System.Activities.WorkflowApplication.Load%2A> w celu załadowania utrwalonego wystąpienia <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>przepływu pracy z elementu. Ten przykład pochodzi z `LoadAndCompleteInstance` metody w przykładzie utrwalania [aplikacji przepływu pracy](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) .  
  
 [!code-csharp[CFX_WorkflowApplicationExample#27](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instance, updateMap, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie.</param>
        <param name="updateMap">Mapa aktualizacji.</param>
        <param name="timeout">Interwał, w którym operacja rozpoczęcia ładowania musi zostać zakończona, zanim operacja zostanie anulowana.</param>
        <summary>Ładuje wystąpienie przepływu pracy z magazynu wystąpienia z określonym wystąpieniem, mapą aktualizacji i interwałem limitu czasu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje wystąpienie przepływu pracy możliwy do uruchomienia z <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie możliwy do uruchomienia to wystąpienie, dla którego upłynął limit czasu czasomierza lub blokady wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void LoadRunnableInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadRunnableInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.LoadRunnableInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadRunnableInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadRunnableInstance();" />
      <MemberSignature Language="F#" Value="member this.LoadRunnableInstance : unit -&gt; unit" Usage="workflowApplication.LoadRunnableInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ładuje wystąpienie przepływu pracy możliwy do uruchomienia z <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie możliwy do uruchomienia to wystąpienie, dla którego upłynął limit czasu czasomierza lub blokady wystąpienia.  
  
 Domyślnie operacja ładowania musi zakończyć się w ciągu 30 sekund lub w wyniku <xref:System.TimeoutException> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void LoadRunnableInstance (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadRunnableInstance(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.LoadRunnableInstance(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadRunnableInstance (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadRunnableInstance(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.LoadRunnableInstance : TimeSpan -&gt; unit" Usage="workflowApplication.LoadRunnableInstance timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym operacja ładowania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Ładuje wystąpienie przepływu pracy możliwy do uruchomienia z <see cref="P:System.Activities.WorkflowApplication.InstanceStore" /> przy użyciu określonego interwału limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie możliwy do uruchomienia to wystąpienie, dla którego upłynął limit czasu czasomierza lub blokady wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginAssociateKeys">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginAssociateKeys (System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; keys, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginAssociateKeys(class System.Collections.Generic.ICollection`1&lt;class System.Runtime.DurableInstancing.InstanceKey&gt; keys, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginAssociateKeys(System.Collections.Generic.ICollection{System.Runtime.DurableInstancing.InstanceKey},System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnBeginAssociateKeys (keys As ICollection(Of InstanceKey), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginAssociateKeys(System::Collections::Generic::ICollection&lt;System::Runtime::DurableInstancing::InstanceKey ^&gt; ^ keys, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginAssociateKeys : System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginAssociateKeys (keys, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt;" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginPersist">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginPersist (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginPersist(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginPersist(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnBeginPersist (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginPersist(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginPersist : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginPersist (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginResumeBookmark">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginResumeBookmark : System.Activities.Bookmark * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginResumeBookmark (bookmark, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">To be added.</param>
        <param name="value">To be added.</param>
        <param name="timeout">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisassociateKeys">
      <MemberSignature Language="C#" Value="protected internal override void OnDisassociateKeys (System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; keys);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnDisassociateKeys(class System.Collections.Generic.ICollection`1&lt;class System.Runtime.DurableInstancing.InstanceKey&gt; keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnDisassociateKeys(System.Collections.Generic.ICollection{System.Runtime.DurableInstancing.InstanceKey})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnDisassociateKeys (keys As ICollection(Of InstanceKey))" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnDisassociateKeys(System::Collections::Generic::ICollection&lt;System::Runtime::DurableInstancing::InstanceKey ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="override this.OnDisassociateKeys : System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; -&gt; unit" Usage="workflowApplication.OnDisassociateKeys keys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt;" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndAssociateKeys">
      <MemberSignature Language="C#" Value="protected internal override void OnEndAssociateKeys (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnEndAssociateKeys(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndAssociateKeys(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnEndAssociateKeys (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnEndAssociateKeys(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndAssociateKeys : IAsyncResult -&gt; unit" Usage="workflowApplication.OnEndAssociateKeys result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndPersist">
      <MemberSignature Language="C#" Value="protected internal override void OnEndPersist (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnEndPersist(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndPersist(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnEndPersist (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnEndPersist(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndPersist : IAsyncResult -&gt; unit" Usage="workflowApplication.OnEndPersist result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndResumeBookmark">
      <MemberSignature Language="C#" Value="protected internal override System.Activities.BookmarkResumptionResult OnEndResumeBookmark (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance valuetype System.Activities.BookmarkResumptionResult OnEndResumeBookmark(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndResumeBookmark(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnEndResumeBookmark (result As IAsyncResult) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Activities::BookmarkResumptionResult OnEndResumeBookmark(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndResumeBookmark : IAsyncResult -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.OnEndResumeBookmark result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyPaused">
      <MemberSignature Language="C#" Value="protected override void OnNotifyPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnNotifyPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnNotifyPaused" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnNotifyPaused ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnNotifyPaused();" />
      <MemberSignature Language="F#" Value="override this.OnNotifyPaused : unit -&gt; unit" Usage="workflowApplication.OnNotifyPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyUnhandledException">
      <MemberSignature Language="C#" Value="protected override void OnNotifyUnhandledException (Exception exception, System.Activities.Activity exceptionSource, string exceptionSourceInstanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnNotifyUnhandledException(class System.Exception exception, class System.Activities.Activity exceptionSource, string exceptionSourceInstanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnNotifyUnhandledException(System.Exception,System.Activities.Activity,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnNotifyUnhandledException(Exception ^ exception, System::Activities::Activity ^ exceptionSource, System::String ^ exceptionSourceInstanceId);" />
      <MemberSignature Language="F#" Value="override this.OnNotifyUnhandledException : Exception * System.Activities.Activity * string -&gt; unit" Usage="workflowApplication.OnNotifyUnhandledException (exception, exceptionSource, exceptionSourceInstanceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
        <Parameter Name="exceptionSource" Type="System.Activities.Activity" />
        <Parameter Name="exceptionSourceInstanceId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="exception">To be added.</param>
        <param name="exceptionSource">To be added.</param>
        <param name="exceptionSourceInstanceId">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRequestAbort">
      <MemberSignature Language="C#" Value="protected internal override void OnRequestAbort (Exception reason);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRequestAbort(class System.Exception reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnRequestAbort(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRequestAbort (reason As Exception)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRequestAbort(Exception ^ reason);" />
      <MemberSignature Language="F#" Value="override this.OnRequestAbort : Exception -&gt; unit" Usage="workflowApplication.OnRequestAbort reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="reason">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnhandledException">
      <MemberSignature Language="C#" Value="public Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs,System.Activities.UnhandledExceptionAction&gt; OnUnhandledException { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class System.Activities.WorkflowApplicationUnhandledExceptionEventArgs, valuetype System.Activities.UnhandledExceptionAction&gt; OnUnhandledException" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.OnUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Property OnUnhandledException As Func(Of WorkflowApplicationUnhandledExceptionEventArgs, UnhandledExceptionAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ OnUnhandledException { Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ get(); void set(Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OnUnhandledException : Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs, System.Activities.UnhandledExceptionAction&gt; with get, set" Usage="System.Activities.WorkflowApplication.OnUnhandledException" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs,System.Activities.UnhandledExceptionAction&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Func`2" /> obiekt, który jest wywoływany, gdy bieżące wystąpienie przepływu pracy napotka nieobsługiwany wyjątek.</summary>
        <value>Delegat, który jest wywoływany, gdy wystąpienie przepływu pracy napotka nieobsługiwany wyjątek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarówno <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A> , <xref:System.ServiceModel.Activities.Description.WorkflowUnhandledExceptionBehavior> jak i dyktować zachowanie środowiska uruchomieniowego, gdy wyjątek nie jest obsługiwany w przepływie pracy, jednak <xref:System.ServiceModel.Activities.Description.WorkflowUnhandledExceptionBehavior> ma opcję opuszczenia zawieszonego przepływu pracy w magazynie trwałości, chociaż <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A> nie jest to możliwe. Przyczyną tej sytuacji jest to, że działanie w zawieszonym przepływie pracy jest specyficzne dla hosta <xref:System.Activities.WorkflowApplication> i nie jest. Aby zaimplementować tę funkcję przy <xref:System.Activities.WorkflowApplication>użyciu programu, należy <xref:System.Activities.Persistence.PersistenceParticipant> utworzyć niestandardową, która ma takie zachowanie.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy, który zgłasza wyjątek. Wyjątek jest nieobsługiwany przez przepływ pracy i <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A> wywoływany jest program obsługi. <xref:System.Activities.WorkflowApplicationUnhandledExceptionEventArgs> Są one sprawdzane w celu podania informacji o wyjątku, a przepływ pracy zostaje zakończony.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Persist">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Utrwala wystąpienie przepływu pracy w magazynie wystąpień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="public void Persist ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Persist() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Persist" />
      <MemberSignature Language="VB.NET" Value="Public Sub Persist ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Persist();" />
      <MemberSignature Language="F#" Value="member this.Persist : unit -&gt; unit" Usage="workflowApplication.Persist " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Utrwala wystąpienie przepływu pracy w magazynie wystąpień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja utrwalania nie <xref:System.TimeoutException> zostanie ukończona w ciągu 30 sekund, zostanie zgłoszony.  
  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Activities.WorkflowApplication.Persist%2A> , aby zachować wystąpienie przepływu pracy przed uruchomieniem przepływu pracy. Ten przykład jest częścią `StartAndUnloadInstance` metody w przykładzie utrwalania [aplikacji przepływu pracy](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) .  
  
 [!code-csharp[CFX_WorkflowApplicationExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="public void Persist (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Persist(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Persist(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Persist (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Persist(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Persist : TimeSpan -&gt; unit" Usage="workflowApplication.Persist timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym operacja utrwalania musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <summary>Utrwala wystąpienie przepływu pracy w magazynie wystąpień przy użyciu określonego interwału limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Activities.WorkflowApplication.Persist%2A> , aby zachować wystąpienie przepływu pracy przed uruchomieniem przepływu pracy. Ten przykład pochodzi z `StartAndUnloadInstance` metody w przykładzie utrwalania [aplikacji przepływu pracy](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) .  
  
 [!code-csharp[CFX_WorkflowApplicationExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistableIdle">
      <MemberSignature Language="C#" Value="public Func&lt;System.Activities.WorkflowApplicationIdleEventArgs,System.Activities.PersistableIdleAction&gt; PersistableIdle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class System.Activities.WorkflowApplicationIdleEventArgs, valuetype System.Activities.PersistableIdleAction&gt; PersistableIdle" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.PersistableIdle" />
      <MemberSignature Language="VB.NET" Value="Public Property PersistableIdle As Func(Of WorkflowApplicationIdleEventArgs, PersistableIdleAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ PersistableIdle { Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ get(); void set(Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PersistableIdle : Func&lt;System.Activities.WorkflowApplicationIdleEventArgs, System.Activities.PersistableIdleAction&gt; with get, set" Usage="System.Activities.WorkflowApplication.PersistableIdle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Activities.WorkflowApplicationIdleEventArgs,System.Activities.PersistableIdleAction&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia delegata, który jest wywoływany, gdy bieżące wystąpienie przepływu pracy jest w stanie bezczynności i może zostać utrwalone.</summary>
        <value>Delegat, który jest wywoływany, gdy bieżące wystąpienie przepływu pracy jest bezczynny i może być utrwalony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy przepływ pracy stanie się bezczynny i może być <xref:System.Activities.WorkflowApplication.Idle%2A> utrwalony, zarówno, jak i <xref:System.Activities.WorkflowApplication.PersistableIdle%2A> są wywoływane, w tej kolejności. <xref:System.Activities.PersistableIdleAction.None> <xref:System.Activities.PersistableIdleAction.Persist> <xref:System.Activities.PersistableIdleAction.Unload>Procedura obsługi zwraca jedną <xref:System.Activities.PersistableIdleAction> z wartości wyliczenia,, lub. <xref:System.Activities.WorkflowApplication.PersistableIdle%2A>  
  
   
  
## Examples  
 Poniższy przykład obsługuje <xref:System.Activities.WorkflowApplication.PersistableIdle%2A> procedurę obsługi i powoduje, że środowisko uruchomieniowe w celu utrwalenia i zwolnienia przepływu pracy.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#26](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeBookmark">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje zainicjowanie operacji w celu wznowienia zakładki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (System.Activities.Bookmark bookmark, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(class System.Activities.Bookmark bookmark, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.Activities.Bookmark,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : System.Activities.Bookmark * obj -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmark, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Zakładka, która ma zostać wznowiona.</param>
        <param name="value">Obiekt przeszedł jako parametr do metody, która jest wywoływana, gdy zakładka zostanie wznowiona.</param>
        <summary>Powoduje zainicjowanie operacji w celu wznowienia określonej zakładki przy użyciu określonej wartości. Zakładka, która ma zostać wznowiona, została wcześniej utworzona przez działanie w ramach wystąpienia przepływu pracy.</summary>
        <returns>Wynik operacji wznowienia zakładki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik zakładki wskazuje, czy operacja wznawiania zakończyła się powodzeniem, czy niepowodzeniem.  
  
   
  
## Examples  
 Poniższy przykład tworzy przepływ pracy, który używa `ReadLine` działania, które <xref:System.Activities.Bookmark>tworzy. Przepływ pracy jest uruchamiany, a po <xref:System.Activities.Bookmark> utworzeniu, a przepływ pracy jest bezczynny, dane wejściowe użytkownika są zbierane i Zakładka zostaje wznowiona.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#24](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (string bookmarkName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(string bookmarkName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResumeBookmark (bookmarkName As String, value As Object) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::String ^ bookmarkName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : string * obj -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmarkName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Nazwa zakładki, która ma zostać wznowiona.</param>
        <param name="value">Obiekt przeszedł jako parametr do metody, która jest wywoływana, gdy zakładka zostanie wznowiona.</param>
        <summary>Powoduje zainicjowanie operacji w celu wznowienia zakładki o określonej nazwie przy użyciu określonej wartości. Zakładka, która ma zostać wznowiona, została wcześniej utworzona przez działanie w ramach wystąpienia przepływu pracy.</summary>
        <returns>Wynik operacji wznowienia zakładki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik zakładki wskazuje, czy operacja wznawiania zakończyła się powodzeniem, czy niepowodzeniem.  
  
   
  
## Examples  
 Poniższy przykład tworzy przepływ pracy, który używa `ReadLine` działania, które <xref:System.Activities.Bookmark>tworzy. Przepływ pracy jest uruchamiany, a po <xref:System.Activities.Bookmark> utworzeniu, a przepływ pracy jest bezczynny, dane wejściowe użytkownika są zbierane i Zakładka zostaje wznowiona.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : System.Activities.Bookmark * obj * TimeSpan -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmark, value, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="bookmark">Zakładka, która ma zostać wznowiona.</param>
        <param name="value">Obiekt przeszedł jako parametr do metody, która jest wywoływana, gdy zakładka zostanie wznowiona.</param>
        <param name="timeout">Przedział czasu, w którym należy wznowić zakładkę.</param>
        <summary>Powoduje zainicjowanie operacji wznawiania określonej zakładki przy użyciu określonej wartości i interwału limitu czasu. Zakładka, która ma zostać wznowiona, została wcześniej utworzona przez działanie w ramach wystąpienia przepływu pracy.</summary>
        <returns>Wynik operacji wznowienia zakładki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik zakładki wskazuje, czy operacja wznawiania zakończyła się powodzeniem, czy niepowodzeniem.  
  
   
  
## Examples  
 Poniższy przykład tworzy przepływ pracy, który używa `ReadLine` działania, które <xref:System.Activities.Bookmark>tworzy. Przepływ pracy jest uruchamiany, a po <xref:System.Activities.Bookmark> utworzeniu, a przepływ pracy jest bezczynny, dane wejściowe użytkownika są zbierane i Zakładka zostaje wznowiona.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#25](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (string bookmarkName, object value, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(string bookmarkName, object value, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.String,System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResumeBookmark (bookmarkName As String, value As Object, timeout As TimeSpan) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : string * obj * TimeSpan -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmarkName, value, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Nazwa zakładki, która ma zostać wznowiona.</param>
        <param name="value">Obiekt przeszedł jako parametr do metody, która jest wywoływana, gdy zakładka zostanie wznowiona.</param>
        <param name="timeout">Przedział czasu, w którym należy wznowić zakładkę.</param>
        <summary>Powoduje zainicjowanie operacji w celu wznowienia zakładki o określonej nazwie przy użyciu określonej wartości i interwału limitu czasu. Zakładka, która ma zostać wznowiona, została wcześniej utworzona przez działanie w ramach wystąpienia przepływu pracy.</summary>
        <returns>Wynik operacji wznowienia zakładki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik zakładki wskazuje, czy operacja wznawiania zakończyła się powodzeniem, czy niepowodzeniem.  
  
   
  
## Examples  
 Poniższy przykład tworzy przepływ pracy, który używa `ReadLine` działania, które <xref:System.Activities.Bookmark>tworzy. Przepływ pracy jest uruchamiany, a po <xref:System.Activities.Bookmark> utworzeniu, a przepływ pracy jest bezczynny, dane wejściowe użytkownika są zbierane i Zakładka zostaje wznowiona.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna lub wznawia wykonywanie wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby zainicjować wykonywanie nowo utworzonego wystąpienia przepływu pracy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Run" />
      <MemberSignature Language="VB.NET" Value="Public Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; unit" Usage="workflowApplication.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna lub wznawia wykonywanie wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby zainicjować wykonywanie nowo utworzonego wystąpienia przepływu pracy.  
  
 Jeśli operacja Run nie <xref:System.TimeoutException> zostanie wykonana w ciągu 30 sekund, zostanie zgłoszony.  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po zakończeniu przepływu pracy następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public void Run (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Run(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Run(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Run (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Run(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Run : TimeSpan -&gt; unit" Usage="workflowApplication.Run timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Wywołaj tę metodę, aby zainicjować wykonywanie nowo utworzonego wystąpienia przepływu pracy.  
  
Interwał, w którym operacja uruchamiania musi zostać zakończona, zanim operacja zostanie anulowana i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Rozpoczyna lub wznawia wykonywanie wystąpienia przepływu pracy przy użyciu określonego interwału limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Activities.WorkflowInvoker.Invoke%2A>w przeciwieństwie do tego metoda spowoduje przekroczenie limitu czasu, gdy przepływ pracy nie zostanie uruchomiony w określonym czasie, a nie musi zostać ukończony w określonym czasie. Przyczyną tego jest to, że <xref:System.Activities.WorkflowInvoker.Invoke%2A> wykonuje przepływ pracy synchronicznie (blokując wątek hosta), podczas gdy <xref:System.Activities.WorkflowApplication.Run%2A> wykonuje asynchronicznie, blokując tylko wątek hosta przez czas, w którym przepływ pracy ma zostać uruchomiony.  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po zakończeniu przepływu pracy następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsInstanceKeys">
      <MemberSignature Language="C#" Value="protected internal override bool SupportsInstanceKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsInstanceKeys" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.SupportsInstanceKeys" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property SupportsInstanceKeys As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool SupportsInstanceKeys { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsInstanceKeys : bool" Usage="System.Activities.WorkflowApplication.SupportsInstanceKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Terminate">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy wystąpienie przepływu pracy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (Exception reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(class System.Exception reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(Exception ^ reason);" />
      <MemberSignature Language="F#" Value="member this.Terminate : Exception -&gt; unit" Usage="workflowApplication.Terminate reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="reason">Przyczyna zakończenia wystąpienia przepływu pracy.</param>
        <summary>Kończy wystąpienie przepływu pracy przy użyciu określonego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda planuje zakończenie wystąpienia przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu zakończenia, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> dojścia.  
  
 Domyślnie <xref:System.Activities.WorkflowApplication.Terminate%2A> operacja musi zakończyć się w ciągu 30 sekund <xref:System.TimeoutException> lub jest zgłaszany.  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po uruchomieniu <xref:System.Activities.WorkflowApplication.Terminate%2A> przepływu pracy jest wywoływana. Po zakończeniu przepływu pracy następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow e6b33409-f010-49f1-82ce-56f8baabe5e5 Terminated.  
Exception: System.ApplicationException  
Terminating the workflow.   
Workflow e6b33409-f010-49f1-82ce-56f8baabe5e5 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#16](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ reason);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowApplication.Terminate reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="reason">Przyczyna zakończenia wystąpienia przepływu pracy.</param>
        <summary>Kończy wystąpienie przepływu pracy przy użyciu określonego komunikatu o błędzie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda planuje zakończenie wystąpienia przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu zakończenia, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> dojścia.  
  
 Domyślnie <xref:System.Activities.WorkflowApplication.Terminate%2A> operacja musi zakończyć się w ciągu 30 sekund <xref:System.TimeoutException> lub jest zgłaszany.  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po uruchomieniu <xref:System.Activities.WorkflowApplication.Terminate%2A> przepływu pracy jest wywoływana. Po zakończeniu przepływu pracy następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow f87c6f91-4fe4-40b9-b7cb-4f1bd071bf84 Terminated.   
Exception: System.Activities.WorkflowApplicationTerminatedException  
Terminating the workflow.   
Workflow f87c6f91-4fe4-40b9-b7cb-4f1bd071bf84 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#18](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (Exception reason, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(class System.Exception reason, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.Exception,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As Exception, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(Exception ^ reason, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Terminate : Exception * TimeSpan -&gt; unit" Usage="workflowApplication.Terminate (reason, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="reason">Przyczyna zakończenia wystąpienia przepływu pracy.</param>
        <param name="timeout">Interwał, w którym <see cref="M:System.Activities.WorkflowApplication.Terminate(System.Exception,System.TimeSpan)" /> operacja musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <summary>Kończy wystąpienie przepływu pracy przy użyciu określonego wyjątku i limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda planuje zakończenie przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu zakończenia, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> dojścia.  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po uruchomieniu <xref:System.Activities.WorkflowApplication.Terminate%2A> przepływu pracy jest wywoływana. Po zakończeniu przepływu pracy następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow de28efe5-9057-472b-8d95-899c249893c5 Terminated.  
Exception: System.ApplicationException  
Terminating the workflow.   
Workflow de28efe5-9057-472b-8d95-899c249893c5 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#17](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string reason, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string reason, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As String, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ reason, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string * TimeSpan -&gt; unit" Usage="workflowApplication.Terminate (reason, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="reason">Przyczyna zakończenia wystąpienia przepływu pracy.</param>
        <param name="timeout">Interwał, w którym <see cref="M:System.Activities.WorkflowApplication.Terminate(System.String,System.TimeSpan)" /> operacja musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <summary>Kończy wystąpienie przepływu pracy przy użyciu określonego komunikatu o błędzie i limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda planuje zakończenie wystąpienia przepływu pracy. Aby otrzymywać powiadomienia po zakończeniu zakończenia, użyj <xref:System.Activities.WorkflowApplication.Completed%2A> dojścia.  
  
   
  
## Examples  
 Poniższy przykład umożliwia hostowanie przepływu pracy <xref:System.Activities.WorkflowApplication>przy użyciu polecenia. Wystąpienie jest skonstruowane przy użyciu określonej definicji przepływu pracy, są obsługiwane zdarzenia cyklu życia przepływu pracy, a przepływ pracy jest wywoływany z <xref:System.Activities.WorkflowApplication.Run%2A>wywołaniem. <xref:System.Activities.WorkflowApplication> Po uruchomieniu <xref:System.Activities.WorkflowApplication.Terminate%2A> przepływu pracy jest wywoływana. Po zakończeniu przepływu pracy następujące dane wyjściowe są wyświetlane w konsoli programu.  
  
```Output  
Starting the workflow.   
Workflow 2897d2ef-377e-4224-ae93-5c19b38f487c Terminated.   
Exception: System.Activities.WorkflowApplicationTerminatedException  
Terminating the workflow.   
Workflow 2897d2ef-377e-4224-ae93-5c19b38f487c unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#19](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unload">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Utrzymuje i zwalnia wystąpienie przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie operacja zwalniania musi zakończyć się w ciągu 30 sekund lub w <xref:System.TimeoutException> wyniku.  
  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowApplication.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Utrzymuje i zwalnia wystąpienie przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie operacja zwalniania musi zakończyć się w ciągu 30 sekund lub w <xref:System.TimeoutException> wyniku.  
  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
   
  
## Examples  
 Poniższy przykład kodu jest częścią przykładu [działania NoPersistScope](~/docs/framework/windows-workflow-foundation/samples/nopersistscope-activity.md) . W tym przykładzie przepływ pracy jest bezczynny, a aplikacja hosta oczekuje na dane wejściowe użytkownika. Jeśli użytkownik zdecyduje się na zwolnienie, <xref:System.Activities.WorkflowApplication.Unload%2A> jest wywoływana. Jeśli to się powiedzie, przepływ pracy zostanie utrwalony i zwolniony z pamięci.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Unload(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Unload : TimeSpan -&gt; unit" Usage="workflowApplication.Unload timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym operacja zwalniania musi zostać zakończona, zanim operacja zostanie anulowana <see cref="T:System.TimeoutException" /> i zostanie zgłoszony.</param>
        <summary>Utrzymuje i zwalnia wystąpienie przepływu pracy przy użyciu określonego interwału limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wystąpienie przepływu pracy zostało wcześniej załadowane z trwałości, to ten <xref:System.Runtime.DurableInstancing.InstanceStore> sam użyty do załadowania przepływu pracy jest używany na potrzeby trwałości. Jeśli przepływ pracy został utworzony i nie został jeszcze utrwalony, <xref:System.Activities.WorkflowApplication.InstanceStore%2A> należy go skonfigurować przed wywołaniem tej metody lub w przeciwnym razie jest zgłaszany w <xref:System.InvalidOperationException> przypadku wywołania tej metody.  
  
   
  
## Examples  
 Poniższy przykład kodu jest częścią przykładu [działania NoPersistScope](~/docs/framework/windows-workflow-foundation/samples/nopersistscope-activity.md) . W tym przykładzie przepływ pracy jest bezczynny, a aplikacja hosta oczekuje na dane wejściowe użytkownika. Jeśli użytkownik zdecyduje się na zwolnienie, <xref:System.Activities.WorkflowApplication.Unload%2A> jest wywoływana. Jeśli to się powiedzie, przepływ pracy zostanie utrwalony i zwolniony z pamięci.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationEventArgs&gt; Unloaded { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationEventArgs&gt; Unloaded" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Property Unloaded As Action(Of WorkflowApplicationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ Unloaded { Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Unloaded : Action&lt;System.Activities.WorkflowApplicationEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Unloaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Action`1" /> , która jest wywoływana, gdy bieżący przepływ pracy zostanie zwolniony.</summary>
        <value>Akcja, która jest wywoływana, gdy wystąpienie przepływu pracy zostanie zwolnione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład <xref:System.Activities.WorkflowApplicationEventArgs> kodu sprawdza, czy przekazano <xref:System.Activities.WorkflowApplication.Unloaded%2A> do procedury obsługi <xref:System.Activities.WorkflowApplication> wystąpienia i wyświetla <xref:System.Activities.WorkflowApplicationEventArgs.InstanceId%2A> przepływ pracy, który został zwolniony.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#3](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

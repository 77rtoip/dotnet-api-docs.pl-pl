<Type Name="RuntimeArgument" FullName="System.Activities.RuntimeArgument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="52643e7408b63e1d9d083848549c03d168ec218b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36648620" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RuntimeArgument : System.Activities.LocationReference" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RuntimeArgument extends System.Activities.LocationReference" />
  <TypeSignature Language="DocId" Value="T:System.Activities.RuntimeArgument" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RuntimeArgument&#xA;Inherits LocationReference" />
  <TypeSignature Language="C++ CLI" Value="public ref class RuntimeArgument sealed : System::Activities::LocationReference" />
  <TypeSignature Language="F#" Value="type RuntimeArgument = class&#xA;    inherit LocationReference" />
  <AssemblyInfo>
    <AssemblyName>System.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Activities.LocationReference</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Opisuje właściwości argumentu działania do środowiska wykonawczego.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Activities.RuntimeArgument" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RuntimeArgument (string name, Type argumentType, System.Activities.ArgumentDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type argumentType, valuetype System.Activities.ArgumentDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.RuntimeArgument.#ctor(System.String,System.Type,System.Activities.ArgumentDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, argumentType As Type, direction As ArgumentDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RuntimeArgument(System::String ^ name, Type ^ argumentType, System::Activities::ArgumentDirection direction);" />
      <MemberSignature Language="F#" Value="new System.Activities.RuntimeArgument : string * Type * System.Activities.ArgumentDirection -&gt; System.Activities.RuntimeArgument" Usage="new System.Activities.RuntimeArgument (name, argumentType, direction)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="argumentType" Type="System.Type" />
        <Parameter Name="direction" Type="System.Activities.ArgumentDirection" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <param name="argumentType">Typ <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <param name="direction">Kierunek przepływu danych za pomocą argumentu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Activities.RuntimeArgument" /> przy użyciu nazwy, typu danych i kierunek argumentu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RuntimeArgument (string name, Type argumentType, System.Activities.ArgumentDirection direction, bool isRequired);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type argumentType, valuetype System.Activities.ArgumentDirection direction, bool isRequired) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.RuntimeArgument.#ctor(System.String,System.Type,System.Activities.ArgumentDirection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, argumentType As Type, direction As ArgumentDirection, isRequired As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RuntimeArgument(System::String ^ name, Type ^ argumentType, System::Activities::ArgumentDirection direction, bool isRequired);" />
      <MemberSignature Language="F#" Value="new System.Activities.RuntimeArgument : string * Type * System.Activities.ArgumentDirection * bool -&gt; System.Activities.RuntimeArgument" Usage="new System.Activities.RuntimeArgument (name, argumentType, direction, isRequired)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="argumentType" Type="System.Type" />
        <Parameter Name="direction" Type="System.Activities.ArgumentDirection" />
        <Parameter Name="isRequired" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <param name="argumentType">Typ danych miary <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <param name="direction">Kierunek przepływu danych za pomocą argumentu.</param>
        <param name="isRequired">
          <see langword="true" /> Aby wskazać, że <see cref="T:System.Activities.RuntimeArgument" /> jest wymagane może być powiązane z wartością; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Activities.RuntimeArgument" /> przy użyciu nazwę, typ danych argumentu kierunku i wartość wskazującą, czy <see cref="T:System.Activities.RuntimeArgument" /> musi być powiązana z wartością.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RuntimeArgument (string name, Type argumentType, System.Activities.ArgumentDirection direction, System.Collections.Generic.List&lt;string&gt; overloadGroupNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type argumentType, valuetype System.Activities.ArgumentDirection direction, class System.Collections.Generic.List`1&lt;string&gt; overloadGroupNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.RuntimeArgument.#ctor(System.String,System.Type,System.Activities.ArgumentDirection,System.Collections.Generic.List{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, argumentType As Type, direction As ArgumentDirection, overloadGroupNames As List(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RuntimeArgument(System::String ^ name, Type ^ argumentType, System::Activities::ArgumentDirection direction, System::Collections::Generic::List&lt;System::String ^&gt; ^ overloadGroupNames);" />
      <MemberSignature Language="F#" Value="new System.Activities.RuntimeArgument : string * Type * System.Activities.ArgumentDirection * System.Collections.Generic.List&lt;string&gt; -&gt; System.Activities.RuntimeArgument" Usage="new System.Activities.RuntimeArgument (name, argumentType, direction, overloadGroupNames)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="argumentType" Type="System.Type" />
        <Parameter Name="direction" Type="System.Activities.ArgumentDirection" />
        <Parameter Name="overloadGroupNames" Type="System.Collections.Generic.List&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <param name="argumentType">Typ danych miary <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <param name="direction">Kierunek przepływu danych za pomocą argumentu.</param>
        <param name="overloadGroupNames">Grupy metod przeciążonych, które są stosowane do tego <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Activities.RuntimeArgument" /> przy użyciu nazwy, typu danych kierunek argumentu i określenie listy nazw grupy przeciążenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RuntimeArgument (string name, Type argumentType, System.Activities.ArgumentDirection direction, bool isRequired, System.Collections.Generic.List&lt;string&gt; overloadGroupNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type argumentType, valuetype System.Activities.ArgumentDirection direction, bool isRequired, class System.Collections.Generic.List`1&lt;string&gt; overloadGroupNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.RuntimeArgument.#ctor(System.String,System.Type,System.Activities.ArgumentDirection,System.Boolean,System.Collections.Generic.List{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, argumentType As Type, direction As ArgumentDirection, isRequired As Boolean, overloadGroupNames As List(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RuntimeArgument(System::String ^ name, Type ^ argumentType, System::Activities::ArgumentDirection direction, bool isRequired, System::Collections::Generic::List&lt;System::String ^&gt; ^ overloadGroupNames);" />
      <MemberSignature Language="F#" Value="new System.Activities.RuntimeArgument : string * Type * System.Activities.ArgumentDirection * bool * System.Collections.Generic.List&lt;string&gt; -&gt; System.Activities.RuntimeArgument" Usage="new System.Activities.RuntimeArgument (name, argumentType, direction, isRequired, overloadGroupNames)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="argumentType" Type="System.Type" />
        <Parameter Name="direction" Type="System.Activities.ArgumentDirection" />
        <Parameter Name="isRequired" Type="System.Boolean" />
        <Parameter Name="overloadGroupNames" Type="System.Collections.Generic.List&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <param name="argumentType">Typ danych miary <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <param name="direction">Kierunek przepływu danych za pomocą argumentu.</param>
        <param name="isRequired">
          <see langword="true" /> Aby wskazać, że <see cref="T:System.Activities.RuntimeArgument" /> jest wymagane może być powiązane z wartością; w przeciwnym razie <see langword="false" />.</param>
        <param name="overloadGroupNames">Nazwy grup przeciążenia, które są stosowane do tego <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Activities.RuntimeArgument" /> klasy o nazwie, typ danych, kierunek, czy <see cref="T:System.Activities.RuntimeArgument" /> należy powiązać wartość i określenie listy nazw grupy przeciążenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wymagane argumenty, które są niepowiązane powodują błędy sprawdzania poprawności, które są wyświetlane w czasie projektowania.  
  
 <xref:System.Activities.RuntimeArgument.IsRequired%2A?displayProperty=nameWithType> Ustawiono `true` Jeśli <xref:System.Activities.RequiredArgumentAttribute?displayProperty=nameWithType> jest stosowany do argumentu.  
  
 Grupy metod przeciążonych można ustawić dla argumentów za pośrednictwem <xref:System.Activities.OverloadGroupAttribute>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Direction">
      <MemberSignature Language="C#" Value="public System.Activities.ArgumentDirection Direction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Activities.ArgumentDirection Direction" />
      <MemberSignature Language="DocId" Value="P:System.Activities.RuntimeArgument.Direction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Direction As ArgumentDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::ArgumentDirection Direction { System::Activities::ArgumentDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.Direction : System.Activities.ArgumentDirection" Usage="System.Activities.RuntimeArgument.Direction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.ArgumentDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kierunek przepływu danych za pośrednictwem to <see cref="T:System.Activities.RuntimeArgument" />.</summary>
        <value>Kierunek przepływu danych za pomocą argumentu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public object Get (System.Activities.ActivityContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Get(class System.Activities.ActivityContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.RuntimeArgument.Get(System.Activities.ActivityContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Get (context As ActivityContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Get(System::Activities::ActivityContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.Get : System.Activities.ActivityContext -&gt; obj" Usage="runtimeArgument.Get context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Activities.ActivityContext" />
      </Parameters>
      <Docs>
        <param name="context">Bieżący kontekst działania.</param>
        <summary>Pobiera wartość <see cref="T:System.Activities.RuntimeArgument" /> przy użyciu kontekstu określonego działania.</summary>
        <returns>Wartość <see cref="T:System.Activities.RuntimeArgument" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T Get&lt;T&gt; (System.Activities.ActivityContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T Get&lt;T&gt;(class System.Activities.ActivityContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.RuntimeArgument.Get``1(System.Activities.ActivityContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Get(Of T) (context As ActivityContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; T Get(System::Activities::ActivityContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.Get : System.Activities.ActivityContext -&gt; 'T" Usage="runtimeArgument.Get context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.Activities.ActivityContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zwracanej wartości.</typeparam>
        <param name="context">Bieżący kontekst działania.</param>
        <summary>Pobiera wartość jednoznacznie <see cref="T:System.Activities.RuntimeArgument" /> przy użyciu kontekstu określonego działania.</summary>
        <returns>Wartość <see cref="T:System.Activities.RuntimeArgument" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLocation">
      <MemberSignature Language="C#" Value="public override System.Activities.Location GetLocation (System.Activities.ActivityContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Activities.Location GetLocation(class System.Activities.ActivityContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.RuntimeArgument.GetLocation(System.Activities.ActivityContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetLocation (context As ActivityContext) As Location" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Activities::Location ^ GetLocation(System::Activities::ActivityContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetLocation : System.Activities.ActivityContext -&gt; System.Activities.Location" Usage="runtimeArgument.GetLocation context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Location</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Activities.ActivityContext" />
      </Parameters>
      <Docs>
        <param name="context">Lokalizacja argumentu.</param>
        <summary>Zwraca <see cref="T:System.Activities.Location" /> dla tego <see cref="T:System.Activities.RuntimeArgument" />.</summary>
        <returns>Lokalizacja <see cref="T:System.Activities.RuntimeArgument" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequired">
      <MemberSignature Language="C#" Value="public bool IsRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequired" />
      <MemberSignature Language="DocId" Value="P:System.Activities.RuntimeArgument.IsRequired" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequired As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequired { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequired : bool" Usage="System.Activities.RuntimeArgument.IsRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Activities.RuntimeArgument" /> musi być powiązana z wartością.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Activities.RuntimeArgument" /> musi być powiązana z wartością; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli argument jest wymagana i nie jest powiązany z wartością <xref:System.Activities.ValidationException> jest generowany, gdy działanie zawierającego jest gotowy do wykonywania, o ile nie są używane grupy metod przeciążonych i liczbą wymaganych argumentów: grupa metod przeciążonych są powiązane. Aby uzyskać więcej informacji, zobacz <xref:System.Activities.RuntimeArgument.OverloadGroupNames%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameCore">
      <MemberSignature Language="C#" Value="protected override string NameCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NameCore" />
      <MemberSignature Language="DocId" Value="P:System.Activities.RuntimeArgument.NameCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property NameCore As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::String ^ NameCore { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameCore : string" Usage="System.Activities.RuntimeArgument.NameCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OverloadGroupNames">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; OverloadGroupNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; OverloadGroupNames" />
      <MemberSignature Language="DocId" Value="P:System.Activities.RuntimeArgument.OverloadGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverloadGroupNames As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ OverloadGroupNames { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OverloadGroupNames : System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="System.Activities.RuntimeArgument.OverloadGroupNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę przeciążenia grup tego <see cref="T:System.Activities.RuntimeArgument" /> należy.</summary>
        <value>Lista nazw grup przeciążenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Argumenty mogą być zgrupowane razem do utworzenia grupy metod przeciążonych prawidłowe. <xref:System.Activities.RuntimeArgument.OverloadGroupNames%2A> identyfikuje grupy metod przeciążonych, do których należy ten argument. Grupa metod przeciążonych nie może być podzbiór lub równoważne zbiór innej grupy przeciążenia. Jedynym wyjątkiem od tej reguły jest podzbiór, który zawiera tylko argumenty, gdzie <xref:System.Activities.RuntimeArgument.IsRequired%2A> jest `false`. Grupy metod przeciążonych mogą nakładać się na, ale jeśli przecięciu grupy zawiera wszystkie wymagane argumenty jednej lub obu grup metod przeciążonych, występuje błąd.  
  
 Grupa metod przeciążonych jest uznawany za granica, jeśli wszystkie <xref:System.Activities.RuntimeArgument.IsRequired%2A> argumentów w grupie są powiązane. Jeśli grupa ma wartość zero <xref:System.Activities.RuntimeArgument.IsRequired%2A> argumentów i co najmniej jednego argumentu powiązany, a następnie grupy jest uznawany za powiązane z. Jest to błąd, jeśli żadna z grup są powiązane, chyba że nie ma jedną grupę metod przeciążonych <xref:System.Activities.RuntimeArgument.IsRequired%2A> argumenty w nim. Powiązanie <xref:System.Activities.RuntimeArgument.IsRequired%2A> argumenty z więcej niż jedną grupę metod przeciążonych nie jest dozwolone. Występuje błąd ma więcej niż jedną grupę metod przeciążonych powiązana, który jest, wszystkie wymagane argumenty w jedna grupa metod przeciążonych są powiązane i wszystkich argumentów w innej grupie przeciążenia jest także powiązany.  
  
 Wszelkie naruszenia minionego reguły powoduje <xref:System.Activities.ValidationException> jest generowany, gdy działanie zawierającego jest gotowa do wykonania.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Activities.OverloadGroupAttribute>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public void Set (System.Activities.ActivityContext context, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Set(class System.Activities.ActivityContext context, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.RuntimeArgument.Set(System.Activities.ActivityContext,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Set (context As ActivityContext, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Set(System::Activities::ActivityContext ^ context, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Set : System.Activities.ActivityContext * obj -&gt; unit" Usage="runtimeArgument.Set (context, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Activities.ActivityContext" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">Bieżący kontekst działania.</param>
        <param name="value">Nowa wartość <see cref="T:System.Activities.RuntimeArgument" />.</param>
        <summary>Ustawia wartość <see cref="T:System.Activities.RuntimeArgument" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeCore">
      <MemberSignature Language="C#" Value="protected override Type TypeCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TypeCore" />
      <MemberSignature Language="DocId" Value="P:System.Activities.RuntimeArgument.TypeCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property TypeCore As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Type ^ TypeCore { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeCore : Type" Usage="System.Activities.RuntimeArgument.TypeCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
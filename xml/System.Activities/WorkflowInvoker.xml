<Type Name="WorkflowInvoker" FullName="System.Activities.WorkflowInvoker">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d657d47debe88cddaa6631a275d224726f673e73" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69343403" /></Metadata><TypeSignature Language="C#" Value="public sealed class WorkflowInvoker" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInvoker extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Activities.WorkflowInvoker" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInvoker" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInvoker sealed" />
  <TypeSignature Language="F#" Value="type WorkflowInvoker = class" />
  <AssemblyInfo>
    <AssemblyName>System.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia sposób wywoływania przepływu pracy tak, jakby był wywołaniem metody.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activities.WorkflowInvoker>zawiera zarówno metody wystąpienia, jak i statyczne do wywoływania przepływów pracy synchronicznie i metody wystąpień do wywoływania przepływów pracy asynchronicznie.  
  
 <xref:System.Activities.WorkflowInvoker>nie zezwala na kontrolowanie wystąpienia, takie jak utrwalanie, zwalnianie lub wznawianie zakładek. Jeśli jest wymagana kontrola wystąpienia, użyj <xref:System.Activities.WorkflowApplication> zamiast niej.  
  
 Aby wykonać przepływy pracy synchronicznie bez kontroli wystąpienia, wywołaj <xref:System.Activities.WorkflowInvoker.Invoke%2A> metodę. Aby wykonać przepływ pracy asynchronicznie bez kontroli wystąpienia, użyj <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A> par <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> metod <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> i lub metody.  
  
   
  
## Examples  
 Poniższy przykład synchronicznie wywołuje przepływ pracy składający się z pojedynczego <xref:System.Activities.Statements.WriteLine> działania przy <xref:System.Activities.WorkflowInvoker>użyciu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowInvoker (System.Activities.Activity workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflow As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowInvoker(System::Activities::Activity ^ workflow);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowInvoker : System.Activities.Activity -&gt; System.Activities.WorkflowInvoker" Usage="new System.Activities.WorkflowInvoker workflow" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflow">Definicja przepływu pracy, która ma zostać wywołana przez to wystąpienie <see cref="T:System.Activities.WorkflowInvoker" /> klasy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Activities.WorkflowInvoker" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activities.WorkflowInvoker>zawiera zarówno metody wystąpienia, jak i statyczne do wywoływania przepływów pracy synchronicznie i metody wystąpień do wywoływania przepływów pracy asynchronicznie.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego <xref:System.Activities.Statements.WriteLine> działania.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje przepływ pracy asynchronicznie przy <see cref="T:System.IAsyncResult" /> użyciu wzorca projektowego asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu przepływu pracy.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie przy użyciu <see cref="T:System.AsyncCallback" /> określonego i dostarczonego przez użytkownika stanu.</summary>
        <returns>Odwołanie do asynchronicznej operacji Invoke.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia o ukończeniu przepływu pracy i pobieraniu parametrów wyjściowych przepływu pracy, wywołaj <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> `callback` metodę. Jeśli <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana przed ukończeniem przepływu pracy, zostaje ona zablokowana do momentu zakończenia przepływu pracy. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Są one pobierane przez wywołanie <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Gdy wywołanie <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> zwrotne zwraca, każdy argument danych wyjściowych jest zwracany w słowniku wyników, który jest poprzedzony przez nazwę argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (inputs As IDictionary(Of String, Object), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (inputs, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu przepływu pracy.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie przy użyciu <see cref="T:System.Collections.Generic.IDictionary`2" /> określonych <see cref="T:System.AsyncCallback" />parametrów wejściowych, i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do asynchronicznej operacji Invoke.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia o ukończeniu przepływu pracy i pobieraniu parametrów wyjściowych przepływu pracy, wywołaj <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> `callback` metodę. Jeśli <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana przed ukończeniem przepływu pracy, zostaje ona zablokowana do momentu zakończenia przepływu pracy.  Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Są one pobierane przez wywołanie <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Gdy wywołanie <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> zwrotne zwraca, każdy argument danych wyjściowych jest zwracany w słowniku wyników, który jest poprzedzony przez nazwę argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu przepływu pracy.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie przy użyciu określonego interwału limitu czasu <see cref="T:System.AsyncCallback" />, i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do asynchronicznej operacji Invoke.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia o ukończeniu przepływu pracy i pobieraniu parametrów wyjściowych przepływu pracy, wywołaj <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> `callback` metodę. Jeśli <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana przed ukończeniem przepływu pracy, zostaje ona zablokowana do momentu zakończenia przepływu pracy. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie wygenerowany, <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> gdy wywoływana jest metoda.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Są one pobierane przez wywołanie <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Gdy wywołanie <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> zwrotne zwraca, każdy argument danych wyjściowych jest zwracany w słowniku wyników, który jest poprzedzony przez nazwę argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (inputs As IDictionary(Of String, Object), timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (inputs, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="callback">Metoda, która ma być wywoływana po zakończeniu przepływu pracy.</param>
        <param name="state">Opcjonalny obiekt specyficzny dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie przy użyciu <see cref="T:System.Collections.Generic.IDictionary`2" /> określonego parametru wejściowego, interwału limitu czasu <see cref="T:System.AsyncCallback" />, i stanu dostarczonego przez użytkownika.</summary>
        <returns>Odwołanie do asynchronicznej operacji Invoke.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia o ukończeniu przepływu pracy i pobieraniu parametrów wyjściowych przepływu pracy, wywołaj <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> `callback` metodę. Jeśli <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana przed ukończeniem przepływu pracy, zostaje ona zablokowana do momentu zakończenia przepływu pracy. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie wygenerowany po <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> wywołaniu.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy <xref:System.IAsyncResult> użyciu wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Są one pobierane przez wywołanie <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Gdy wywołanie <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> zwrotne zwraca, każdy argument danych wyjściowych jest zwracany w słowniku wyników, który jest poprzedzony przez nazwę argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync (object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync(object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.CancelAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync (userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync(System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : obj -&gt; unit" Usage="workflowInvoker.CancelAsync userState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="userState">Token dla przepływu pracy, który ma zostać anulowany.</param>
        <summary>Próbuje anulować przepływ pracy, który został wywołany z <paramref name="userState" />określonym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można anulować tylko przepływ pracy wywoływany przez <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> jedno z przeciążeń, które `userState` pobiera parametr.  
  
 Jeśli anulowanie zakończy się pomyślnie, <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> Właściwość <xref:System.Activities.InvokeCompletedEventArgs> przekazana do <xref:System.Activities.WorkflowInvoker.InvokeCompleted> procedury obsługi jest ustawiona na `true`; w przeciwnym razie jest ustawiona na `false`.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po wywołaniu przepływu pracy host próbuje anulować przepływ pracy.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; EndInvoke (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; EndInvoke(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (result As IAsyncResult) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ EndInvoke(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndInvoke : IAsyncResult -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.EndInvoke result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Odwołujesiędooperacji,którauruchomiłaprzepływpracy.<see cref="T:System.IAsyncResult" /> <see cref="Overload:System.Activities.WorkflowInvoker.BeginInvoke" /></param>
        <summary>Zwraca wyniki przepływu pracy, który został wywołany przy użyciu jednego z <see cref="Overload:System.Activities.WorkflowInvoker.BeginInvoke" /> przeciążeń.</summary>
        <returns>Słownik działań <see cref="T:System.Activities.OutArgument" /> głównych i <see cref="T:System.Activities.InOutArgument" /> wartości, które są oparte na nazwie argumentu, który reprezentuje dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia o ukończeniu przepływu pracy i pobieraniu parametrów wyjściowych przepływu pracy, wywołaj <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> `callback` metodę określoną przez <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A>. Jeśli <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana przed ukończeniem przepływu pracy, zostaje ona zablokowana do momentu zakończenia przepływu pracy.  
  
 Ta metoda zwraca wynik przepływu pracy wywołanego asynchronicznie przy użyciu <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [Omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Są one pobierane przez wywołanie <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Gdy wywołanie <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> zwrotne zwraca, każdy argument danych wyjściowych jest zwracany w słowniku wyników, który jest poprzedzony przez nazwę argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowInvoker.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As WorkflowInstanceExtensionManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::Hosting::WorkflowInstanceExtensionManager ^ Extensions { System::Activities::Hosting::WorkflowInstanceExtensionManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.Activities.Hosting.WorkflowInstanceExtensionManager" Usage="System.Activities.WorkflowInvoker.Extensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Hosting.WorkflowInstanceExtensionManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozszerzenia, które są dostępne dla przepływów pracy wywoływanych <see cref="T:System.Activities.WorkflowInvoker" /> przez wystąpienie. <see cref="T:System.Collections.ObjectModel.Collection`1" /></summary>
        <value>Rozszerzenia, które są dostępne dla przepływów pracy wywoływanych <see cref="T:System.Activities.WorkflowInvoker" /> przez wystąpienie. <see cref="T:System.Collections.ObjectModel.Collection`1" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana przez autorów hosta przepływu pracy do dodawania rozszerzeń do <xref:System.Activities.WorkflowInvoker> wystąpienia, dzięki czemu będą one dostępne dla przepływów pracy wywoływanych przez nią.  
  
   
  
## Examples  
 Poniższy przykład rejestruje niestandardowe <xref:System.Activities.Tracking.TrackingParticipant> <xref:System.Activities.WorkflowInvoker.Extensions%2A> z kolekcją <xref:System.Activities.WorkflowInvoker> wystąpienia. Ten przykład kodu jest częścią niestandardowego przykładu [śledzenia](~/docs/framework/windows-workflow-foundation/samples/custom-tracking.md) .  
  
 [!code-csharp[CFX_WorkflowInvokerExample#40](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#40)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje przepływ pracy synchronicznie i zwraca słownik działań <see cref="T:System.Activities.OutArgument" /> głównych i <see cref="T:System.Activities.InOutArgument" /> wartości, które odpowiadają na dane wyjściowe przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.Invoke%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke () As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke();" />
      <MemberSignature Language="F#" Value="member this.Invoke : unit -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje przepływ pracy synchronicznie przy użyciu definicji przepływu pracy przekazaną do <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" /> konstruktora.</summary>
        <returns>Słownik działań <see cref="T:System.Activities.OutArgument" /> głównych i <see cref="T:System.Activities.InOutArgument" /> wartości, które są oparte na nazwie argumentu, który reprezentuje dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.Invoke%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego `DiceRoll` działania. `DiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Gdy wywołanie `Invoke` zwrotne zwraca, każdy argument danych wyjściowych jest zwracany w słowniku wyników, który jest poprzedzony przez nazwę argumentu. Przepływ pracy jest wywoływany dwa razy, przy użyciu definicji przepływu pracy `WorkflowInvoker` przekazaną do konstruktora.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#31](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#31)]  
  
 Jeśli działanie główne przepływu pracy nie ma argumentów wyjściowych lub nie są one wymagane przez hosta, można je wymusić. Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego <xref:System.Activities.Statements.WriteLine> działania, które nie ma żadnych argumentów wyjściowych.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke workflow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflow">Definicja przepływu pracy do wywołania.</param>
        <summary>Wywołuje przepływ pracy synchronicznie przy użyciu określonej definicji przepływu pracy.</summary>
        <returns>Słownik działań <see cref="T:System.Activities.OutArgument" /> głównych i <see cref="T:System.Activities.InOutArgument" /> wartości, które są oparte na nazwie argumentu, który reprezentuje dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.Invoke%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego `DiceRoll` działania. `DiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Gdy wywołanie `Invoke` zwrotne zwraca, każdy argument danych wyjściowych jest zwracany w słowniku wyników, który jest poprzedzony przez nazwę argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#30](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#30)]  
  
 Jeśli działanie główne przepływu pracy nie ma argumentów wyjściowych lub nie są one wymagane przez hosta, można je wymusić. Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego <xref:System.Activities.Statements.WriteLine> działania, które nie ma żadnych argumentów wyjściowych.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (inputs As IDictionary(Of String, Object)) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke inputs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <summary>Wywołuje działanie przesłane do <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" /> konstruktora synchronicznie z określonymi <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrami wejściowymi.</summary>
        <returns>Słownik działań <see cref="T:System.Activities.OutArgument" /> głównych i <see cref="T:System.Activities.InOutArgument" /> wartości, które są oparte na nazwie argumentu, który reprezentuje dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.Invoke%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego `Divide` działania, które ma dwa argumenty wejściowe i dwa argumenty wyjściowe. Gdy przepływ pracy jest wywoływany, `arguments` jest przesyłany słownik zawierający wartości dla każdego argumentu wejściowego, który jest określany przez nazwę argumentu. Gdy wywołanie `Invoke` zwrotne zwraca, każdy argument wyjściowy jest zwracany `outputs` w słowniku, również przy użyciu nazwy argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#22)]  
  
 Jeśli przepływ pracy pochodzi z <xref:System.Activities.ActivityWithResult>, takich jak `CodeActivity<TResult>` lub `Activity<TResult>`, i istnieją argumenty wyjściowe oprócz dobrze zdefiniowanego <xref:System.Activities.Activity%601.Result%2A> argumentu wyjściowego, nieogólne Przeciążenie `Invoke`, takie jak this, musi być używane w Aby pobrać dodatkowe argumenty. W tym celu definicja przepływu pracy przeniesiona do `WorkflowInvoker` konstruktora musi być typu. <xref:System.Activities.Activity> W tym przykładzie `Divide` działanie pochodzi z `CodeActivity<int>`, ale jest zadeklarowane jako <xref:System.Activities.Activity> tak, że jest używane `Invoke`Przeciążenie, które zwraca słownik argumentów zamiast pojedynczej wartości zwracanej.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#121](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#121)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#23](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Wywołuje przepływ pracy synchronicznie z określonym interwałem limitu czasu.</summary>
        <returns>Słownik działań <see cref="T:System.Activities.OutArgument" /> głównych i <see cref="T:System.Activities.InOutArgument" /> wartości, które są oparte na nazwie argumentu, który reprezentuje dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie zgłoszony.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy, który zawiera dwa <xref:System.Activities.Statements.WriteLine> działania <xref:System.Activities.Statements.Delay> i działanie skonfigurowane z <xref:System.Activities.Statements.Delay.Duration%2A> jedną minutę. Ten przepływ pracy jest wywoływany dwukrotnie. po raz pierwszy z interwałem limitu czasu wynoszącym dwie minuty i drugim razem z interwałem limitu czasu wynoszącym 30 sekund. Pierwszy przepływ pracy został zakończony pomyślnie, ale drugi z nich <xref:System.TimeoutException> nie jest zwracany i zostanie wyświetlony następujący komunikat.  
  
```Output  
The operation did not complete within the allotted timeout of 00:00:30.   
The time allotted to this operation may have been a portion of a longer timeout.  
```  
  
 [!code-csharp[CFX_WorkflowInvokerExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#51)]  
  
 Aby zapoznać się z przykładem użycia `Invoke` z argumentami wyjściowymi, zobacz <xref:System.Activities.WorkflowInvoker.Invoke%2A> Przeciążenie z tymi samymi parametrami co to Przeciążenie, bez interwału limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, inputs As IDictionary(Of String, Object)) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflow">Definicja przepływu pracy do wywołania.</param>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <summary>Wywołuje przepływ pracy synchronicznie przy użyciu określonej definicji przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> i parametrów wejściowych.</summary>
        <returns>Słownik działań <see cref="T:System.Activities.OutArgument" /> głównych i <see cref="T:System.Activities.InOutArgument" /> wartości, które są oparte na nazwie argumentu, który reprezentuje dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.Invoke%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego `Divide` działania, które ma dwa argumenty wejściowe i dwa argumenty wyjściowe. Gdy przepływ pracy jest wywoływany, `arguments` jest przesyłany słownik zawierający wartości dla każdego argumentu wejściowego, który jest określany przez nazwę argumentu. Gdy wywołanie `Invoke` zwrotne zwraca, każdy argument wyjściowy jest zwracany `outputs` w słowniku, również przy użyciu nazwy argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#20)]  
  
 Jeśli przepływ pracy pochodzi z <xref:System.Activities.ActivityWithResult>, takich jak `CodeActivity<TResult>` lub `Activity<TResult>`, i istnieją argumenty wyjściowe oprócz dobrze zdefiniowanego <xref:System.Activities.Activity%601.Result%2A> argumentu wyjściowego, nieogólne Przeciążenie `Invoke`, takie jak this, musi być używane w Aby pobrać dodatkowe argumenty. W tym celu przekazana `Invoke` definicja przepływu pracy musi być typu. <xref:System.Activities.Activity> W tym przykładzie `Divide` działanie pochodzi z `CodeActivity<int>`, ale jest zadeklarowane jako <xref:System.Activities.Activity> tak, że jest używane `Invoke`Przeciążenie, które zwraca słownik argumentów zamiast pojedynczej wartości zwracanej.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#121](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#121)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#21](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity * TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="workflow">Definicja przepływu pracy do wywołania.</param>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Wywołuje przepływ pracy synchronicznie przy użyciu określonej definicji przepływu pracy i interwału limitu czasu.</summary>
        <returns>Słownik działań <see cref="T:System.Activities.OutArgument" /> głównych i <see cref="T:System.Activities.InOutArgument" /> wartości, które są oparte na nazwie argumentu, który reprezentuje dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie zgłoszony.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy, który zawiera dwa <xref:System.Activities.Statements.WriteLine> działania <xref:System.Activities.Statements.Delay> i działanie skonfigurowane z <xref:System.Activities.Statements.Delay.Duration%2A> jedną minutę. Ten przepływ pracy jest wywoływany dwukrotnie. po raz pierwszy z interwałem limitu czasu wynoszącym dwie minuty i drugim razem z interwałem limitu czasu wynoszącym 30 sekund. Pierwszy przepływ pracy został zakończony pomyślnie, ale drugi nie <xref:System.TimeoutException> został zgłoszony.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#50)]  
  
 Aby zapoznać się z przykładem użycia `Invoke` z argumentami wyjściowymi, zobacz <xref:System.Activities.WorkflowInvoker.Invoke%2A> Przeciążenie z tymi samymi parametrami co to Przeciążenie, bez interwału limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (inputs As IDictionary(Of String, Object), timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke (inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Wywołuje działanie przesłane do <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" /> konstruktora synchronicznie z określonymi <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrami wejściowymi i określonym interwałem limitu czasu.</summary>
        <returns>Słownik działań <see cref="T:System.Activities.OutArgument" /> głównych i <see cref="T:System.Activities.InOutArgument" /> wartości, które są oparte na nazwie argumentu, który reprezentuje dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie zgłoszony.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy, który zawiera dwa <xref:System.Activities.Statements.WriteLine> działania <xref:System.Activities.Statements.Delay> i działanie skonfigurowane z <xref:System.Activities.Statements.Delay.Duration%2A> jedną minutę. Ten przepływ pracy jest wywoływany dwukrotnie. po raz pierwszy z interwałem limitu czasu wynoszącym dwie minuty i drugim razem z interwałem limitu czasu wynoszącym 30 sekund. Pierwszy przepływ pracy został zakończony pomyślnie, ale drugi z nich <xref:System.TimeoutException> nie jest zwracany i zostanie wyświetlony następujący komunikat.  
  
```Output  
The operation did not complete within the allotted timeout of 00:00:30.   
The time allotted to this operation may have been a portion of a longer timeout.  
```  
  
 [!code-csharp[CFX_WorkflowInvokerExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#51)]  
  
 Aby zapoznać się z przykładem użycia `Invoke` z argumentami wejściowymi i wyjściowymi, zobacz <xref:System.Activities.WorkflowInvoker.Invoke%2A> Przeciążenie z takimi samymi parametrami jak to Przeciążenie, bez interwału limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, inputs As IDictionary(Of String, Object), timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="workflow">Definicja przepływu pracy do wywołania.</param>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Wywołuje przepływ pracy synchronicznie przy użyciu określonej definicji przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> , parametrów wejściowych i interwału limitu czasu.</summary>
        <returns>Słownik działań <see cref="T:System.Activities.OutArgument" /> głównych i <see cref="T:System.Activities.InOutArgument" /> wartości, które są oparte na nazwie argumentu, który reprezentuje dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie zgłoszony.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy, który zawiera dwa <xref:System.Activities.Statements.WriteLine> działania <xref:System.Activities.Statements.Delay> i działanie skonfigurowane z <xref:System.Activities.Statements.Delay.Duration%2A> jedną minutę. Ten przepływ pracy jest wywoływany dwukrotnie. po raz pierwszy z interwałem limitu czasu wynoszącym dwie minuty i drugim razem z interwałem limitu czasu wynoszącym 30 sekund. Pierwszy przepływ pracy został zakończony pomyślnie, ale drugi nie <xref:System.TimeoutException> został zgłoszony.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#50)]  
  
 Aby zapoznać się z przykładem użycia `Invoke` z argumentami wejściowymi i wyjściowymi, zobacz <xref:System.Activities.WorkflowInvoker.Invoke%2A> Przeciążenie z takimi samymi parametrami jak to Przeciążenie, bez interwału limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke workflow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ przepływu pracy.</typeparam>
        <param name="workflow">Definicja przepływu pracy do wywołania. Definicja przepływu pracy musi pochodzić od <see cref="T:System.Activities.ActivityWithResult" />.</param>
        <summary>Wywołuje przepływ pracy synchronicznie przy użyciu definicji przepływu pracy przekazaną do <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" /> konstruktora.</summary>
        <returns>Wartość typu TResult z wynikiem wykonania działania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.Invoke%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego `Add` działania, które ma dwa argumenty wejściowe i ponieważ pochodzi od `CodeActivity<int>` niego, ma jeden prawidłowo zdefiniowany <xref:System.Activities.Activity%601.Result%2A> argument wyjściowy. Gdy przepływ pracy jest wywoływany, `arguments` jest przesyłany słownik zawierający wartości dla każdego argumentu wejściowego, który jest określany przez nazwę argumentu. Gdy wywołanie `Invoke` funkcji zwraca, zwracana jest wartość <xref:System.Activities.Activity%601.Result%2A> argumentu wyjściowego. Ten przykład kodu jest oparty na użyciu przykładu [klasy WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) .  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ przepływu pracy.</typeparam>
        <param name="workflow">Definicja przepływu pracy do wywołania.</param>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <summary>Wywołuje przepływ pracy synchronicznie przy użyciu określonej definicji przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> i parametrów wejściowych.</summary>
        <returns>Wartość typu TResult z wynikiem wykonania działania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.Invoke%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego `Add` działania, które ma dwa argumenty wejściowe i ponieważ pochodzi od `CodeActivity<int>` niego, ma jeden prawidłowo zdefiniowany <xref:System.Activities.Activity%601.Result%2A> argument wyjściowy. Gdy przepływ pracy jest wywoływany, `arguments` jest przesyłany słownik zawierający wartości dla każdego argumentu wejściowego, który jest określany przez nazwę argumentu. Gdy wywołanie `Invoke` funkcji zwraca, zwracana jest wartość <xref:System.Activities.Activity%601.Result%2A> argumentu wyjściowego. Ten przykład kodu jest oparty na użyciu przykładu [klasy WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) .  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object), timeout As TimeSpan) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; * System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ przepływu pracy.</typeparam>
        <param name="workflow">Definicja przepływu pracy do wywołania.</param>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Wywołuje przepływ pracy synchronicznie przy użyciu określonej definicji przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> , parametrów wejściowych i interwału limitu czasu.</summary>
        <returns>Wartość typu TResult z wynikiem wykonania działania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie zgłoszony.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego `Add` działania, które ma dwa argumenty wejściowe i ponieważ pochodzi od `CodeActivity<int>` niego, ma jeden prawidłowo zdefiniowany <xref:System.Activities.Activity%601.Result%2A> argument wyjściowy. Gdy przepływ pracy jest wywoływany, `arguments` jest przesyłany słownik zawierający wartości dla każdego argumentu wejściowego, który jest określany przez nazwę argumentu. Gdy wywołanie `Invoke` funkcji zwraca, zwracana jest wartość <xref:System.Activities.Activity%601.Result%2A> argumentu wyjściowego. Ten przykład kodu jest oparty na użyciu przykładu [klasy WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) .  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, out System.Collections.Generic.IDictionary&lt;string,object&gt; additionalOutputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, [out] class System.Collections.Generic.IDictionary`2&lt;string, object&gt;&amp; additionalOutputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object}@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object), ByRef additionalOutputs As IDictionary(Of String, Object), timeout As TimeSpan) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, [Runtime::InteropServices::Out] System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ % additionalOutputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; * System.Collections.Generic.IDictionary&lt;string, obj&gt; *  * TimeSpan -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs, additionalOutputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="additionalOutputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ przepływu pracy.</typeparam>
        <param name="workflow">Definicja przepływu pracy do wywołania.</param>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <param name="additionalOutputs">Słownik dodatkowych parametrów wyjściowych przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Wywołuje przepływ pracy synchronicznie przy użyciu określonej definicji przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> , parametrów wejściowych, <see cref="T:System.Collections.Generic.IDictionary`2" /> dodatkowych parametrów wyjściowych i interwału limitu czasu.</summary>
        <returns>Wartość typu TResult z wynikiem wykonania działania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu zakończenia przepływu pracy, w tym czasu bezczynności. Wszystkie wykonywanie przepływu pracy jest gwarantowane do wykonania na wątku wywołującym. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie zgłoszony.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z pojedynczego `Add` działania, które ma dwa argumenty wejściowe i ponieważ pochodzi od `CodeActivity<int>` niego, ma jeden prawidłowo zdefiniowany <xref:System.Activities.Activity%601.Result%2A> argument wyjściowy. Gdy przepływ pracy jest wywoływany, `arguments` jest przesyłany słownik zawierający wartości dla każdego argumentu wejściowego, który jest określany przez nazwę argumentu. Gdy wywołanie `Invoke` funkcji zwraca, zwracana jest wartość <xref:System.Activities.Activity%601.Result%2A> argumentu wyjściowego. Ten przykład kodu jest oparty na użyciu przykładu [klasy WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) .  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie wywołuje przepływ pracy przy użyciu asynchronicznego wzorca projektowego opartego na zdarzeniach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia po zakończeniu przepływu pracy, dojście <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy użyciu asynchronicznego wzorca projektowego opartego na zdarzeniach. Aby uzyskać więcej informacji, zobacz [Omówienie asynchronicznego wzorca opartego na zdarzeniach](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync();" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : unit -&gt; unit" Usage="workflowInvoker.InvokeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie wywołuje przepływ pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia po zakończeniu przepływu pracy, dojście <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy użyciu asynchronicznego wzorca projektowego opartego na zdarzeniach. Aby uzyskać więcej informacji, zobacz [Omówienie asynchronicznego wzorca opartego na zdarzeniach](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po zakończeniu przepływu pracy zostaną one pobrane w programie <xref:System.Activities.WorkflowInvoker.InvokeCompleted> obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; unit" Usage="workflowInvoker.InvokeAsync inputs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie przy użyciu <see cref="T:System.Collections.Generic.IDictionary`2" /> określonych parametrów wejściowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia po zakończeniu przepływu pracy, dojście <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy użyciu asynchronicznego wzorca projektowego opartego na zdarzeniach. Aby uzyskać więcej informacji, zobacz [Omówienie asynchronicznego wzorca opartego na zdarzeniach](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po zakończeniu przepływu pracy zostaną one pobrane w programie <xref:System.Activities.WorkflowInvoker.InvokeCompleted> obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : obj -&gt; unit" Usage="workflowInvoker.InvokeAsync userState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="userState">Obiekt dostarczony przez użytkownika służący do rozróżnienia tej konkretnej asynchronicznej operacji Invoke z innych bieżących asynchronicznych operacji Invoke.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie przy użyciu określonego unikatowego identyfikatora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi być unikatowy we wszystkich aktualnie uruchomionych <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> operacjach dla bieżącego działania. `userState` Jeśli parametr nie jest unikatowy <xref:System.ArgumentException> , zostanie zgłoszony. `userState` `userState`służy do identyfikowania przepływu pracy w <xref:System.Activities.WorkflowInvoker.InvokeCompleted>programie oraz do anulowania przepływu pracy przy <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>użyciu.  
  
 Aby otrzymywać powiadomienia po zakończeniu przepływu pracy, dojście <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy użyciu asynchronicznego wzorca projektowego opartego na zdarzeniach. Aby uzyskać więcej informacji, zobacz [Omówienie asynchronicznego wzorca opartego na zdarzeniach](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po zakończeniu przepływu pracy zostaną one pobrane w programie <xref:System.Activities.WorkflowInvoker.InvokeCompleted> obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : TimeSpan -&gt; unit" Usage="workflowInvoker.InvokeAsync timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie z określonym interwałem limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia po zakończeniu przepływu pracy, dojście <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie zgłoszony.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy użyciu asynchronicznego wzorca projektowego opartego na zdarzeniach. Aby uzyskać więcej informacji, zobacz [Omówienie asynchronicznego wzorca opartego na zdarzeniach](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po zakończeniu przepływu pracy zostaną one pobrane w programie <xref:System.Activities.WorkflowInvoker.InvokeCompleted> obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; * obj -&gt; unit" Usage="workflowInvoker.InvokeAsync (inputs, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <param name="userState">Obiekt dostarczony przez użytkownika służący do rozróżnienia tej konkretnej asynchronicznej operacji Invoke z innych bieżących asynchronicznych operacji Invoke.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie przy użyciu <see cref="T:System.Collections.Generic.IDictionary`2" /> określonych parametrów wejściowych i unikatowych identyfikatorów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi być unikatowy we wszystkich aktualnie uruchomionych <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> operacjach dla bieżącego działania. `userState` Jeśli `userState` nie jest unikatowa <xref:System.ArgumentException> , zostanie zgłoszony. `userState`służy do identyfikowania przepływu pracy w <xref:System.Activities.WorkflowInvoker.InvokeCompleted>programie oraz do anulowania przepływu pracy przy <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>użyciu.  
  
 Aby otrzymywać powiadomienia po zakończeniu przepływu pracy, dojście <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Aby skonfigurować interwał przekroczenia limitu czasu, w którym przepływ pracy musi być zakończony, użyj <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> jednego z przeciążeń, które <xref:System.TimeSpan>zajmie.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy użyciu asynchronicznego wzorca projektowego opartego na zdarzeniach. Aby uzyskać więcej informacji, zobacz [Omówienie asynchronicznego wzorca opartego na zdarzeniach](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po zakończeniu przepływu pracy zostaną one pobrane w programie <xref:System.Activities.WorkflowInvoker.InvokeCompleted> obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; unit" Usage="workflowInvoker.InvokeAsync (inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie z określonymi <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrami wejściowymi i określonym interwałem limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia po zakończeniu przepływu pracy, dojście <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie zgłoszony.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy użyciu asynchronicznego wzorca projektowego opartego na zdarzeniach. Aby uzyskać więcej informacji, zobacz [Omówienie asynchronicznego wzorca opartego na zdarzeniach](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po zakończeniu przepływu pracy zostaną one pobrane w programie <xref:System.Activities.WorkflowInvoker.InvokeCompleted> obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (TimeSpan timeout, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(valuetype System.TimeSpan timeout, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (timeout As TimeSpan, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(TimeSpan timeout, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : TimeSpan * obj -&gt; unit" Usage="workflowInvoker.InvokeAsync (timeout, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="userState">Obiekt dostarczony przez użytkownika służący do rozróżnienia tej konkretnej asynchronicznej operacji Invoke z innych bieżących asynchronicznych operacji Invoke.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie z określonym interwałem limitu czasu i unikatowym identyfikatorem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi być unikatowy we wszystkich aktualnie uruchomionych <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> operacjach dla bieżącego działania. `userState` Jeśli `userState` nie jest unikatowa <xref:System.ArgumentException> , zostanie zgłoszony. `userState`służy do identyfikowania przepływu pracy w <xref:System.Activities.WorkflowInvoker.InvokeCompleted>programie oraz do anulowania przepływu pracy przy <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>użyciu.  
  
 Aby otrzymywać powiadomienia po zakończeniu przepływu pracy, dojście <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie zgłoszony.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy użyciu asynchronicznego wzorca projektowego opartego na zdarzeniach. Aby uzyskać więcej informacji, zobacz [Omówienie asynchronicznego wzorca opartego na zdarzeniach](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po zakończeniu przepływu pracy zostaną one pobrane w programie <xref:System.Activities.WorkflowInvoker.InvokeCompleted> obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), timeout As TimeSpan, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan * obj -&gt; unit" Usage="workflowInvoker.InvokeAsync (inputs, timeout, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik parametrów wejściowych do przepływu pracy, który jest poprzedzony przez nazwę argumentu.</param>
        <param name="timeout">Interwał, w którym przepływ pracy musi zostać zakończony, zanim zostanie przerwany i <see cref="T:System.TimeoutException" /> zostanie zgłoszony.</param>
        <param name="userState">Obiekt dostarczony przez użytkownika służący do rozróżnienia tej konkretnej asynchronicznej operacji Invoke z innych bieżących asynchronicznych operacji Invoke.</param>
        <summary>Wywołuje przepływ pracy asynchronicznie z określonymi <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrami wejściowymi, określonym interwałem limitu czasu i unikatowym identyfikatorem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi być unikatowy we wszystkich aktualnie uruchomionych <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> operacjach dla bieżącego działania. `userState` Jeśli `userState` nie jest unikatowa <xref:System.ArgumentException> , zostanie zgłoszony. `userState`służy do identyfikowania przepływu pracy w <xref:System.Activities.WorkflowInvoker.InvokeCompleted>programie oraz do anulowania przepływu pracy przy <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>użyciu.  
  
 Aby otrzymywać powiadomienia po zakończeniu przepływu pracy, dojście <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Jeśli przepływ pracy nie zostanie ukończony w określonym limicie czasu, przepływ pracy zostanie przerwany i <xref:System.TimeoutException> zostanie zgłoszony.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest generowany tylko wtedy, gdy upłynie limit czasu, a przepływ pracy stanie się nieczynny podczas wykonywania. Przepływ pracy, który trwa dłużej niż określony limit czasu, zostanie zakończony pomyślnie, jeśli przepływ pracy nie stanie się bezczynny.  
  
 Ta metoda wywołuje przepływ pracy asynchronicznie przy użyciu asynchronicznego wzorca projektowego opartego na zdarzeniach. Aby uzyskać więcej informacji, zobacz [Omówienie asynchronicznego wzorca opartego na zdarzeniach](https://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po zakończeniu przepływu pracy zostaną one pobrane w programie <xref:System.Activities.WorkflowInvoker.InvokeCompleted> obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt; InvokeCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Activities.InvokeCompletedEventArgs&gt; InvokeCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Activities.WorkflowInvoker.InvokeCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event InvokeCompleted As EventHandler(Of InvokeCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Activities::InvokeCompletedEventArgs ^&gt; ^ InvokeCompleted;" />
      <MemberSignature Language="F#" Value="member this.InvokeCompleted : EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt; " Usage="member this.InvokeCompleted : System.EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy przepływ pracy wywoływany przez jedno <see cref="Overload:System.Activities.WorkflowInvoker.InvokeAsync" /> z przeciążeń zostanie ukończony lub anulowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsłuż to, aby określić, czy przepływ pracy wywołany <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> z jednym z przeciążeń został pomyślnie zakończony i pobrać argumenty wyjściowe ukończonego przepływu pracy.  
  
   
  
## Examples  
 Poniższy przykład wywołuje przepływ pracy składający się z `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty wyjściowe, które reprezentują wyniki operacji rzutowania indeksu. Po zakończeniu przepływu pracy zostaną one pobrane w programie <xref:System.Activities.WorkflowInvoker.InvokeCompleted> obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

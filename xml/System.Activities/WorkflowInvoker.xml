<Type Name="WorkflowInvoker" FullName="System.Activities.WorkflowInvoker">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a3f571fdd8687db855e07c0035a0de1869318081" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34285317" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WorkflowInvoker" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInvoker extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Activities.WorkflowInvoker" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInvoker" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInvoker sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Umożliwia wywoływanie przepływu pracy, jak w przypadku wywołania metody.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activities.WorkflowInvoker> zawiera wystąpienie i metody statyczne do wywoływania synchronicznie przepływów pracy i wystąpienia metody do wywołania asynchroniczne przepływy pracy.  
  
 <xref:System.Activities.WorkflowInvoker> nie zezwala na wystąpienie kontrolki przykład przechowywanie, zwalnianie lub wznawianie zakładki. W razie potrzeby sterowania wystąpienia użyj <xref:System.Activities.WorkflowApplication> zamiast tego.  
  
 Aby wykonywać przepływy pracy synchronicznie przy użyciu kontrolka nie wystąpienia, należy wywołać <xref:System.Activities.WorkflowInvoker.Invoke%2A> metody. Aby wykonać asynchronicznie z formantem nie wystąpienie przepływu pracy, użyj <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A> i <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> pary metody lub <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> — metoda.  
  
   
  
## Examples  
 Poniższy przykład wywołuje synchronicznie przepływu pracy składającą się z pojedynczej <xref:System.Activities.Statements.WriteLine> działania przy użyciu <xref:System.Activities.WorkflowInvoker>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowInvoker (System.Activities.Activity workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflow As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowInvoker(System::Activities::Activity ^ workflow);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflow">Definicji przepływu pracy do wywołania przez to wystąpienie przepływu pracy <see cref="T:System.Activities.WorkflowInvoker" /> klasy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Activities.WorkflowInvoker" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activities.WorkflowInvoker> zawiera wystąpienie i metody statyczne do wywoływania synchronicznie przepływów pracy i wystąpienia metody do wywołania asynchroniczne przepływy pracy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej <xref:System.Activities.Statements.WriteLine> działania.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje asynchronicznie za pomocą przepływu pracy <see cref="T:System.IAsyncResult" /> wzorca projektowego asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda wywoływana, gdy przepływ pracy został ukończony.</param>
        <param name="state">Opcjonalne obiekt specyficzne dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Wywołuje asynchronicznie przy użyciu określonego przepływu pracy <see cref="T:System.AsyncCallback" /> i stanu użytkownika.</summary>
        <returns>Odwołanie do asynchronicznego wywołania operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiadomienie po zakończeniu przepływu pracy i pobieranie parametrów wyjściowych przepływu pracy, należy wywołać <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> z `callback` metody. Jeśli <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana przed zakończeniem przepływu pracy, blokuje do momentu ukończenia przepływu pracy. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A> overloads które trwają <xref:System.TimeSpan>.  
  
 Ta metoda wywołuje asynchronicznie za pomocą przepływu pracy <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Są one pobierane przez wywołanie metody <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Po wywołaniu <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> zwraca każdy argument wyjściowy jest zwracany w słowniku danych wyjściowych, wyznaczaną przez Nazwa argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (inputs As IDictionary(Of String, Object), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <param name="callback">Metoda wywoływana, gdy przepływ pracy został ukończony.</param>
        <param name="state">Opcjonalne obiekt specyficzne dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Wywołuje asynchronicznie przy użyciu określonego przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrów wejściowych <see cref="T:System.AsyncCallback" />i stanu użytkownika.</summary>
        <returns>Odwołanie do asynchronicznego wywołania operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiadomienie po zakończeniu przepływu pracy i pobieranie parametrów wyjściowych przepływu pracy, należy wywołać <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> z `callback` metody. Jeśli <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana przed zakończeniem przepływu pracy, blokuje do momentu ukończenia przepływu pracy.  Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A> overloads które trwają <xref:System.TimeSpan>.  
  
 Ta metoda wywołuje asynchronicznie za pomocą przepływu pracy <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Są one pobierane przez wywołanie metody <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Po wywołaniu <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> zwraca każdy argument wyjściowy jest zwracany w słowniku danych wyjściowych, wyznaczaną przez Nazwa argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <param name="callback">Metoda wywoływana, gdy przepływ pracy został ukończony.</param>
        <param name="state">Opcjonalne obiekt specyficzne dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Wywołuje asynchronicznie za pomocą określony limit czasu, przepływ pracy <see cref="T:System.AsyncCallback" />i stanu użytkownika.</summary>
        <returns>Odwołanie do asynchronicznego wywołania operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiadomienie po zakończeniu przepływu pracy i pobieranie parametrów wyjściowych przepływu pracy, należy wywołać <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> z `callback` metody. Jeśli <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana przed zakończeniem przepływu pracy, blokuje do momentu ukończenia przepływu pracy. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany, gdy <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> metoda jest wywoływana.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby ukończyć zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
 Ta metoda wywołuje asynchronicznie za pomocą przepływu pracy <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Są one pobierane przez wywołanie metody <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Po wywołaniu <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> zwraca każdy argument wyjściowy jest zwracany w słowniku danych wyjściowych, wyznaczaną przez Nazwa argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (inputs As IDictionary(Of String, Object), timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <param name="callback">Metoda wywoływana, gdy przepływ pracy został ukończony.</param>
        <param name="state">Opcjonalne obiekt specyficzne dla aplikacji, który zawiera informacje o operacji asynchronicznej.</param>
        <summary>Wywołuje asynchronicznie przy użyciu określonego przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrów wejściowych, limit czasu <see cref="T:System.AsyncCallback" />i stanu użytkownika.</summary>
        <returns>Odwołanie do asynchronicznego wywołania operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiadomienie po zakończeniu przepływu pracy i pobieranie parametrów wyjściowych przepływu pracy, należy wywołać <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> z `callback` metody. Jeśli <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana przed zakończeniem przepływu pracy, blokuje do momentu ukończenia przepływu pracy. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany, gdy <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby ukończyć zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
 Ta metoda wywołuje asynchronicznie za pomocą przepływu pracy <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Są one pobierane przez wywołanie metody <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Po wywołaniu <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> zwraca każdy argument wyjściowy jest zwracany w słowniku danych wyjściowych, wyznaczaną przez Nazwa argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync (object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync(object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.CancelAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync (userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync(System::Object ^ userState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="userState">Token anulować przepływ pracy.</param>
        <summary>Próbuje anulować przepływu pracy, który został wywołany z określonym <paramref name="userState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko przepływ pracy wywołany przez jedną z <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> przeciążeń, które przyjmuje `userState` parametru może być anulowane.  
  
 Jeśli anulowanie zakończy się powodzeniem, <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> właściwość <xref:System.Activities.InvokeCompletedEventArgs> przekazany do <xref:System.Activities.WorkflowInvoker.InvokeCompleted> program obsługi ma ustawioną wartość `true`; w przeciwnym razie wartość jest równa `false`.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Gdy przepływ pracy zostanie wywołany, host próbuje anulować przepływ pracy.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; EndInvoke (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; EndInvoke(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (result As IAsyncResult) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ EndInvoke(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się <see cref="Overload:System.Activities.WorkflowInvoker.BeginInvoke" /> operacji, który uruchomił przepływ pracy.</param>
        <summary>Zwraca wyniki do przepływu pracy, który został wywołany za pomocą jednego z <see cref="Overload:System.Activities.WorkflowInvoker.BeginInvoke" /> przeciążenia.</summary>
        <returns>Słownik działanie główne <see cref="T:System.Activities.OutArgument" /> i <see cref="T:System.Activities.InOutArgument" /> wartości wyznaczaną przez argument nazwy reprezentujące dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiadomienie po zakończeniu przepływu pracy i pobieranie parametrów wyjściowych przepływu pracy, należy wywołać <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> z `callback` metodą określoną przez <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A>. Jeśli <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> jest wywoływana przed zakończeniem przepływu pracy, blokuje do momentu ukończenia przepływu pracy.  
  
 Ta metoda zwraca wynik przepływu pracy wywołany asynchronicznie za pomocą <xref:System.IAsyncResult> wzorca projektowego asynchronicznego. Aby uzyskać więcej informacji, zobacz [omówienie programowania asynchronicznego](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Są one pobierane przez wywołanie metody <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Po wywołaniu <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> zwraca każdy argument wyjściowy jest zwracany w słowniku danych wyjściowych, wyznaczaną przez Nazwa argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowInvoker.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As WorkflowInstanceExtensionManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::Hosting::WorkflowInstanceExtensionManager ^ Extensions { System::Activities::Hosting::WorkflowInstanceExtensionManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Hosting.WorkflowInstanceExtensionManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.ObjectModel.Collection`1" /> rozszerzeń, które są dostępne dla przepływów pracy wywołany przez <see cref="T:System.Activities.WorkflowInvoker" /> wystąpienia.</summary>
        <value>
          <see cref="T:System.Collections.ObjectModel.Collection`1" /> Rozszerzeń, które są dostępne dla przepływów pracy wywołany przez <see cref="T:System.Activities.WorkflowInvoker" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana przez autorów hosta przepływu pracy można dodać rozszerzenia do <xref:System.Activities.WorkflowInvoker> wystąpienia, więc będą one dostępne do przepływów pracy wywołany przez nią.  
  
   
  
## Examples  
 Poniższy przykład rejestruje niestandardowego <xref:System.Activities.Tracking.TrackingParticipant> z <xref:System.Activities.WorkflowInvoker.Extensions%2A> Kolekcja <xref:System.Activities.WorkflowInvoker> wystąpienia. Ten przykładowy kod jest częścią [śledzenia niestandardowe](~/docs/framework/windows-workflow-foundation/samples/custom-tracking.md) próbki.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#40](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#40)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje synchronicznie przepływu pracy i zwraca słownik działanie główne <see cref="T:System.Activities.OutArgument" /> i <see cref="T:System.Activities.InOutArgument" /> wartości wyznaczaną przez argument nazwy reprezentujące dane wyjściowe przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.Invoke%2A> overloads które trwają <xref:System.TimeSpan>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke () As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje synchronicznie przy użyciu definicji przepływu pracy przekazywany do przepływu pracy <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" /> konstruktora.</summary>
        <returns>Słownik działanie główne <see cref="T:System.Activities.OutArgument" /> i <see cref="T:System.Activities.InOutArgument" /> wartości wyznaczaną przez argument nazwy reprezentujące dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.Invoke%2A> overloads które trwają <xref:System.TimeSpan>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej `DiceRoll` działania. `DiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po wywołaniu `Invoke` zwraca każdy argument wyjściowy jest zwracany w słowniku danych wyjściowych, wyznaczaną przez Nazwa argumentu. Przepływ pracy jest wywoływana dwukrotnie przy użyciu definicji przepływu pracy przekazany `WorkflowInvoker` konstruktora.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#31](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#31)]  
  
 Jeśli nie są wymagane przez hosta przepływu pracy działania głównego nie ma argumentów danych wyjściowych, można być ignorowane. Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej <xref:System.Activities.Statements.WriteLine> działanie, które nie ma żadnych danych wyjściowych argumentów.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflow">Definicja przepływu pracy przepływu pracy do wywołania.</param>
        <summary>Wywołuje synchronicznie przy użyciu określonego przepływu pracy definicji przepływu pracy.</summary>
        <returns>Słownik działanie główne <see cref="T:System.Activities.OutArgument" /> i <see cref="T:System.Activities.InOutArgument" /> wartości wyznaczaną przez argument nazwy reprezentujące dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.Invoke%2A> overloads które trwają <xref:System.TimeSpan>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej `DiceRoll` działania. `DiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po wywołaniu `Invoke` zwraca każdy argument wyjściowy jest zwracany w słowniku danych wyjściowych, wyznaczaną przez Nazwa argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#30](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#30)]  
  
 Jeśli nie są wymagane przez hosta przepływu pracy działania głównego nie ma argumentów danych wyjściowych, można być ignorowane. Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej <xref:System.Activities.Statements.WriteLine> działanie, które nie ma żadnych danych wyjściowych argumentów.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (inputs As IDictionary(Of String, Object)) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <summary>Wywołuje aktywność przekazany do <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" /> Konstruktor synchronicznie przy użyciu określonego <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrów wejściowych.</summary>
        <returns>Słownik działanie główne <see cref="T:System.Activities.OutArgument" /> i <see cref="T:System.Activities.InOutArgument" /> wartości wyznaczaną przez argument nazwy reprezentujące dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.Invoke%2A> overloads które trwają <xref:System.TimeSpan>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej `Divide` działanie, czy ma dwa argumenty w danych wejściowych i wyjściowych dwóch argumentów. Jeśli przepływ pracy zostanie wywołane, `arguments` słownika jest przekazywany, która zawiera wartości dla każdego wejścia argumentu, wyznaczaną przez Nazwa argumentu. Po wywołaniu `Invoke` zwraca każdy argument wyjściowy jest zwracany w `outputs` słownika, także klucze w postaci nazwy argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#22)]  
  
 Jeśli przepływ pracy jest pochodną <xref:System.Activities.ActivityWithResult>, takich jak `CodeActivity<TResult>` lub `Activity<TResult>`, i argumenty wyjściowe oprócz dobrze zdefiniowany <xref:System.Activities.Activity%601.Result%2A> output argumentu, przeciążenia nieogólnego `Invoke`, taki jak ta, musi być używany w Aby pobrać dodatkowe argumenty. Aby to zrobić, definicji przepływu pracy przekazany `WorkflowInvoker` Konstruktor musi być typu <xref:System.Activities.Activity>. W tym przykładzie `Divide` działania jest pochodną `CodeActivity<int>`, ale jest zadeklarowany jako <xref:System.Activities.Activity> tak, aby to przeciążenia z `Invoke`, zwraca słownika argumentów zamiast pojedynczego zwracanej wartości, jest używany.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#121](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#121)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#23](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <summary>Wywołuje przepływu pracy synchronicznie przy użyciu określonego limitu czasu.</summary>
        <returns>Słownik działanie główne <see cref="T:System.Activities.OutArgument" /> i <see cref="T:System.Activities.InOutArgument" /> wartości wyznaczaną przez argument nazwy reprezentujące dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby ukończyć zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy, który zawiera dwa <xref:System.Activities.Statements.WriteLine> działań i <xref:System.Activities.Statements.Delay> działania skonfigurowano <xref:System.Activities.Statements.Delay.Duration%2A> jednej minuty. Ten przepływ pracy jest wywoływana dwukrotnie; po raz pierwszy z limitu czasu wynosi dwie minuty, a za drugim razem z limit czasu wynoszący 30 sekund. Pierwszy przepływu pracy zostało ukończone pomyślnie, ale nie ma jeden i <xref:System.TimeoutException> jest zgłaszany i zostanie wyświetlony następujący komunikat.  
  
```Output  
The operation did not complete within the allotted timeout of 00:00:30.   
The time allotted to this operation may have been a portion of a longer timeout.  
```  
  
 [!code-csharp[CFX_WorkflowInvokerExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#51)]  
  
 Na przykład za pomocą `Invoke` z danych wyjściowych argumentami, zobacz przeciążenia <xref:System.Activities.WorkflowInvoker.Invoke%2A> o takich samych parametrach co tego przeciążenia bez limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, inputs As IDictionary(Of String, Object)) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflow">Definicja przepływu pracy przepływu pracy do wywołania.</param>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <summary>Wywołuje synchronicznie przy użyciu określonego przepływu pracy definicji przepływu pracy i <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrów wejściowych.</summary>
        <returns>Słownik działanie główne <see cref="T:System.Activities.OutArgument" /> i <see cref="T:System.Activities.InOutArgument" /> wartości wyznaczaną przez argument nazwy reprezentujące dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.Invoke%2A> overloads które trwają <xref:System.TimeSpan>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej `Divide` działanie, czy ma dwa argumenty w danych wejściowych i wyjściowych dwóch argumentów. Jeśli przepływ pracy zostanie wywołane, `arguments` słownika jest przekazywany, która zawiera wartości dla każdego wejścia argumentu, wyznaczaną przez Nazwa argumentu. Po wywołaniu `Invoke` zwraca każdy argument wyjściowy jest zwracany w `outputs` słownika, także klucze w postaci nazwy argumentu.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#20)]  
  
 Jeśli przepływ pracy jest pochodną <xref:System.Activities.ActivityWithResult>, takich jak `CodeActivity<TResult>` lub `Activity<TResult>`, i argumenty wyjściowe oprócz dobrze zdefiniowany <xref:System.Activities.Activity%601.Result%2A> output argumentu, przeciążenia nieogólnego `Invoke`, taki jak ta, musi być używany w Aby pobrać dodatkowe argumenty. Aby to zrobić, definicji przepływu pracy przekazany `Invoke` musi być typu <xref:System.Activities.Activity>. W tym przykładzie `Divide` działania jest pochodną `CodeActivity<int>`, ale jest zadeklarowany jako <xref:System.Activities.Activity> tak, aby to przeciążenia z `Invoke`, zwraca słownika argumentów zamiast pojedynczego zwracanej wartości, jest używany.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#121](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#121)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#21](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="workflow">Definicja przepływu pracy przepływu pracy do wywołania.</param>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <summary>Wywołuje przepływu pracy synchronicznie przy użyciu definicji określonego przepływu pracy i interwał limitu czasu.</summary>
        <returns>Słownik działanie główne <see cref="T:System.Activities.OutArgument" /> i <see cref="T:System.Activities.InOutArgument" /> wartości wyznaczaną przez argument nazwy reprezentujące dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby ukończyć zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy, który zawiera dwa <xref:System.Activities.Statements.WriteLine> działań i <xref:System.Activities.Statements.Delay> działania skonfigurowano <xref:System.Activities.Statements.Delay.Duration%2A> jednej minuty. Ten przepływ pracy jest wywoływana dwukrotnie; po raz pierwszy z limitu czasu wynosi dwie minuty, a za drugim razem z limit czasu wynoszący 30 sekund. Pierwszy przepływu pracy zostało ukończone pomyślnie, ale nie ma jeden i <xref:System.TimeoutException> jest generowany.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#50)]  
  
 Na przykład za pomocą `Invoke` z danych wyjściowych argumentami, zobacz przeciążenia <xref:System.Activities.WorkflowInvoker.Invoke%2A> o takich samych parametrach co tego przeciążenia bez limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (inputs As IDictionary(Of String, Object), timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <summary>Wywołuje aktywność przekazany do <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" /> Konstruktor synchronicznie przy użyciu określonego <see cref="T:System.Collections.Generic.IDictionary`2" /> parametry wejściowe i określonego limitu czasu.</summary>
        <returns>Słownik działanie główne <see cref="T:System.Activities.OutArgument" /> i <see cref="T:System.Activities.InOutArgument" /> wartości wyznaczaną przez argument nazwy reprezentujące dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby ukończyć zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy, który zawiera dwa <xref:System.Activities.Statements.WriteLine> działań i <xref:System.Activities.Statements.Delay> działania skonfigurowano <xref:System.Activities.Statements.Delay.Duration%2A> jednej minuty. Ten przepływ pracy jest wywoływana dwukrotnie; po raz pierwszy z limitu czasu wynosi dwie minuty, a za drugim razem z limit czasu wynoszący 30 sekund. Pierwszy przepływu pracy zostało ukończone pomyślnie, ale nie ma jeden i <xref:System.TimeoutException> jest zgłaszany i zostanie wyświetlony następujący komunikat.  
  
```Output  
The operation did not complete within the allotted timeout of 00:00:30.   
The time allotted to this operation may have been a portion of a longer timeout.  
```  
  
 [!code-csharp[CFX_WorkflowInvokerExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#51)]  
  
 Na przykład za pomocą `Invoke` argumentów wejściowych i wyjściowych, zobacz przeciążenia <xref:System.Activities.WorkflowInvoker.Invoke%2A> o takich samych parametrach co tego przeciążenia bez limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, inputs As IDictionary(Of String, Object), timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="workflow">Definicja przepływu pracy przepływu pracy do wywołania.</param>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <summary>Wywołuje synchronicznie przy użyciu definicji przepływu pracy określonego przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> parametry wejściowe i interwał limitu czasu.</summary>
        <returns>Słownik działanie główne <see cref="T:System.Activities.OutArgument" /> i <see cref="T:System.Activities.InOutArgument" /> wartości wyznaczaną przez argument nazwy reprezentujące dane wyjściowe przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby ukończyć zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy, który zawiera dwa <xref:System.Activities.Statements.WriteLine> działań i <xref:System.Activities.Statements.Delay> działania skonfigurowano <xref:System.Activities.Statements.Delay.Duration%2A> jednej minuty. Ten przepływ pracy jest wywoływana dwukrotnie; po raz pierwszy z limitu czasu wynosi dwie minuty, a za drugim razem z limit czasu wynoszący 30 sekund. Pierwszy przepływu pracy zostało ukończone pomyślnie, ale nie ma jeden i <xref:System.TimeoutException> jest generowany.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#50)]  
  
 Na przykład za pomocą `Invoke` argumentów wejściowych i wyjściowych, zobacz przeciążenia <xref:System.Activities.WorkflowInvoker.Invoke%2A> o takich samych parametrach co tego przeciążenia bez limitu czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ przepływu pracy.</typeparam>
        <param name="workflow">Definicja przepływu pracy przepływu pracy do wywołania. Definicji przepływu pracy musi pochodzić od <see cref="T:System.Activities.ActivityWithResult" />.</param>
        <summary>Wywołuje synchronicznie przy użyciu definicji przepływu pracy przekazywany do przepływu pracy <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" /> konstruktora.</summary>
        <returns>Wartości typu TResult w wyniku wykonania działania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.Invoke%2A> overloads które trwają <xref:System.TimeSpan>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej `Add` działania, która ma dwa argumenty wejściowe i ponieważ dziedziczy `CodeActivity<int>` istnieje dobrze zdefiniowany <xref:System.Activities.Activity%601.Result%2A> output argumentu. Jeśli przepływ pracy zostanie wywołane, `arguments` słownika jest przekazywany, która zawiera wartości dla każdego wejścia argumentu, wyznaczaną przez Nazwa argumentu. Po wywołaniu `Invoke` zwraca wartość <xref:System.Activities.Activity%601.Result%2A> argument wyjściowy jest zwracany. W tym przykładzie kodu jest oparta na off z [za pomocą klasy WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) próbki.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ przepływu pracy.</typeparam>
        <param name="workflow">Definicja przepływu pracy przepływu pracy do wywołania.</param>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <summary>Wywołuje synchronicznie przy użyciu określonego przepływu pracy definicji przepływu pracy i <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrów wejściowych.</summary>
        <returns>Wartości typu TResult w wyniku wykonania działania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.Invoke%2A> overloads które trwają <xref:System.TimeSpan>.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby zakończyć, zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej `Add` działania, która ma dwa argumenty wejściowe i ponieważ dziedziczy `CodeActivity<int>` istnieje dobrze zdefiniowany <xref:System.Activities.Activity%601.Result%2A> output argumentu. Jeśli przepływ pracy zostanie wywołane, `arguments` słownika jest przekazywany, która zawiera wartości dla każdego wejścia argumentu, wyznaczaną przez Nazwa argumentu. Po wywołaniu `Invoke` zwraca wartość <xref:System.Activities.Activity%601.Result%2A> argument wyjściowy jest zwracany. W tym przykładzie kodu jest oparta na off z [za pomocą klasy WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) próbki.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object), timeout As TimeSpan) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ przepływu pracy.</typeparam>
        <param name="workflow">Definicja przepływu pracy przepływu pracy do wywołania.</param>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <summary>Wywołuje synchronicznie przy użyciu definicji przepływu pracy określonego przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> parametry wejściowe i interwał limitu czasu.</summary>
        <returns>Wartości typu TResult w wyniku wykonania działania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby zakończyć, zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej `Add` działania, która ma dwa argumenty wejściowe i ponieważ dziedziczy `CodeActivity<int>` istnieje dobrze zdefiniowany <xref:System.Activities.Activity%601.Result%2A> output argumentu. Jeśli przepływ pracy zostanie wywołane, `arguments` słownika jest przekazywany, która zawiera wartości dla każdego wejścia argumentu, wyznaczaną przez Nazwa argumentu. Po wywołaniu `Invoke` zwraca wartość <xref:System.Activities.Activity%601.Result%2A> argument wyjściowy jest zwracany. W tym przykładzie kodu jest oparta na off z [za pomocą klasy WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) próbki.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, out System.Collections.Generic.IDictionary&lt;string,object&gt; additionalOutputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, [out] class System.Collections.Generic.IDictionary`2&lt;string, object&gt;&amp; additionalOutputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object}@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object), ByRef additionalOutputs As IDictionary(Of String, Object), timeout As TimeSpan) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, [Runtime::InteropServices::Out] System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ % additionalOutputs, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="additionalOutputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;&amp;" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ przepływu pracy.</typeparam>
        <param name="workflow">Definicja przepływu pracy przepływu pracy do wywołania.</param>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <param name="additionalOutputs">Słownik zawierający dodatkowe dane wyjściowe parametry przepływu pracy, wyznaczaną przez Nazwa argumentu.</param>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <summary>Wywołuje synchronicznie przy użyciu definicji przepływu pracy określonego przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrów wejściowych <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrów dodatkowe dane wyjściowe i interwał limitu czasu.</summary>
        <returns>Wartości typu TResult w wyniku wykonania działania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten uniemożliwia metody dopiero po ukończeniu przepływu pracy, w tym czas bezczynności. Wszystkie wykonywania przepływu pracy jest gwarantowana do wykonania na wywoływanie wątku. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby zakończyć, zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie przepływu pracy składającą się z pojedynczej `Add` działania, która ma dwa argumenty wejściowe i ponieważ dziedziczy `CodeActivity<int>` istnieje dobrze zdefiniowany <xref:System.Activities.Activity%601.Result%2A> output argumentu. Jeśli przepływ pracy zostanie wywołane, `arguments` słownika jest przekazywany, która zawiera wartości dla każdego wejścia argumentu, wyznaczaną przez Nazwa argumentu. Po wywołaniu `Invoke` zwraca wartość <xref:System.Activities.Activity%601.Result%2A> argument wyjściowy jest zwracany. W tym przykładzie kodu jest oparta na off z [za pomocą klasy WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) próbki.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje asynchronicznie za pomocą opartego na zdarzeniach asynchroniczne wzorcu przepływ pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymać powiadomienie po zakończeniu przepływu pracy, obsługi <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> overloads które trwają <xref:System.TimeSpan>.  
  
 Ta metoda wywołuje asynchronicznie za pomocą opartego na zdarzeniach asynchroniczne wzorcu przepływ pracy. Aby uzyskać więcej informacji, zobacz [oparty na zdarzeniach asynchroniczny wzorzec — Przegląd](http://go.microsoft.com/fwlink/?LinkId=141765).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje asynchronicznie przepływ pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymać powiadomienie po zakończeniu przepływu pracy, obsługi <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> overloads które trwają <xref:System.TimeSpan>.  
  
 Ta metoda wywołuje asynchronicznie za pomocą opartego na zdarzeniach asynchroniczne wzorcu przepływ pracy. Aby uzyskać więcej informacji, zobacz [oparty na zdarzeniach asynchroniczny wzorzec — Przegląd](http://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po zakończeniu tych przepływu pracy są pobierane w <xref:System.Activities.WorkflowInvoker.InvokeCompleted> programu obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <summary>Wywołuje asynchronicznie przy użyciu określonego przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrów wejściowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymać powiadomienie po zakończeniu przepływu pracy, obsługi <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> overloads które trwają <xref:System.TimeSpan>.  
  
 Ta metoda wywołuje asynchronicznie za pomocą opartego na zdarzeniach asynchroniczne wzorcu przepływ pracy. Aby uzyskać więcej informacji, zobacz [oparty na zdarzeniach asynchroniczny wzorzec — Przegląd](http://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po zakończeniu tych przepływu pracy są pobierane w <xref:System.Activities.WorkflowInvoker.InvokeCompleted> programu obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Object ^ userState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="userState">Obiekt użytkownika używane do odróżnienia tego określonego asynchroniczne wywołać operację od innych bieżącego asynchronicznego wywołania operacji.</param>
        <summary>Wywołuje asynchronicznie za pomocą określonego Unikatowy identyfikator przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `userState` Parametru musi być unikatowa we wszystkich aktualnie uruchomionych <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> operacje dla bieżącego działania. Jeśli `userState` parametru nie jest unikatowa, <xref:System.ArgumentException> jest generowany. `userState` Służy do identyfikowania przepływu pracy w <xref:System.Activities.WorkflowInvoker.InvokeCompleted>i Anuluj przy użyciu przepływu pracy <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Aby otrzymać powiadomienie po zakończeniu przepływu pracy, obsługi <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> overloads które trwają <xref:System.TimeSpan>.  
  
 Ta metoda wywołuje asynchronicznie za pomocą opartego na zdarzeniach asynchroniczne wzorcu przepływ pracy. Aby uzyskać więcej informacji, zobacz [oparty na zdarzeniach asynchroniczny wzorzec — Przegląd](http://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po zakończeniu tych przepływu pracy są pobierane w <xref:System.Activities.WorkflowInvoker.InvokeCompleted> programu obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <summary>Wywołuje asynchronicznie z określonego limitu czasu przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymać powiadomienie po zakończeniu przepływu pracy, obsługi <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby ukończyć zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
 Ta metoda wywołuje asynchronicznie za pomocą opartego na zdarzeniach asynchroniczne wzorcu przepływ pracy. Aby uzyskać więcej informacji, zobacz [oparty na zdarzeniach asynchroniczny wzorzec — Przegląd](http://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po zakończeniu tych przepływu pracy są pobierane w <xref:System.Activities.WorkflowInvoker.InvokeCompleted> programu obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, System::Object ^ userState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <param name="userState">Obiekt użytkownika używane do odróżnienia tego określonego asynchroniczne wywołać operację od innych bieżącego asynchronicznego wywołania operacji.</param>
        <summary>Wywołuje asynchronicznie przy użyciu określonego przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> parametry wejściowe i unikatowym identyfikatorem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `userState` Parametru musi być unikatowa we wszystkich aktualnie uruchomionych <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> operacje dla bieżącego działania. Jeśli `userState` nie jest unikatowa, <xref:System.ArgumentException> jest generowany. `userState` Służy do identyfikowania przepływu pracy w <xref:System.Activities.WorkflowInvoker.InvokeCompleted>i Anuluj przy użyciu przepływu pracy <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Aby otrzymać powiadomienie po zakończeniu przepływu pracy, obsługi <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Aby skonfigurować interwał limitu czasu, w którym należy wykonać przepływu pracy, użyj jednej z <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> overloads które trwają <xref:System.TimeSpan>.  
  
 Ta metoda wywołuje asynchronicznie za pomocą opartego na zdarzeniach asynchroniczne wzorcu przepływ pracy. Aby uzyskać więcej informacji, zobacz [oparty na zdarzeniach asynchroniczny wzorzec — Przegląd](http://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po zakończeniu tych przepływu pracy są pobierane w <xref:System.Activities.WorkflowInvoker.InvokeCompleted> programu obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <summary>Wywołuje asynchronicznie z określonego przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> parametry wejściowe i określonego limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymać powiadomienie po zakończeniu przepływu pracy, obsługi <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby ukończyć zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
 Ta metoda wywołuje asynchronicznie za pomocą opartego na zdarzeniach asynchroniczne wzorcu przepływ pracy. Aby uzyskać więcej informacji, zobacz [oparty na zdarzeniach asynchroniczny wzorzec — Przegląd](http://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po zakończeniu tych przepływu pracy są pobierane w <xref:System.Activities.WorkflowInvoker.InvokeCompleted> programu obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (TimeSpan timeout, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(valuetype System.TimeSpan timeout, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (timeout As TimeSpan, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(TimeSpan timeout, System::Object ^ userState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <param name="userState">Obiekt użytkownika używane do odróżnienia tego określonego asynchroniczne wywołać operację od innych bieżącego asynchronicznego wywołania operacji.</param>
        <summary>Wywołuje asynchronicznie z określonego limitu czasu i unikatowy identyfikator przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `userState` Parametru musi być unikatowa we wszystkich aktualnie uruchomionych <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> operacje dla bieżącego działania. Jeśli `userState` nie jest unikatowa, <xref:System.ArgumentException> jest generowany. `userState` Służy do identyfikowania przepływu pracy w <xref:System.Activities.WorkflowInvoker.InvokeCompleted>i Anuluj przy użyciu przepływu pracy <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Aby otrzymać powiadomienie po zakończeniu przepływu pracy, obsługi <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby ukończyć zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
 Ta metoda wywołuje asynchronicznie za pomocą opartego na zdarzeniach asynchroniczne wzorcu przepływ pracy. Aby uzyskać więcej informacji, zobacz [oparty na zdarzeniach asynchroniczny wzorzec — Przegląd](http://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po zakończeniu tych przepływu pracy są pobierane w <xref:System.Activities.WorkflowInvoker.InvokeCompleted> programu obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), timeout As TimeSpan, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout, System::Object ^ userState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">Słownik zawierający parametry wejściowe w przepływie pracy, wyznaczaną przez Nazwa argumentu.</param>
        <param name="timeout">Interwał przepływu pracy należy wykonać, zanim jest zostało przerwane i a <see cref="T:System.TimeoutException" /> jest generowany.</param>
        <param name="userState">Obiekt użytkownika używane do odróżnienia tego określonego asynchroniczne wywołać operację od innych bieżącego asynchronicznego wywołania operacji.</param>
        <summary>Wywołuje asynchronicznie z określonego przepływu pracy <see cref="T:System.Collections.Generic.IDictionary`2" /> parametrów wejściowych, określony limit czasu i unikatowym identyfikatorem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `userState` Parametru musi być unikatowa we wszystkich aktualnie uruchomionych <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> operacje dla bieżącego działania. Jeśli `userState` nie jest unikatowa, <xref:System.ArgumentException> jest generowany. `userState` Służy do identyfikowania przepływu pracy w <xref:System.Activities.WorkflowInvoker.InvokeCompleted>i Anuluj przy użyciu przepływu pracy <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Aby otrzymać powiadomienie po zakończeniu przepływu pracy, obsługi <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Jeśli przepływ pracy nie zostanie zakończone w ramach określonego limitu czasu przepływu pracy zostało przerwane i <xref:System.TimeoutException> jest generowany.  
  
> [!NOTE]
>  <xref:System.TimeoutException> Jest tylko element zgłaszany, gdy upłynie limit czasu, a przepływ pracy przestanie być bezczynne podczas wykonywania. Przepływ pracy, który będzie trwało dłużej niż interwał określony limit czasu, aby ukończyć zakończy się pomyślnie, jeśli przepływ pracy przejdzie w stan bezczynności.  
  
 Ta metoda wywołuje asynchronicznie za pomocą opartego na zdarzeniach asynchroniczne wzorcu przepływ pracy. Aby uzyskać więcej informacji, zobacz [oparty na zdarzeniach asynchroniczny wzorzec — Przegląd](http://go.microsoft.com/fwlink/?LinkId=141765).  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po zakończeniu tych przepływu pracy są pobierane w <xref:System.Activities.WorkflowInvoker.InvokeCompleted> programu obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt; InvokeCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Activities.InvokeCompletedEventArgs&gt; InvokeCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Activities.WorkflowInvoker.InvokeCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event InvokeCompleted As EventHandler(Of InvokeCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Activities::InvokeCompletedEventArgs ^&gt; ^ InvokeCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy przepływ pracy wywołany przez jedną z <see cref="Overload:System.Activities.WorkflowInvoker.InvokeAsync" /> przeciążenia zostało zakończone lub anulowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługi, aby ustalić, czy przepływ pracy wywołany z jednym z <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> przeciążenia została ukończona pomyślnie i pobrać argumenty wyjściowe ukończone przepływu pracy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywoływanie składające się z przepływu pracy `LongRunningDiceRoll` działania. `LongRunningDiceRoll` Działanie ma dwa argumenty danych wyjściowych reprezentujące wyniki operacji zbiorczego grupowane. Po zakończeniu tych przepływu pracy są pobierane w <xref:System.Activities.WorkflowInvoker.InvokeCompleted> programu obsługi.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
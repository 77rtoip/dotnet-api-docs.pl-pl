<Type Name="EntityConnection" FullName="System.Data.EntityClient.EntityConnection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="384a4e9b8077be465ec13086c481928809fbf963" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39833040" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class EntityConnection : System.Data.Common.DbConnection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit EntityConnection extends System.Data.Common.DbConnection" />
  <TypeSignature Language="DocId" Value="T:System.Data.EntityClient.EntityConnection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityConnection&#xA;Inherits DbConnection" />
  <TypeSignature Language="C++ CLI" Value="public ref class EntityConnection sealed : System::Data::Common::DbConnection" />
  <TypeSignature Language="F#" Value="type EntityConnection = class&#xA;    inherit DbConnection" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbConnection</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera odwołanie do modelu koncepcyjnego i połączenie ze źródłem danych. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uniknąć przypadkowo umieszczenie obiektów, takich jak <xref:System.Data.Common.CommandTrees> i <xref:System.Data.Objects.ObjectContext> nie jest zsynchronizowany z ich metadanymi <xref:System.Data.EntityClient.EntityConnection> zablokować jej metadane. Brak zmian do parametrów połączenia są dozwolone po metadanych jest zablokowany. Poniżej przedstawiono dwa scenariusze, w których jest zablokowany metadanych:  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest konstruowany przy użyciu domyślnego konstruktora, lub za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.String%29> konstruktora, który akceptuje parametry połączenia. W obu przypadkach parametry połączenia można zmieniać wiele razy przed otwarciem połączenia. Wywoływanie <xref:System.Data.EntityClient.EntityConnection.Open%2A> lub <xref:System.Data.EntityClient.EntityConnection.GetMetadataWorkspace%2A> blokad metadanych.  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest tworzony za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.Data.Metadata.Edm.MetadataWorkspace%2CSystem.Data.Common.DbConnection%29> konstruktora, który akceptuje <xref:System.Data.Metadata.Edm.MetadataWorkspace> i <xref:System.Data.Common.DbConnection>. W tym przypadku metadanych jest zablokowany podczas konstruowania. Brak zmian do parametrów połączenia nigdy nie są dozwolone.  
  
 Podczas ładowania metadanych <xref:System.Data.EntityClient.EntityConnection> sprawdza, czy modelu koncepcyjnego, model magazynu i pliku mapowania są wszystkie dostępne.  
  
 Aby uzyskać przykłady kodu, zobacz [Praca z EntityClient](http://msdn.microsoft.com/library/dec4728c-8dff-4e30-abe0-0f78fb5d5af5).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.EntityClient.EntityConnection" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uniknąć przypadkowo umieszczenie obiektów, takich jak <xref:System.Data.Common.CommandTrees> i <xref:System.Data.Objects.ObjectContext> nie jest zsynchronizowany z ich metadanymi <xref:System.Data.EntityClient.EntityConnection> zablokować jej metadane. Brak zmian do parametrów połączenia są dozwolone po metadanych jest zablokowany. Poniżej przedstawiono dwa scenariusze, w których jest zablokowany metadanych:  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest konstruowany przy użyciu domyślnego konstruktora, lub za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.String%29> konstruktora, który akceptuje parametry połączenia. W obu przypadkach parametry połączenia można zmieniać wiele razy przed otwarciem połączenia. Wywoływanie <xref:System.Data.EntityClient.EntityConnection.Open%2A> lub <xref:System.Data.EntityClient.EntityConnection.GetMetadataWorkspace%2A> blokad metadanych.  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest tworzony za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.Data.Metadata.Edm.MetadataWorkspace%2CSystem.Data.Common.DbConnection%29> konstruktora, który akceptuje <xref:System.Data.Metadata.Edm.MetadataWorkspace> i <xref:System.Data.Common.DbConnection>. W tym przypadku metadanych jest zablokowany podczas konstruowania. Brak zmian do parametrów połączenia nigdy nie są dozwolone.  
  
 Podczas ładowania metadanych <xref:System.Data.EntityClient.EntityConnection> sprawdza, czy modelu koncepcyjnego, model magazynu i pliku mapowania są wszystkie dostępne.  
  
 Aby uzyskać przykłady kodu, zobacz [Praca z EntityClient](http://msdn.microsoft.com/library/dec4728c-8dff-4e30-abe0-0f78fb5d5af5).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityConnection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.EntityClient.EntityConnection" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uniknąć przypadkowo umieszczenie obiektów, takich jak <xref:System.Data.Common.CommandTrees> i <xref:System.Data.Objects.ObjectContext> nie jest zsynchronizowany z ich metadanymi <xref:System.Data.EntityClient.EntityConnection> zablokować jej metadane. Brak zmian do parametrów połączenia są dozwolone po metadanych jest zablokowany. Poniżej przedstawiono dwa scenariusze, w których jest zablokowany metadanych:  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest konstruowany przy użyciu domyślnego konstruktora, lub za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.String%29> konstruktora, który akceptuje parametry połączenia. W obu przypadkach parametry połączenia można zmieniać wiele razy przed otwarciem połączenia. Wywoływanie <xref:System.Data.EntityClient.EntityConnection.Open%2A> lub <xref:System.Data.EntityClient.EntityConnection.GetMetadataWorkspace%2A> blokad metadanych.  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest tworzony za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.Data.Metadata.Edm.MetadataWorkspace%2CSystem.Data.Common.DbConnection%29> konstruktora, który akceptuje <xref:System.Data.Metadata.Edm.MetadataWorkspace> i <xref:System.Data.Common.DbConnection>. W tym przypadku metadanych jest zablokowany podczas konstruowania. Brak zmian do parametrów połączenia nigdy nie są dozwolone.  
  
 Podczas ładowania metadanych <xref:System.Data.EntityClient.EntityConnection> sprawdza, czy modelu koncepcyjnego, model magazynu i pliku mapowania są wszystkie dostępne.  
  
 Aby uzyskać przykłady kodu, zobacz [Praca z EntityClient](http://msdn.microsoft.com/library/dec4728c-8dff-4e30-abe0-0f78fb5d5af5).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityConnection (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityConnection(System::String ^ connectionString);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityClient.EntityConnection : string -&gt; System.Data.EntityClient.EntityConnection" Usage="new System.Data.EntityClient.EntityConnection connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Parametry połączenia specyficzne dla dostawcy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.EntityClient.EntityConnection" /> klasy, w oparciu o parametry połączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generuj nazwanych parametrów połączenia przechowywanych w pliku konfiguracji aplikacji. Te parametry połączenia o nazwie mogą być dostarczane zamiast `connectionString` parametru podczas tworzenia wystąpienia <xref:System.Data.EntityClient.EntityConnection> klasy.  
  
 Aby uniknąć przypadkowo umieszczanie obiektów <xref:System.Data.Common.CommandTrees> i <xref:System.Data.Objects.ObjectContext> nie jest zsynchronizowany z ich metadanymi <xref:System.Data.EntityClient.EntityConnection> zablokować jej metadane. Brak zmian do parametrów połączenia są dozwolone po metadanych jest zablokowany. Poniżej przedstawiono dwa scenariusze, w których jest zablokowany metadanych:  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest konstruowany przy użyciu domyślnego konstruktora, lub za pomocą tego konstruktora (<xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.String%29>), który akceptuje parametry połączenia. W obu przypadkach parametry połączenia można zmieniać wiele razy przed otwarciem połączenia. Wywoływanie <xref:System.Data.EntityClient.EntityConnection.Open%2A> lub <xref:System.Data.EntityClient.EntityConnection.GetMetadataWorkspace%2A> blokad metadanych.  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest tworzony za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.Data.Metadata.Edm.MetadataWorkspace%2CSystem.Data.Common.DbConnection%29> konstruktora, który akceptuje <xref:System.Data.Metadata.Edm.MetadataWorkspace> i <xref:System.Data.Common.DbConnection>. W tym przypadku metadanych jest zablokowany podczas konstruowania. Brak zmian do parametrów połączenia nigdy nie są dozwolone.  
  
 Podczas ładowania metadanych <xref:System.Data.EntityClient.EntityConnection> sprawdza, czy modelu koncepcyjnego, model magazynu i pliku mapowania są wszystkie dostępne.  
  
 Aby uzyskać przykłady kodu, zobacz [Praca z EntityClient](http://msdn.microsoft.com/library/dec4728c-8dff-4e30-abe0-0f78fb5d5af5).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podano słowo kluczowe parametrów połączenia nieprawidłowy lub nie podano słowo kluczowe parametrów połączenia wymagane.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityConnection (System.Data.Metadata.Edm.MetadataWorkspace workspace, System.Data.Common.DbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.Metadata.Edm.MetadataWorkspace workspace, class System.Data.Common.DbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.#ctor(System.Data.Metadata.Edm.MetadataWorkspace,System.Data.Common.DbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workspace As MetadataWorkspace, connection As DbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityConnection(System::Data::Metadata::Edm::MetadataWorkspace ^ workspace, System::Data::Common::DbConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityClient.EntityConnection : System.Data.Metadata.Edm.MetadataWorkspace * System.Data.Common.DbConnection -&gt; System.Data.EntityClient.EntityConnection" Usage="new System.Data.EntityClient.EntityConnection (workspace, connection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workspace" Type="System.Data.Metadata.Edm.MetadataWorkspace" />
        <Parameter Name="connection" Type="System.Data.Common.DbConnection" />
      </Parameters>
      <Docs>
        <param name="workspace">A <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> ma zostać skojarzony z tym <see cref="T:System.Data.EntityClient.EntityConnection" />.</param>
        <param name="connection">Połączenie, dla tego źródła danych bazowych <see cref="T:System.Data.EntityClient.EntityConnection" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.EntityClient.EntityConnection" /> klasy z określonym <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> i <see cref="T:System.Data.Common.DbConnection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor pozwala na tworzenie <xref:System.Data.EntityClient.EntityConnection> z metadanych, nie z pliku na dysku lub z zasobu osadzonego w zestawie.  
  
 Aby uniknąć przypadkowo umieszczenie obiektów, takich jak <xref:System.Data.Common.CommandTrees> i <xref:System.Data.Objects.ObjectContext> nie jest zsynchronizowany z ich metadanymi <xref:System.Data.EntityClient.EntityConnection> zablokować jej metadane. Brak zmian do parametrów połączenia są dozwolone po metadanych jest zablokowany. Poniżej przedstawiono dwa scenariusze, w których jest zablokowany metadanych:  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest konstruowany przy użyciu domyślnego konstruktora, lub za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.String%29> konstruktora, który akceptuje parametry połączenia. W obu przypadkach parametry połączenia można zmieniać wiele razy przed otwarciem połączenia. Wywoływanie <xref:System.Data.EntityClient.EntityConnection.Open%2A> lub <xref:System.Data.EntityClient.EntityConnection.GetMetadataWorkspace%2A> blokad metadanych.  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest tworzony za pomocą tego konstruktora (<xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.Data.Metadata.Edm.MetadataWorkspace%2CSystem.Data.Common.DbConnection%29>), który akceptuje <xref:System.Data.Metadata.Edm.MetadataWorkspace> i <xref:System.Data.Common.DbConnection>. W tym przypadku metadanych jest zablokowany podczas konstruowania. Brak zmian do parametrów połączenia nigdy nie są dozwolone.  
  
 Podczas ładowania metadanych <xref:System.Data.EntityClient.EntityConnection> sprawdza, czy modelu koncepcyjnego, model magazynu i pliku mapowania są wszystkie dostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="workspace" /> Lub <paramref name="connection" /> parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Brak modelu koncepcyjnego z obszaru roboczego.  
  
—lub— 
Brakuje pliku mapowania z obszaru roboczego.  
  
—lub— 
Brak modelu magazynu z obszaru roboczego.  
  
—lub— 
<paramref name="connection" /> Nie jest w stanie zamkniętym.</exception>
        <exception cref="T:System.Data.ProviderIncompatibleException">
          <paramref name="connection" /> Nie jest od dostawcy ADO.NET Entity Framework na zgodną.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginDbTransaction">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbTransaction BeginDbTransaction (System.Data.IsolationLevel isolationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbTransaction BeginDbTransaction(valuetype System.Data.IsolationLevel isolationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.BeginDbTransaction(System.Data.IsolationLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbTransaction ^ BeginDbTransaction(System::Data::IsolationLevel isolationLevel);" />
      <MemberSignature Language="F#" Value="override this.BeginDbTransaction : System.Data.IsolationLevel -&gt; System.Data.Common.DbTransaction" Usage="entityConnection.BeginDbTransaction isolationLevel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isolationLevel" Type="System.Data.IsolationLevel" />
      </Parameters>
      <Docs>
        <param name="isolationLevel">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginTransaction">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się transakcji bazy danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.EntityClient.EntityTransaction BeginTransaction ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityClient.EntityTransaction BeginTransaction() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.BeginTransaction" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction () As EntityTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityClient::EntityTransaction ^ BeginTransaction();" />
      <MemberSignature Language="F#" Value="override this.BeginTransaction : unit -&gt; System.Data.EntityClient.EntityTransaction" Usage="entityConnection.BeginTransaction " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityClient.EntityTransaction</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się transakcji przy użyciu podstawowego dostawcy.</summary>
        <returns>Nowy <see cref="T:System.Data.EntityClient.EntityTransaction" />. Zwrócony <see cref="T:System.Data.EntityClient.EntityTransaction" /> wystąpienia później może być skojarzony z <see cref="T:System.Data.EntityClient.EntityCommand" /> można wykonać polecenia w ramach tej transakcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.EntityClient.EntityConnection.BeginTransaction%2A> Metoda używa <xref:System.Data.IsolationLevel.Unspecified> poziom izolacji transakcji. Aby określić poziom izolacji różnych, należy wywołać <xref:System.Data.EntityClient.EntityConnection.BeginTransaction%2A>. Ta wartość może być interpretowane inaczej przez różnych dostawców podstawowych. Chcąc aplikacji jako przenośne w ramach wielu dostawców, należy go jawnie określić poziom izolacji transakcji przez wywołanie metody <xref:System.Data.EntityClient.EntityConnection.BeginTransaction%2A>.  
  
 W każdej określonej chwili może istnieć nie więcej niż jednej aktywnej transakcji, który został utworzony za pomocą <xref:System.Data.EntityClient.EntityConnection.BeginTransaction%2A>. Próba wywołania wszystkich <xref:System.Data.EntityClient.EntityConnection.BeginTransaction%2A> przeciążenia na <xref:System.Data.EntityClient.EntityConnection> , jest już aktualne wyniki transakcji <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Źródłowy dostawca nie jest znany.  
  
—lub— 
Wywołanie <see cref="M:System.Data.EntityClient.EntityConnection.BeginTransaction" /> przeprowadzono <see cref="T:System.Data.EntityClient.EntityConnection" /> ma już bieżącej transakcji.  
  
—lub— 
Stan <see cref="T:System.Data.EntityClient.EntityConnection" /> nie <see cref="F:System.Data.ConnectionState.Open" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.EntityClient.EntityTransaction BeginTransaction (System.Data.IsolationLevel isolationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityClient.EntityTransaction BeginTransaction(valuetype System.Data.IsolationLevel isolationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.BeginTransaction(System.Data.IsolationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityClient::EntityTransaction ^ BeginTransaction(System::Data::IsolationLevel isolationLevel);" />
      <MemberSignature Language="F#" Value="override this.BeginTransaction : System.Data.IsolationLevel -&gt; System.Data.EntityClient.EntityTransaction" Usage="entityConnection.BeginTransaction isolationLevel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityClient.EntityTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isolationLevel" Type="System.Data.IsolationLevel" />
      </Parameters>
      <Docs>
        <param name="isolationLevel">Poziom izolacji transakcji.</param>
        <summary>Rozpoczyna się transakcji z poziomu izolacji określony przy użyciu podstawowego dostawcy.</summary>
        <returns>Nowy <see cref="T:System.Data.EntityClient.EntityTransaction" />. Zwrócony <see cref="T:System.Data.EntityClient.EntityTransaction" /> wystąpienia później może być skojarzony z <see cref="T:System.Data.EntityClient.EntityCommand" /> można wykonać polecenia w ramach tej transakcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W każdej określonej chwili może istnieć nie więcej niż jednej aktywnej transakcji, który został utworzony za pomocą <xref:System.Data.EntityClient.EntityConnection.BeginTransaction%2A>. Próba wywołania wszystkich <xref:System.Data.EntityClient.EntityConnection.BeginTransaction%2A> przeciążenia na <xref:System.Data.EntityClient.EntityConnection> , jest już aktualne wyniki transakcji <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Źródłowy dostawca nie jest znany.  
  
—lub— 
Wywołanie <see cref="M:System.Data.EntityClient.EntityConnection.BeginTransaction" /> przeprowadzono <see cref="T:System.Data.EntityClient.EntityConnection" /> ma już bieżącej transakcji.  
  
—lub— 
Stan <see cref="T:System.Data.EntityClient.EntityConnection" /> nie <see cref="F:System.Data.ConnectionState.Open" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChangeDatabase">
      <MemberSignature Language="C#" Value="public override void ChangeDatabase (string databaseName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ChangeDatabase(string databaseName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.ChangeDatabase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ChangeDatabase (databaseName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ChangeDatabase(System::String ^ databaseName);" />
      <MemberSignature Language="F#" Value="override this.ChangeDatabase : string -&gt; unit" Usage="entityConnection.ChangeDatabase databaseName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="databaseName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="databaseName">Nieobsługiwane.</param>
        <summary>Nieobsługiwane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.EntityClient.EntityConnection.ChangeDatabase%2A> Wymagana jest metoda, podczas wyprowadzania z <xref:System.Data.Common.DbConnection>. Ta metoda nie jest obsługiwana i zgłosi <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kiedy metoda jest wywoływana.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="entityConnection.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka połączenie z bazą danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródłowy dostawca danych nie jest znany, wywołanie <xref:System.Data.EntityClient.EntityConnection.Close%2A> nic nie robi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wystąpił błąd podczas zamykania połączenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionString">
      <MemberSignature Language="C#" Value="public override string ConnectionString { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionString" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityClient.EntityConnection.ConnectionString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionString { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionString : string with get, set" Usage="System.Data.EntityClient.EntityConnection.ConnectionString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Data.EntityClient.EntityConnection" /> parametry połączenia.</summary>
        <value>Parametry połączenia wymagane do nawiązania początkowego połączenia ze źródłem danych. Wartością domyślną jest ciąg pusty. Połączenia zamknięte aktualnie ustawione jest zwracana wartość. Jeśli wartość nie została ustawiona, zwracany jest pusty ciąg.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `EntityClient` Parametry połączenia, który składa się z sekwencji słów kluczowych/pary wartości, parametr rozdzielone średnikami. Znak równości (=) łączy każde słowo kluczowe i jego wartość. W poniższej tabeli wymieniono prawidłowe nazwy wartości — słowo kluczowe w <xref:System.Data.EntityClient.EntityConnection.ConnectionString%2A>.  
  
|Słowo kluczowe|Opis|  
|-------------|-----------------|  
|`Provider`|Jeśli wymagane `Name` — słowo kluczowe nie jest określony. Nazwa dostawcy, która służy do pobierania <xref:System.Data.Common.DbProviderFactory> obiektu źródłowego dostawcy. Ta wartość jest stała.<br /><br /> Gdy `Name` — słowo kluczowe jest niedostępna w parametrach połączenia niepusta wartość dla `Provider` — słowo kluczowe jest wymagana. This — słowo kluczowe jest wzajemnie wykluczających się przy użyciu `Name` — słowo kluczowe.|  
|`Provider Connection String`|Opcjonalna. Określa parametry połączenia specyficzne dla dostawcy, który jest przekazywany do bazowego źródła danych. Ten ciąg połączenia jest wyrażany za pomocą prawidłową — słowo kluczowe/pary wartości dla dostawcy danych. Nieprawidłowy `Provider Connection String` spowoduje błąd w czasie wykonywania, gdy zostanie on oceniony przez źródło danych.<br /><br /> This — słowo kluczowe jest wzajemnie wykluczających się przy użyciu `Name` — słowo kluczowe.<br /><br /> Wartość `Provider Connection String` muszą być ujęte w cudzysłowy. Oto przykład:<br /><br /> `Provider Connection String ="Server=serverName; User ID = userID";`<br /><br /> Poniższy przykład nie będzie działać:<br /><br /> `Provider Connection String =Server=serverName; User ID = userID`|  
|`Metadata`|Jeśli wymagane `Name` — słowo kluczowe nie jest określony. Rozdzielany potoku lista katalogów, plików i lokalizacje zasobów, w którym model i informacje dotyczące mapowania. Oto przykład:<br /><br /> `Metadata=`<br /><br /> `c:\model &#124; c:\model\sql\mapping.msl;`<br /><br /> Spacje na każdej stronie separatora potoku są ignorowane.<br /><br /> This — słowo kluczowe jest wzajemnie wykluczających się przy użyciu `Name` — słowo kluczowe.|  
|`Name`|Aplikację można opcjonalnie określić nazwę połączenia w pliku konfiguracyjnym aplikacji, który zawiera wartości parametrów połączeń wymaganych — słowo kluczowe i wartości. W tym przypadku nie podajesz je bezpośrednio w parametrach połączenia. `Name` — Słowo kluczowe nie jest dozwolona w pliku konfiguracji.<br /><br /> Gdy `Name` — słowo kluczowe jest niedostępna w parametrach połączenia, wartości niepuste dostawcy — słowo kluczowe jest wymagana.<br /><br /> This — słowo kluczowe jest wzajemnie wykluczających się przy użyciu wszystkich innych połączenia ciąg słów kluczowych.|  
  
 Aplikacja może dostarczyć — słowo kluczowe/wartości bezpośrednio we <xref:System.Data.EntityClient.EntityConnection.ConnectionString%2A> właściwości lub jest on można określić wartość dla `Name` — słowo kluczowe. Jeśli `Name` — słowo kluczowe zostanie określona, połączenie — słowo kluczowe/wartości ciągu są pobierane z pliku konfiguracji aplikacji, w następujący sposób:  
  
 `Name=AdventureWorksEntities;`  
  
 Jeśli `Name` słowo kluczowe jest używane w <xref:System.Data.EntityClient.EntityConnection.ConnectionString%2A> właściwości innych słów kluczowych nie są dozwolone. `Name` — Słowo kluczowe odwołuje się do nazwanych parametrów połączenia przechowywanych w `connectionStrings` sekcji w pliku konfiguracyjnym aplikacji, jak pokazano w poniższym przykładzie. `Provider`, `Metadata`, I `Provider Connection String` wartości są pobierane z pliku konfiguracji w czasie wykonywania.  
  
  
  
 Słowo kluczowe/pary wartości, również mogą być dostarczane bezpośrednio w <xref:System.Data.EntityClient.EntityConnection.ConnectionString%2A> właściwości, jak pokazano w poniższym przykładzie. W tym przypadku `Name` — słowo kluczowe nie jest używany.  
  
```  
"Provider=System.Data.SqlClient;  
Metadata=c:\metadata|c:\Metadata\Sql;  
Provider Connection String= 'Data Source=localhost;  
    Initial Catalog=AdventureWorks;Integrated Security=True;Connection Timeout=60' "  
```  
  
 Aby uniknąć przypadkowo umieszczenie obiektów, takich jak <xref:System.Data.Common.CommandTrees> i <xref:System.Data.Objects.ObjectContext> nie jest zsynchronizowany z ich metadanymi <xref:System.Data.EntityClient.EntityConnection> zablokować jej metadane. Brak zmian do parametrów połączenia są dozwolone po metadanych jest zablokowany. Poniżej przedstawiono dwa scenariusze, w których jest zablokowany metadanych:  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest konstruowany przy użyciu domyślnego konstruktora, lub za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.String%29> konstruktora, który akceptuje parametry połączenia. W obu przypadkach parametry połączenia można zmieniać wiele razy przed otwarciem połączenia. Wywoływanie <xref:System.Data.EntityClient.EntityConnection.Open%2A> lub <xref:System.Data.EntityClient.EntityConnection.GetMetadataWorkspace%2A> blokad metadanych.  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest tworzony za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.Data.Metadata.Edm.MetadataWorkspace%2CSystem.Data.Common.DbConnection%29> konstruktora, który akceptuje <xref:System.Data.Metadata.Edm.MetadataWorkspace> i <xref:System.Data.Common.DbConnection>. W tym przypadku metadanych jest zablokowany podczas konstruowania. Brak zmian do parametrów połączenia nigdy nie są dozwolone.  
  
 Podczas ładowania metadanych <xref:System.Data.EntityClient.EntityConnection> sprawdza, czy modelu koncepcyjnego, model magazynu i pliku mapowania są wszystkie dostępne.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Data.EntityClient.EntityConnectionStringBuilder> w połączeniu z <xref:System.Data.SqlClient.SqlConnectionStringBuilder>. Ten kod ustawia właściwości `SqlConnectionStringBuilder` utworzyć <xref:System.Data.SqlClient.SqlConnection> ciąg, który dostarcza część podstawowego dostawcy połączenia. Należy pamiętać, że `Provider` nie można ustawić nazwy przy użyciu `SqlConnectionStringBuilder`, ponieważ nie wykorzystuje ona prawidłowy `SqlConnection` składni. Ten kod tworzy <xref:System.Data.EntityClient.EntityConnection> ciągów, ustawiając `EntityConnectionStringBuilder` właściwości.  
  
 [!code-csharp[eSQLBasicExamples#BuildingConnectionStringWithEntityCommand](~/samples/snippets/csharp/VS_Snippets_Data/eSQLBasicExamples/CS/Program.cs#buildingconnectionstringwithentitycommand)]
 [!code-vb[eSQLBasicExamples#BuildingConnectionStringWithEntityCommand](~/samples/snippets/visualbasic/VS_Snippets_Data/eSQLBasicExamples/VB/Program.vb#buildingconnectionstringwithentitycommand)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Próbowano ustawić <see cref="P:System.Data.EntityClient.EntityConnection.ConnectionString" /> właściwości po <see cref="T:System.Data.EntityClient.EntityConnection" />firmy <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> został zainicjowany. <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> Jest inicjowane, gdy <see cref="T:System.Data.EntityClient.EntityConnection" /> wystąpienia jest tworzony za pomocą przeciążenia, które przyjmuje <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> jako parametr, lub gdy <see cref="T:System.Data.EntityClient.EntityConnection" /> wystąpienie zostało otwarte.</exception>
        <exception cref="T:System.ArgumentException">Podano słowo kluczowe parametrów połączenia nieprawidłowy lub nie podano słowo kluczowe parametrów połączenia wymagane.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionTimeout">
      <MemberSignature Language="C#" Value="public override int ConnectionTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ConnectionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityClient.EntityConnection.ConnectionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ConnectionTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ConnectionTimeout { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionTimeout : int" Usage="System.Data.EntityClient.EntityConnection.ConnectionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę sekund oczekiwania podczas próby nawiązania połączenia przed końcowy próby i wygenerowaniem błędu.</summary>
        <value>Czas (w sekundach) oczekiwania na połączenie, aby otworzyć. Wartość domyślna to źródłowy dostawca danych domyślny limit czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwraca zero, jeśli źródłowy dostawca danych nie jest znany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podana wartość jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCommand">
      <MemberSignature Language="C#" Value="public System.Data.EntityClient.EntityCommand CreateCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityClient.EntityCommand CreateCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.CreateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCommand () As EntityCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityClient::EntityCommand ^ CreateCommand();" />
      <MemberSignature Language="F#" Value="override this.CreateCommand : unit -&gt; System.Data.EntityClient.EntityCommand" Usage="entityConnection.CreateCommand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityClient.EntityCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Data.EntityClient.EntityCommand" />, za pomocą <see cref="P:System.Data.EntityClient.EntityCommand.Connection" /> równa to <see cref="T:System.Data.EntityClient.EntityConnection" />.</summary>
        <returns>
          <see cref="T:System.Data.EntityClient.EntityCommand" /> Obiektu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Nazwa podstawowego dostawcy danych nie jest znany.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDbCommand">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbCommand CreateDbCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbCommand CreateDbCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.CreateDbCommand" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateDbCommand () As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbCommand ^ CreateDbCommand();" />
      <MemberSignature Language="F#" Value="override this.CreateDbCommand : unit -&gt; System.Data.Common.DbCommand" Usage="entityConnection.CreateDbCommand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Database">
      <MemberSignature Language="C#" Value="public override string Database { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Database" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityClient.EntityConnection.Database" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Database As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Database { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Database : string" Usage="System.Data.EntityClient.EntityConnection.Database" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę aktualnie używana baza danych lub bazy danych, który będzie używany po otwarciu połączenia.</summary>
        <value>Wartość <see langword="Database" /> właściwości podstawowego dostawcy danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości określonego słowa kluczowego takich jak `Database`, która jest mapowana <xref:System.Data.EntityClient.EntityConnection.Database%2A> właściwości, można znaleźć w dokumentacji dla podstawowego dostawcy danych. Równoważne słowa kluczowe SQL Server w dokumentacji dla <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Źródłowy dostawca danych nie jest znany.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public override string DataSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityClient.EntityConnection.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DataSource As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DataSource { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSource : string" Usage="System.Data.EntityClient.EntityConnection.DataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę lub adres sieciowy źródła danych, aby nawiązać połączenie.</summary>
        <value>Nazwa źródła danych. Wartością domyślną jest ciąg pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości określonego słowa kluczowego takich jak `DataSource`, która jest mapowana <xref:System.Data.EntityClient.EntityConnection.DataSource%2A> właściwości, można znaleźć w dokumentacji dla podstawowego dostawcy danych. Równoważne słowa kluczowe SQL Server w dokumentacji dla <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Źródłowy dostawca danych nie jest znany.</exception>
      </Docs>
    </Member>
    <Member MemberName="DbProviderFactory">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbProviderFactory DbProviderFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbProviderFactory DbProviderFactory" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityClient.EntityConnection.DbProviderFactory" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DbProviderFactory As DbProviderFactory" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Data::Common::DbProviderFactory ^ DbProviderFactory { System::Data::Common::DbProviderFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DbProviderFactory : System.Data.Common.DbProviderFactory" Usage="System.Data.EntityClient.EntityConnection.DbProviderFactory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbProviderFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="entityConnection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnlistTransaction">
      <MemberSignature Language="C#" Value="public override void EnlistTransaction (System.Transactions.Transaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EnlistTransaction(class System.Transactions.Transaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.EnlistTransaction(System.Transactions.Transaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EnlistTransaction(System::Transactions::Transaction ^ transaction);" />
      <MemberSignature Language="F#" Value="override this.EnlistTransaction : System.Transactions.Transaction -&gt; unit" Usage="entityConnection.EnlistTransaction transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Transactions.Transaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Obiekt transakcji, które można zarejestrować do.</param>
        <summary>Powoduje to zarejestrowanie <see cref="T:System.Data.EntityClient.EntityConnection" /> w określonej transakcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przekazuje wywołanie do połączenia ze źródłem danych można jawnie zarejestrować w przekazanych <xref:System.Transactions.Transaction>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Stan <see cref="T:System.Data.EntityClient.EntityConnection" /> nie <see cref="F:System.Data.ConnectionState.Open" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataWorkspace">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.MetadataWorkspace GetMetadataWorkspace ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Metadata.Edm.MetadataWorkspace GetMetadataWorkspace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.GetMetadataWorkspace" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadataWorkspace () As MetadataWorkspace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Metadata::Edm::MetadataWorkspace ^ GetMetadataWorkspace();" />
      <MemberSignature Language="F#" Value="member this.GetMetadataWorkspace : unit -&gt; System.Data.Metadata.Edm.MetadataWorkspace" Usage="entityConnection.GetMetadataWorkspace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.MetadataWorkspace</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> skojarzony z tym <see cref="T:System.Data.EntityClient.EntityConnection" />.</summary>
        <returns>
          <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> Skojarzony z tym <see cref="T:System.Data.EntityClient.EntityConnection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.Metadata.Edm.MetadataWorkspace> jest tworzony automatycznie w chwili <xref:System.Data.EntityClient.EntityConnection> klasa jest tworzona. Proces tworzenia może zgłaszać wyjątki dotyczące metadanych. Metadanych jest ładowany do pamięci, a aplikacja Entity Data Model (EDM) używa tych metadanych do dostępu do informacji o źródle danych. Aby uzyskać więcej informacji, zobacz [metadanych ADO.NET](http://msdn.microsoft.com/library/196097a5-a791-4ac4-9e6a-805685d481d5).  
  
 Aby uniknąć przypadkowo umieszczenie obiektów, takich jak <xref:System.Data.Common.CommandTrees> i <xref:System.Data.Objects.ObjectContext> nie jest zsynchronizowany z ich metadanymi <xref:System.Data.EntityClient.EntityConnection> zablokować jej metadane. Brak zmian do parametrów połączenia są dozwolone po metadanych jest zablokowany. Poniżej przedstawiono dwa scenariusze, w których jest zablokowany metadanych:  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest konstruowany przy użyciu domyślnego konstruktora, lub za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.String%29> konstruktora, który akceptuje parametry połączenia. W obu przypadkach parametry połączenia mogą ulec zmianie wielokrotnie przed otwarciem połączenia. <xref:System.Data.EntityClient.EntityConnection.Open%2A> lub <xref:System.Data.EntityClient.EntityConnection.GetMetadataWorkspace%2A> blokad metadanych.  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest tworzony za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.Data.Metadata.Edm.MetadataWorkspace%2CSystem.Data.Common.DbConnection%29> konstruktora, który akceptuje <xref:System.Data.Metadata.Edm.MetadataWorkspace> i <xref:System.Data.Common.DbConnection>. W tym przypadku metadanych jest zablokowany podczas konstruowania. Brak zmian do parametrów połączenia nigdy nie są dozwolone.  
  
 Podczas ładowania metadanych <xref:System.Data.EntityClient.EntityConnection> sprawdza, czy modelu koncepcyjnego, model magazynu i pliku mapowania są wszystkie dostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.MetadataException">Parametry połączenia w tekście zawiera nieprawidłową <see langword="Metadata" /> wartość słowa kluczowego.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public override void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityClient.EntityConnection.Open" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Open();" />
      <MemberSignature Language="F#" Value="override this.Open : unit -&gt; unit" Usage="entityConnection.Open " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nawiązuje połączenie ze źródłem danych, wywołując źródłowy dostawca danych <see langword="Open" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uniknąć przypadkowo umieszczenie obiektów, takich jak <xref:System.Data.Common.CommandTrees> i <xref:System.Data.Objects.ObjectContext> nie jest zsynchronizowany z ich metadanymi <xref:System.Data.EntityClient.EntityConnection> zablokować jej metadane. Brak zmian do parametrów połączenia są dozwolone po metadanych jest zablokowany. Poniżej przedstawiono dwa scenariusze, w których jest zablokowany metadanych:  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest konstruowany przy użyciu domyślnego konstruktora, lub za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.String%29> konstruktora, który akceptuje parametry połączenia. W obu przypadkach parametry połączenia można zmieniać wiele razy przed otwarciem połączenia. Wywoływanie <xref:System.Data.EntityClient.EntityConnection.Open%2A> lub <xref:System.Data.EntityClient.EntityConnection.GetMetadataWorkspace%2A> blokad metadanych.  
  
-   <xref:System.Data.EntityClient.EntityConnection> Wystąpienia jest tworzony za pomocą <xref:System.Data.EntityClient.EntityConnection.%23ctor%28System.Data.Metadata.Edm.MetadataWorkspace%2CSystem.Data.Common.DbConnection%29> Konstruktor, który akceptuje <xref:System.Data.Metadata.Edm.MetadataWorkspace> i <xref:System.Data.Common.DbConnection>. W tym przypadku metadanych jest zablokowany podczas konstruowania. Brak zmian do parametrów połączenia nigdy nie są dozwolone.  
  
 Podczas ładowania metadanych <xref:System.Data.EntityClient.EntityConnection> sprawdza, czy modelu koncepcyjnego, model magazynu i pliku mapowania są wszystkie dostępne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wystąpi błąd podczas otwierania połączenia lub nazwę źródłowy dostawca danych nie jest znany.</exception>
        <exception cref="T:System.Data.MetadataException">Parametry połączenia w tekście zawiera nieprawidłową <see langword="Metadata" /> wartość słowa kluczowego.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVersion">
      <MemberSignature Language="C#" Value="public override string ServerVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServerVersion" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityClient.EntityConnection.ServerVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ServerVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ServerVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServerVersion : string" Usage="System.Data.EntityClient.EntityConnection.ServerVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg, który zawiera wersję źródła danych, z którym klient jest połączony.</summary>
        <value>Wersja źródła danych, który jest zawarty w parametrach połączenia dostawcy.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Połączenie jest zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public override System.Data.ConnectionState State { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.ConnectionState State" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityClient.EntityConnection.State" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property State As ConnectionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::ConnectionState State { System::Data::ConnectionState get(); };" />
      <MemberSignature Language="F#" Value="member this.State : System.Data.ConnectionState" Usage="System.Data.EntityClient.EntityConnection.State" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.ConnectionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Data.ConnectionState" /> właściwość źródłowy Dostawca Jeśli <see cref="T:System.Data.EntityClient.EntityConnection" /> jest otwarty. W przeciwnym razie zwraca <see cref="F:System.Data.ConnectionState.Closed" />.</summary>
        <value>
          <see cref="F:System.Data.ConnectionState.Open" />, jeśli i tylko wtedy, gdy oba <see cref="T:System.Data.EntityClient.EntityConnection" />firmy stan wewnętrzny i źródłowy dostawca <see cref="T:System.Data.ConnectionState" /> są otwarte. Jeśli <see cref="T:System.Data.EntityClient.EntityConnection" />jego stan jest otwarty, ale dostawcy <see cref="T:System.Data.ConnectionState" /> jest zamknięte, właściwość ta zwraca <see cref="F:System.Data.ConnectionState.Broken" />. W przeciwnym razie zwraca <see cref="F:System.Data.ConnectionState.Closed" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StoreConnection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection StoreConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection StoreConnection" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityClient.EntityConnection.StoreConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StoreConnection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ StoreConnection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StoreConnection : System.Data.Common.DbConnection" Usage="System.Data.EntityClient.EntityConnection.StoreConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia dostęp do podstawowego połączenia ze źródłem danych używanym przez <see cref="T:System.Data.EntityClient.EntityConnection" /> obiektu.</summary>
        <value>
          <see cref="T:System.Data.Common.DbConnection" /> Dla połączenia ze źródłem danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Data.EntityClient.EntityConnection> obiekt jest zamknięty, połączenia ze źródłem danych zwróconych zostanie zamknięte. Jeśli jest otwarty, zostanie zwrócony połączenie ze źródłem danych Otwórz. Jeśli informacje o połączeniu w źródle danych została ustawiona, zwrócona wartość jest zawsze inną niż null. Jeśli brakuje informacji połączenia źródła danych (na przykład, jeśli został użyty Konstruktor domyślny, a potem ustawiono nie parametrów połączenia), zwracany jest odwołanie o wartości null.  
  
 Tego samego połączenia źródła danych używane przez program Entity Framework mogą być udostępniane w innych częściach aplikacji. Połączenia ze źródłem danych jest zwracana jako <xref:System.Data.Common.DbConnection> obiektu z <xref:System.Data.Objects.ObjectContext.Connection%2A> właściwość <xref:System.Data.Objects.ObjectContext>, lub z <xref:System.Data.EntityClient.EntityConnection.StoreConnection%2A> właściwość <xref:System.Data.EntityClient.EntityConnection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
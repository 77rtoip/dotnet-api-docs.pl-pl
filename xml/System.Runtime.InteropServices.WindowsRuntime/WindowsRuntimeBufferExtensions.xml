<Type Name="WindowsRuntimeBufferExtensions" FullName="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b16353af8e7f80818f7f979e4f22574d4ed9073c" /><Meta Name="ms.sourcegitcommit" Value="efa3ad59f4ee23bbc2824414ef546bbf142c360e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/02/2019" /><Meta Name="ms.locfileid" Value="67506414" /></Metadata><TypeSignature Language="C#" Value="public static class WindowsRuntimeBufferExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit WindowsRuntimeBufferExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions" />
  <TypeSignature Language="VB.NET" Value="Public Module WindowsRuntimeBufferExtensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsRuntimeBufferExtensions abstract sealed" />
  <TypeSignature Language="F#" Value="type WindowsRuntimeBufferExtensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="dotnet-uwp-10.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia metody rozszerzenia obsługi środowiska uruchomieniowego Windows buforów (Windows.Storage.Streams.IBuffer interface).</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer AsBuffer (this byte[] source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer AsBuffer(unsigned int8[] source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsBuffer (source As Byte()) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ AsBuffer(cli::array &lt;System::Byte&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsBuffer : byte[] -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Tablica do reprezentowania.</param>
        <summary>Zwraca interfejs Windows.Storage.Streams.IBuffer, który reprezentuje określonej tablicy bajtów.</summary>
        <returns>Interfejs Windows.Storage.Streams.IBuffer, który reprezentuje określonej tablicy bajtów.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer AsBuffer (this byte[] source, int offset, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer AsBuffer(unsigned int8[] source, int32 offset, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsBuffer (source As Byte(), offset As Integer, length As Integer) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ AsBuffer(cli::array &lt;System::Byte&gt; ^ source, int offset, int length);" />
      <MemberSignature Language="F#" Value="static member AsBuffer : byte[] * int * int -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer (source, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Tablica, która zawiera zakres bajtów, który jest reprezentowany przez IBuffer.</param>
        <param name="offset">Przesunięcie w <paramref name="source" /> gdzie rozpoczyna się w zakresie.</param>
        <param name="length">Długość zakresu, który jest reprezentowany przez IBuffer.</param>
        <summary>Zwraca interfejs Windows.Storage.Streams.IBuffer, który reprezentuje zakresu bajtów w określonej tablicy bajtów.</summary>
        <returns>Interfejs IBuffer, który reprezentuje określony zakres bajtów w <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> lub <paramref name="length" /> jest mniejsza od 0 (zero).</exception>
        <exception cref="T:System.ArgumentException">Tablica nie jest wystarczająco duży, aby służyć jako magazyn zapasowy dla IBuffer; oznacza to, że liczba bajtów w <paramref name="source" />, rozpoczynająca się w <paramref name="offset" />, jest mniejsza niż <paramref name="length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer AsBuffer (this byte[] source, int offset, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer AsBuffer(unsigned int8[] source, int32 offset, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer(System.Byte[],System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsBuffer (source As Byte(), offset As Integer, length As Integer, capacity As Integer) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ AsBuffer(cli::array &lt;System::Byte&gt; ^ source, int offset, int length, int capacity);" />
      <MemberSignature Language="F#" Value="static member AsBuffer : byte[] * int * int * int -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer (source, offset, length, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Tablica, która zawiera zakres bajtów, który jest reprezentowany przez IBuffer.</param>
        <param name="offset">Przesunięcie w <paramref name="source" /> gdzie rozpoczyna się w zakresie.</param>
        <param name="length">Wartość właściwości Length IBuffer.</param>
        <param name="capacity">Rozmiar zakres, który jest reprezentowany przez IBuffer. Właściwości pojemności IBuffer jest równa tej wartości.</param>
        <summary>Zwraca interfejs Windows.Storage.Streams.IBuffer, który reprezentuje zakresu bajtów w określonej tablicy bajtów. Ustawia właściwości Length IBuffer opcjonalnie wartość, która jest mniejsza niż pojemność.</summary>
        <returns>Interfejs IBuffer, który reprezentuje określony zakres bajtów w <paramref name="source" /> i ma wartość właściwości określonej długości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />, <paramref name="length" />, lub <paramref name="capacity" /> jest mniejsza od 0 (zero).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> jest większa niż <paramref name="capacity" />. - lub -tablicy nie jest wystarczająco duży, która będzie służyć jako magazyn zapasowy dla IBuffer; oznacza to, że liczba bajtów w <paramref name="source" />, rozpoczynająca się w <paramref name="offset" />, jest mniejsza niż <paramref name="length" /> lub <paramref name="capacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsStream">
      <MemberSignature Language="C#" Value="public static System.IO.Stream AsStream (this Windows.Storage.Streams.IBuffer source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream AsStream(class Windows.Storage.Streams.IBuffer source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsStream(Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsStream (source As IBuffer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::IO::Stream ^ AsStream(Windows::Storage::Streams::IBuffer ^ source);" />
      <MemberSignature Language="F#" Value="static member AsStream : Windows.Storage.Streams.IBuffer -&gt; System.IO.Stream" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsStream source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">IBuffer do reprezentowania jako strumień.</param>
        <summary>Zwraca strumień, który reprezentuje tej samej pamięci, który reprezentuje określony interfejs Windows.Storage.Streams.IBuffer.</summary>
        <returns>Strumień, który reprezentuje tej samej pamięci, który reprezentuje określony interfejs Windows.Storage.Streams.IBuffer.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this byte[] source, Windows.Storage.Streams.IBuffer destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(unsigned int8[] source, class Windows.Storage.Streams.IBuffer destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(System.Byte[],Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As Byte(), destination As IBuffer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;System::Byte&gt; ^ source, Windows::Storage::Streams::IBuffer ^ destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : byte[] * Windows.Storage.Streams.IBuffer -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
      </Parameters>
      <Docs>
        <param name="source">Tablica do kopiowania danych z.</param>
        <param name="destination">Bufor do kopiowania danych.</param>
        <summary>Kopie wszystkich bajtów ze źródła do buforu docelowego (Windows.Storage.Streams.IBuffer) w tablicy, zaczynając od przesunięcia 0 (zero) w obu. Metoda nie powoduje aktualizacji długość buforu miejsca docelowego.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> lub <paramref name="destination" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">Rozmiar <paramref name="source" /> przekracza pojemność <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, byte[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, unsigned int8[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, destination As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, cli::array &lt;System::Byte&gt; ^ destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * byte[] -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="destination" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Bufor do kopiowania danych z.</param>
        <param name="destination">Tablica do kopiowania danych.</param>
        <summary>Kopiuje wszystkie bajty z bufor źródłowy (Windows.Storage.Streams.IBuffer) do tablicy docelowej, rozpoczynając od przesunięcia 0 (zero) w obu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> lub <paramref name="destination" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">Rozmiar <paramref name="source" /> przekracza rozmiar okna <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, Windows.Storage.Streams.IBuffer destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, class Windows.Storage.Streams.IBuffer destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, destination As IBuffer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, Windows::Storage::Streams::IBuffer ^ destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * Windows.Storage.Streams.IBuffer -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
      </Parameters>
      <Docs>
        <param name="source">Bufor źródłowy.</param>
        <param name="destination">Bufor docelowy.</param>
        <summary>Kopiuje wszystkie bajty z bufor źródłowy (Windows.Storage.Streams.IBuffer) do bufora docelowego, rozpoczynając od przesunięcia 0 (zero) w obu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> lub <paramref name="destination" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">Rozmiar <paramref name="source" /> przekracza pojemność <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this byte[] source, int sourceIndex, Windows.Storage.Streams.IBuffer destination, uint destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(unsigned int8[] source, int32 sourceIndex, class Windows.Storage.Streams.IBuffer destination, unsigned int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(System.Byte[],System.Int32,Windows.Storage.Streams.IBuffer,System.UInt32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As Byte(), sourceIndex As Integer, destination As IBuffer, destinationIndex As UInteger, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;System::Byte&gt; ^ source, int sourceIndex, Windows::Storage::Streams::IBuffer ^ destination, System::UInt32 destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="static member CopyTo : byte[] * int * Windows.Storage.Streams.IBuffer * uint32 * int -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
        <Parameter Name="destinationIndex" Type="System.UInt32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Tablica do kopiowania danych z.</param>
        <param name="sourceIndex">Indeks w <paramref name="source" /> chcesz rozpocząć kopiowanie danych z.</param>
        <param name="destination">Bufor do kopiowania danych.</param>
        <param name="destinationIndex">Indeks w <paramref name="destination" /> chcesz rozpocząć kopiowanie danych.</param>
        <param name="count">Liczba bajtów do skopiowania.</param>
        <summary>Kopie bajtów z tablicy źródłowej do buforu docelowego (Windows.Storage.Streams.IBuffer), określając wartość początkowa indeksu w tablicy źródłowej, począwszy od indeksu w buforze docelowym, a liczba bajtów do skopiowania. Metoda nie powoduje aktualizacji właściwości długość buforu miejsca docelowego.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> lub <paramref name="destination" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />, <paramref name="sourceIndex" />, lub <paramref name="destinationIndex" /> jest mniejsza od 0 (zero).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> jest większa niż lub równa długości <paramref name="source" />. - lub -liczba bajtów w <paramref name="source" />, rozpoczynająca się w <paramref name="sourceIndex" />, jest mniejsza niż <paramref name="count" />. - lub -kopiowanie <paramref name="count" /> bajtów, rozpoczynając od <paramref name="destinationIndex" />, spowodowałoby przekroczenie pojemność <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, uint sourceIndex, byte[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, unsigned int32 sourceIndex, unsigned int8[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,System.UInt32,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, sourceIndex As UInteger, destination As Byte(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 sourceIndex, cli::array &lt;System::Byte&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * uint32 * byte[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.UInt32" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Bufor do kopiowania danych z.</param>
        <param name="sourceIndex">Indeks w <paramref name="source" /> chcesz rozpocząć kopiowanie danych z.</param>
        <param name="destination">Tablica do kopiowania danych.</param>
        <param name="destinationIndex">Indeks w <paramref name="destination" /> chcesz rozpocząć kopiowanie danych.</param>
        <param name="count">Liczba bajtów do skopiowania.</param>
        <summary>Bajty kopie z bufor źródłowy (Windows.Storage.Streams.IBuffer) do tablicy docelowej, określając wartość początkowa indeksu w buforze źródłowym, począwszy od indeksu w tablicy docelowej, a liczba bajtów do skopiowania.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> lub <paramref name="destination" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />, <paramref name="sourceIndex" />, lub <paramref name="destinationIndex" /> jest mniejsza od 0 (zero).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> jest większa niż lub równa pojemności <paramref name="source" />. - lub -<paramref name="destinationIndex" /> jest większa niż lub równa długości <paramref name="destination" />. - lub -liczba bajtów w <paramref name="source" />, rozpoczynająca się w <paramref name="sourceIndex" />, jest mniejsza niż <paramref name="count" />. - lub -kopiowanie <paramref name="count" /> bajtów, rozpoczynając od <paramref name="destinationIndex" />, przekracza rozmiar <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, uint sourceIndex, Windows.Storage.Streams.IBuffer destination, uint destinationIndex, uint count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, unsigned int32 sourceIndex, class Windows.Storage.Streams.IBuffer destination, unsigned int32 destinationIndex, unsigned int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,System.UInt32,Windows.Storage.Streams.IBuffer,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, sourceIndex As UInteger, destination As IBuffer, destinationIndex As UInteger, count As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 sourceIndex, Windows::Storage::Streams::IBuffer ^ destination, System::UInt32 destinationIndex, System::UInt32 count);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * uint32 * Windows.Storage.Streams.IBuffer * uint32 * uint32 -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.UInt32" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
        <Parameter Name="destinationIndex" Type="System.UInt32" />
        <Parameter Name="count" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="source">Bufor do kopiowania danych z.</param>
        <param name="sourceIndex">Indeks w <paramref name="source" /> chcesz rozpocząć kopiowanie danych z.</param>
        <param name="destination">Bufor do kopiowania danych.</param>
        <param name="destinationIndex">Indeks w <paramref name="destination" /> chcesz rozpocząć kopiowanie danych.</param>
        <param name="count">Liczba bajtów do skopiowania.</param>
        <summary>Bajty kopie z bufor źródłowy (Windows.Storage.Streams.IBuffer) do bufora docelowego, określając wartość początkowa indeksu w źródle, począwszy od indeksu w miejscu docelowym, a liczba bajtów do skopiowania.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> lub <paramref name="destination" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />, <paramref name="sourceIndex" />, lub <paramref name="destinationIndex" /> jest mniejsza od 0 (zero).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> jest większa niż lub równa pojemności <paramref name="source" />. - lub -<paramref name="destinationIndex" /> jest większa niż lub równa pojemności <paramref name="destination" />. - lub -liczba bajtów w <paramref name="source" />, rozpoczynająca się w <paramref name="sourceIndex" />, jest mniejsza niż <paramref name="count" />. - lub -kopiowanie <paramref name="count" /> bajtów, rozpoczynając od <paramref name="destinationIndex" />, spowodowałoby przekroczenie pojemność <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public static byte GetByte (this Windows.Storage.Streams.IBuffer source, uint byteOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 GetByte(class Windows.Storage.Streams.IBuffer source, unsigned int32 byteOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetByte(Windows.Storage.Streams.IBuffer,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetByte (source As IBuffer, byteOffset As UInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Byte GetByte(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 byteOffset);" />
      <MemberSignature Language="F#" Value="static member GetByte : Windows.Storage.Streams.IBuffer * uint32 -&gt; byte" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetByte (source, byteOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="byteOffset" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="source">Bufor, który można pobrać bajtów z.</param>
        <param name="byteOffset">Przesunięcie bajtu.</param>
        <summary>Zwraca bajt od określonego przesunięcia określonego interfejsu Windows.Storage.Streams.IBuffer.</summary>
        <returns>Bajt od określonego przesunięcia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteOffset" /> jest mniejsza od 0 (zero).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteOffset" /> jest większa niż lub równa pojemności <paramref name="source" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWindowsRuntimeBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer (this System.IO.MemoryStream underlyingStream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer(class System.IO.MemoryStream underlyingStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer(System.IO.MemoryStream)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetWindowsRuntimeBuffer (underlyingStream As MemoryStream) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ GetWindowsRuntimeBuffer(System::IO::MemoryStream ^ underlyingStream);" />
      <MemberSignature Language="F#" Value="static member GetWindowsRuntimeBuffer : System.IO.MemoryStream -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer underlyingStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingStream" Type="System.IO.MemoryStream" RefType="this" />
      </Parameters>
      <Docs>
        <param name="underlyingStream">Strumień, który zapewnia IBuffer pamięci zapasowy.</param>
        <summary>Zwraca interfejs Windows.Storage.Streams.IBuffer, który reprezentuje tej samej pamięci jako strumień pamięci określonej.</summary>
        <returns>Interfejs Windows.Storage.Streams.IBuffer, który jest zabezpieczony za pomocą tej samej pamięci, która będzie tworzyć kopię strumień pamięci określonej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWindowsRuntimeBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer (this System.IO.MemoryStream underlyingStream, int positionInStream, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer(class System.IO.MemoryStream underlyingStream, int32 positionInStream, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer(System.IO.MemoryStream,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetWindowsRuntimeBuffer (underlyingStream As MemoryStream, positionInStream As Integer, length As Integer) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ GetWindowsRuntimeBuffer(System::IO::MemoryStream ^ underlyingStream, int positionInStream, int length);" />
      <MemberSignature Language="F#" Value="static member GetWindowsRuntimeBuffer : System.IO.MemoryStream * int * int -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer (underlyingStream, positionInStream, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingStream" Type="System.IO.MemoryStream" RefType="this" />
        <Parameter Name="positionInStream" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="underlyingStream">Strumień, który udostępnia IBuffer pamięci.</param>
        <param name="positionInStream">Pozycja region pamięci współużytkowanej w <paramref name="underlyingStream" />.</param>
        <param name="length">Maksymalny rozmiar obszaru pamięci współdzielonej. Jeśli liczba bajtów w <paramref name="underlyingStream" />, począwszy od stawki <paramref name="positionInStream" />, jest mniejsza niż <paramref name="length" />, IBuffer, który jest zwracany reprezentuje tylko liczba dostępnych bajtów.</param>
        <summary>Zwraca interfejs Windows.Storage.Streams.IBuffer, który reprezentuje regionu w pamięci, która reprezentuje strumień pamięci określonej.</summary>
        <returns>Interfejs Windows.Storage.Streams.IBuffer, która jest wspierana przez regionu w pamięci, która będzie tworzyć kopię strumień pamięci określonej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="underlyingStream" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="positionInStream" /> lub <paramref name="length" /> jest mniejsza od 0 (zero).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="positionInStream" /> wykracza poza koniec <paramref name="source" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="underlyingStream" /> nie może ujawnić podstawowego buforu pamięci.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="underlyingStream" /> zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSameData">
      <MemberSignature Language="C#" Value="public static bool IsSameData (this Windows.Storage.Streams.IBuffer buffer, Windows.Storage.Streams.IBuffer otherBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSameData(class Windows.Storage.Streams.IBuffer buffer, class Windows.Storage.Streams.IBuffer otherBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.IsSameData(Windows.Storage.Streams.IBuffer,Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsSameData (buffer As IBuffer, otherBuffer As IBuffer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsSameData(Windows::Storage::Streams::IBuffer ^ buffer, Windows::Storage::Streams::IBuffer ^ otherBuffer);" />
      <MemberSignature Language="F#" Value="static member IsSameData : Windows.Storage.Streams.IBuffer * Windows.Storage.Streams.IBuffer -&gt; bool" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.IsSameData (buffer, otherBuffer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="otherBuffer" Type="Windows.Storage.Streams.IBuffer" />
      </Parameters>
      <Docs>
        <param name="buffer">Pierwszy buforu.</param>
        <param name="otherBuffer">Drugi buforu.</param>
        <summary>Zwraca wartość wskazującą, czy dwa buforów (Windows.Storage.Streams.IBuffer obiekty) reprezentują tego samego podstawowego regionu pamięci.</summary>
        <returns>wartość true, jeśli regiony pamięci, które są reprezentowane przez dwa buforów mają ten sam punkt początkowy; w przeciwnym razie wartość false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public static byte[] ToArray (this Windows.Storage.Streams.IBuffer source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ToArray(class Windows.Storage.Streams.IBuffer source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray(Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray (source As IBuffer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;System::Byte&gt; ^ ToArray(Windows::Storage::Streams::IBuffer ^ source);" />
      <MemberSignature Language="F#" Value="static member ToArray : Windows.Storage.Streams.IBuffer -&gt; byte[]" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Bufor, w których zawartość wypełniania nowej tablicy.</param>
        <summary>Zwraca nową tablicę, która jest tworzona na podstawie zawartości określonego bufora (Windows.Storage.Streams.IBuffer). Rozmiar tablicy jest wartością właściwości długości IBuffer.</summary>
        <returns>Tablica bajtów zawierająca bajty w określonym IBuffer, rozpoczynając od przesunięcie: 0 (zero), a w tym liczbę bajtów równa wartości właściwości Length IBuffer.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public static byte[] ToArray (this Windows.Storage.Streams.IBuffer source, uint sourceIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ToArray(class Windows.Storage.Streams.IBuffer source, unsigned int32 sourceIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray(Windows.Storage.Streams.IBuffer,System.UInt32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray (source As IBuffer, sourceIndex As UInteger, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;System::Byte&gt; ^ ToArray(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 sourceIndex, int count);" />
      <MemberSignature Language="F#" Value="static member ToArray : Windows.Storage.Streams.IBuffer * uint32 * int -&gt; byte[]" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray (source, sourceIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.UInt32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Bufor, w których zawartość wypełniania nowej tablicy.</param>
        <param name="sourceIndex">Indeks w <paramref name="source" /> chcesz rozpocząć kopiowanie danych z.</param>
        <param name="count">Liczba bajtów do skopiowania.</param>
        <summary>Zwraca nową tablicę, która jest tworzona na podstawie zawartości określonego bufora (Windows.Storage.Streams.IBuffer), zaczynając od określonego przesunięcia i włączając określoną liczbę bajtów.</summary>
        <returns>Tablica bajtów, która zawiera określony zakres bajtów.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> lub <paramref name="sourceIndex" /> jest mniejsza od 0 (zero).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> jest większa niż lub równa pojemności <paramref name="source" />. - lub -liczba bajtów w <paramref name="source" />, rozpoczynająca się w <paramref name="sourceIndex" />, jest mniejsza niż <paramref name="count" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
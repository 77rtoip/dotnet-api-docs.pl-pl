<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <Metadata><Meta Name="ms.openlocfilehash" Value="088e9871030da39eb83bd368e9532fcc3fa59426" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69438700" /></Metadata><TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Storyboard&#xA;Inherits ParallelTimeline" />
  <TypeSignature Language="C++ CLI" Value="public ref class Storyboard : System::Windows::Media::Animation::ParallelTimeline" />
  <TypeSignature Language="F#" Value="type Storyboard = class&#xA;    inherit ParallelTimeline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Oś czasu kontenera, która dostarcza informacje o obiektach i właściwościach dla animacji podrzędnych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Interaktywna kontrola scenorysów  
 W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem przy użyciu znaczników, należy określić <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> Właściwość <xref:System.Windows.Media.Animation.BeginStoryboard> obiektu, który go tworzy. Aby zapoznać się z przykładem [, zobacz How to: Użyj wyzwalaczy zdarzeń, aby kontrolować scenorys po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md). Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
## <a name="data-binding-and-animating-timelines"></a>Powiązanie danych i animowanie osi czasu  
 Większość właściwości osi czasu można powiązać z danymi lub animować; Jednak ze względu na sposób działania systemu chronometrażu, powiązane z danymi lub animowane osie czasu nie zachowują się jak inne powiązane z danymi lub obiekty animowane. Aby zrozumieć ich zachowanie, można zrozumieć, co to znaczy, aby aktywować oś czasu.  
  
 Po aktywowaniu osi czasu kopie są wykonywane z osi czasu i jej podrzędnych osi czasu. Te kopie są zamrożone (tylko do odczytu) <xref:System.Windows.Media.Animation.Clock> i obiekty są tworzone z nich. Te zegary służą do poprawnego działania animowania właściwości. Jeśli oś czasu jest związana z danymi lub animowanych, tworzona jest migawka bieżących wartości podczas tworzenia zegara. Mimo że oryginalna oś czasu może nadal zmieniać, jego zegar nie jest.  
  
 Aby oś czasu mogła odzwierciedlać powiązanie danych lub zmiany animacji, należy utworzyć jej zegar. Zegary nie są odtwarzane automatycznie. Poniżej przedstawiono kilka sposobów stosowania zmian osi czasu:  
  
-   Jeśli oś czasu jest lub należy do <xref:System.Windows.Media.Animation.Storyboard>, można wprowadzić zmiany przez ponowne zastosowanie jej scenorysu <xref:System.Windows.Media.Animation.BeginStoryboard> przy użyciu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody lub. Powoduje to również ponowne uruchomienie animacji. W kodzie, można użyć <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> metody, aby przejść do poprzedniej pozycji scenorysu.  
  
-   Jeśli zastosowano animację bezpośrednio do właściwości przy użyciu <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> metody, należy ponownie <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> wywołać metodę i przekazać ją do zmodyfikowanej animacji.  
  
-   Jeśli pracujesz bezpośrednio na poziomie zegara, Utwórz i Zastosuj nowy zestaw zegarów i użyj ich, aby zastąpić poprzedni zestaw utworzonych zegarów.  
  
 Aby zapoznać się z przykładem animacji powiązanej z danymi, zobacz [przykład animacji z kluczem krzywej łamanej](https://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Storyboard();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Media.Animation.Storyboard" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje zestaw animacji skojarzonych z tym <see cref="T:System.Windows.Media.Animation.Storyboard" />elementem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin();" />
      <MemberSignature Language="F#" Value="member this.Begin : unit -&gt; unit" Usage="storyboard.Begin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym i inicjuje je.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt zawarty w tym samym zakresie nazw co elementy docelowe animacji scenorysu. Animacje bez a <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości dostosowane są już animowane, są one zastępowane <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przy użyciu zachowania do oddania.  
  
 Scenorysów rozpoczętych przy użyciu tej metody nie można wstrzymywać, wznawiać działania ani w inny sposób interaktywnie sterować po ich uruchomieniu. Aby można było sterować scenorysem, użyj <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody lub. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A>  
  
 Rozpoczęcie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
   
  
## Examples  
 Poniższy przykład używa scenorysu do animacji a <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się<xref:System.Windows.FrameworkContentElement>w zakresie nazw.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt zawarty w tym samym zakresie nazw co elementy docelowe animacji scenorysu. Animacje bez a <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości dostosowane są już animowane, są one zastępowane <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przy użyciu zachowania do oddania.  
  
 Scenorysów rozpoczętych przy użyciu tej metody nie można wstrzymywać, wznawiać działania ani w inny sposób interaktywnie sterować po ich uruchomieniu. Aby można było sterować scenorysem, użyj <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> metody lub. <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29>  
  
 Rozpoczęcie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt zawarty w tym samym zakresie nazw co elementy docelowe animacji scenorysu. Animacje bez a <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <param name="isControllable"><see langword="true" />Jeśli scenorys powinien być interaktywnie kontrolowany; w przeciwnym razie. <see langword="false" /></param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości dostosowane są już animowane, są one zastępowane <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przy użyciu zachowania do oddania.  
  
 Aby interaktywnie kontrolować ten scenorys, należy określić ten sam `containingObject` podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu  
  
 Po wywołaniu <xref:System.Windows.Media.Animation.Clock> tej metody obiekty są tworzone dla scenorysu i wszelkich osi czasu, które zawiera. Te zegary są przechowywane przy `containingObject`użyciu.  
  
 Rozpoczęcie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
   
  
## Examples  
 Poniższy przykład używa kontrolowanego scenorysu do animacji a <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się<xref:System.Windows.FrameworkContentElement>w zakresie nazw.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt zawarty w tym samym zakresie nazw co elementy docelowe animacji scenorysu. Animacje bez a <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <param name="handoffBehavior">Zachowanie, które ma być używane przez nową animację do współdziałania z bieżącymi animacjami.</param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym i inicjuje je przy użyciu określonego. <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu nie jest Usuń te zegary automatycznie.  
  
 Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu. Istnieje kilka sposobów usunięcia zegara.  
  
-   Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu. Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim. Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.  
  
-   <xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę. Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara. Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie jest wywoływane, jeśli czynny czas trwania zegara jest nieograniczona.  W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.  
  
 Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Poniższy <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przykład używa <xref:System.Windows.Media.Animation.HandoffBehavior> do animacji, gdy użytkownik kliknie lewym przyciskiem myszy, a <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> następnie po kliknięciu prawego użytkownika.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt zawarty w tym samym zakresie nazw co elementy docelowe animacji scenorysu. Animacje bez a <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <param name="isControllable"><see langword="true" />Jeśli scenorys powinien być interaktywnie kontrolowany; w przeciwnym razie. <see langword="false" /></param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości dostosowane są już animowane, są one zastępowane <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przy użyciu zachowania do oddania.  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu  
  
 Po wywołaniu <xref:System.Windows.Media.Animation.Clock> tej metody obiekty są tworzone dla scenorysu i wszelkich osi czasu, które zawiera. Te zegary są przechowywane przy `containingObject`użyciu.  
  
 Rozpoczęcie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego zastosowano <paramref name="frameworkTemplate" /> określony. Animacje bez a <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <param name="frameworkTemplate">Szablon do animacji.</param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym w ramach określonego szablonu i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości dostosowane są już animowane, są one zastępowane <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przy użyciu zachowania do oddania.  
  
 Po wywołaniu <xref:System.Windows.Media.Animation.Clock> tej metody obiekty są tworzone dla scenorysu i wszelkich osi czasu, które zawiera. Te zegary są przechowywane przy `containingObject`użyciu.  
  
 Rozpoczęcie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt zawarty w tym samym zakresie nazw co elementy docelowe animacji scenorysu. Animacje bez określonego <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <param name="handoffBehavior">Zachowanie, które ma być używane przez nową animację do współdziałania z bieżącymi animacjami.</param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym i inicjuje je przy użyciu określonego. <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przykład używa <xref:System.Windows.Media.Animation.HandoffBehavior> do animacji, gdy użytkownik kliknie lewym przyciskiem myszy, a <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> następnie po kliknięciu prawego użytkownika.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt zawarty w tym samym zakresie nazw co elementy docelowe animacji scenorysu. Animacje bez określonego <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <param name="handoffBehavior">Zachowanie, które ma być używane przez nową animację do współdziałania z bieżącymi animacjami.</param>
        <param name="isControllable">Deklaruje, czy animacja jest sterowana (może zostać wstrzymana) po uruchomieniu.</param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym i inicjuje je przy użyciu określonego. <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości dostosowane są już animowane, są one zastępowane przy użyciu określonego zachowania do nadania.  
  
 Aby interaktywnie kontrolować ten scenorys, należy określić ten sam `containingObject` podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu  
  
 Po wywołaniu <xref:System.Windows.Media.Animation.Clock> tej metody obiekty są tworzone dla scenorysu i wszelkich osi czasu, które zawiera. Te zegary są przechowywane przy `containingObject`użyciu.  
  
 Rozpoczęcie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu nie jest Usuń te zegary automatycznie.  
  
 Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu. Istnieje kilka sposobów usunięcia zegara.  
  
-   Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu. Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim. Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.  
  
-   <xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę. Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara. Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie jest wywoływane, jeśli czynny czas trwania zegara jest nieograniczona.  W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.  
  
 Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Poniższy przykład używa kontrolowanego scenorysu do animacji a <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się<xref:System.Windows.FrameworkContentElement>w zakresie nazw.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> W następnym przykładzie używa <xref:System.Windows.Media.Animation.HandoffBehavior> się do animacji, gdy użytkownik kliknie lewym przyciskiem myszy, <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> a <xref:System.Windows.Media.Animation.HandoffBehavior> następnie po kliknięciu prawego użytkownika.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego zastosowano <paramref name="frameworkTemplate" /> określony.  Animacje bez a <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <param name="frameworkTemplate">Szablon do animacji.</param>
        <param name="isControllable"><see langword="true" />Jeśli scenorys powinien być interaktywnie kontrolowany; w przeciwnym razie. <see langword="false" /></param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym w ramach określonego szablonu i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości dostosowane są już animowane, są one zastępowane <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przy użyciu zachowania do oddania.  
  
 Aby interaktywnie kontrolować ten scenorys, należy określić ten sam `containingObject` podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu  
  
 Po wywołaniu <xref:System.Windows.Media.Animation.Clock> tej metody obiekty są tworzone dla scenorysu i wszelkich osi czasu, które zawiera. Te zegary są przechowywane przy `containingObject`użyciu.  
  
 Rozpoczęcie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego zastosowano <paramref name="frameworkTemplate" /> określony. Animacje bez a <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <param name="frameworkTemplate">Szablon do animacji.</param>
        <param name="handoffBehavior">Zachowanie, które ma być używane przez nową animację do współdziałania z bieżącymi animacjami.</param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym w ramach określonego szablonu i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu <xref:System.Windows.Media.Animation.Clock> tej metody obiekty są tworzone dla scenorysu i wszelkich osi czasu, które zawiera. Te zegary są przechowywane przy `containingObject`użyciu.  
  
 Rozpoczęcie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu nie jest Usuń te zegary automatycznie.  
  
 Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu. Istnieje kilka sposobów usunięcia zegara.  
  
-   Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu. Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim. Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.  
  
-   <xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę. Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara. Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie jest wywoływane, jeśli czynny czas trwania zegara jest nieograniczona.  W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.  
  
 Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt zawarty w tym samym zakresie nazw co elementy docelowe animacji scenorysu. Animacje bez określonego <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <param name="handoffBehavior">Zachowanie, które ma być używane przez nową animację do współdziałania z bieżącymi animacjami.</param>
        <param name="isControllable">Deklaruje, czy animacja jest sterowana (może zostać wstrzymana) po uruchomieniu.</param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu  
  
 Po wywołaniu <xref:System.Windows.Media.Animation.Clock> tej metody obiekty są tworzone dla scenorysu i wszelkich osi czasu, które zawiera. Te zegary są przechowywane przy `containingObject`użyciu.  
  
 Rozpoczęcie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu nie jest Usuń te zegary automatycznie.  
  
 Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu. Istnieje kilka sposobów usunięcia zegara.  
  
-   Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu. Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim. Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.  
  
-   <xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę. Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara. Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie jest wywoływane, jeśli czynny czas trwania zegara jest nieograniczona.  W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.  
  
 Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć scenorys z możliwością kontroli.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> W następnym przykładzie używa <xref:System.Windows.Media.Animation.HandoffBehavior> się do animacji, gdy użytkownik kliknie lewym przyciskiem myszy, <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> a <xref:System.Windows.Media.Animation.HandoffBehavior> następnie po kliknięciu prawego użytkownika.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego zastosowano <paramref name="frameworkTemplate" /> określony. Animacje bez a <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <paramref name="containingObject" />.</param>
        <param name="frameworkTemplate">Szablon do animacji.</param>
        <param name="handoffBehavior">Zachowanie, które ma być używane przez nową animację do współdziałania z bieżącymi animacjami.</param>
        <param name="isControllable"><see langword="true" />Jeśli scenorys powinien być interaktywnie kontrolowany; w przeciwnym razie. <see langword="false" /></param>
        <summary>Stosuje animacje skojarzone z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementem docelowym w ramach określonego szablonu i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować ten scenorys, należy określić ten sam `containingObject` podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu  
  
 Po wywołaniu <xref:System.Windows.Media.Animation.Clock> tej metody obiekty są tworzone dla scenorysu i wszelkich osi czasu, które zawiera. Te zegary są przechowywane przy `containingObject`użyciu.  
  
 Rozpoczęcie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po <xref:System.Windows.Media.Animation.Storyboard>zastosowaniu <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> do właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, wszystkie obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu nie jest Usuń te zegary automatycznie.  
  
 Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegarów przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>programu, należy usunąć z właściwości animowane zegary, po ich zakończeniu. Istnieje kilka sposobów usunięcia zegara.  
  
-   Aby usunąć wszystkie zegary z właściwości, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowanego obiektu. Określ animowaną właściwość jako pierwszy parametr, a `null` w drugim. Spowoduje to usunięcie wszystkich zegarów animacji z właściwości.  
  
-   <xref:System.Windows.Media.Animation.AnimationClock> Aby usunąć określony z listy zegarów, <xref:System.Windows.Media.Animation.Clock.Controller%2A> Użyj właściwości <xref:System.Windows.Media.Animation.AnimationClock> do pobrania <xref:System.Windows.Media.Animation.ClockController>a <xref:System.Windows.Media.Animation.ClockController>, a następnie Wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodę. Jest to zazwyczaj wykonywane w programie <xref:System.Windows.Media.Animation.Clock.Completed> obsługi zdarzeń zegara. Należy zauważyć, że tylko zegary główne mogą być sterowane <xref:System.Windows.Media.Animation.ClockController>przez <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; Właściwość zegara podrzędnego zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzenie nie jest wywoływane, jeśli czynny czas trwania zegara jest nieograniczona.  W takim przypadku użytkownik musi określić, kiedy ma być wywoływana <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to szczególnie problem w przypadku animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest odzyskiwany, jego zegary również są rozłączone i odzyskiwane.  
  
 Aby uzyskać więcej informacji na temat obiektów zegara, zobacz [animacje i system chronometrażu — przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Storyboard" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Storyboard ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Animation.Storyboard" Usage="storyboard.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy modyfikowalny klon tego <see cref="T:System.Windows.Media.Animation.Storyboard" />elementu, tworząc głębokie kopie wartości tego obiektu. Podczas kopiowania właściwości zależności ta metoda kopiuje odwołania do zasobów i powiązania danych (ale mogą nie być już rozpoznawane), ale nie ma animacji ani ich bieżących wartości.</summary>
        <returns>Modyfikowalny klon bieżącego obiektu. <see cref="P:System.Windows.Freezable.IsFrozen" /> Właściwość sklonowanego obiektu jest <see langword="false" /> <see cref="P:System.Windows.Freezable.IsFrozen" /> nawet wtedy, gdy właściwość source ma wartość<see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia modyfikowalnych kopii obiektów zamrożonych <xref:System.Windows.Freezable> (lub dowolnego <xref:System.Windows.Freezable> obiektu). Dla wygody ta metoda zaciemnienia dziedziczonej wersji z silnie wpisaną implementacją.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="storyboard.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.Windows.Media.Animation.Storyboard" /> klasy.</summary>
        <returns>Nowe <see cref="T:System.Windows.Media.Animation.Storyboard" /> wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CreateInstance%2A> program podczas tworzenia nowych wystąpień <xref:System.Windows.Media.Animation.Storyboard> klasy dla różnych metod klonowania (takich jak <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A>).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono typową implementację <xref:System.Windows.Freezable.CreateInstanceCore%2A>programu.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Każda <see cref="T:System.Windows.Media.Animation.Storyboard" /> podklasa musi implementować tę metodę. Typową implementacją jest po prostu wywołanie konstruktora bez parametrów klasy i zwrócenie wyniku.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> Szybkość zegara to szybkość, z jaką czas jest aktualnie postępować w porównaniu z czasem rzeczywistym.  
  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentGlobalSpeed();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : unit -&gt; double" Usage="storyboard.GetCurrentGlobalSpeed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /></summary>
        <returns>Bieżąca szybkość globalna lub 0, jeśli zegar jest zatrzymany.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /></summary>
        <returns>Bieżąca szybkość globalna lub <see langword="null" /> Jeśli zegar jest zatrzymany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> Szybkość zegara to szybkość, z jaką czas jest aktualnie postępować w porównaniu z czasem rzeczywistym.  
  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /></summary>
        <returns>Bieżąca szybkość globalna lub <see langword="null" /> Jeśli zegar jest zatrzymany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> Szybkość zegara to szybkość, z jaką czas jest aktualnie postępować w porównaniu z czasem rzeczywistym.  
  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentIteration">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCurrentIteration();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : unit -&gt; int" Usage="storyboard.GetCurrentIteration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /></summary>
        <returns>Bieżąca iteracja zegara w bieżącym aktywnym okresie lub <see langword="null" /> Jeśli ten zegar zostanie zatrzymany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwsza iteracja zegara ma wartość 1.  
  
 Jeśli ten scenorys ma <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> `true`ustawienie, pełna iteracja składa się z pary do przodu, a nie tylko jednego z tych segmentów.  
  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkContentElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkContentElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /></summary>
        <returns>Bieżąca iteracja zegara w bieżącym aktywnym okresie lub <see langword="null" /> Jeśli ten zegar zostanie zatrzymany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwsza iteracja zegara ma wartość 1.  
  
 Jeśli ten scenorys ma <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> `true`ustawienie, pełna iteracja składa się z pary do przodu, a nie tylko jednego z tych segmentów.  
  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /></summary>
        <returns>Bieżąca iteracja zegara w bieżącym aktywnym okresie lub <see langword="null" /> Jeśli ten zegar zostanie zatrzymany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwsza iteracja zegara ma wartość 1.  
  
 Jeśli oś czasu tego zegara ma <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> `true`ustawienie, pełna iteracja składa się z pary do przodu, a nie tylko jednego z tych segmentów.  
  
 Bez względu na bieżącą iterację, wyszukiwanie zegara zwraca bieżącą iterację do 1. Ponowne uruchomienie zegara również zwraca bieżącą iterację do 1.  
  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentProgress">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentProgress();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : unit -&gt; double" Usage="storyboard.GetCurrentProgress " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /></summary>
        <returns><see langword="null" />Jeśli ten zegar ma <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />wartość, lub 0,0, jeśli ten zegar jest aktywny <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> i ma <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> długość <see cref="P:System.Windows.Duration.Forever" />z; w przeciwnym razie wartością z zakresu od 0,0 do 1,0, która wskazuje bieżący postęp tego zegara w bieżącej iteracji. Wartość 0,0 wskazuje brak postępu, a wartość 1,0 wskazuje, że zegar znajduje się na końcu bieżącej iteracji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /></summary>
        <returns><see langword="null" />Jeśli ten zegar ma <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />wartość, lub 0,0, jeśli ten zegar jest aktywny <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> i ma <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> długość <see cref="P:System.Windows.Duration.Forever" />z; w przeciwnym razie wartością z zakresu od 0,0 do 1,0, która wskazuje bieżący postęp tego zegara w bieżącej iteracji. Wartość 0,0 wskazuje brak postępu, a wartość 1,0 wskazuje, że zegar znajduje się na końcu bieżącej iteracji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /></summary>
        <returns><see langword="null" />Jeśli ten zegar ma <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />wartość, lub 0,0, jeśli ten zegar jest aktywny <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> i ma <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> długość <see cref="P:System.Windows.Duration.Forever" />z; w przeciwnym razie wartością z zakresu od 0,0 do 1,0, która wskazuje bieżący postęp tego zegara w bieżącej iteracji. Wartość 0,0 wskazuje brak postępu, a wartość 1,0 wskazuje, że zegar znajduje się na końcu bieżącej iteracji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentState">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState () As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : unit -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /></summary>
        <returns>Bieżący stan zegara utworzonego dla tego scenorysu: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, lub <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie informuje użytkownika o wstrzymaniu scenorysu. Aby określić, czy scenorys jest wstrzymany, użyj <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> metody.  
  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkContentElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkContentElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /></summary>
        <returns>Bieżący stan zegara utworzonego dla tego scenorysu: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, lub <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie informuje użytkownika o wstrzymaniu scenorysu. Aby określić, czy scenorys jest wstrzymany, użyj <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> metody.  
  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /></summary>
        <returns>Bieżący stan zegara utworzonego dla tego scenorysu: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, lub <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie informuje użytkownika o wstrzymaniu scenorysu. Aby określić, czy scenorys jest wstrzymany, użyj <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> metody.  
  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentTime">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime () As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetCurrentTime();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : unit -&gt; TimeSpan" Usage="storyboard.GetCurrentTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /></summary>
        <returns><see langword="null" />Jeśli zegar <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />tego scenorysu to; w przeciwnym razie bieżąca godzina zegara scenorysu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkContentElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkContentElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /></summary>
        <returns><see langword="null" />Jeśli zegar <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />tego scenorysu to; w przeciwnym razie bieżąca godzina zegara scenorysu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera, <see cref="T:System.Windows.Media.Animation.Clock" /> który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu.<see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /></summary>
        <returns><see langword="null" />Jeśli zegar <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />tego scenorysu to; w przeciwnym razie bieżąca godzina zegara scenorysu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetIsPaused">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> została ona utworzona dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu jest wstrzymana.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused();" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : unit -&gt; bool" Usage="storyboard.GetIsPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> została ona utworzona dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu jest wstrzymana.</summary>
        <returns><see langword="true" />Jeśli utworzono dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu jest <see langword="false" />wstrzymany; w przeciwnym razie. <see cref="T:System.Windows.Media.Animation.Clock" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkContentElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkContentElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> została ona utworzona dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu jest wstrzymana.</summary>
        <returns><see langword="true" />Jeśli utworzono dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu jest <see langword="false" />wstrzymany; w przeciwnym razie. <see cref="T:System.Windows.Media.Animation.Clock" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> została ona utworzona dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu jest wstrzymana.</summary>
        <returns><see langword="true" />Jeśli utworzono dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> elementu jest <see langword="false" />wstrzymany; w przeciwnym razie. <see cref="T:System.Windows.Media.Animation.Clock" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody do pobierania informacji o zegarze scenorysu, musi być możliwe przetworzenie scenorysu. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTarget (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetTarget(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTarget : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Media.Animation.Storyboard.GetTarget element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Oś czasu, z której ma zostać <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />pobrany.</param>
        <summary>Pobiera wartość określonej <see cref="T:System.Windows.Media.Animation.Timeline" />wartości. <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /></summary>
        <returns>Obiekt zależności, do którego <paramref name="element" />należy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Użyj dołączonej właściwości z osią czasu animacji, aby wskazać obiekt docelowy. Aby uzyskać więcej informacji na temat działania obiektów docelowych scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji o tym, jak działają dołączone właściwości, zobacz temat [dołączone właściwości przegląd](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetName (element As DependencyObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTargetName(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetName : System.Windows.DependencyObject -&gt; string" Usage="System.Windows.Media.Animation.Storyboard.GetTargetName element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Oś czasu, z której ma zostać <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />pobrany.</param>
        <summary>Pobiera wartość określonej <see cref="T:System.Windows.Media.Animation.Timeline" />wartości. <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /></summary>
        <returns>Nazwa obiektu zależności wskazywanego przez <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> przyłączoną właściwość dla określonego obiektu. Aby uzyskać więcej informacji na temat działania obiektów docelowych scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji o tym, jak działają dołączone właściwości, zobacz temat [dołączone właściwości przegląd](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetProperty (element As DependencyObject) As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PropertyPath ^ GetTargetProperty(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetProperty : System.Windows.DependencyObject -&gt; System.Windows.PropertyPath" Usage="System.Windows.Media.Animation.Storyboard.GetTargetProperty element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać uzyskana wartość <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</param>
        <summary>Pobiera wartość określonej <see cref="T:System.Windows.Media.Animation.Timeline" />wartości. <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /></summary>
        <returns>Właściwość będąca elementem <paramref name="element" />wskazywanym przez.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> przyłączoną właściwość dla określonego obiektu. Aby uzyskać więcej informacji o tym, jak działa obiekt <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> docelowy scenorysu, zobacz dołączona właściwość. Aby uzyskać więcej informacji o tym, jak działają dołączone właściwości, zobacz temat [dołączone właściwości przegląd](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Należy pamiętać, że <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> jeśli został ustawiony w znaczniku, Metoda ta zwraca <xref:System.Windows.PropertyPath> wartość pustą, ponieważ odwołanie do właściwości jest rozpoznawane i przechowywane wewnętrznie podczas analizy.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pause">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstrzymuje <see cref="T:System.Windows.Media.Animation.Storyboard" />działanie ,którezostałoutworzone<see cref="T:System.Windows.Media.Animation.Clock" /> dla tego elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberSignature Language="F#" Value="member this.Pause : unit -&gt; unit" Usage="storyboard.Pause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje <see cref="T:System.Windows.Media.Animation.Storyboard" />działanie ,którezostałoutworzone<see cref="T:System.Windows.Media.Animation.Clock" /> dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wstrzymuje scenorys, ale nie ma dostrzegalnego efektu, jeśli nie jest ona aktywna lub obecnie jest wstrzymana. Efektem ubocznym są również wstrzymane wszystkie skojarzone elementy podrzędne.  
  
 W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
## <a name="beginning-a-paused-storyboard"></a>Rozpoczęcie wstrzymanego scenorysu  
 <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> W przypadku wstrzymania scenorysu zostanie on wznowiony i ponownie uruchomiony. Nie jest to jednak tak samo. Metoda faktycznie zastępuje <xref:System.Windows.Media.Animation.Storyboard> wstrzymanie nową niewstrzymaną wersją. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Za każdym razem <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> , gdy wywoływana jest metoda, obiekty zegara są tworzone dla scenorysu. Te zegary są dystrybuowane do właściwości, które są animowane. Dlatego po <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> ponownym wywołaniu metody nie jest ponownie uruchamiana jej zegary; zastępuje je nowymi zegarami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Wstrzymuje określoną <see cref="T:System.Windows.FrameworkContentElement" /> skojarzoną z tym <see cref="T:System.Windows.Media.Animation.Storyboard" />elementem. <see cref="T:System.Windows.Media.Animation.Clock" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wstrzymuje scenorys, ale nie ma dostrzegalnego efektu, jeśli nie jest ona aktywna lub obecnie jest wstrzymana. Efektem ubocznym są również wstrzymane wszystkie skojarzone elementy podrzędne.  
  
 Wyszukiwanie wstrzymanego scenorysu nie powoduje jego wznowienia. Jedynym sposobem wznowienia wstrzymanego scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Wywołanie metody ponownie zastępuje wstrzymane Scenorysy nową, która ma wygląd.  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby uzyskać przykład, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Wstrzymywanie zegara scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenie.  
  
## <a name="beginning-a-paused-storyboard"></a>Rozpoczęcie wstrzymanego scenorysu  
 <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> W przypadku wstrzymania scenorysu zostanie on wznowiony i ponownie uruchomiony. Nie jest to jednak tak samo. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Metoda faktycznie zastępuje samą siebie niewstrzymaną wersją. Za każdym razem <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> , gdy wywoływana jest metoda, obiekty zegara są tworzone dla scenorysu. Te zegary są dystrybuowane do właściwości, które są animowane. Dlatego po <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> ponownym wywołaniu metody nie jest ponownie uruchamiana jej zegary; zastępuje je nowymi zegarami.  
  
   
  
## Examples  
 Poniższy przykład używa kontrolowanego scenorysu do animacji a <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się<xref:System.Windows.FrameworkContentElement>w zakresie nazw.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Wstrzymuje określoną <see cref="T:System.Windows.FrameworkElement" /> skojarzoną z tym <see cref="T:System.Windows.Media.Animation.Storyboard" />elementem. <see cref="T:System.Windows.Media.Animation.Clock" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wstrzymuje scenorys, ale nie ma dostrzegalnego efektu, jeśli nie jest ona aktywna lub obecnie jest wstrzymana. Efektem ubocznym są również wstrzymane wszystkie skojarzone elementy podrzędne.  
  
 Wyszukiwanie wstrzymanego scenorysu nie powoduje jego wznowienia. Jedynym sposobem wznowienia wstrzymanego scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Wywołanie metody ponownie zastępuje wstrzymane Scenorysy nową, która ma wygląd.  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Wstrzymywanie zegara scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenie.  
  
## <a name="beginning-a-paused-storyboard"></a>Rozpoczęcie wstrzymanego scenorysu  
 <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> W przypadku wstrzymania scenorysu zostanie on wznowiony i ponownie uruchomiony. Nie jest to jednak tak samo. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Metoda faktycznie zastępuje samą siebie niewstrzymaną wersją. Za każdym razem <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> , gdy wywoływana jest metoda, obiekty zegara są tworzone dla scenorysu. Te zegary są dystrybuowane do właściwości, które są animowane. Dlatego po <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> ponownym wywołaniu metody nie jest ponownie uruchamiana jej zegary; zastępuje je nowymi zegarami.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa obiekty, które zostały utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />elementu. <see cref="T:System.Windows.Media.Animation.Clock" /> Animacje, które należą do <see cref="T:System.Windows.Media.Animation.Storyboard" /> tego nie mają już wpływu na właściwości, które po animacji, niezależnie <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> od ich ustawień.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="storyboard.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa obiekty, które zostały utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />elementu. <see cref="T:System.Windows.Media.Animation.Clock" /> Animacje, które należą do <see cref="T:System.Windows.Media.Animation.Storyboard" /> tego nie mają już wpływu na właściwości, które po animacji, niezależnie <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> od ich ustawień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Wszystkie interaktywne akcje wykonywane w <xref:System.Windows.Media.Animation.Clock>, a tym samym również <xref:System.Windows.Media.Animation.Storyboard>na, pojawiają się na następnym znaczniku aparatu czasu, który ma miejsce tuż przed następnym renderowaniem. Oznacza to, że <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> metoda nadal ma wpływ na animowane właściwości do tego czasu. Innymi słowy, gdy ramka zostanie wyświetlona, zostanie usunięty scenorys. Jeśli musisz usunąć skojarzenie animacji z właściwością przed tym terminem, użyj <xref:System.Windows.UIElement.BeginAnimation%2A> metody `animation` z wartością `null`parametru.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Usuwa obiekty, które zostały utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />elementu. <see cref="T:System.Windows.Media.Animation.Clock" /> Animacje, które należą do <see cref="T:System.Windows.Media.Animation.Storyboard" /> tego nie mają już wpływu na właściwości, które po animacji, niezależnie <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> od ich ustawień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Usuwanie zegara scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> zdarzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Usuwa obiekty, które zostały utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />elementu. <see cref="T:System.Windows.Media.Animation.Clock" /> Animacje, które należą do <see cref="T:System.Windows.Media.Animation.Storyboard" /> tego nie mają już wpływu na właściwości, które po animacji, niezależnie <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> od ich ustawień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Usuwanie zegara scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> zdarzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resume">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wznawia działanie <see cref="T:System.Windows.Media.Animation.Storyboard" />, które zostało utworzone dla tego elementu. <see cref="T:System.Windows.Media.Animation.Clock" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="storyboard.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia działanie <see cref="T:System.Windows.Media.Animation.Storyboard" />, które zostało utworzone dla tego elementu. <see cref="T:System.Windows.Media.Animation.Clock" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Wznawia działanie <see cref="T:System.Windows.Media.Animation.Storyboard" />, które zostało utworzone dla tego elementu. <see cref="T:System.Windows.Media.Animation.Clock" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wznawianie scenorysu, który nie jest wstrzymany, nie ma żadnego wpływu.  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Wyszukiwanie wstrzymanego scenorysu nie powoduje jego wznowienia. Jedynym sposobem wznowienia wstrzymanego scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Wywołanie metody po rozpoczęciu scenorysu zastępuje stary scenorys, który ma wygląd.  
  
 Wznawianie wstrzymanego zegara scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenie.  
  
   
  
## Examples  
 Poniższy przykład używa kontrolowanego scenorysu do animacji a <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się<xref:System.Windows.FrameworkContentElement>w zakresie nazw.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Wznawia działanie <see cref="T:System.Windows.Media.Animation.Storyboard" />, które zostało utworzone dla tego elementu. <see cref="T:System.Windows.Media.Animation.Clock" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wznawianie scenorysu, który nie jest wstrzymany, nie ma żadnego wpływu.  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Wyszukiwanie wstrzymanego scenorysu nie powoduje jego wznowienia. Jedynym sposobem wznowienia wstrzymanego scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Wywołanie metody po rozpoczęciu scenorysu zastępuje stary scenorys, który ma wygląd.  
  
 Wznawianie wstrzymanego zegara scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje to <see cref="T:System.Windows.Media.Animation.Storyboard" /> nowe położenie w momencie wystąpienia następnego taktu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan -&gt; unit" Usage="storyboard.Seek offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnia lub ujemna opisująca wielkość, o jaką oś czasu ma być przenoszona do przodu lub do tyłu.</param>
        <summary>Poszukuje tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> podanego położenia. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądane wyszukiwanie w następnym taktie zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwróć uwagę, że operacje wyszukiwania nie pobierają <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ani <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> nie uwzględniają ustawień scenorysu. Scenorys jest traktowany tak, jakby miał wartość <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i nie. <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje wielkość, o którą oś czasu powinna zostać przeniesiona do przodu lub <paramref name="origin" />do tyłu od określonego.</param>
        <param name="origin">Pozycja, z której <paramref name="offset" /> jest stosowany.</param>
        <summary>Poszukuje tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> podanego położenia. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądane wyszukiwanie w następnym taktie zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwróć uwagę, że operacje wyszukiwania nie pobierają <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ani <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> nie uwzględniają ustawień scenorysu. Scenorys jest traktowany tak, jakby miał wartość <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i nie. <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje wielkość, o którą oś czasu powinna zostać przeniesiona do przodu lub <paramref name="origin" />do tyłu od określonego.</param>
        <param name="origin">Pozycja, z której <paramref name="offset" /> jest stosowany.</param>
        <summary>Poszukuje tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> podanego położenia. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądane wyszukiwanie w następnym taktie zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwróć uwagę, że operacje wyszukiwania nie pobierają <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ani <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> nie uwzględniają ustawień scenorysu. Scenorys jest traktowany tak, jakby miał wartość <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i nie. <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>  
  
 Ta metoda zmienia zegar <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> scenorysu na. <xref:System.Windows.Media.Animation.ClockState.Active> Ta metoda nie ma wpływu na drzewo chronometrażu do czasu następnego przetworzenia taktu. Jako efekt uboczny, odpowiednie zdarzenia nie są również wywoływane do momentu.  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Wyszukiwanie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> metody i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> .  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje wielkość, o którą oś czasu powinna zostać przeniesiona do przodu lub <paramref name="origin" />do tyłu od określonego.</param>
        <param name="origin">Pozycja, z której <paramref name="offset" /> jest stosowany.</param>
        <summary>Poszukuje tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> podanego położenia. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądane wyszukiwanie w następnym taktie zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwróć uwagę, że operacje wyszukiwania nie pobierają <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ani <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> nie uwzględniają ustawień scenorysu. Scenorys jest traktowany tak, jakby miał wartość <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i nie. <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>  
  
 Ta metoda zmienia zegar <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> scenorysu na. <xref:System.Windows.Media.Animation.ClockState.Active> Ta metoda nie ma wpływu na drzewo chronometrażu do czasu następnego przetworzenia taktu. Jako efekt uboczny, odpowiednie zdarzenia nie są również wywoływane do momentu.  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. Z możliwością kontroli scenorysu można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać je, jeśli jest to możliwe do kontrolowania. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Wyszukiwanie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przeszukiwać (pomijać) do jednej sekundy po rozpoczęciu scenorysu.  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 W następnym przykładzie pokazano <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> metody i. <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SeekAlignedToLastTick">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Poszukuje tej <see cref="T:System.Windows.Media.Animation.Storyboard" /> zmiany do nowej pozycji natychmiast (synchronicznie).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan -&gt; unit" Usage="storyboard.SeekAlignedToLastTick offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnia lub ujemna opisująca wielkość, o jaką oś czasu ma być przenoszona do przodu lub do tyłu.</param>
        <summary>Poszukuje tej <see cref="T:System.Windows.Media.Animation.Storyboard" /> zmiany do nowej pozycji natychmiast (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Wyrównuje czas <xref:System.Windows.Media.Animation.Storyboard> przeszukiwania z ostatnim taktem zegara. Wartości są natychmiast aktualizowane w celu odzwierciedlenia zmian z <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>powodu, nawet jeśli ekran nie odzwierciedla tych zmian do momentu aktualizacji ekranu.  
  
 Zwróć uwagę, że operacje wyszukiwania nie pobierają <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ani <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> nie uwzględniają ustawień scenorysu. Scenorys jest traktowany tak, jakby miał wartość <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i nie. <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>  
  
 Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje wielkość, o którą oś czasu powinna zostać przeniesiona do przodu lub <paramref name="origin" />do tyłu od określonego.</param>
        <param name="origin">Pozycja, z której <paramref name="offset" /> jest stosowany.</param>
        <summary>Poszukuje tej <see cref="T:System.Windows.Media.Animation.Storyboard" /> zmiany do nowej pozycji natychmiast (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Wyrównuje czas <xref:System.Windows.Media.Animation.Storyboard> przeszukiwania z ostatnim taktem zegara. Wartości są natychmiast aktualizowane w celu odzwierciedlenia zmian z <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>powodu, nawet jeśli ekran nie odzwierciedla tych zmian do momentu aktualizacji ekranu.  
  
 Zwróć uwagę, że operacje wyszukiwania nie pobierają <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ani <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> nie uwzględniają ustawień scenorysu. Scenorys jest traktowany tak, jakby miał wartość <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i nie. <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>  
  
 Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje wielkość, o którą oś czasu powinna zostać przeniesiona do przodu lub <paramref name="origin" />do tyłu od określonego.</param>
        <param name="origin">Pozycja, z której <paramref name="offset" /> jest stosowany.</param>
        <summary>Poszukuje tej <see cref="T:System.Windows.Media.Animation.Storyboard" /> zmiany do nowej pozycji natychmiast (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Wyrównuje czas <xref:System.Windows.Media.Animation.Storyboard> przeszukiwania z ostatnim taktem zegara. Wartości są natychmiast aktualizowane w celu odzwierciedlenia zmian z <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>powodu, nawet jeśli ekran nie odzwierciedla tych zmian do momentu aktualizacji ekranu.  
  
 Zwróć uwagę, że operacje wyszukiwania nie pobierają <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ani <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> nie uwzględniają ustawień scenorysu. Scenorys jest traktowany tak, jakby miał wartość <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i nie. <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>  
  
 Ta metoda zmienia zegar <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> scenorysu na  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Wyszukiwanie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> metody i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> .  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje wielkość, o którą oś czasu powinna zostać przeniesiona do przodu lub <paramref name="origin" />do tyłu od określonego.</param>
        <param name="origin">Pozycja, z której <paramref name="offset" /> jest stosowany.</param>
        <summary>Poszukuje tej <see cref="T:System.Windows.Media.Animation.Storyboard" /> zmiany do nowej pozycji natychmiast (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Wyrównuje czas <xref:System.Windows.Media.Animation.Storyboard> przeszukiwania z ostatnim taktem zegara. Wartości są natychmiast aktualizowane w celu odzwierciedlenia zmian z <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>powodu, nawet jeśli ekran nie odzwierciedla tych zmian do momentu aktualizacji ekranu.  
  
 Zwróć uwagę, że operacje wyszukiwania nie pobierają <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ani <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> nie uwzględniają ustawień scenorysu. Scenorys jest traktowany tak, jakby miał wartość <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i nie. <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>  
  
 Ta metoda zmienia zegar <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> scenorysu na  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Wyszukiwanie scenorysu wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> metody i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> .  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSpeedRatio">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia współczynnik szybkości interaktywnej dla <see cref="T:System.Windows.Media.Animation.Clock" /> , który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : double -&gt; unit" Usage="storyboard.SetSpeedRatio speedRatio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Wartość skończoną większa od zera, która jest nowym współczynnikiem interaktywnej szybkości scenorysu. Ta wartość jest mnożona względem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wartości scenorysu, aby określić skuteczną szybkość scenorysu. Ta wartość nie zastępuje <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> właściwości scenorysu. Na przykład wywołanie tej metody i określenie współczynnika szybkości interaktywnej 3 w scenorysie z 0,5 powoduje <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> , że scenorys ma efektywną prędkość 1,5.</param>
        <summary>Ustawia współczynnik szybkości interaktywnej dla <see cref="T:System.Windows.Media.Animation.Clock" /> , który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkContentElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkContentElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkContentElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <param name="speedRatio">Wartość skończoną większa od zera, która jest nowym współczynnikiem interaktywnej szybkości scenorysu. Ta wartość jest mnożona względem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wartości scenorysu, aby określić skuteczną szybkość scenorysu. Ta wartość nie zastępuje <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> właściwości scenorysu. Na przykład wywołanie tej metody i określenie współczynnika szybkości interaktywnej 3 w scenorysie z 0,5 powoduje <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> , że scenorys ma efektywną prędkość 1,5.</param>
        <summary>Ustawia współczynnik <see cref="T:System.Windows.Media.Animation.Clock" /> szybkości interaktywnej, który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Wywołanie tej metody wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenie.  
  
   
  
## Examples  
 Poniższy przykład używa kontrolowanego scenorysu do animacji a <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się<xref:System.Windows.FrameworkContentElement>w zakresie nazw.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <param name="speedRatio">Wartość skończoną większa od zera, która jest nowym współczynnikiem interaktywnej szybkości scenorysu. Ta wartość jest mnożona względem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wartości scenorysu, aby określić skuteczną szybkość scenorysu. Ta wartość nie zastępuje <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> właściwości scenorysu. Na przykład wywołanie tej metody i określenie współczynnika szybkości interaktywnej 3 w scenorysie z 0,5 powoduje <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> , że scenorys ma efektywną prędkość 1,5.</param>
        <summary>Ustawia współczynnik <see cref="T:System.Windows.Media.Animation.Clock" /> szybkości interaktywnej, który został utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 Wywołanie tej metody wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTarget (element As DependencyObject, value As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTarget(System::Windows::DependencyObject ^ element, System::Windows::DependencyObject ^ value);" />
      <MemberSignature Language="F#" Value="static member SetTarget : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTarget (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.Media.Animation.Timeline" /> Który powinien wskazywać określony obiekt zależności.</param>
        <param name="value">Obiekt zależności do celu.</param>
        <summary>Tworzy określony <see cref="T:System.Windows.Media.Animation.Timeline" /> obiekt docelowy obiektu zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.Windows.Media.Animation.Storyboard.Target%2A> przyłączoną właściwość dla określonego obiektu. Aby uzyskać więcej informacji na temat działania obiektów docelowych scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji o tym, jak działają dołączone właściwości, zobacz temat [dołączone właściwości przegląd](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
> [!NOTE]
>  Nie można serializować <xref:System.Windows.DependencyObject> właściwości,ponieważmożeonabyćustawiona<xref:System.Windows.Media.Animation.Storyboard.Target%2A> na wartość any. Nie ma gwarancji, że ten obiekt może być prawidłowo przywoływany z XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetName (element As DependencyObject, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetName(System::Windows::DependencyObject ^ element, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member SetTargetName : System.Windows.DependencyObject * string -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetName (element, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.Media.Animation.Timeline" /> Który powinien wskazywać określony obiekt zależności.</param>
        <param name="name">Nazwa obiektu zależności do celu.</param>
        <summary>Tworzy określony <see cref="T:System.Windows.Media.Animation.Timeline" /> obiekt docelowy obiektu zależności o określonej nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> przyłączoną właściwość dla określonego obiektu. Aby uzyskać więcej informacji na temat działania obiektów docelowych scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji o tym, jak działają dołączone właściwości, zobacz temat [dołączone właściwości przegląd](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetProperty (element As DependencyObject, path As PropertyPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetProperty(System::Windows::DependencyObject ^ element, System::Windows::PropertyPath ^ path);" />
      <MemberSignature Language="F#" Value="static member SetTargetProperty : System.Windows.DependencyObject * System.Windows.PropertyPath -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetProperty (element, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">, <see cref="T:System.Windows.Media.Animation.Timeline" /> Z którym ma zostać skojarzona określona właściwość zależności.</param>
        <param name="path">Ścieżka opisująca właściwość zależności, która ma być animowana.</param>
        <summary>Tworzy określony <see cref="T:System.Windows.Media.Animation.Timeline" /> element docelowy określonej właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> przyłączoną właściwość dla określonego obiektu. Aby uzyskać więcej informacji na temat działania obiektów docelowych scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A>. Aby uzyskać więcej informacji o tym, jak działają dołączone właściwości, zobacz temat [dołączone właściwości przegląd](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipToFill">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwiększa bieżącą godzinę tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill();" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : unit -&gt; unit" Usage="storyboard.SkipToFill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwiększa bieżącą godzinę tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Zwiększa bieżącą godzinę tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda postępuje bieżącą godzinę scenorysu do końca okresu aktywności; zachowanie scenorysu w tym punkcie jest określone przez jego <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> ustawienie. Jeśli <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> jest ustawiona na <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, wypełnienie scenorysu; Jeśli właściwość jest ustawiona na <xref:System.Windows.Media.Animation.FillBehavior.Stop>, scenorys zostanie zatrzymany.  
  
 Wywołanie tej metody w scenorysie z nieskończonym czasem trwania powoduje, że nieskończona liczba powtórzeń nie ma żadnego wpływu. Wywołanie tej metody w nieaktywnym scenorysie nie ma żadnego wpływu.  
  
 Przechodzenie zegara do jego okresu wypełnienia wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia i. <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated>  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
   
  
## Examples  
 Poniższy przykład używa kontrolowanego scenorysu do animacji a <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się<xref:System.Windows.FrameworkContentElement>w zakresie nazw.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Zwiększa bieżącą godzinę tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda postępuje bieżącą godzinę scenorysu do końca okresu aktywności; zachowanie scenorysu w tym punkcie jest określone przez jego <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> ustawienie. Jeśli <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> jest ustawiona na <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, wypełnienie scenorysu; Jeśli właściwość jest ustawiona na <xref:System.Windows.Media.Animation.FillBehavior.Stop>, scenorys zostanie zatrzymany.  
  
 Wywołanie tej metody w scenorysie z nieskończonym czasem trwania powoduje, że nieskończona liczba powtórzeń nie ma żadnego wpływu. Wywołanie tej metody w nieaktywnym scenorysie nie ma żadnego wpływu.  
  
 Przechodzenie zegara do jego okresu wypełnienia wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia i. <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated>  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Stop">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje zatrzymanie <see cref="T:System.Windows.Media.Animation.Clock" /> programu, który został utworzony <see cref="T:System.Windows.Media.Animation.Storyboard" />dla tego elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="storyboard.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje zatrzymanie <see cref="T:System.Windows.Media.Animation.Clock" /> programu, który został utworzony <see cref="T:System.Windows.Media.Animation.Storyboard" />dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że zatrzymywanie scenorysu nie <xref:System.Windows.Media.Animation.Timeline.Completed> powoduje wyzwolenia zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Powoduje zatrzymanie <see cref="T:System.Windows.Media.Animation.Clock" /> programu, który został utworzony <see cref="T:System.Windows.Media.Animation.Storyboard" />dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.ClockState.Stopped> Scenorys nie ma już wpływu na właściwości docelowe: właściwości, które były animowane, powracają do poprzednich wartości.  
  
 Zatrzymywanie zegara wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i, ale nie zdarzenia.<xref:System.Windows.Media.Animation.Timeline.Completed>  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
   
  
## Examples  
 Poniższy przykład używa kontrolowanego scenorysu do animacji a <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się<xref:System.Windows.FrameworkContentElement>w zakresie nazw.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt określony, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> Metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementów podrzędnych.</param>
        <summary>Powoduje zatrzymanie <see cref="T:System.Windows.Media.Animation.Clock" /> programu, który został utworzony <see cref="T:System.Windows.Media.Animation.Storyboard" />dla tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.ClockState.Stopped> Scenorys nie ma już wpływu na właściwości docelowe: właściwości, które były animowane, powracają do poprzednich wartości.  
  
 Zatrzymywanie zegara wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia i, ale nie zdarzenia.<xref:System.Windows.Media.Animation.Timeline.Completed>  
  
 Aby interaktywnie kontrolować ten scenorys, należy użyć tego samego `containingObject` parametru podczas wywoływania interaktywnych metod, które zostały użyte do rozpoczęcia scenorysu. W przypadku scenorysu możliwego do kontrolowania można wstrzymywać, wznawiać, wyszukiwać, zatrzymywać i usuwać. Aby można było sterować scenorysem w kodzie, należy użyć odpowiedniego przeciążenia <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody scenorysu i określić `true` , aby można było je sterować. Aby zapoznać się z przykładem, zobacz [How to: Kontrolowanie scenorysu po jego](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)uruchomieniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="ILAsm" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.Target" />
      <MemberSignature Language="VB.NET" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="F#" Value="see GetTarget, and SetTarget" Usage="see GetTarget, and SetTarget" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który ma być animowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt docelowy musi być obiektem zależności.  
  
> [!NOTE]
>  Nie można serializować <xref:System.Windows.DependencyObject> właściwości,ponieważmożeonabyćustawiona<xref:System.Windows.Media.Animation.Storyboard.Target%2A> na wartość any. Nie ma gwarancji, że ten obiekt może być prawidłowo przywoływany w języku XAML.  
  
<a name="dependencyPropertyInfo_Target"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Media.Animation.Storyboard.TargetProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="ILAsm" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      <MemberSignature Language="VB.NET" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="F#" Value="see GetTargetName, and SetTargetName" Usage="see GetTargetName, and SetTargetName" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia nazwę obiektu do animacji. Obiekt musi być typu <see cref="T:System.Windows.FrameworkElement" />, <see cref="T:System.Windows.FrameworkContentElement" />, lub <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości jest opcjonalne. Jeśli nie <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> jest określony, animacje scenorysu są stosowane do jednego z następujących elementów:  
  
-   Jeśli scenorys <xref:System.Windows.Media.Animation.BeginStoryboard>, do którego należy animacja, został uruchomiony przy użyciu, element, który jest <xref:System.Windows.Media.Animation.BeginStoryboard> właścicielem akcji, która wyzwala scenorys, jest celem.  
  
-   Jeśli seria ujęć została uruchomiona przy użyciu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody <xref:System.Windows.FrameworkElement> , lub <xref:System.Windows.FrameworkContentElement> <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> określona, gdy seria ujęć została rozpoczęta z użyciem metody.  
  
 Gdy ta właściwość jest ustawiona na osi czasu z elementami podrzędnymi, te podrzędne osie czasu dziedziczą <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> , chyba że określają własne.  
  
## <a name="making-an-object-targetable"></a>Tworzenie obiektu jako docelowego  
 W przypadku [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]korzystania z programu należy wykonać jedną z następujących dwóch akcji, aby obiekt mógł być obiektem docelowym przez scenorys:  
  
-   Jeśli obiekt jest <xref:System.Windows.FrameworkElement> lub a <xref:System.Windows.FrameworkContentElement>, ustaw jego <xref:System.Windows.FrameworkElement.Name%2A> właściwość.  
  
-   Jeśli obiekt jest <xref:System.Windows.Freezable> lub niestandardowym <xref:System.Windows.FrameworkContentElement> lub <xref:System.Windows.FrameworkContentElement>, przypisz mu nazwę przy użyciu rozszerzenia znacznika [x:Name dyrektywy](~/docs/framework/xaml-services/x-name-directive.md) .  
  
 W przypadku korzystania z kodu można utworzyć obiekt docelowy przy użyciu <xref:System.Windows.NameScope.RegisterName%2A> metody, aby przypisać obiektowi nazwę.  
  
<a name="dependencyPropertyInfo_TargetName"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Media.Animation.Storyboard.TargetNameProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetNameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetNameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetNameProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> Identyfikuje załączoną właściwość.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> Identyfikuje załączoną właściwość.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetPropertyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetPropertyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetPropertyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> Identyfikuje załączoną właściwość.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
  </Members>
</Type>

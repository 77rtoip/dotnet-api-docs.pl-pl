<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0f642caada13897161927a70906f8be750f00d6b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36496472" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Storyboard&#xA;Inherits ParallelTimeline" />
  <TypeSignature Language="C++ CLI" Value="public ref class Storyboard : System::Windows::Media::Animation::ParallelTimeline" />
  <TypeSignature Language="F#" Value="type Storyboard = class&#xA;    inherit ParallelTimeline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Oś czasu do kontenera, która zawiera obiekt, a właściwość kierowanie informacji do jego animacji podrzędnych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Interaktywnie kontrolowanie Scenorys  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Scenorysu kontrolowane w znaczniku, ustaw <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> właściwość <xref:System.Windows.Media.Animation.BeginStoryboard> obiektu, który tworzy; na przykład zobacz [porady: wyzwalacze zdarzeń używana do sterowania scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md). Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="data-binding-and-animating-timelines"></a>Powiązanie danych i animacji na osi czasu  
 Większość właściwości osi czasu może być danych powiązany lub animowany; ze względu na sposób działania systemu chronometrażu, dane, które powiązane lub animowany osiach czasu nie zachowują się podobnie jak inne dane powiązany lub Animowanie obiektów. Aby zrozumieć ich zachowanie, pomaga zrozumieć, co oznacza to aktywować osi czasu.  
  
 Oś czasu została aktywowana, kopie są wprowadzane oś czasu i jego podrzędnych osi czasu. Te kopie są zablokowane (tylko do odczytu) i <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone z nich. Zegary wykonują rzeczywistą pracę z animowania właściwości docelowej. Jeśli osi czasu jest powiązany z danymi lub animowany, migawkę bieżącej wartości są wysyłane w przypadku tworzenia jego zegara. Mimo że oryginalnej osi czasu może kontynuować zmiany, nie ma jego zegara.  
  
 Dla osi czasu w celu odzwierciedlenia zmian animacji lub powiązania danych należy ponownie utworzyć jego zegara. Zegary nie są ponownie tworzone automatycznie automatycznie. Poniżej przedstawiono kilka sposobów, aby zastosować zmiany osi czasu:  
  
-   Jeśli oś czasu jest lub należy do <xref:System.Windows.Media.Animation.Storyboard>, można tworzyć i odzwierciedlenia zmian przez ponowne zastosowanie przy użyciu jego scenorysu <xref:System.Windows.Media.Animation.BeginStoryboard> lub <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody. To ustawienie działa po stronie również ponownego uruchomienia animacji. W kodzie, można użyć <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> metodę scenorysu z powrotem do jego poprzedniej pozycji.  
  
-   Jeśli wybrano animację bezpośrednio do właściwości przy użyciu <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> metody, wywołaj <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> metody ponownie i przekaż go animacji, które zostały zmodyfikowane.  
  
-   Podczas pracy bezpośrednio na poziomie zegara, utworzyć i zastosować nowy zestaw zegary i używać ich do zastąpienia poprzedniego zestawu utworzonego zegary.  
  
 Na przykład dane powiązane animacji, zobacz [próbki animacji krzywej składanej klucza](http://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Storyboard();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Media.Animation.Storyboard" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje zbiór animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin();" />
      <MemberSignature Language="F#" Value="member this.Begin : unit -&gt; unit" Usage="storyboard.Begin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich elementów docelowych i inicjuje je.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako miejsca docelowe animacji tego scenorysu. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich elementów docelowych i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowej są już animowany, zastąpienia przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przekazaniem zachowanie.  
  
 Scenorys pracę z tej metody nie wstrzymana, wznowione lub w przeciwnym razie interaktywnie kontrolowane po uruchomieniu. Aby wprowadzić sterowane scenorysu, należy użyć <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> lub <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto scenorysu do animowania <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Jest zawarty w <xref:System.Windows.FrameworkContentElement>jego nazwy zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako miejsca docelowe animacji tego scenorysu. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich elementów docelowych i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowej są już animowany, zastąpienia przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przekazaniem zachowanie.  
  
 Scenorys pracę z tej metody nie wstrzymana, wznowione lub w przeciwnym razie interaktywnie kontrolowane po uruchomieniu. Aby wprowadzić sterowane scenorysu, należy użyć <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> lub <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29> metody.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako miejsca docelowe animacji tego scenorysu. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> Jeśli scenorysu powinna być interaktywnie kontroli; w przeciwnym razie <see langword="false" />.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich elementów docelowych i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowej są już animowany, zastąpienia przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przekazaniem zachowanie.  
  
 Aby interaktywnie sterować tego scenorysu, należy określić ten sam `containingObject` podczas wywoływania metody interaktywnego, który pozwala rozpocząć scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osiach czasu zawiera. Zegary są przechowywane w `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu do animowania <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Jest zawarty w <xref:System.Windows.FrameworkContentElement>jego nazwy zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako miejsca docelowe animacji tego scenorysu. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="handoffBehavior">Zachowanie Nowa animacja powinna być używana do interakcji z dowolnego bieżącego animacji.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich elementów docelowych i inicjuje je, korzystając z określonego <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> je przy użyciu właściwości <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock> obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; nie obsługuje system chronometrażu Usuń zegary automatycznie.  
  
 Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegara.  
  
-   Aby usunąć wszystkie zegary z właściwości, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowany obiektu. Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> programu obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędnych zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest wywoływana, gdy efektywny czas trwania zegar jest nieskończoność.  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> do animowania po kliknięciu lewym przyciskiem myszy, a <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> po kliknięciu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako miejsca docelowe animacji tego scenorysu. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> Jeśli scenorysu powinna być interaktywnie kontroli; w przeciwnym razie <see langword="false" />.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich elementów docelowych i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowej są już animowany, zastąpienia przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przekazaniem zachowanie.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osiach czasu zawiera. Zegary są przechowywane w `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego określony <c>frameworkTemplate</c> została zastosowana. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Szablon, który ma być animowane.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich obiektów docelowych w ramach określonego szablonu oraz je inicjuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowej są już animowany, zastąpienia przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przekazaniem zachowanie.  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osiach czasu zawiera. Zegary są przechowywane w `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako miejsca docelowe animacji tego scenorysu. Animacje bez określonej <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="handoffBehavior">Zachowanie Nowa animacja powinna być używana do interakcji z dowolnego bieżącego animacji.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich elementów docelowych i inicjuje je, korzystając z określonego <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> do animowania po kliknięciu lewym przyciskiem myszy, a <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> po kliknięciu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako miejsca docelowe animacji tego scenorysu. Animacje bez określonej <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="handoffBehavior">Zachowanie Nowa animacja powinna być używana do interakcji z dowolnego bieżącego animacji.</param>
        <param name="isControllable">Deklaruje, czy animacja jest kontrolowane (może być wstrzymane) po uruchomieniu.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich elementów docelowych i inicjuje je, korzystając z określonego <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości docelowe są już animowany, są one zastąpione, używając zachowania przekazaniem określony.  
  
 Aby interaktywnie sterować tego scenorysu, należy określić ten sam `containingObject` podczas wywoływania metody interaktywnego, który pozwala rozpocząć scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osiach czasu zawiera. Zegary są przechowywane w `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> je przy użyciu właściwości <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock> obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; nie obsługuje system chronometrażu Usuń zegary automatycznie.  
  
 Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegara.  
  
-   Aby usunąć wszystkie zegary z właściwości, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowany obiektu. Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> programu obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędnych zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest wywoływana, gdy efektywny czas trwania zegar jest nieskończoność.  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu do animowania <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Jest zawarty w <xref:System.Windows.FrameworkContentElement>jego nazwy zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 W następnym przykładzie użyto <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> do animowania po kliknięciu lewym przyciskiem myszy, a <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> po kliknięciu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego określony <c>frameworkTemplate</c> została zastosowana.  Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Szablon, który ma być animowane.</param>
        <param name="isControllable">
          <see langword="true" /> Jeśli scenorysu powinna być interaktywnie kontroli; w przeciwnym razie <see langword="false" />.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich obiektów docelowych w ramach określonego szablonu oraz je inicjuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowej są już animowany, zastąpienia przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> przekazaniem zachowanie.  
  
 Aby interaktywnie sterować tego scenorysu, należy określić ten sam `containingObject` podczas wywoływania metody interaktywnego, który pozwala rozpocząć scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osiach czasu zawiera. Zegary są przechowywane w `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego określony <c>frameworkTemplate</c> została zastosowana. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Szablon, który ma być animowane.</param>
        <param name="handoffBehavior">Zachowanie Nowa animacja powinna być używana do interakcji z dowolnego bieżącego animacji.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich obiektów docelowych w ramach określonego szablonu oraz je inicjuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osiach czasu zawiera. Zegary są przechowywane w `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> je przy użyciu właściwości <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock> obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; nie obsługuje system chronometrażu Usuń zegary automatycznie.  
  
 Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegara.  
  
-   Aby usunąć wszystkie zegary z właściwości, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowany obiektu. Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> programu obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędnych zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest wywoływana, gdy efektywny czas trwania zegar jest nieskończoność.  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako miejsca docelowe animacji tego scenorysu. Animacje bez określonej <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="handoffBehavior">Zachowanie Nowa animacja powinna być używana do interakcji z dowolnego bieżącego animacji.</param>
        <param name="isControllable">Deklaruje, czy animacja jest kontrolowane (może być wstrzymane) po uruchomieniu.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich elementów docelowych i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osiach czasu zawiera. Zegary są przechowywane w `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> je przy użyciu właściwości <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock> obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; nie obsługuje system chronometrażu Usuń zegary automatycznie.  
  
 Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegara.  
  
-   Aby usunąć wszystkie zegary z właściwości, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowany obiektu. Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> programu obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędnych zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest wywoływana, gdy efektywny czas trwania zegar jest nieskończoność.  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia sterowane scenorysu.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 W następnym przykładzie użyto <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> do animowania po kliknięciu lewym przyciskiem myszy, a <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> po kliknięciu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego określony <c>frameworkTemplate</c> została zastosowana. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Szablon, który ma być animowane.</param>
        <param name="handoffBehavior">Zachowanie Nowa animacja powinna być używana do interakcji z dowolnego bieżącego animacji.</param>
        <param name="isControllable">
          <see langword="true" /> Jeśli scenorysu powinna być interaktywnie kontroli; w przeciwnym razie <see langword="false" />.</param>
        <summary>Stosuje animacje skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich obiektów docelowych w ramach określonego szablonu oraz je inicjuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie sterować tego scenorysu, należy określić ten sam `containingObject` podczas wywoływania metody interaktywnego, który pozwala rozpocząć scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osiach czasu zawiera. Zegary są przechowywane w `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> je przy użyciu właściwości <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock> obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; nie obsługuje system chronometrażu Usuń zegary automatycznie.  
  
 Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegara.  
  
-   Aby usunąć wszystkie zegary z właściwości, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metody animowany obiektu. Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> programu obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędnych zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest wywoływana, gdy efektywny czas trwania zegar jest nieskończoność.  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Storyboard" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Storyboard ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Animation.Storyboard" Usage="storyboard.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy modyfikowalną klonu tego <see cref="T:System.Windows.Media.Animation.Storyboard" />, tworzenie bezpośrednich kopii wartości tego obiektu. Podczas kopiowania właściwości zależności, ta metoda umożliwia skopiowanie powiązania odwołań i dane zasobów, ale nie rozpoznają może ale animacje lub ich bieżącymi wartościami.</summary>
        <returns>Można modyfikować klonowania bieżącego obiektu. Sklonowany obiekt <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość jest <see langword="false" /> nawet wtedy, gdy źródło <see cref="P:System.Windows.Freezable.IsFrozen" /> jest właściwość <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia kopii można modyfikować zablokowane <xref:System.Windows.Freezable> obiektów (lub dowolnej <xref:System.Windows.Freezable> obiektu). Dla wygody ta metoda zasłania dziedziczone wersji z silnie typizowaną implementację.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="storyboard.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Windows.Media.Animation.Storyboard" /> klasy.</summary>
        <returns>Nowy <see cref="T:System.Windows.Media.Animation.Storyboard" /> wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CreateInstance%2A> podczas tworzenia nowych wystąpień <xref:System.Windows.Media.Animation.Storyboard> klasy dla różnych metod klonowania (takich jak <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A>).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono Typowa implementacja <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Każdy <see cref="T:System.Windows.Media.Animation.Storyboard" /> podklasy należy zaimplementować tę metodę. Typowa implementacja jest po prostu Wywołaj Konstruktor domyślny klasy i zwracają wynik.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zegar <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> szybkości to szybkość, z jaką obecnie postępuje jego czas, w porównaniu do czasu rzeczywistych.  
  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentGlobalSpeed();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : unit -&gt; double" Usage="storyboard.GetCurrentGlobalSpeed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżąca szybkość globalnych lub 0, jeśli zegar został zatrzymany.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżąca szybkość globalnych, lub <see langword="null" /> Jeśli zegar został zatrzymany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zegar <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> szybkości to szybkość, z jaką obecnie postępuje jego czas, w porównaniu do czasu rzeczywistych.  
  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżąca szybkość globalnych, lub <see langword="null" /> Jeśli zegar został zatrzymany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zegar <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> szybkości to szybkość, z jaką obecnie postępuje jego czas, w porównaniu do czasu rzeczywistych.  
  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentIteration">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCurrentIteration();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : unit -&gt; int" Usage="storyboard.GetCurrentIteration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Ten zegar bieżącą iterację w jego bieżącym aktywnym okresie lub <see langword="null" /> Jeśli ten zegar zostanie zatrzymana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zegar pierwszej iteracji ma wartość 1.  
  
 Jeśli ma to scenorysu <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> ustawienie `true`, pełny iteracji składa się z pary wstecznego do przodu, nie tylko jeden z nich segmentów.  
  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkContentElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkContentElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Ten zegar bieżącą iterację w jego bieżącym aktywnym okresie lub <see langword="null" /> Jeśli ten zegar zostanie zatrzymana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zegar pierwszej iteracji ma wartość 1.  
  
 Jeśli ma to scenorysu <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> ustawienie `true`, pełny iteracji składa się z pary wstecznego do przodu, nie tylko jeden z nich segmentów.  
  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Ten zegar bieżącą iterację w jego bieżącym aktywnym okresie lub <see langword="null" /> Jeśli ten zegar zostanie zatrzymana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zegar pierwszej iteracji ma wartość 1.  
  
 Jeśli ten zegar osi czasu <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> ustawienie `true`, pełny iteracji składa się z pary wstecznego do przodu, nie tylko jeden z nich segmentów.  
  
 Niezależnie od jego bieżącej iteracji wyszukiwanie zegarze zwraca jego bieżącej iteracji do 1. Ponowne uruchamianie zegar zwraca również wartość jego bieżącej iteracji do 1.  
  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentProgress">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentProgress();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : unit -&gt; double" Usage="storyboard.GetCurrentProgress " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli ten zegar jest <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, lub 0.0, jeśli ten zegar jest aktywna i jego <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ma <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> z <see cref="P:System.Windows.Duration.Forever" />; w przeciwnym razie wartość z zakresu od 0,0 do 1,0, która wskazuje bieżący postęp ten zegar w jego bieżącej iteracji. Wartość 0.0 oznacza nie postępu, a wartość 1.0 oznacza, że zegar jest na końcu jego bieżącej iteracji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli ten zegar jest <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, lub 0.0, jeśli ten zegar jest aktywna i jego <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ma <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> z <see cref="P:System.Windows.Duration.Forever" />; w przeciwnym razie wartość z zakresu od 0,0 do 1,0, która wskazuje bieżący postęp ten zegar w jego bieżącej iteracji. Wartość 0.0 oznacza nie postępu, a wartość 1.0 oznacza, że zegar jest na końcu jego bieżącej iteracji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli ten zegar jest <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, lub 0.0, jeśli ten zegar jest aktywna i jego <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ma <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> z <see cref="P:System.Windows.Duration.Forever" />; w przeciwnym razie wartość z zakresu od 0,0 do 1,0, która wskazuje bieżący postęp ten zegar w jego bieżącej iteracji. Wartość 0.0 oznacza nie postępu, a wartość 1.0 oznacza, że zegar jest na końcu jego bieżącej iteracji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentState">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState () As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : unit -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżący stan zegara utworzone dla tego scenorysu: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, lub <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zorientować się, czy jest wstrzymana scenorysu. Aby określić, czy scenorysu jest wstrzymana, użyj <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> metody.  
  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkContentElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkContentElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżący stan zegara utworzone dla tego scenorysu: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, lub <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zorientować się, czy jest wstrzymana scenorysu. Aby określić, czy scenorysu jest wstrzymana, użyj <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> metody.  
  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżący stan zegara utworzone dla tego scenorysu: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, lub <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zorientować się, czy jest wstrzymana scenorysu. Aby określić, czy scenorysu jest wstrzymana, użyj <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> metody.  
  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentTime">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime () As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetCurrentTime();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : unit -&gt; TimeSpan" Usage="storyboard.GetCurrentTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli jest to scenorysu zegara <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; w przeciwnym razie bieżący czas zegara scenorysu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkContentElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkContentElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli jest to scenorysu zegara <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; w przeciwnym razie bieżący czas zegara scenorysu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli jest to scenorysu zegara <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; w przeciwnym razie bieżący czas zegara scenorysu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetIsPaused">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> jest wstrzymana.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused();" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : unit -&gt; bool" Usage="storyboard.GetIsPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> jest wstrzymana.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Media.Animation.Clock" /> utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> jest wstrzymana, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkContentElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkContentElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> jest wstrzymana.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Media.Animation.Clock" /> utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> jest wstrzymana, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> jest wstrzymana.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Media.Animation.Clock" /> utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> jest wstrzymana, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody można pobrać informacji o zegara scenorysu, musi być kontrolowane scenorysu. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTarget (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetTarget(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTarget : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Media.Animation.Storyboard.GetTarget element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Oś czasu, w którym można pobrać <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> wartość określonego <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>Obiekt zależności objęci <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Media.Animation.Storyboard.Target%2A> dołączona właściwość z animacji osi czasu, aby wskazać, obiekt, który ich elementami docelowymi. Aby uzyskać więcej informacji na temat działania przeznaczonych dla scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetName (element As DependencyObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTargetName(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetName : System.Windows.DependencyObject -&gt; string" Usage="System.Windows.Media.Animation.Storyboard.GetTargetName element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Oś czasu, w którym można pobrać <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> wartość określonego <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>Nazwa obiektu zależności objęci <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> dołączona właściwość określonego obiektu. Aby uzyskać więcej informacji na temat działania przeznaczonych dla scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetProperty (element As DependencyObject) As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PropertyPath ^ GetTargetProperty(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetProperty : System.Windows.DependencyObject -&gt; System.Windows.PropertyPath" Usage="System.Windows.Media.Animation.Storyboard.GetTargetProperty element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego można pobrać <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> wartość określonego <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>Właściwość będąca celem <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> dołączona właściwość określonego obiektu. Aby uzyskać więcej informacji na temat działania przeznaczonych dla scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> dołączona właściwość. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Należy pamiętać, że jeśli <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> został ustawiony w znacznikach, ta metoda zwraca pustą <xref:System.Windows.PropertyPath> ponieważ odwołania do właściwości jest rozwiązany i przechowywane wewnętrznie, gdy zostanie przeanalizowany.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pause">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberSignature Language="F#" Value="member this.Pause : unit -&gt; unit" Usage="storyboard.Pause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wstrzymuje scenorysu, ale nie ma zauważalny efektu Jeśli nie jest aktywny lub jest aktualnie wstrzymana. Jako efekt uboczny wszystkie skojarzone elementy podrzędne są również wstrzymane.  
  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="beginning-a-paused-storyboard"></a>Począwszy od scenorysu wstrzymana  
 Gdy użytkownik <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> scenorysu, który został wstrzymany, wygląda na to, aby wznowić i uruchomić ponownie. Jednak to nie to, co faktycznie się nie dzieje. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Metoda zastępuje faktycznie wstrzymana <xref:System.Windows.Media.Animation.Storyboard> za pomocą nowej wersji ze stanu wstrzymania. Zawsze <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metoda jest wywoływana, zegara obiekty są tworzone dla scenorysu. Zegary są dystrybuowane do ich animowania właściwości. Tak, gdy <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metoda jest wywoływana ponownie, nie jest ponownie uruchamiany zegarami jego; zastępuje je z nowej zegary.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Wstrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> określonego <see cref="T:System.Windows.FrameworkContentElement" /> skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wstrzymuje scenorysu, ale nie ma zauważalny efektu Jeśli nie jest aktywny lub jest aktualnie wstrzymana. Jako efekt uboczny wszystkie skojarzone elementy podrzędne są również wstrzymane.  
  
 Wyszukiwanie wstrzymanej scenorysu nie spowodują jego wznowienie. Jedynym sposobem na wznowienie wstrzymanego scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. Wywoływanie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> nową nazwę, która ma wygląd jej wznawianie metoda ponownie zastępuje wstrzymanej scenorysu.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Z przykładem, zobacz [porady: kontrolować scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wstrzymywanie wyzwalaczy zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
## <a name="beginning-a-paused-storyboard"></a>Począwszy od scenorysu wstrzymana  
 Gdy użytkownik <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> scenorysu, który został wstrzymany, wygląda na to, aby wznowić i uruchomić ponownie. Jednak to nie to, co faktycznie się nie dzieje. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Metoda faktycznie zastępuje się ze stanu wstrzymania wersji. Zawsze <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metoda jest wywoływana, zegara obiekty są tworzone dla scenorysu. Zegary są dystrybuowane do ich animowania właściwości. Tak, gdy <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metoda jest wywoływana ponownie, nie jest ponownie uruchamiany zegarami jego; zastępuje je z nowej zegary.  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu do animowania <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Jest zawarty w <xref:System.Windows.FrameworkContentElement>jego nazwy zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Wstrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> określonego <see cref="T:System.Windows.FrameworkElement" /> skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wstrzymuje scenorysu, ale nie ma zauważalny efektu Jeśli nie jest aktywny lub jest aktualnie wstrzymana. Jako efekt uboczny wszystkie skojarzone elementy podrzędne są również wstrzymane.  
  
 Wyszukiwanie wstrzymanej scenorysu nie spowodują jego wznowienie. Jedynym sposobem na wznowienie wstrzymanego scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. Wywoływanie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> nową nazwę, która ma wygląd jej wznawianie metoda ponownie zastępuje wstrzymanej scenorysu.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wstrzymywanie wyzwalaczy zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
## <a name="beginning-a-paused-storyboard"></a>Począwszy od scenorysu wstrzymana  
 Gdy użytkownik <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> scenorysu, który został wstrzymany, wygląda na to, aby wznowić i uruchomić ponownie. Jednak to nie to, co faktycznie się nie dzieje. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Metoda faktycznie zastępuje się ze stanu wstrzymania wersji. Zawsze <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metoda jest wywoływana, zegara obiekty są tworzone dla scenorysu. Zegary są dystrybuowane do ich animowania właściwości. Tak, gdy <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metoda jest wywoływana ponownie, nie jest ponownie uruchamiany zegarami jego; zastępuje je z nowej zegary.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />. Animacji, które należą do tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> nie wpływa na właściwości one raz animowany, niezależnie od ich <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> ustawienie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="storyboard.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />. Animacji, które należą do tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> nie wpływa na właściwości one raz animowany, niezależnie od ich <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> ustawienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wszystkie interaktywnego działania podjęte w <xref:System.Windows.Media.Animation.Clock>i w związku z tym również na <xref:System.Windows.Media.Animation.Storyboard>, są dokonywane na następny znaczników aparatu chronometrażu, które odbywa się tuż przed następnym renderowania. Oznacza to, że <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> metody nadal ma wpływ na animowanej właściwości do tego czasu. Innymi słowy przy następnym ramki jest wyświetlana, scenorysu zostaną usunięte. Jeśli musisz usunąć skojarzenie z właściwości animacji przed upływem wskazanego terminu, użyj <xref:System.Windows.UIElement.BeginAnimation%2A> metody z `animation` wartości parametru `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Usuwa <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />. Animacji, które należą do tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> nie wpływa na właściwości one raz animowany, niezależnie od ich <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> ustawienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Usuwanie wyzwalaczy zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Usuwa <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />. Animacji, które należą do tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> nie wpływa na właściwości one raz animowany, niezależnie od ich <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> ustawienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Usuwanie wyzwalaczy zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resume">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wznawia <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="storyboard.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Wznawia <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wznawianie scenorysu, który nie jest wstrzymany nie ma znaczenia.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wyszukiwanie wstrzymanej scenorysu nie spowodują jego wznowienie. Jedynym sposobem na wznowienie wstrzymanego scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. Wywoływanie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> starego scenorysu, który ma wygląd jej wznawianie zastępuje metodę po rozpoczęciu scenorysu.  
  
 Wznawianie wstrzymanej wyzwala zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu do animowania <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Jest zawarty w <xref:System.Windows.FrameworkContentElement>jego nazwy zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Wznawia <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wznawianie scenorysu, który nie jest wstrzymany nie ma znaczenia.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wyszukiwanie wstrzymanej scenorysu nie spowodują jego wznowienie. Jedynym sposobem na wznowienie wstrzymanego scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. Wywoływanie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> starego scenorysu, który ma wygląd jej wznawianie zastępuje metodę po rozpoczęciu scenorysu.  
  
 Wznawianie wstrzymanej wyzwala zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> nowe miejsce, gdy wystąpi dalej znaczników zegara.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan -&gt; unit" Usage="storyboard.Seek offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnią lub ujemną opisujący kwota za pomocą którego oś czasu należy przenosić do przodu i do tyłu.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do określonej pozycji. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądania wyszukiwania podczas następnego znaczników zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że operacji szukania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawień konta. Scenorysu jest traktowana tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1, a nie <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnią lub ujemną, która opisuje ilość za pomocą którego oś czasu należy przejść do przodu lub do tyłu z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Położenie, w którym <c>przesunięcie</c> została zastosowana.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do określonej pozycji. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądania wyszukiwania podczas następnego znaczników zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że operacji szukania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawień konta. Scenorysu jest traktowana tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1, a nie <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <param name="offset">Wartość dodatnią lub ujemną, która opisuje ilość za pomocą którego oś czasu należy przejść do przodu lub do tyłu z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Położenie, w którym <c>przesunięcie</c> została zastosowana.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do określonej pozycji. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądania wyszukiwania podczas następnego znaczników zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że operacji szukania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawień konta. Scenorysu jest traktowana tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1, a nie <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Ta metoda zmiany zegara scenorysu <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> do <xref:System.Windows.Media.Animation.ClockState.Active>. Ta metoda nie ma wpływu na drzewie chronometrażu do następnego wznowienia znaczników jest przetwarzana. Jako efekt uboczny odpowiednie również nie pojawienia się do tego czasu.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wyszukiwanie wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono oba <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metody.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <param name="offset">Wartość dodatnią lub ujemną, która opisuje ilość za pomocą którego oś czasu należy przejść do przodu lub do tyłu z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Położenie, w którym <c>przesunięcie</c> została zastosowana.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do określonej pozycji. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądania wyszukiwania podczas następnego znaczników zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że operacji szukania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawień konta. Scenorysu jest traktowana tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1, a nie <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Ta metoda zmiany zegara scenorysu <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> do <xref:System.Windows.Media.Animation.ClockState.Active>. Ta metoda nie ma wpływu na drzewie chronometrażu do następnego wznowienia znaczników jest przetwarzana. Jako efekt uboczny odpowiednie również nie pojawienia się do tego czasu.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i usuwane, jeśli ma zostać kontrolowane. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wyszukiwanie wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak do wyszukania (pomiń) do jednej sekundy po rozpoczęciu scenorysu.  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 W kolejnym przykładzie pokazano zarówno <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metody.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SeekAlignedToLastTick">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do nowej pozycji bezpośrednio (synchronicznie).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan -&gt; unit" Usage="storyboard.SeekAlignedToLastTick offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnią lub ujemną opisujący kwota za pomocą którego oś czasu należy przenosić do przodu i do tyłu.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do nowej pozycji bezpośrednio (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Wyrównuje czasie seeked <xref:System.Windows.Media.Animation.Storyboard> z ostatnich znaczników zegara. Wartości od razu są aktualizowane w celu odzwierciedlenia zmian z powodu <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, mimo że ekranu nie odzwierciedla te zmiany do aktualizacji ekranu.  
  
 Należy pamiętać, że operacji szukania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawień konta. Scenorysu jest traktowana tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1, a nie <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnią lub ujemną, która opisuje ilość za pomocą którego oś czasu należy przejść do przodu lub do tyłu z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Położenie, w którym <c>przesunięcie</c> została zastosowana.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do nowej pozycji bezpośrednio (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Wyrównuje czasie seeked <xref:System.Windows.Media.Animation.Storyboard> z ostatnich znaczników zegara. Wartości od razu są aktualizowane w celu odzwierciedlenia zmian z powodu <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, mimo że ekranu nie odzwierciedla te zmiany do aktualizacji ekranu.  
  
 Należy pamiętać, że operacji szukania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawień konta. Scenorysu jest traktowana tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1, a nie <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <param name="offset">Wartość dodatnią lub ujemną, która opisuje ilość za pomocą którego oś czasu należy przejść do przodu lub do tyłu z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Położenie, w którym <c>przesunięcie</c> została zastosowana.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do nowej pozycji bezpośrednio (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Wyrównuje czasie seeked <xref:System.Windows.Media.Animation.Storyboard> z ostatnich znaczników zegara. Wartości od razu są aktualizowane w celu odzwierciedlenia zmian z powodu <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, mimo że ekranu nie odzwierciedla te zmiany do aktualizacji ekranu.  
  
 Należy pamiętać, że operacji szukania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawień konta. Scenorysu jest traktowana tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1, a nie <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Ta metoda zmiany zegara scenorysu <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> do  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Wyszukiwanie wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono oba <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metody.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <param name="offset">Wartość dodatnią lub ujemną, która opisuje ilość za pomocą którego oś czasu należy przejść do przodu lub do tyłu z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Położenie, w którym <c>przesunięcie</c> została zastosowana.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do nowej pozycji bezpośrednio (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Wyrównuje czasie seeked <xref:System.Windows.Media.Animation.Storyboard> z ostatnich znaczników zegara. Wartości od razu są aktualizowane w celu odzwierciedlenia zmian z powodu <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, mimo że ekranu nie odzwierciedla te zmiany do aktualizacji ekranu.  
  
 Należy pamiętać, że operacji szukania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawień konta. Scenorysu jest traktowana tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1, a nie <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Ta metoda zmiany zegara scenorysu <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> do  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Wyszukiwanie wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono oba <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metody.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSpeedRatio">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia współczynnik interakcyjne szybkości <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : double -&gt; unit" Usage="storyboard.SetSpeedRatio speedRatio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Wartością skończoną większą niż zero jest wskaźnik prędkości interakcyjne nowego scenorysu. Wartość ta jest mnożona przed scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wartość określającą szybkość scenorysu. Ta wartość nie powoduje zastąpienia scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> właściwości. Na przykład wywołanie tej metody i określając interaktywnych szybkości stopień 3 scenorysu z <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> 0,5 daje scenorysu szybkość 1.5.</param>
        <summary>Ustawia współczynnik interakcyjne szybkości <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkContentElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkContentElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkContentElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <param name="speedRatio">Wartością skończoną większą niż zero jest wskaźnik prędkości interakcyjne nowego scenorysu. Wartość ta jest mnożona przed scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wartość określającą szybkość scenorysu. Ta wartość nie powoduje zastąpienia scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> właściwości. Na przykład wywołanie tej metody i określając interaktywnych szybkości stopień 3 scenorysu z <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> 0,5 daje scenorysu szybkość 1.5.</param>
        <summary>Ustawia stosunek interakcyjne szybkości <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wywołanie tej metody wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu do animowania <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Jest zawarty w <xref:System.Windows.FrameworkContentElement>jego nazwy zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <param name="speedRatio">Wartością skończoną większą niż zero jest wskaźnik prędkości interakcyjne nowego scenorysu. Wartość ta jest mnożona przed scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wartość określającą szybkość scenorysu. Ta wartość nie powoduje zastąpienia scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> właściwości. Na przykład wywołanie tej metody i określając interaktywnych szybkości stopień 3 scenorysu z <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> 0,5 daje scenorysu szybkość 1.5.</param>
        <summary>Ustawia stosunek interakcyjne szybkości <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wywołanie tej metody wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTarget (element As DependencyObject, value As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTarget(System::Windows::DependencyObject ^ element, System::Windows::DependencyObject ^ value);" />
      <MemberSignature Language="F#" Value="static member SetTarget : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTarget (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> Który powinna docelowy obiekt zależności określony.</param>
        <param name="value">Obiekt zależności do obiektu docelowego.</param>
        <summary>Sprawia, że określony <see cref="T:System.Windows.Media.Animation.Timeline" /> docelowy obiekt zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.Windows.Media.Animation.Storyboard.Target%2A> dołączona właściwość określonego obiektu. Aby uzyskać więcej informacji na temat działania przeznaczonych dla scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
> [!NOTE]
>  <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Właściwość nie jest możliwy do serializacji, ponieważ może zostać ustawiony dla każdego <xref:System.Windows.DependencyObject>. Ten obiekt mogą być poprawnie przywoływane z XAML nie jest gwarantowana.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetName (element As DependencyObject, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetName(System::Windows::DependencyObject ^ element, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member SetTargetName : System.Windows.DependencyObject * string -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetName (element, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> Który powinna docelowy obiekt zależności określony.</param>
        <param name="name">Nazwa obiektu zależności do obiektu docelowego.</param>
        <summary>Sprawia, że określony <see cref="T:System.Windows.Media.Animation.Timeline" /> docelowy obiekt zależności o określonej nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> dołączona właściwość określonego obiektu. Aby uzyskać więcej informacji na temat działania przeznaczonych dla scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetProperty (element As DependencyObject, path As PropertyPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetProperty(System::Windows::DependencyObject ^ element, System::Windows::PropertyPath ^ path);" />
      <MemberSignature Language="F#" Value="static member SetTargetProperty : System.Windows.DependencyObject * System.Windows.PropertyPath -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetProperty (element, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> z którą chcesz skojarzyć właściwości określonym zależności.</param>
        <param name="path">Ścieżki, w której opisano właściwości zależności, aby być animowane.</param>
        <summary>Sprawia, że określony <see cref="T:System.Windows.Media.Animation.Timeline" /> zależności określona właściwość target.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> dołączona właściwość określonego obiektu. Aby uzyskać więcej informacji na temat działania przeznaczonych dla scenorysu, zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A>. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości, zobacz [dołączony Przegląd właściwości](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipToFill">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zmienia bieżący czas tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill();" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : unit -&gt; unit" Usage="storyboard.SkipToFill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmienia bieżący czas tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Zmienia bieżący czas tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesuwa scenorysu bieżący czas na końcu okresu aktywnego; zachowanie scenorysu w tym momencie jest określony przez jego <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> ustawienie. Jeśli <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> ustawiono <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, wypełnia scenorysu; Jeśli właściwość jest ustawiona na <xref:System.Windows.Media.Animation.FillBehavior.Stop>, zatrzymuje scenorysu.  
  
 Wywołanie tej metody scenorysu z nieograniczony czas trwania, nieograniczoną liczbę powtórzeń nie ma znaczenia. Wywołanie tej metody nieaktywne scenorysu nie ma znaczenia.  
  
 Zaawansowane zegar do wypełnienia jego okresu wyzwalaczy <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu do animowania <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Jest zawarty w <xref:System.Windows.FrameworkContentElement>jego nazwy zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Zmienia bieżący czas tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesuwa scenorysu bieżący czas na końcu okresu aktywnego; zachowanie scenorysu w tym momencie jest określony przez jego <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> ustawienie. Jeśli <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> ustawiono <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, wypełnia scenorysu; Jeśli właściwość jest ustawiona na <xref:System.Windows.Media.Animation.FillBehavior.Stop>, zatrzymuje scenorysu.  
  
 Wywołanie tej metody scenorysu z nieograniczony czas trwania, nieograniczoną liczbę powtórzeń nie ma znaczenia. Wywołanie tej metody nieaktywne scenorysu nie ma znaczenia.  
  
 Zaawansowane zegar do wypełnienia jego okresu wyzwalaczy <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Stop">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zatrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="storyboard.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zatrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że zatrzymanie scenorysu nie uruchomi się <xref:System.Windows.Media.Animation.Timeline.Completed> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Zatrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Media.Animation.ClockState.Stopped> scenorysu nie wpływa na jej właściwości elementu docelowego: właściwości, które zostały animowany powrócić do poprzedniej wartości.  
  
 Zatrzymywanie wyzwalaczy zegara <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzeń, ale nie <xref:System.Windows.Media.Animation.Timeline.Completed> zdarzeń.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu do animowania <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Jest zawarty w <xref:System.Windows.FrameworkContentElement>jego nazwy zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, kiedy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> wywołano metodę. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiektów, które zostały utworzone dla tego scenorysu i jej funkcji podrzędnych.</param>
        <summary>Zatrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony dla tego <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Media.Animation.ClockState.Stopped> scenorysu nie wpływa na jej właściwości elementu docelowego: właściwości, które zostały animowany powrócić do poprzedniej wartości.  
  
 Zatrzymywanie wyzwalaczy zegara <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzeń, ale nie <xref:System.Windows.Media.Animation.Timeline.Completed> zdarzeń.  
  
 Aby interaktywnie sterować tego scenorysu, należy użyć takie same `containingObject` parametr podczas wywoływania metod interaktywnych, które zostały użyte do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby wprowadzić scenorysu kontrolowane w kodzie, należy użyć odpowiedniego przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> — metoda i określ `true` dokonanie kontroli. Na przykład zobacz [porady: kontrolowanie scenorysu po jego uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="ILAsm" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.Target" />
      <MemberSignature Language="VB.NET" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="F#" Value="see GetTarget, and SetTarget" Usage="see GetTarget, and SetTarget" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="ILAsm" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      <MemberSignature Language="VB.NET" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="F#" Value="see GetTargetName, and SetTargetName" Usage="see GetTargetName, and SetTargetName" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetNameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetNameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetNameProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> dołączona właściwość.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> dołączona właściwość.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetPropertyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetPropertyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetPropertyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> dołączona właściwość.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
  </Members>
</Type>
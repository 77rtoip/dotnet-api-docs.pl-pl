<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="277dccf156343c8e0c972aed5cd1f2cf6e323c87" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48646421" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Storyboard&#xA;Inherits ParallelTimeline" />
  <TypeSignature Language="C++ CLI" Value="public ref class Storyboard : System::Windows::Media::Animation::ParallelTimeline" />
  <TypeSignature Language="F#" Value="type Storyboard = class&#xA;    inherit ParallelTimeline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Oś czasu do kontenera, która zawiera obiekt i właściwości kierowanie informacji do jego podrzędnych animacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Kontrolowanie interaktywnie scenorysów  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Scenorysu kontrolowane w znaczniku, ustaw <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> właściwość <xref:System.Windows.Media.Animation.BeginStoryboard> obiekt, który tworzy; na przykład, zobacz [porady: Użyj wyzwalaczy zdarzeń, aby kontrolować Scenorys po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md). Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="data-binding-and-animating-timelines"></a>Powiązanie danych oraz animowanie osi czasu  
 Większość właściwości osi czasu mogą zawierać dane, powiązany lub animowany; ze względu na sposób działa system chronometrażu, dane, które są powiązane lub animowany osi czasu nie zachowywać się podobnie jak inne dane powiązane lub animowany obiektów. Aby zrozumieć ich zachowania, pomaga to zrozumieć, znaczenia aktywować na osi czasu.  
  
 Po aktywowaniu osi czasu kopie są wprowadzane osi czasu i jego podrzędnych osi czasu. Te kopie są zablokowane (wprowadzone w trybie tylko do odczytu) i <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone z nich. Zegary wykonują rzeczywistą pracę z animowanie właściwości docelowych. Jeśli jest powiązany z danymi lub animowany, migawkę bieżącej wartości wykonywane, gdy zostanie utworzony jego zegara. Mimo że oryginalnej osi czasu, może nadal ulegałyby zmianie, nie jest jego zegara.  
  
 Dla osi czasu uwzględnić zmiany w animacji lub powiązania danych należy ponownie utworzyć jego zegara. Zegary nie są ponownie tworzone dla Ciebie automatycznie. Poniżej przedstawiono kilka sposobów, aby zastosować zmiany osi czasu:  
  
-   Jeśli jest na osi czasu, lub należy do <xref:System.Windows.Media.Animation.Storyboard>, możesz przekształcić ją odzwierciedlenia zmian przez ponowne wprowadzenie jego za pomocą scenorysu <xref:System.Windows.Media.Animation.BeginStoryboard> lub <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody. Ma to również ponowne uruchomienie animacji efektem ubocznym. W kodzie, można użyć <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> metodę scenorysu z powrotem do jego poprzedniej pozycji.  
  
-   Jeśli animacji są stosowane bezpośrednio do właściwości przy użyciu <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> metody, wywołanie <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> ponownie metodą i przekaż go animacji, który został zmodyfikowany.  
  
-   Pracując bezpośrednio na poziomie zegara, utworzyć i zastosować nowy zestaw zegary i ich używać w celu zastąpienia poprzedniego zestawu utworzonego zegary.  
  
 Na przykład dane powiązane animacji, zobacz [przykład animacji z krzywymi składanymi klucz](http://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Storyboard();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Media.Animation.Storyboard" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje zbiór animacji skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin();" />
      <MemberSignature Language="F#" Value="member this.Begin : unit -&gt; unit" Usage="storyboard.Begin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich celów oraz je inicjuje.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako elementy docelowe tego scenorysu animacji. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich celów oraz je inicjuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowych są już animowany, zostaną zastąpione przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> zachowanie dotyczące przekazania.  
  
 Scenorysy pracę przy użyciu tej metody nie wstrzymana, wznowić lub w przeciwnym razie interaktywnie kontrolowane po uruchomieniu. Aby scenorysu sterowane, użyj <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> lub <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto scenorysu, aby animować <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się w obrębie <xref:System.Windows.FrameworkContentElement>firmy Nazwa zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako elementy docelowe tego scenorysu animacji. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich celów oraz je inicjuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowych są już animowany, zostaną zastąpione przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> zachowanie dotyczące przekazania.  
  
 Scenorysy pracę przy użyciu tej metody nie wstrzymana, wznowić lub w przeciwnym razie interaktywnie kontrolowane po uruchomieniu. Aby scenorysu sterowane, użyj <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> lub <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29> metody.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako elementy docelowe tego scenorysu animacji. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> Jeśli scenorysu powinien być interaktywnie kontroli; w przeciwnym razie <see langword="false" />.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich celów oraz je inicjuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowych są już animowany, zostaną zastąpione przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> zachowanie dotyczące przekazania.  
  
 Aby interaktywnie kontrolować scenorys, należy określić ten sam `containingObject` podczas wywoływania metod interaktywnych, która umożliwia rozpoczęcie scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osi czasu zawiera. Zegary są przechowywane w usłudze `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu, aby animować <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się w obrębie <xref:System.Windows.FrameworkContentElement>firmy Nazwa zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako elementy docelowe tego scenorysu animacji. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="handoffBehavior">Zachowanie nowej animacji należy używać do interakcji z dowolnej bieżącej animacji.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do swoich celów i inicjuje je przy użyciu określonego <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> za pomocą właściwości <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> obiektów była poprzednio skojarzona z tą właściwością, kontynuując zużywanie zasobów systemowych; nie obsługuje system chronometrażu automatyczne usuwanie zegary.  
  
 Aby uniknąć problemów z wydajnością, po zastosowaniu dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z animowanych właściwości po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegara.  
  
-   Aby usunąć wszystkie zegary z właściwością, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metoda obiekt animowany. Określa właściwość, jest animowany podczas pierwszego parametru i `null` jako drugiego. Spowoduje to usunięcie wszystkie zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołać <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> program obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego można kontrolować, <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędne zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest wywoływana, gdy efektywnym czasem trwania zegara jest nieskończona.  W takim przypadku użytkownik musi określić, kiedy do wywołania <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to głównie problemu dla animacji na obiekty, które mają długi okres istnienia.  Gdy obiekt jest bezużyteczne, jego zegary również są odłączone i wyrzucania.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [Animacja i System chronometrażu w — Przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> animować po kliknięciu lewym przyciskiem myszy, a <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> po kliknięciu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako elementy docelowe tego scenorysu animacji. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> Jeśli scenorysu powinien być interaktywnie kontroli; w przeciwnym razie <see langword="false" />.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich celów oraz je inicjuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowych są już animowany, zostaną zastąpione przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> zachowanie dotyczące przekazania.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osi czasu zawiera. Zegary są przechowywane w usłudze `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego określony <c>frameworkTemplate</c> zostały zastosowane. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Szablon Aby animować.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do swoich celów w ramach określonego szablonu i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowych są już animowany, zostaną zastąpione przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> zachowanie dotyczące przekazania.  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osi czasu zawiera. Zegary są przechowywane w usłudze `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako elementy docelowe tego scenorysu animacji. Animacje bez określonej <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="handoffBehavior">Zachowanie nowej animacji należy używać do interakcji z dowolnej bieżącej animacji.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do swoich celów i inicjuje je przy użyciu określonego <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> animować po kliknięciu lewym przyciskiem myszy, a <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> po kliknięciu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako elementy docelowe tego scenorysu animacji. Animacje bez określonej <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="handoffBehavior">Zachowanie nowej animacji należy używać do interakcji z dowolnej bieżącej animacji.</param>
        <param name="isControllable">Deklaruje, czy animacja jest kontrolowane (może być wstrzymana) po uruchomieniu.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do swoich celów i inicjuje je przy użyciu określonego <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowych są już animowany, zostaną zastąpione przy użyciu zachowanie dotyczące określonego przekazania.  
  
 Aby interaktywnie kontrolować scenorys, należy określić ten sam `containingObject` podczas wywoływania metod interaktywnych, która umożliwia rozpoczęcie scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osi czasu zawiera. Zegary są przechowywane w usłudze `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> za pomocą właściwości <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> obiektów była poprzednio skojarzona z tą właściwością, kontynuując zużywanie zasobów systemowych; nie obsługuje system chronometrażu automatyczne usuwanie zegary.  
  
 Aby uniknąć problemów z wydajnością, po zastosowaniu dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z animowanych właściwości po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegara.  
  
-   Aby usunąć wszystkie zegary z właściwością, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metoda obiekt animowany. Określa właściwość, jest animowany podczas pierwszego parametru i `null` jako drugiego. Spowoduje to usunięcie wszystkie zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołać <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> program obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego można kontrolować, <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędne zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest wywoływana, gdy efektywnym czasem trwania zegara jest nieskończona.  W takim przypadku użytkownik musi określić, kiedy do wywołania <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to głównie problemu dla animacji na obiekty, które mają długi okres istnienia.  Gdy obiekt jest bezużyteczne, jego zegary również są odłączone i wyrzucania.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [Animacja i System chronometrażu w — Przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu, aby animować <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się w obrębie <xref:System.Windows.FrameworkContentElement>firmy Nazwa zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 W następnym przykładzie użyto <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> animować po kliknięciu lewym przyciskiem myszy, a <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> po kliknięciu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego określony <c>frameworkTemplate</c> zostały zastosowane.  Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Szablon Aby animować.</param>
        <param name="isControllable">
          <see langword="true" /> Jeśli scenorysu powinien być interaktywnie kontroli; w przeciwnym razie <see langword="false" />.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do swoich celów w ramach określonego szablonu i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwości docelowych są już animowany, zostaną zastąpione przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> zachowanie dotyczące przekazania.  
  
 Aby interaktywnie kontrolować scenorys, należy określić ten sam `containingObject` podczas wywoływania metod interaktywnych, która umożliwia rozpoczęcie scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osi czasu zawiera. Zegary są przechowywane w usłudze `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego określony <c>frameworkTemplate</c> zostały zastosowane. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Szablon Aby animować.</param>
        <param name="handoffBehavior">Zachowanie nowej animacji należy używać do interakcji z dowolnej bieżącej animacji.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do swoich celów w ramach określonego szablonu i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osi czasu zawiera. Zegary są przechowywane w usłudze `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> za pomocą właściwości <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> obiektów była poprzednio skojarzona z tą właściwością, kontynuując zużywanie zasobów systemowych; nie obsługuje system chronometrażu automatyczne usuwanie zegary.  
  
 Aby uniknąć problemów z wydajnością, po zastosowaniu dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z animowanych właściwości po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegara.  
  
-   Aby usunąć wszystkie zegary z właściwością, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metoda obiekt animowany. Określa właściwość, jest animowany podczas pierwszego parametru i `null` jako drugiego. Spowoduje to usunięcie wszystkie zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołać <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> program obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego można kontrolować, <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędne zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest wywoływana, gdy efektywnym czasem trwania zegara jest nieskończona.  W takim przypadku użytkownik musi określić, kiedy do wywołania <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to głównie problemu dla animacji na obiekty, które mają długi okres istnienia.  Gdy obiekt jest bezużyteczne, jego zegary również są odłączone i wyrzucania.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [Animacja i System chronometrażu w — Przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt znajdujący się w obrębie tej samej nazwie jako elementy docelowe tego scenorysu animacji. Animacje bez określonej <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="handoffBehavior">Zachowanie nowej animacji należy używać do interakcji z dowolnej bieżącej animacji.</param>
        <param name="isControllable">Deklaruje, czy animacja jest kontrolowane (może być wstrzymana) po uruchomieniu.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do ich celów oraz je inicjuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osi czasu zawiera. Zegary są przechowywane w usłudze `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> za pomocą właściwości <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> obiektów była poprzednio skojarzona z tą właściwością, kontynuując zużywanie zasobów systemowych; nie obsługuje system chronometrażu automatyczne usuwanie zegary.  
  
 Aby uniknąć problemów z wydajnością, po zastosowaniu dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z animowanych właściwości po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegara.  
  
-   Aby usunąć wszystkie zegary z właściwością, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metoda obiekt animowany. Określa właściwość, jest animowany podczas pierwszego parametru i `null` jako drugiego. Spowoduje to usunięcie wszystkie zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołać <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> program obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego można kontrolować, <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędne zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest wywoływana, gdy efektywnym czasem trwania zegara jest nieskończona.  W takim przypadku użytkownik musi określić, kiedy do wywołania <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to głównie problemu dla animacji na obiekty, które mają długi okres istnienia.  Gdy obiekt jest bezużyteczne, jego zegary również są odłączone i wyrzucania.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [Animacja i System chronometrażu w — Przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć sterowane scenorysu.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 W następnym przykładzie użyto <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> animować po kliknięciu lewym przyciskiem myszy, a <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> po kliknięciu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Obiekt, do którego określony <c>frameworkTemplate</c> zostały zastosowane. Animacje bez <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> są stosowane do <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Szablon Aby animować.</param>
        <param name="handoffBehavior">Zachowanie nowej animacji należy używać do interakcji z dowolnej bieżącej animacji.</param>
        <param name="isControllable">
          <see langword="true" /> Jeśli scenorysu powinien być interaktywnie kontroli; w przeciwnym razie <see langword="false" />.</param>
        <summary>Stosuje się animacjami skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> do swoich celów w ramach określonego szablonu i inicjuje je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować scenorys, należy określić ten sam `containingObject` podczas wywoływania metod interaktywnych, która umożliwia rozpoczęcie scenorysu  
  
 Gdy ta metoda jest wywoływana, <xref:System.Windows.Media.Animation.Clock> obiekty są tworzone dla scenorysu i wszelkie osi czasu zawiera. Zegary są przechowywane w usłudze `containingObject`.  
  
 Począwszy od wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzenia.  
  
## <a name="using-the-compose-handoffbehavior"></a>Korzystanie z Compose HandoffBehavior  
 Po zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock> za pomocą właściwości <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> obiektów była poprzednio skojarzona z tą właściwością, kontynuując zużywanie zasobów systemowych; nie obsługuje system chronometrażu automatyczne usuwanie zegary.  
  
 Aby uniknąć problemów z wydajnością, po zastosowaniu dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, tworzenie zegary należy usunąć z animowanych właściwości po ich zakończeniu. Istnieje kilka sposobów, aby usunąć zegara.  
  
-   Aby usunąć wszystkie zegary z właściwością, należy użyć <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metoda obiekt animowany. Określa właściwość, jest animowany podczas pierwszego parametru i `null` jako drugiego. Spowoduje to usunięcie wszystkie zegary animacji z właściwości.  
  
-   Aby usunąć określony <xref:System.Windows.Media.Animation.AnimationClock> z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość <xref:System.Windows.Media.Animation.AnimationClock> można pobrać <xref:System.Windows.Media.Animation.ClockController>, następnie wywołać <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metody <xref:System.Windows.Media.Animation.ClockController>. Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed> program obsługi zdarzeń dla zegara. Należy pamiętać, że tylko zegary głównego można kontrolować, <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> właściwość zegara podrzędne zwraca `null`. Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed> zdarzeń nie jest wywoływana, gdy efektywnym czasem trwania zegara jest nieskończona.  W takim przypadku użytkownik musi określić, kiedy do wywołania <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Jest to głównie problemu dla animacji na obiekty, które mają długi okres istnienia.  Gdy obiekt jest bezużyteczne, jego zegary również są odłączone i wyrzucania.  
  
 Aby uzyskać więcej informacji o obiektach zegara, zobacz [Animacja i System chronometrażu w — Przegląd](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Storyboard" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Storyboard ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Animation.Storyboard" Usage="storyboard.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy klon można modyfikować tego <see cref="T:System.Windows.Media.Animation.Storyboard" />, tworzenie kopii głębokiego wartości tego obiektu. Podczas kopiowania właściwości zależności, ta metoda kopiuje zasobów odwołania i powiązania danych (ale nie rozpoznają może) ale animacji lub ich bieżącymi wartościami.</summary>
        <returns>Można modyfikować klonowania bieżącego obiektu. Sklonowany obiekt <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="false" /> nawet wtedy, gdy źródło <see cref="P:System.Windows.Freezable.IsFrozen" /> właściwość <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana do tworzenia kopii można modyfikować zamrożone <xref:System.Windows.Freezable> obiektów (lub dowolnego <xref:System.Windows.Freezable> obiektu). Dla wygody ta metoda zasłania dziedziczone wersji z silnie typizowaną implementację.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="storyboard.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Windows.Media.Animation.Storyboard" /> klasy.</summary>
        <returns>Nowy <see cref="T:System.Windows.Media.Animation.Storyboard" /> wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CreateInstance%2A> podczas tworzenia nowych wystąpień <xref:System.Windows.Media.Animation.Storyboard> klasy dla różnych metod klonowania (takie jak <xref:System.Windows.Freezable.Clone%2A> i <xref:System.Windows.Freezable.CloneCurrentValue%2A>).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano Typowa implementacja metody <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Każdy <see cref="T:System.Windows.Media.Animation.Storyboard" /> subclass musi zaimplementować tę metodę. Typowa implementacja jest po prostu Wywołaj domyślny konstruktor klasy i zwraca wynik.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zegar <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> szybkość to szybkość, z jaką obecnie postępuje czas, w porównaniu do czasu w rzeczywistych warunkach.  
  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentGlobalSpeed();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : unit -&gt; double" Usage="storyboard.GetCurrentGlobalSpeed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżąca prędkość globalne lub 0, jeśli zegar jest zatrzymana.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżąca prędkość globalne, lub <see langword="null" /> zatrzymanie zegara.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zegar <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> szybkość to szybkość, z jaką obecnie postępuje czas, w porównaniu do czasu w rzeczywistych warunkach.  
  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżąca prędkość globalne, lub <see langword="null" /> zatrzymanie zegara.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zegar <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> szybkość to szybkość, z jaką obecnie postępuje czas, w porównaniu do czasu w rzeczywistych warunkach.  
  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentIteration">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCurrentIteration();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : unit -&gt; int" Usage="storyboard.GetCurrentIteration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżąca iteracja na zegarze w ciągu bieżącego okresu aktywności lub <see langword="null" /> Jeśli ten zegar jest zatrzymana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwszą iteracją zegara ma wartość 1.  
  
 Jeśli ma to scenorysu <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> ustawienie `true`pełną iteracji składa się z pary odwrotnej kolejności do przodu, nie tylko jeden z nich segmenty.  
  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkContentElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkContentElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżąca iteracja na zegarze w ciągu bieżącego okresu aktywności lub <see langword="null" /> Jeśli ten zegar jest zatrzymana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwszą iteracją zegara ma wartość 1.  
  
 Jeśli ma to scenorysu <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> ustawienie `true`pełną iteracji składa się z pary odwrotnej kolejności do przodu, nie tylko jeden z nich segmenty.  
  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżąca iteracja na zegarze w ciągu bieżącego okresu aktywności lub <see langword="null" /> Jeśli ten zegar jest zatrzymana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwszą iteracją zegara ma wartość 1.  
  
 Jeśli ten zegar osi czasu <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> ustawienie `true`pełną iteracji składa się z pary odwrotnej kolejności do przodu, nie tylko jeden z nich segmenty.  
  
 Niezależnie od jego bieżąca iteracja znalezienia zegar zwraca jego bieżąca iteracja 1. Ponowne uruchamianie zegar zwraca również wartość jego bieżąca iteracja 1.  
  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentProgress">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentProgress();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : unit -&gt; double" Usage="storyboard.GetCurrentProgress " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli ten zegar <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, lub 0.0, jeśli ten zegar jest aktywny i jego <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ma <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> z <see cref="P:System.Windows.Duration.Forever" />; w przeciwnym razie wartość z zakresu od 0.0 do 1.0, która wskazuje bieżący postęp ten zegar w jego bieżącej iteracji. Wartość 0.0 oznacza brak postępu, a wartość 1.0 oznacza, że zegar znajduje się na końcu jej bieżącą iterację.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli ten zegar <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, lub 0.0, jeśli ten zegar jest aktywny i jego <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ma <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> z <see cref="P:System.Windows.Duration.Forever" />; w przeciwnym razie wartość z zakresu od 0.0 do 1.0, która wskazuje bieżący postęp ten zegar w jego bieżącej iteracji. Wartość 0.0 oznacza brak postępu, a wartość 1.0 oznacza, że zegar znajduje się na końcu jej bieżącą iterację.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli ten zegar <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, lub 0.0, jeśli ten zegar jest aktywny i jego <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ma <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> z <see cref="P:System.Windows.Duration.Forever" />; w przeciwnym razie wartość z zakresu od 0.0 do 1.0, która wskazuje bieżący postęp ten zegar w jego bieżącej iteracji. Wartość 0.0 oznacza brak postępu, a wartość 1.0 oznacza, że zegar znajduje się na końcu jej bieżącą iterację.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentState">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState () As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : unit -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżący stan zegara utworzone dla tego scenorysu: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, lub <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie poinformować Cię, czy scenorysu została wstrzymana. Aby określić, czy scenorysu została wstrzymana, użyj <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> metody.  
  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkContentElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkContentElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżący stan zegara utworzone dla tego scenorysu: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, lub <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie poinformować Cię, czy scenorysu została wstrzymana. Aby określić, czy scenorysu została wstrzymana, użyj <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> metody.  
  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Bieżący stan zegara utworzone dla tego scenorysu: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, lub <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie poinformować Cię, czy scenorysu została wstrzymana. Aby określić, czy scenorysu została wstrzymana, użyj <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> metody.  
  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentTime">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime () As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetCurrentTime();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : unit -&gt; TimeSpan" Usage="storyboard.GetCurrentTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli zegar tej scenorys jest <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; w przeciwnym razie bieżący czas zegara scenorysu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkContentElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkContentElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli zegar tej scenorys jest <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; w przeciwnym razie bieżący czas zegara scenorysu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> z <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> Jeśli zegar tej scenorys jest <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; w przeciwnym razie bieżący czas zegara scenorysu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetIsPaused">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> zostało wstrzymane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused();" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : unit -&gt; bool" Usage="storyboard.GetIsPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> zostało wstrzymane.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Media.Animation.Clock" /> utworzone w tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> jest wstrzymana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkContentElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkContentElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> zostało wstrzymane.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Media.Animation.Clock" /> utworzone w tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> jest wstrzymana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> zostało wstrzymane.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Media.Animation.Clock" /> utworzone w tym <see cref="T:System.Windows.Media.Animation.Storyboard" /> jest wstrzymana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, aby pobrać informacje o zegar scenorysu, scenorysu musi być kontrolowane. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTarget (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetTarget(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTarget : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Media.Animation.Storyboard.GetTarget element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Oś czasu, z którego mają zostać pobrane <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> wartość określonego <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>Obiekt zależności objęte <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Media.Animation.Storyboard.Target%2A> dołączona właściwość z osi czasu animacji, aby wskazać obiekt, który docelowych. Aby uzyskać więcej informacji na temat działania celem scenorysu zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości pracy zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetName (element As DependencyObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTargetName(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetName : System.Windows.DependencyObject -&gt; string" Usage="System.Windows.Media.Animation.Storyboard.GetTargetName element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Oś czasu, z którego mają zostać pobrane <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> wartość określonego <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>Nazwa obiektu zależności objęte <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> dołączonych właściwości określonego obiektu. Aby uzyskać więcej informacji na temat działania celem scenorysu zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości pracy zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetProperty (element As DependencyObject) As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PropertyPath ^ GetTargetProperty(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetProperty : System.Windows.DependencyObject -&gt; System.Windows.PropertyPath" Usage="System.Windows.Media.Animation.Storyboard.GetTargetProperty element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego można pobrać <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</param>
        <summary>Pobiera <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> wartość określonego <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>Właściwość będąca celem <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> dołączonych właściwości określonego obiektu. Aby uzyskać więcej informacji na temat działania celem scenorysu zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> dołączona właściwość. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości pracy zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Należy pamiętać, że jeśli <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> został ustawiony w znacznikach, ta metoda zwraca pustą <xref:System.Windows.PropertyPath> , ponieważ odwołania do właściwości jest rozwiązany i przechowywane wewnętrznie, kiedy jest analizowany.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pause">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberSignature Language="F#" Value="member this.Pause : unit -&gt; unit" Usage="storyboard.Pause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wstrzymuje scenorysu, ale ma zauważalny znaczenia, jeśli nie jest aktywny, czy aktualnie wstrzymana. Jako efekt uboczny wszystkie skojarzone obiekty podrzędne również są wstrzymane.  
  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="beginning-a-paused-storyboard"></a>Począwszy od wstrzymania scenorysu  
 Gdy użytkownik <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> scenorysem, która została wstrzymana, wydaje się, aby wznowić i uruchomić ponownie. Dotyczy to jednak nie co rzeczywiście się dzieje. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Metoda zastępuje faktycznie wstrzymana <xref:System.Windows.Media.Animation.Storyboard> do nowej wersji nie wstrzymane. Każdorazowo <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metoda jest wywoływana, obiekty clock są tworzone dla scenorysu. Zegary są dystrybuowane do właściwości, które one animować. Więc, gdy <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> wywoływana jest metoda ponownie, nie jest ponownie uruchamiany jego zegary; zastępuje je za pomocą nowego zegary.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Wstrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> określonego <see cref="T:System.Windows.FrameworkContentElement" /> skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wstrzymuje scenorysu, ale ma zauważalny znaczenia, jeśli nie jest aktywny, czy aktualnie wstrzymana. Jako efekt uboczny wszystkie skojarzone obiekty podrzędne również są wstrzymane.  
  
 Wyszukiwanie scenorysu wstrzymania nie spowodują jego wznowienie. Jedynym sposobem, aby wznowić wstrzymany scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. Wywoływanie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> nową nazwę, która ma wygląd jej wznawianie metody ponownie zamienia wstrzymania scenorysu.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Dla przykładu, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wstrzymywanie wyzwalaczy zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
## <a name="beginning-a-paused-storyboard"></a>Począwszy od wstrzymania scenorysu  
 Gdy użytkownik <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> scenorysem, która została wstrzymana, wydaje się, aby wznowić i uruchomić ponownie. Dotyczy to jednak nie co rzeczywiście się dzieje. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Metoda faktycznie zastępuje sam niewstrzymane wersją. Każdorazowo <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metoda jest wywoływana, obiekty clock są tworzone dla scenorysu. Zegary są dystrybuowane do właściwości, które one animować. Więc, gdy <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> wywoływana jest metoda ponownie, nie jest ponownie uruchamiany jego zegary; zastępuje je za pomocą nowego zegary.  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu, aby animować <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się w obrębie <xref:System.Windows.FrameworkContentElement>firmy Nazwa zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Wstrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> określonego <see cref="T:System.Windows.FrameworkElement" /> skojarzony z tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wstrzymuje scenorysu, ale ma zauważalny znaczenia, jeśli nie jest aktywny, czy aktualnie wstrzymana. Jako efekt uboczny wszystkie skojarzone obiekty podrzędne również są wstrzymane.  
  
 Wyszukiwanie scenorysu wstrzymania nie spowodują jego wznowienie. Jedynym sposobem, aby wznowić wstrzymany scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. Wywoływanie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> nową nazwę, która ma wygląd jej wznawianie metody ponownie zamienia wstrzymania scenorysu.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wstrzymywanie wyzwalaczy zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
## <a name="beginning-a-paused-storyboard"></a>Począwszy od wstrzymania scenorysu  
 Gdy użytkownik <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> scenorysem, która została wstrzymana, wydaje się, aby wznowić i uruchomić ponownie. Dotyczy to jednak nie co rzeczywiście się dzieje. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Metoda faktycznie zastępuje sam niewstrzymane wersją. Każdorazowo <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metoda jest wywoływana, obiekty clock są tworzone dla scenorysu. Zegary są dystrybuowane do właściwości, które one animować. Więc, gdy <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> wywoływana jest metoda ponownie, nie jest ponownie uruchamiany jego zegary; zastępuje je za pomocą nowego zegary.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />. Animacje, które należą do tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> już nie wpływa na właściwości one raz animowany, niezależnie od ich <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> ustawienie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="storyboard.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />. Animacje, które należą do tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> już nie wpływa na właściwości one raz animowany, niezależnie od ich <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> ustawienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wszystkie interaktywne działania podjęte w <xref:System.Windows.Media.Animation.Clock>i w związku z tym również na <xref:System.Windows.Media.Animation.Storyboard>, odbywa się na następnym znaczników aparat czasu, który ma miejsce wkrótce przed następnym renderowania. Oznacza to, że <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> metoda nadal ma wpływ na właściwości animowany do tego czasu. Innymi słowy przy następnym ramki jest wyświetlany, scenorys jest usuwany. Jeśli musisz usunąć skojarzenie animacji z właściwością przed upływem wskazanego terminu, użyj <xref:System.Windows.UIElement.BeginAnimation%2A> metody z `animation` wartość parametru `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Usuwa <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />. Animacje, które należą do tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> już nie wpływa na właściwości one raz animowany, niezależnie od ich <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> ustawienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Usuwanie wyzwalaczy zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Usuwa <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />. Animacje, które należą do tego <see cref="T:System.Windows.Media.Animation.Storyboard" /> już nie wpływa na właściwości one raz animowany, niezależnie od ich <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> ustawienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Usuwanie wyzwalaczy zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resume">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wznawia <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="storyboard.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Wznawia <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wznawianie scenorysem, która nie została wstrzymana nie ma znaczenia.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wyszukiwanie scenorysu wstrzymania nie spowodują jego wznowienie. Jedynym sposobem, aby wznowić wstrzymany scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. Wywoływanie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody po uruchomieniu scenorysu zastępuje stare scenorysu, która ma wygląd jej wznawianie.  
  
 Wznawianie wstrzymanej wyzwala zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu, aby animować <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się w obrębie <xref:System.Windows.FrameworkContentElement>firmy Nazwa zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Wznawia <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wznawianie scenorysem, która nie została wstrzymana nie ma znaczenia.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wyszukiwanie scenorysu wstrzymania nie spowodują jego wznowienie. Jedynym sposobem, aby wznowić wstrzymany scenorysu jest użycie <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> metody. Wywoływanie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody po uruchomieniu scenorysu zastępuje stare scenorysu, która ma wygląd jej wznawianie.  
  
 Wznawianie wstrzymanej wyzwala zegara scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> nowe miejsce, gdy wystąpi dalej cykli zegara.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan -&gt; unit" Usage="storyboard.Seek offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje ilość, za pomocą którego oś czasu należy przejść do przodu lub Wstecz.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> na określonej pozycji. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądanie wyszukiwanie po wystąpieniu dalej cykli zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że operacje wyszukiwania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawienia do konta. Scenorys jest traktowany tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i bez <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje ilość, za pomocą którego oś czasu powinien przejść do przodu lub wstecz z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Pozycja, z którego <c>przesunięcie</c> jest stosowany.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> na określonej pozycji. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądanie wyszukiwanie po wystąpieniu dalej cykli zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że operacje wyszukiwania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawienia do konta. Scenorys jest traktowany tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i bez <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje ilość, za pomocą którego oś czasu powinien przejść do przodu lub wstecz z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Pozycja, z którego <c>przesunięcie</c> jest stosowany.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> na określonej pozycji. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądanie wyszukiwanie po wystąpieniu dalej cykli zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że operacje wyszukiwania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawienia do konta. Scenorys jest traktowany tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i bez <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Ta metoda zmienia zegara scenorysu <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> do <xref:System.Windows.Media.Animation.ClockState.Active>. Ta metoda nie ma wpływu na drzewie chronometrażu aż do następnego znacznik jest przetwarzana. Jako efekt uboczny odpowiednie również nie są zgłaszane do tego czasu.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wyszukiwanie wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano oba <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metody.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje ilość, za pomocą którego oś czasu powinien przejść do przodu lub wstecz z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Pozycja, z którego <c>przesunięcie</c> jest stosowany.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> na określonej pozycji. <see cref="T:System.Windows.Media.Animation.Storyboard" /> Wykonuje żądanie wyszukiwanie po wystąpieniu dalej cykli zegara.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że operacje wyszukiwania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawienia do konta. Scenorys jest traktowany tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i bez <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Ta metoda zmienia zegara scenorysu <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> do <xref:System.Windows.Media.Animation.ClockState.Active>. Ta metoda nie ma wpływu na drzewie chronometrażu aż do następnego znacznik jest przetwarzana. Jako efekt uboczny odpowiednie również nie są zgłaszane do tego czasu.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i usuwane, jeśli zostanie podjęta kontrolowania. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wyszukiwanie wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak do wyszukania (pomiń) do 1 sekundy po rozpoczęciu scenorysu.  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 W kolejnym przykładzie pokazano oba <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metody.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SeekAlignedToLastTick">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do nowej pozycji bezpośrednio (synchronicznie).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan -&gt; unit" Usage="storyboard.SeekAlignedToLastTick offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje ilość, za pomocą którego oś czasu należy przejść do przodu lub Wstecz.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do nowej pozycji bezpośrednio (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Wyrównuje czas seeked <xref:System.Windows.Media.Animation.Storyboard> z ostatniej najmniejszej zegara. Wartości od razu są aktualizowane w celu odzwierciedlenia zmian ze względu na <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, nawet jeśli ekran nie odzwierciedlać te zmiany, dopóki aktualizacje ekranu.  
  
 Należy zauważyć, że operacje wyszukiwania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawienia do konta. Scenorys jest traktowany tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i bez <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje ilość, za pomocą którego oś czasu powinien przejść do przodu lub wstecz z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Pozycja, z którego <c>przesunięcie</c> jest stosowany.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do nowej pozycji bezpośrednio (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Wyrównuje czas seeked <xref:System.Windows.Media.Animation.Storyboard> z ostatniej najmniejszej zegara. Wartości od razu są aktualizowane w celu odzwierciedlenia zmian ze względu na <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, nawet jeśli ekran nie odzwierciedlać te zmiany, dopóki aktualizacje ekranu.  
  
 Należy zauważyć, że operacje wyszukiwania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawienia do konta. Scenorys jest traktowany tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i bez <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje ilość, za pomocą którego oś czasu powinien przejść do przodu lub wstecz z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Pozycja, z którego <c>przesunięcie</c> jest stosowany.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do nowej pozycji bezpośrednio (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Wyrównuje czas seeked <xref:System.Windows.Media.Animation.Storyboard> z ostatniej najmniejszej zegara. Wartości od razu są aktualizowane w celu odzwierciedlenia zmian ze względu na <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, nawet jeśli ekran nie odzwierciedlać te zmiany, dopóki aktualizacje ekranu.  
  
 Należy zauważyć, że operacje wyszukiwania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawienia do konta. Scenorys jest traktowany tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i bez <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Ta metoda zmienia zegara scenorysu <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> do  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Wyszukiwanie wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano oba <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metody.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <param name="offset">Wartość dodatnia lub ujemna, która opisuje ilość, za pomocą którego oś czasu powinien przejść do przodu lub wstecz z określonego <c>pochodzenia</c>.</param>
        <param name="origin">Pozycja, z którego <c>przesunięcie</c> jest stosowany.</param>
        <summary>Ma to <see cref="T:System.Windows.Media.Animation.Storyboard" /> do nowej pozycji bezpośrednio (synchronicznie).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Wyrównuje czas seeked <xref:System.Windows.Media.Animation.Storyboard> z ostatniej najmniejszej zegara. Wartości od razu są aktualizowane w celu odzwierciedlenia zmian ze względu na <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, nawet jeśli ekran nie odzwierciedlać te zmiany, dopóki aktualizacje ekranu.  
  
 Należy zauważyć, że operacje wyszukiwania nie przyjmują scenorysu <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> lub <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> ustawienia do konta. Scenorys jest traktowany tak, jakby ma <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 i bez <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Ta metoda zmienia zegara scenorysu <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> do  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Wyszukiwanie wyzwalaczy scenorysu <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano oba <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> i <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metody.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSpeedRatio">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia współczynnik interaktywne szybkość <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : double -&gt; unit" Usage="storyboard.SetSpeedRatio speedRatio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Skończoną wartość większą niż zero, będącego wskaźnik interaktywne prędkości nowego scenorysu. Ta wartość jest mnożony względem scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wartość określającą szybkość scenorysu. Ta wartość nie powoduje zastąpienia scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> właściwości. Na przykład, wywołanie tej metody i określając interaktywne szybkość stopień 3 w serii ujęć z <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wynosi 0,5 zapewnia scenorysu szybkość 1.5.</param>
        <summary>Ustawia współczynnik interaktywne szybkość <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkContentElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkContentElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkContentElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <param name="speedRatio">Skończoną wartość większą niż zero, będącego wskaźnik interaktywne prędkości nowego scenorysu. Ta wartość jest mnożony względem scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wartość określającą szybkość scenorysu. Ta wartość nie powoduje zastąpienia scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> właściwości. Na przykład, wywołanie tej metody i określając interaktywne szybkość stopień 3 w serii ujęć z <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wynosi 0,5 zapewnia scenorysu szybkość 1.5.</param>
        <summary>Ustawia współczynnik interaktywne szybkość <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wywołanie tej metody wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu, aby animować <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się w obrębie <xref:System.Windows.FrameworkContentElement>firmy Nazwa zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <param name="speedRatio">Skończoną wartość większą niż zero, będącego wskaźnik interaktywne prędkości nowego scenorysu. Ta wartość jest mnożony względem scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wartość określającą szybkość scenorysu. Ta wartość nie powoduje zastąpienia scenorysu <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> właściwości. Na przykład, wywołanie tej metody i określając interaktywne szybkość stopień 3 w serii ujęć z <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> wynosi 0,5 zapewnia scenorysu szybkość 1.5.</param>
        <summary>Ustawia współczynnik interaktywne szybkość <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Wywołanie tej metody wyzwala <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTarget (element As DependencyObject, value As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTarget(System::Windows::DependencyObject ^ element, System::Windows::DependencyObject ^ value);" />
      <MemberSignature Language="F#" Value="static member SetTarget : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTarget (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> Którego powinien dotyczyć obiektu określona zależność.</param>
        <param name="value">Obiekt zależności do obiektu docelowego.</param>
        <summary>Sprawia, że określony <see cref="T:System.Windows.Media.Animation.Timeline" /> docelowy obiekt zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.Windows.Media.Animation.Storyboard.Target%2A> dołączonych właściwości określonego obiektu. Aby uzyskać więcej informacji na temat działania celem scenorysu zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości pracy zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
> [!NOTE]
>  <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Właściwość nie jest możliwy do serializacji, ponieważ może być ustawiona na dowolny <xref:System.Windows.DependencyObject>. Nie gwarantuje, że ten obiekt może poprawnie przywoływane z XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetName (element As DependencyObject, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetName(System::Windows::DependencyObject ^ element, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member SetTargetName : System.Windows.DependencyObject * string -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetName (element, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> Którego powinien dotyczyć obiektu określona zależność.</param>
        <param name="name">Nazwa obiektu zależności do obiektu docelowego.</param>
        <summary>Sprawia, że określony <see cref="T:System.Windows.Media.Animation.Timeline" /> docelowy obiekt zależności o określonej nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> dołączonych właściwości określonego obiektu. Aby uzyskać więcej informacji na temat działania celem scenorysu zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości pracy zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetProperty (element As DependencyObject, path As PropertyPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetProperty(System::Windows::DependencyObject ^ element, System::Windows::PropertyPath ^ path);" />
      <MemberSignature Language="F#" Value="static member SetTargetProperty : System.Windows.DependencyObject * System.Windows.PropertyPath -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetProperty (element, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> Za pomocą którego można skojarzyć właściwość określona zależność.</param>
        <param name="path">Ścieżka, które opisują właściwości zależności, aby być animowane.</param>
        <summary>Sprawia, że określony <see cref="T:System.Windows.Media.Animation.Timeline" /> właściwość określona zależność docelowa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> dołączonych właściwości określonego obiektu. Aby uzyskać więcej informacji na temat działania celem scenorysu zobacz <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A>. Aby uzyskać więcej informacji na temat sposobu dołączonych właściwości pracy zobacz [Przegląd właściwości dołączonych](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipToFill">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przesuwa aktualną porę tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill();" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : unit -&gt; unit" Usage="storyboard.SkipToFill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przesuwa aktualną porę tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Przesuwa aktualną porę tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przechodzi scenorysu bieżący czas na koniec okresu aktywnego; zachowanie scenorysu w tym momencie jest określony przez jego <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> ustawienie. Jeśli <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> ustawiono <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, wypełnia scenorysu; Jeśli ustawiono właściwość <xref:System.Windows.Media.Animation.FillBehavior.Stop>, zatrzymuje scenorysu.  
  
 Wywołanie tej metody na scenorysu z czasem trwania nieskończonej nieograniczoną liczbę powtórzeń nie ma znaczenia. Wywołanie tej metody na nieaktywny scenorysu nie ma znaczenia.  
  
 Zegar przesuwania do wypełnienia jego okresu wyzwalaczy <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu, aby animować <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się w obrębie <xref:System.Windows.FrameworkContentElement>firmy Nazwa zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Przesuwa aktualną porę tego scenorysu <see cref="T:System.Windows.Media.Animation.Clock" /> do końca okresu aktywacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przechodzi scenorysu bieżący czas na koniec okresu aktywnego; zachowanie scenorysu w tym momencie jest określony przez jego <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> ustawienie. Jeśli <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> ustawiono <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, wypełnia scenorysu; Jeśli ustawiono właściwość <xref:System.Windows.Media.Animation.FillBehavior.Stop>, zatrzymuje scenorysu.  
  
 Wywołanie tej metody na scenorysu z czasem trwania nieskończonej nieograniczoną liczbę powtórzeń nie ma znaczenia. Wywołanie tej metody na nieaktywny scenorysu nie ma znaczenia.  
  
 Zegar przesuwania do wypełnienia jego okresu wyzwalaczy <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Stop">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zatrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="storyboard.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zatrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że zatrzymanie scenorysu nie uruchomi się <xref:System.Windows.Media.Animation.Timeline.Completed> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Zatrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Media.Animation.ClockState.Stopped> scenorysu nie wpływa już na jego właściwości obiektu docelowego: właściwości, które zostały animowane Przywróć poprzednie wartości.  
  
 Zatrzymywanie wyzwalaczy zegara <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia, ale nie <xref:System.Windows.Media.Animation.Timeline.Completed> zdarzeń.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto sterowane scenorysu, aby animować <xref:System.Windows.Media.TextEffect>. <xref:System.Windows.Media.TextEffect> Znajduje się w obrębie <xref:System.Windows.FrameworkContentElement>firmy Nazwa zakresu.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Określony obiekt, gdy <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> metoda została wywołana. Ten obiekt zawiera <see cref="T:System.Windows.Media.Animation.Clock" /> obiekty, które zostały utworzone dla tego scenorysu i jego elementy podrzędne.</param>
        <summary>Zatrzymuje <see cref="T:System.Windows.Media.Animation.Clock" /> utworzony w tym <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Media.Animation.ClockState.Stopped> scenorysu nie wpływa już na jego właściwości obiektu docelowego: właściwości, które zostały animowane Przywróć poprzednie wartości.  
  
 Zatrzymywanie wyzwalaczy zegara <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> i <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> zdarzenia, ale nie <xref:System.Windows.Media.Animation.Timeline.Completed> zdarzeń.  
  
 Aby interaktywnie kontrolować scenorys, należy użyć, takie same `containingObject` parametru podczas wywoływania metod interaktywnych, których użyto do rozpoczęcia scenorysu. Sterowane scenorysu można wstrzymać, wznowić, wyszukiwanie, zatrzymać i go usunąć. Aby scenorysu kontrolowane w kodzie, należy użyć odpowiedniej przeciążenia scenorysu <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodę i określić `true` zapewnienie kontrolowania. Aby uzyskać przykład, zobacz [porady: kontrolowanie scenorysu po uruchomieniu](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="ILAsm" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.Target" />
      <MemberSignature Language="VB.NET" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="F#" Value="see GetTarget, and SetTarget" Usage="see GetTarget, and SetTarget" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który powinien być animowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt docelowy musi być obiektem zależności.  
  
> [!NOTE]
>  <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Właściwość nie jest możliwy do serializacji, ponieważ może być ustawiona na dowolny <xref:System.Windows.DependencyObject>. Istnieje nie zagwarantować, że ten obiekt może być prawidłowo przywoływany w XAML.  
  
<a name="dependencyPropertyInfo_Target"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Media.Animation.Storyboard.TargetProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="ILAsm" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      <MemberSignature Language="VB.NET" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="F#" Value="see GetTargetName, and SetTargetName" Usage="see GetTargetName, and SetTargetName" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia nazwę obiektu, aby animować. Obiekt musi być <see cref="T:System.Windows.FrameworkElement" />, <see cref="T:System.Windows.FrameworkContentElement" />, lub <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości jest opcjonalne. Jeśli <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> nie zostanie określony, animacjami scenorysu są stosowane do jednej z następujących czynności:  
  
-   Jeśli scenorysu, do której należy animacja została uruchomiona z użyciem <xref:System.Windows.Media.Animation.BeginStoryboard>, element, który jest właścicielem <xref:System.Windows.Media.Animation.BeginStoryboard> podlega akcję, która wyzwala scenorysu.  
  
-   Jeśli scenorysu została uruchomiona z użyciem <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metody <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement> określony uruchomienia serii ujęć z <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metoda jest przeznaczona.  
  
 Gdy ta właściwość jest ustawiona na osi czasu z elementami podrzędnymi tych podrzędnych osi czasu "dziedziczą" elementu nadrzędnego <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> , chyba że określają własne.  
  
## <a name="making-an-object-targetable"></a>Tworzenie obiektu Targetable  
 Korzystając z [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], wykonać jedną z następujących czynności dwa, aby uczynić obiekt targetable scenorysu:  
  
-   Jeśli obiekt jest <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>, ustaw jego <xref:System.Windows.FrameworkElement.Name%2A> właściwości.  
  
-   Jeśli obiekt jest <xref:System.Windows.Freezable> lub niestandardowy <xref:System.Windows.FrameworkContentElement> lub <xref:System.Windows.FrameworkContentElement>, przypisać go przy użyciu nazwy [x: Name — dyrektywa](~/docs/framework/xaml-services/x-name-directive.md) — rozszerzenie znaczników.  
  
 Korzystając z kodu, należy tworzyć obiektu targetable przy użyciu <xref:System.Windows.NameScope.RegisterName%2A> metodę, aby przypisać nazwę obiektu.  
  
<a name="dependencyPropertyInfo_TargetName"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Media.Animation.Storyboard.TargetNameProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetNameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetNameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetNameProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> dołączona właściwość.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> dołączona właściwość.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetPropertyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetPropertyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetPropertyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> dołączona właściwość.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="NamedPipeServerStream" FullName="System.IO.Pipes.NamedPipeServerStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c40d6947ec66b9e66a0e8ba16ffcdc9847c55695" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48633889" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NamedPipeServerStream : System.IO.Pipes.PipeStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NamedPipeServerStream extends System.IO.Pipes.PipeStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.NamedPipeServerStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NamedPipeServerStream&#xA;Inherits PipeStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NamedPipeServerStream sealed : System::IO::Pipes::PipeStream" />
  <TypeSignature Language="F#" Value="type NamedPipeServerStream = class&#xA;    inherit PipeStream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Pipes.PipeStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia <see cref="T:System.IO.Stream" /> wokół nazwany potok obsługi synchroniczne i asynchroniczne operacje odczytu i zapisu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwane potoki zapewniają jednokierunkowe lub dupleks potoków do komunikacji między serwerem potoku i jednym lub kilkoma klientami potoku. Nazwane potoki może służyć do komunikacji międzyprocesowej lokalnie lub za pośrednictwem sieci. Nazwa potoku jednym mogą być współużytkowane przez wiele <xref:System.IO.Pipes.NamedPipeClientStream> obiektów.  
  
 Żaden proces może działać jako serwera potoków nazwanych lub klienta lub obu.  
  
> [!NOTE]
>  Aby uzyskać [!INCLUDE[winxppro](~/includes/winxppro-md.md)] i [!INCLUDE[win2kserver](~/includes/win2kserver-md.md)], maksymalnie 10 potoki jednocześnie można połączyć za pośrednictwem sieci.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wysyłania ciąg z procesu nadrzędnego do procesu podrzędnego, w tym samym komputerze przy użyciu nazwanych potoków. Ten przykład tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiektu w proces nadrzędny <xref:System.IO.Pipes.PipeDirection> wartość <xref:System.IO.Pipes.PipeDirection.Out>. Serwer następnie oczekuje na <xref:System.IO.Pipes.NamedPipeClientStream> obiektu w proces podrzędny się z nim łączyć. W tym przykładzie oba procesy są na tym samym komputerze i <xref:System.IO.Pipes.NamedPipeClientStream> obiekt ma <xref:System.IO.Pipes.PipeDirection> wartość <xref:System.IO.Pipes.PipeDirection.In>. Proces nadrzędny wysyła następnie ciąg dostarczone przez użytkownika do procesu podrzędnego. Ten ciąg jest wyświetlana w konsoli.  
  
 W tym przykładzie jest proces serwera, który używa <xref:System.IO.Pipes.NamedPipeServerStream> klasy. Na przykład cały kod, łącznie z kodem potoku klienta i serwera, zobacz [porady: użycie potoków nazwanych do sieciowej komunikacji międzyprocesowej](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md).  
  
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream pipeName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pipeName">Nazwa potoku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> klasy o nazwie określonej potoku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiekt, który ma następujące cechy:  
  
-   Domyślny kierunek potoku, który z <xref:System.IO.Pipes.PipeDirection.InOut>.  
  
-   Maksymalna liczba wystąpień serwera, które mają taką samą nazwę, wartość 1.  
  
-   A <xref:System.IO.Pipes.PipeTransmissionMode> wartość <xref:System.IO.Pipes.PipeTransmissionMode.Byte>.  
  
-   A <xref:System.IO.Pipes.PipeOptions> wartość <xref:System.IO.Pipes.PipeOptions.None>.  
  
-   Domyślne rozmiary buforów danych wejściowych i wyjściowych.  
  
-   Bez zabezpieczeń potoku.  
  
-   A <xref:System.IO.HandleInheritability> wartość <xref:System.IO.HandleInheritability.None>.  
  
-   Nie określono dodatkowe <xref:System.IO.Pipes.PipeAccessRights>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> jest ustawiona na "anonimowy".</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> zawiera dwukropek (":").</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows Millennium Edition, Windows 98 lub Windows 95, które nie są obsługiwane.</exception>
        <exception cref="T:System.IO.IOException">Przekroczono maksymalną liczbę wystąpień serwera.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
      </Parameters>
      <Docs>
        <param name="pipeName">Nazwa potoku.</param>
        <param name="direction">Jedna z wartości wyliczenia, które określa kierunek potoku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> klasy o nazwie określonej potoku i kierunek potoku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiekt, który ma następujące cechy:  
  
-   A <xref:System.IO.Pipes.PipeTransmissionMode> wartość <xref:System.IO.Pipes.PipeTransmissionMode.Byte>.  
  
-   A <xref:System.IO.Pipes.PipeOptions> wartość <xref:System.IO.Pipes.PipeOptions.None>.  
  
-   Domyślne rozmiary buforów danych wejściowych i wyjściowych.  
  
-   Bez zabezpieczeń potoku.  
  
-   A <xref:System.IO.HandleInheritability> wartość <xref:System.IO.HandleInheritability.None>.  
  
-   Nie określono dodatkowe <xref:System.IO.Pipes.PipeAccessRights>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metodę, aby wysłać ciąg z procesu nadrzędnego na podrzędnych procesu za pośrednictwem nazwanych potoków. Ten przykład tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiektu w procesie nadrzędnym. <xref:System.IO.Pipes.NamedPipeServerStream> Obiekt ma <xref:System.IO.Pipes.PipeDirection> wartość <xref:System.IO.Pipes.PipeDirection.Out>, który następnie blokuje, dopóki <xref:System.IO.Pipes.NamedPipeClientStream> obiektu nawiąże połączenie z bieżącego <xref:System.IO.Pipes.NamedPipeServerStream> obiektu.  
  
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> jest ustawiona na "anonimowy".  
  
—lub— 
 <paramref name="direction" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> zawiera dwukropek (":").</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows Millennium Edition, Windows 98 lub Windows 95, które nie są obsługiwane.</exception>
        <exception cref="T:System.IO.IOException">Przekroczono maksymalną liczbę wystąpień serwera.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pipeName">Nazwa potoku.</param>
        <param name="direction">Jedna z wartości wyliczenia, które określa kierunek potoku.</param>
        <param name="maxNumberOfServerInstances">Maksymalna liczba wystąpień serwera, które mają taką samą nazwę. Możesz przekazać <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> dla tej wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> klasy przy użyciu nazwy określonej potoku, kierunku potoku i maksymalną liczbę wystąpień serwera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiekt, który ma następujące cechy:  
  
-   Domyślna wartość 1 maksymalnej liczby wystąpień serwera, które mają taką samą nazwę.  
  
-   Domyślnie <xref:System.IO.Pipes.PipeTransmissionMode> wartość <xref:System.IO.Pipes.PipeTransmissionMode.Byte>.  
  
-   A <xref:System.IO.Pipes.PipeOptions> wartość <xref:System.IO.Pipes.PipeOptions.None>.  
  
-   Domyślne rozmiary buforów danych wejściowych i wyjściowych.  
  
-   Bez zabezpieczeń potoku.  
  
-   A <xref:System.IO.HandleInheritability> wartość <xref:System.IO.HandleInheritability.None>.  
  
-   Nie określono dodatkowe <xref:System.IO.Pipes.PipeAccessRights>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> jest ustawiona na "anonimowy".  
  
—lub— 
 <paramref name="direction" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.  
  
—lub— 
Wymagana jest liczba ujemna.  
  
—lub— 
 <paramref name="maxNumberofServerInstances" /> jest mniejsza niż -1 lub większa niż 254 (-1 oznacza <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />) 
—lub— 
 <see cref="F:System.IO.HandleInheritability.None" /> lub <see cref="F:System.IO.HandleInheritability.Inheritable" /> jest wymagana.  
  
—lub— 
Prawa dostępu jest ograniczone do <see cref="F:System.IO.Pipes.PipeAccessRights.ChangePermissions" /> , <see cref="F:System.IO.Pipes.PipeAccessRights.TakeOwnership" /> , i <see cref="F:System.IO.Pipes.PipeAccessRights.AccessSystemSecurity" /> flag.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> zawiera dwukropek (":").</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows Millennium Edition, Windows 98 lub Windows 95, które nie są obsługiwane.</exception>
        <exception cref="T:System.IO.IOException">Przekroczono maksymalną liczbę wystąpień serwera.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (System.IO.Pipes.PipeDirection direction, bool isAsync, bool isConnected, Microsoft.Win32.SafeHandles.SafePipeHandle safePipeHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, bool isAsync, bool isConnected, class Microsoft.Win32.SafeHandles.SafePipeHandle safePipeHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.Boolean,System.Boolean,Microsoft.Win32.SafeHandles.SafePipeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::IO::Pipes::PipeDirection direction, bool isAsync, bool isConnected, Microsoft::Win32::SafeHandles::SafePipeHandle ^ safePipeHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : System.IO.Pipes.PipeDirection * bool * bool * Microsoft.Win32.SafeHandles.SafePipeHandle -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (direction, isAsync, isConnected, safePipeHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="isAsync" Type="System.Boolean" />
        <Parameter Name="isConnected" Type="System.Boolean" />
        <Parameter Name="safePipeHandle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
      </Parameters>
      <Docs>
        <param name="direction">Jedna z wartości wyliczenia, które określa kierunek potoku.</param>
        <param name="isAsync">
          <see langword="true" /> Aby wskazać, że dojście zostało otwarte asynchronicznie; w przeciwnym razie <see langword="false" />.</param>
        <param name="isConnected">
          <see langword="true" /> Aby wskazać, że potok jest połączona; w przeciwnym razie <see langword="false" />.</param>
        <param name="safePipeHandle">Bezpiecznego dojścia dla potoku, że <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> obiektu będzie hermetyzacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> klasy dojścia określony potok.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="direction" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="safePipeHandle" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="safePipeHandle" /> jest nieprawidłowego dojścia.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="safePipeHandle" /> nie jest dojściem prawidłowe potoku.  
  
—lub— 
Przekroczono maksymalną liczbę wystąpień serwera.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer, transmissionMode As PipeTransmissionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
      </Parameters>
      <Docs>
        <param name="pipeName">Nazwa potoku.</param>
        <param name="direction">Jedna z wartości wyliczenia, które określa kierunek potoku.</param>
        <param name="maxNumberOfServerInstances">Maksymalna liczba wystąpień serwera, które mają taką samą nazwę. Możesz przekazać <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> dla tej wartości.</param>
        <param name="transmissionMode">Jedna z wartości wyliczenia, które określa tryb przesyłania potoku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> klasy przy użyciu nazwy określonej potoku, kierunku potoku, maksymalna liczba wystąpień serwera, a tryb transmisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiekt, który ma następujące cechy:  
  
-   Domyślnie <xref:System.IO.Pipes.PipeOptions> wartość <xref:System.IO.Pipes.PipeOptions.None>.  
  
-   Domyślne rozmiary buforów danych wejściowych i wyjściowych.  
  
-   Bez zabezpieczeń potoku.  
  
-   A <xref:System.IO.HandleInheritability> wartość <xref:System.IO.HandleInheritability.None>.  
  
-   Nie określono dodatkowe <xref:System.IO.Pipes.PipeAccessRights>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> jest ustawiona na "anonimowy".  
  
—lub— 
 <paramref name="direction" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.  
  
—lub— 
 <paramref name="maxNumberofServerInstances" /> jest mniejsza niż -1 lub większa niż 254 (-1 oznacza <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />)</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> zawiera dwukropek (":").</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows Millennium Edition, Windows 98 lub Windows 95, które nie są obsługiwane.</exception>
        <exception cref="T:System.IO.IOException">Przekroczono maksymalną liczbę wystąpień serwera.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer, transmissionMode As PipeTransmissionMode, options As PipeOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
      </Parameters>
      <Docs>
        <param name="pipeName">Nazwa potoku.</param>
        <param name="direction">Jedna z wartości wyliczenia, które określa kierunek potoku.</param>
        <param name="maxNumberOfServerInstances">Maksymalna liczba wystąpień serwera, które mają taką samą nazwę. Możesz przekazać <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> dla tej wartości.</param>
        <param name="transmissionMode">Jedna z wartości wyliczenia, które określa tryb przesyłania potoku.</param>
        <param name="options">Jedna z wartości wyliczenia, które określa sposób próbę otwarcia lub utworzenia potoku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> klasy przy użyciu nazwy określonej potoku, kierunku potoku, maksymalna liczba wystąpień serwera, tryb transmisji i opcje potoku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiekt, który ma następujące cechy:  
  
-   Domyślne rozmiary buforów danych wejściowych i wyjściowych.  
  
-   Bez zabezpieczeń potoku.  
  
-   A <xref:System.IO.HandleInheritability> wartość <xref:System.IO.HandleInheritability.None>.  
  
-   Nie określono dodatkowe <xref:System.IO.Pipes.PipeAccessRights>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> jest ustawiona na "anonimowy".  
  
—lub— 
 <paramref name="direction" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.  
  
—lub— 
 <paramref name="maxNumberofServerInstances" /> jest mniejsza niż -1 lub większa niż 254 (-1 oznacza <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />) 
—lub— 
 <paramref name="options" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeOptions" /> wartość.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> zawiera dwukropek (":").</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows Millennium Edition, Windows 98 lub Windows 95, które nie są obsługiwane.</exception>
        <exception cref="T:System.IO.IOException">Przekroczono maksymalną liczbę wystąpień serwera.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer, transmissionMode As PipeTransmissionMode, options As PipeOptions, inBufferSize As Integer, outBufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pipeName">Nazwa potoku.</param>
        <param name="direction">Jedna z wartości wyliczenia, które określa kierunek potoku.</param>
        <param name="maxNumberOfServerInstances">Maksymalna liczba wystąpień serwera, które mają taką samą nazwę. Możesz przekazać <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> dla tej wartości.</param>
        <param name="transmissionMode">Jedna z wartości wyliczenia, które określa tryb przesyłania potoku.</param>
        <param name="options">Jedna z wartości wyliczenia, które określa sposób próbę otwarcia lub utworzenia potoku.</param>
        <param name="inBufferSize">Wartość dodatnią większą niż 0, która wskazuje rozmiar buforu wejściowego.</param>
        <param name="outBufferSize">Wartość dodatnią większą niż 0, która wskazuje rozmiar buforu wyjściowego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> klasy przy użyciu nazwy określonej potoku, kierunku potoku, maksymalna liczba wystąpień serwera, tryb transmisji, opcje potoku i zalecane in i out rozmiary buforów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiekt, który ma następujące cechy:  
  
-   Nie potoku dodatkowe zabezpieczenia.  
  
-   Domyślnie <xref:System.IO.HandleInheritability> wartość <xref:System.IO.HandleInheritability.None>.  
  
-   Nie określono dodatkowe <xref:System.IO.Pipes.PipeAccessRights>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> jest ustawiona na "anonimowy".  
  
—lub— 
 <paramref name="direction" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.  
  
—lub— 
 <paramref name="maxNumberofServerInstances" /> jest mniejsza niż -1 lub większa niż 254 (-1 oznacza <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />) 
—lub— 
 <paramref name="options" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeOptions" /> wartość.  
  
—lub— 
 <paramref name="inBufferSize" /> ma wartość ujemną.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> zawiera dwukropek (":").</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows Millennium Edition, Windows 98 lub Windows 95, które nie są obsługiwane.</exception>
        <exception cref="T:System.IO.IOException">Przekroczono maksymalną liczbę wystąpień serwera.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize, System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32,System.IO.Pipes.PipeSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize, System::IO::Pipes::PipeSecurity ^ pipeSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int * System.IO.Pipes.PipeSecurity -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
      </Parameters>
      <Docs>
        <param name="pipeName">Nazwa potoku.</param>
        <param name="direction">Jedna z wartości wyliczenia, które określa kierunek potoku.</param>
        <param name="maxNumberOfServerInstances">Maksymalna liczba wystąpień serwera, które mają taką samą nazwę. Możesz przekazać <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> dla tej wartości.</param>
        <param name="transmissionMode">Jedna z wartości wyliczenia, które określa tryb przesyłania potoku.</param>
        <param name="options">Jedna z wartości wyliczenia, które określa sposób próbę otwarcia lub utworzenia potoku.</param>
        <param name="inBufferSize">Wartość dodatnią większą niż 0, która wskazuje rozmiar buforu wejściowego.</param>
        <param name="outBufferSize">Wartość dodatnią większą niż 0, która wskazuje rozmiar buforu wyjściowego.</param>
        <param name="pipeSecurity">Obiekt, który określa kontroli dostępu i inspekcji zabezpieczeń dla potoku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> nazwy klasy przy użyciu określonego potoku, potok kierunku, maksymalna liczba wystąpień serwera tryb transmisji, opcje potoku, zaleca się wewnątrz i na zewnątrz buforu rozmiarów i przekazać zabezpieczeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiekt, który ma następujące cechy:  
  
-   Domyślnie <xref:System.IO.HandleInheritability> wartość <xref:System.IO.HandleInheritability.None>.  
  
-   Nie określono dodatkowe <xref:System.IO.Pipes.PipeAccessRights>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> jest ustawiona na "anonimowy".  
  
—lub— 
 <paramref name="direction" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.  
  
—lub— 
 <paramref name="maxNumberofServerInstances" /> jest mniejsza niż -1 lub większa niż 254 (-1 oznacza <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />) 
—lub— 
 <paramref name="options" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeOptions" /> wartość.  
  
—lub— 
 <paramref name="inBufferSize" /> ma wartość ujemną.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> zawiera dwukropek (":").</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows Millennium Edition, Windows 98 lub Windows 95, które nie są obsługiwane.</exception>
        <exception cref="T:System.IO.IOException">Przekroczono maksymalną liczbę wystąpień serwera.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize, System.IO.Pipes.PipeSecurity pipeSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32,System.IO.Pipes.PipeSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize, System::IO::Pipes::PipeSecurity ^ pipeSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int * System.IO.Pipes.PipeSecurity * System.IO.HandleInheritability -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity, inheritability)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="pipeName">Nazwa potoku.</param>
        <param name="direction">Jedna z wartości wyliczenia, które określa kierunek potoku.</param>
        <param name="maxNumberOfServerInstances">Maksymalna liczba wystąpień serwera, które mają taką samą nazwę. Możesz przekazać <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> dla tej wartości.</param>
        <param name="transmissionMode">Jedna z wartości wyliczenia, które określa tryb przesyłania potoku.</param>
        <param name="options">Jedna z wartości wyliczenia, które określa sposób próbę otwarcia lub utworzenia potoku.</param>
        <param name="inBufferSize">Wartość dodatnią większą niż 0, która wskazuje rozmiar buforu wejściowego.</param>
        <param name="outBufferSize">Wartość dodatnią większą niż 0, która wskazuje rozmiar buforu wyjściowego.</param>
        <param name="pipeSecurity">Obiekt, który określa kontroli dostępu i inspekcji zabezpieczeń dla potoku.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy podstawowy uchwyt może być dziedziczony przez procesy podrzędne.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> klasy przy użyciu nazwy określonej potoku, kierunku potoku, maksymalna liczba wystąpień serwera, tryb transmisji, opcje potoku, zaleca się in i out rozmiary buforów, potok zabezpieczeń i tryb inheritability.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiektu, który nie ma określone dodatkowe <xref:System.IO.Pipes.PipeAccessRights>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> jest ustawiona na "anonimowy".  
  
—lub— 
 <paramref name="direction" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.  
  
—lub— 
 <paramref name="maxNumberofServerInstances" /> jest mniejsza niż -1 lub większa niż 254 (-1 oznacza <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />) 
—lub— 
 <paramref name="options" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeOptions" /> wartość.  
  
—lub— 
 <paramref name="inBufferSize" /> ma wartość ujemną.  
  
—lub— 
 <paramref name="inheritability" /> nie jest prawidłowym <see cref="T:System.IO.HandleInheritability" /> wartość.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> zawiera dwukropek (":").</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows Millennium Edition, Windows 98 lub Windows 95, które nie są obsługiwane.</exception>
        <exception cref="T:System.IO.IOException">Przekroczono maksymalną liczbę wystąpień serwera.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize, System.IO.Pipes.PipeSecurity pipeSecurity, System.IO.HandleInheritability inheritability, System.IO.Pipes.PipeAccessRights additionalAccessRights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity, valuetype System.IO.HandleInheritability inheritability, valuetype System.IO.Pipes.PipeAccessRights additionalAccessRights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32,System.IO.Pipes.PipeSecurity,System.IO.HandleInheritability,System.IO.Pipes.PipeAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize, System::IO::Pipes::PipeSecurity ^ pipeSecurity, System::IO::HandleInheritability inheritability, System::IO::Pipes::PipeAccessRights additionalAccessRights);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int * System.IO.Pipes.PipeSecurity * System.IO.HandleInheritability * System.IO.Pipes.PipeAccessRights -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity, inheritability, additionalAccessRights)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="additionalAccessRights" Type="System.IO.Pipes.PipeAccessRights" />
      </Parameters>
      <Docs>
        <param name="pipeName">Nazwa potoku.</param>
        <param name="direction">Jedna z wartości wyliczenia, które określa kierunek potoku.</param>
        <param name="maxNumberOfServerInstances">Maksymalna liczba wystąpień serwera, które mają taką samą nazwę. Możesz przekazać <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> dla tej wartości.</param>
        <param name="transmissionMode">Jedna z wartości wyliczenia, które określa tryb przesyłania potoku.</param>
        <param name="options">Jedna z wartości wyliczenia, które określa sposób próbę otwarcia lub utworzenia potoku.</param>
        <param name="inBufferSize">Rozmiar buforu wejściowego.</param>
        <param name="outBufferSize">Rozmiar buforu wyjściowego.</param>
        <param name="pipeSecurity">Obiekt, który określa kontroli dostępu i inspekcji zabezpieczeń dla potoku.</param>
        <param name="inheritability">Jedna z wartości wyliczenia, które określa, czy podstawowy uchwyt może być dziedziczony przez procesy podrzędne.</param>
        <param name="additionalAccessRights">Jedna z wartości wyliczenia, które określa prawa dostępu do potoku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> nazwy klasy przy użyciu określonego potoku, potok kierunku, maksymalna liczba wystąpień serwera tryb transmisji, opcje potoku, zaleca się wewnątrz i na zewnątrz buforu rozmiarów, zabezpieczenia potoku tryb inheritability i przekazać dostępu prawa.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> jest ustawiona na "anonimowy".  
  
—lub— 
 <paramref name="direction" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.  
  
—lub— 
 <paramref name="maxNumberofServerInstances" /> jest mniejsza niż -1 lub większa niż 254 (-1 oznacza <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />) 
—lub— 
 <paramref name="options" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeOptions" /> wartość.  
  
—lub— 
 <paramref name="inBufferSize" /> ma wartość ujemną.  
  
—lub— 
 <paramref name="inheritability" /> nie jest prawidłowym <see cref="T:System.IO.HandleInheritability" /> wartość.  
  
—lub— 
 <paramref name="additionalAccessRights" /> nie jest prawidłowym <see cref="T:System.IO.Pipes.PipeAccessRights" /> wartość.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> zawiera dwukropek (":").</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows Millennium Edition, Windows 98 lub Windows 95, które nie są obsługiwane.</exception>
        <exception cref="T:System.IO.IOException">Przekroczono maksymalną liczbę wystąpień serwera.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">Aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForConnection">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForConnection (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginWaitForConnection(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.BeginWaitForConnection(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForConnection (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForConnection(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginWaitForConnection : AsyncCallback * obj -&gt; IAsyncResult" Usage="namedPipeServerStream.BeginWaitForConnection (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda do wywołania, gdy klient nawiąże połączenie z <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> obiektu.</param>
        <param name="state">Obiekt dostarczony przez użytkownika, który odróżnia tego konkretnego żądania asynchroniczne od innych żądań.</param>
        <summary>Rozpoczyna operację asynchroniczną oczekiwania klientów do łączenia z.</summary>
        <returns>Obiekt, który odwołuje się do żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to odpowiednik asynchroniczne <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A>.  
  
 <xref:System.IO.Pipes.NamedPipeServerStream.EndWaitForConnection%2A> musi zostać wywołana tylko raz dla każdego wywołania <xref:System.IO.Pipes.NamedPipeServerStream.BeginWaitForConnection%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie otwarto asynchronicznie do potoku.  
  
—lub— 
Nawiązano już połączenie potoku.  
  
—lub— 
Nie ustawiono dojście potoku.</exception>
        <exception cref="T:System.IO.IOException">Połączenie potoku zostało przerwane.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.Disconnect" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect();" />
      <MemberSignature Language="F#" Value="member this.Disconnect : unit -&gt; unit" Usage="namedPipeServerStream.Disconnect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozłącza bieżące połączenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.IO.Pipes.NamedPipeServerStream.Disconnect%2A> metoda spowoduje zablokowanie, aż wszystkie znaki wysłane zostały odczytane, chyba że tryb przesyłania potoku jest ustawiony na <xref:System.IO.Pipes.PipeTransmissionMode.Message> i rozmiar buforu jest ustawiony w konstruktorze, utworzony <xref:System.IO.Pipes.NamedPipeServerStream> obiektu. W tym przypadku nie wszystkie komunikaty będą odbierane. Wywoływanie <xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A> powoduje, że serwer blokowane, aż wszystkie dane są odczytywane z potoku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wprowadzono jeszcze żadnych połączeń potoku.  
  
—lub— 
Połączone potoku już został odłączony.  
  
—lub— 
Nie ustawiono dojście potoku.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForConnection">
      <MemberSignature Language="C#" Value="public void EndWaitForConnection (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndWaitForConnection(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.EndWaitForConnection(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndWaitForConnection (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndWaitForConnection(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndWaitForConnection : IAsyncResult -&gt; unit" Usage="namedPipeServerStream.EndWaitForConnection asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądania asynchronicznego.</param>
        <summary>Kończy operację asynchroniczną oczekiwania klientów do łączenia z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.NamedPipeServerStream.EndWaitForConnection%2A> musi zostać wywołana tylko raz dla każdego wywołania <xref:System.IO.Pipes.NamedPipeServerStream.BeginWaitForConnection%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie otwarto asynchronicznie do potoku.  
  
—lub— 
Nie ustawiono dojście potoku.</exception>
        <exception cref="T:System.IO.IOException">Połączenie potoku zostało przerwane.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NamedPipeServerStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NamedPipeServerStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="namedPipeServerStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby niezarządzane, a następnie wykonuje inne operacje oczyszczania przed <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> wystąpienia są odzyskiwane przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetImpersonationUserName">
      <MemberSignature Language="C#" Value="public string GetImpersonationUserName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetImpersonationUserName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.GetImpersonationUserName" />
      <MemberSignature Language="VB.NET" Value="Public Function GetImpersonationUserName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetImpersonationUserName();" />
      <MemberSignature Language="F#" Value="member this.GetImpersonationUserName : unit -&gt; string" Usage="namedPipeServerStream.GetImpersonationUserName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera nazwę użytkownika klienta na drugim końcu potoku.</summary>
        <returns>Nazwa użytkownika klienta na drugim końcu potoku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.NamedPipeServerStream.GetImpersonationUserName%2A> Metoda zwraca `null` Jeśli klient nie został jeszcze zapisany do potoku lub podłączony klient nie może połączyć za pomocą <xref:System.Security.Principal.TokenImpersonationLevel> z <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje metodę, aby utworzyć serwer potoku, który może reagować na wiele jednoczesnych żądań, a metoda personifikacji klienta. Ten przykład tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiektu w procesu nadrzędnego, który następnie tworzy wiele wątków, które poczekaj, aż <xref:System.IO.Pipes.NamedPipeClientStream> obiektów, aby połączyć. Po połączeniu klienta dostarcza mu nazwę pliku na serwer zawartość tego pliku są odczytywać i wysyłane z powrotem do klienta. Ponieważ <xref:System.IO.Pipes.NamedPipeServerStream> personifikuje klienta podczas otwierania pliku, klient może żądać tylko pliki które dział it ma wystarczające uprawnienia do otwarcia.  
  
 [!code-cpp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wprowadzono jeszcze żadnych połączeń potoku.  
  
—lub— 
Połączone potoku już został odłączony.  
  
—lub— 
Nie ustawiono dojście potoku.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Połączenie potoku zostało przerwane.  
  
—lub— 
Nazwa użytkownika klienta jest dłuższa niż 19 znaków.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermissionFlag">Aby uzyskać możliwość manipulować głównym przedmiotem. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MaxAllowedServerInstances">
      <MemberSignature Language="C#" Value="public const int MaxAllowedServerInstances = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxAllowedServerInstances = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxAllowedServerInstances As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxAllowedServerInstances = -1;" />
      <MemberSignature Language="F#" Value="val mutable MaxAllowedServerInstances : int" Usage="System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Reprezentuje maksymalną liczbę wystąpień serwera, które umożliwiają zasobów systemowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances> podczas tworzenia <xref:System.IO.Pipes.NamedPipeServerStream> obiektu, aby ustawić maksymalną liczbę wystąpień serwera, które umożliwiają zasobów systemowych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RunAsClient">
      <MemberSignature Language="C#" Value="public void RunAsClient (System.IO.Pipes.PipeStreamImpersonationWorker impersonationWorker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunAsClient(class System.IO.Pipes.PipeStreamImpersonationWorker impersonationWorker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.RunAsClient(System.IO.Pipes.PipeStreamImpersonationWorker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunAsClient (impersonationWorker As PipeStreamImpersonationWorker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunAsClient(System::IO::Pipes::PipeStreamImpersonationWorker ^ impersonationWorker);" />
      <MemberSignature Language="F#" Value="member this.RunAsClient : System.IO.Pipes.PipeStreamImpersonationWorker -&gt; unit" Usage="namedPipeServerStream.RunAsClient impersonationWorker" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="impersonationWorker" Type="System.IO.Pipes.PipeStreamImpersonationWorker" />
      </Parameters>
      <Docs>
        <param name="impersonationWorker">Delegat, który określa metodę do wywołania.</param>
        <summary>Wywołuje delegata podczas personifikacji klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klient nawiązujący połączenie uprawnienia są stosowane do serwera zdalnego. Na przykład jeśli klient nawiązujący połączenie próbuje żądania zawartości pliku na serwerze, klient może żądać tylko pliki, które ma wystarczające uprawnienia, aby otworzyć.  
  
   
  
## Examples  
 Poniższy przykład pokazuje metodę, aby utworzyć serwer potoku, który może reagować na wiele jednoczesnych żądań, a metoda personifikacji klienta. Ten przykład tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiektu w procesu nadrzędnego, który następnie tworzy wiele wątków, które poczekaj, aż <xref:System.IO.Pipes.NamedPipeClientStream> obiektów, aby połączyć. Po połączeniu klienta dostarcza mu nazwę pliku na serwer zawartość tego pliku są odczytywać i wysyłane z powrotem do klienta. Ponieważ <xref:System.IO.Pipes.NamedPipeServerStream> personifikuje klienta podczas otwierania pliku, klient może żądać tylko pliki które dział it ma wystarczające uprawnienia do otwarcia.  
  
 [!code-cpp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wprowadzono jeszcze żadnych połączeń potoku.  
  
—lub— 
Połączone potoku już został odłączony.  
  
—lub— 
Nie ustawiono dojście potoku.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Połączenie potoku zostało przerwane.  
  
—lub— 
Wystąpił błąd we/wy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermissionFlag">Aby uzyskać możliwość manipulować głównym przedmiotem. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForConnection">
      <MemberSignature Language="C#" Value="public void WaitForConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForConnection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.WaitForConnection" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForConnection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForConnection();" />
      <MemberSignature Language="F#" Value="member this.WaitForConnection : unit -&gt; unit" Usage="namedPipeServerStream.WaitForConnection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka, aż klienta do łączenia z tą <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody powoduje, że <xref:System.IO.Pipes.NamedPipeServerStream> obiekt, aby zapewnić blokowanie do zakończenia klient nawiąże połączenie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metodę, aby wysłać ciąg z procesu nadrzędnego na podrzędnych procesu za pośrednictwem nazwanych potoków. Ten przykład tworzy <xref:System.IO.Pipes.NamedPipeServerStream> obiektu w procesie nadrzędnym. Ten obiekt zawiera <xref:System.IO.Pipes.PipeDirection> wartość <xref:System.IO.Pipes.PipeDirection.Out>, który następnie blokuje, dopóki <xref:System.IO.Pipes.NamedPipeClientStream> obiektu nawiąże połączenie z <xref:System.IO.Pipes.NamedPipeServerStream> obiektu. W tym przykładzie jest częścią większego przykładu przewidzianego dla <xref:System.IO.Pipes.NamedPipeServerStream> i <xref:System.IO.Pipes.NamedPipeClientStream> klasy.  
  
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nawiązano już połączenie potoku.  
  
—lub— 
Nie ustawiono dojście potoku.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Połączenie potoku zostało przerwane.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForConnectionAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie czeka klienta do łączenia z tą <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForConnectionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitForConnectionAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitForConnectionAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForConnectionAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitForConnectionAsync();" />
      <MemberSignature Language="F#" Value="member this.WaitForConnectionAsync : unit -&gt; System.Threading.Tasks.Task" Usage="namedPipeServerStream.WaitForConnectionAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie czeka klienta do łączenia z tą <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> obiektu.</summary>
        <returns>Zadanie reprezentujące operację asynchroniczną oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ jest asynchroniczne, ta metoda zwraca natychmiast, ale proces nawiązywania połączenia zostało zakończone, gdy klient wywołuje <xref:System.IO.Pipes.NamedPipeClientStream.Connect%2A> lub <xref:System.IO.Pipes.NamedPipeClientStream.ConnectAsync%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitForConnectionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitForConnectionAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitForConnectionAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitForConnectionAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitForConnectionAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="namedPipeServerStream.WaitForConnectionAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie czeka klienta do łączenia z tą <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> żądań anulowania z obiektu i monitory.</summary>
        <returns>Zadanie reprezentujące operację asynchroniczną oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ jest asynchroniczne, ta metoda zwraca natychmiast, ale proces nawiązywania połączenia zostało zakończone, gdy klient wywołuje <xref:System.IO.Pipes.NamedPipeClientStream.Connect%2A> lub <xref:System.IO.Pipes.NamedPipeClientStream.ConnectAsync%2A>.  
  
 Anulowania żądań przy użyciu tokenu anulowania będzie działać, tylko jeśli <xref:System.IO.Pipes.NamedPipeServerStream> został utworzony obiekt o wartości opcji potoku <xref:System.IO.Pipes.PipeOptions.Asynchronous?displayProperty=nameWithType> czy anulowanie jest wcześniejsza niż <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
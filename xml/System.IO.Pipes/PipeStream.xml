<Type Name="PipeStream" FullName="System.IO.Pipes.PipeStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3c204000f85d002010ae0a301e6875effb7cfd5" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36485071" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PipeStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PipeStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.PipeStream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PipeStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class PipeStream abstract : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type PipeStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Przedstawia <see cref="T:System.IO.Stream" /> obiekt wokół potok, który obsługuje potoki nazwane i anonimowe.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream> Klasa udostępnia klasę podstawową dla operacji nazwane i anonimowe potoki w programie .NET Framework. Użyj <xref:System.IO.Pipes.NamedPipeServerStream> i <xref:System.IO.Pipes.NamedPipeClientStream> klasy dla operacji nazwanego potoku. Użyj <xref:System.IO.Pipes.AnonymousPipeServerStream> i <xref:System.IO.Pipes.AnonymousPipeClientStream> klasy dla operacje potokowe anonimowy.  
  
 Aby uzyskać więcej informacji na temat potoków, zobacz [potoków](~/docs/standard/io/pipe-operations.md). Na przykład potoków anonimowych zobacz [porady: użycie potoków anonimowych do lokalnej komunikacji międzyprocesowej](~/docs/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication.md). Na przykład nazwane potoki Zobacz [porady: użycie nazwanych potoków do sieciowej komunikacji międzyprocesowej](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.PipeStream" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.#ctor(System.IO.Pipes.PipeDirection,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (direction As PipeDirection, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PipeStream(System::IO::Pipes::PipeDirection direction, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.PipeStream : System.IO.Pipes.PipeDirection * int -&gt; System.IO.Pipes.PipeStream" Usage="new System.IO.Pipes.PipeStream (direction, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.IO.Pipes.PipeDirection" /> wartości, które wskazuje kierunek obiekt potoku.</param>
        <param name="bufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większa niż lub równa 0, który wskazuje rozmiar buforu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.PipeStream" /> przy użyciu określonego <see cref="T:System.IO.Pipes.PipeDirection" /> rozmiar wartość i buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor korzysta tryb transmisji potoku <xref:System.IO.Pipes.PipeTransmissionMode.Byte>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="direction" /> nie jest prawidłową <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.  - lub - <paramref name="bufferSize" /> jest mniejszy niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, System.IO.Pipes.PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, int32 outBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeTransmissionMode,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (direction As PipeDirection, transmissionMode As PipeTransmissionMode, outBufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PipeStream(System::IO::Pipes::PipeDirection direction, System::IO::Pipes::PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.PipeStream : System.IO.Pipes.PipeDirection * System.IO.Pipes.PipeTransmissionMode * int -&gt; System.IO.Pipes.PipeStream" Usage="new System.IO.Pipes.PipeStream (direction, transmissionMode, outBufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Jeden z <see cref="T:System.IO.Pipes.PipeDirection" /> wartości, które wskazuje kierunek obiekt potoku.</param>
        <param name="transmissionMode">Jeden z <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartości, które wskazuje tryb transmisji obiektu potoku.</param>
        <param name="outBufferSize">Dodatnią <see cref="T:System.Int32" /> wartość większa niż lub równa 0, który wskazuje rozmiar buforu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.PipeStream" /> przy użyciu określonego <see cref="T:System.IO.Pipes.PipeDirection" />, <see cref="T:System.IO.Pipes.PipeTransmissionMode" />, a rozmiar buforu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="direction" /> nie jest prawidłową <see cref="T:System.IO.Pipes.PipeDirection" /> wartość.  - lub - <paramref name="transmissionMode" /> nie jest prawidłową <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartość.  - lub - <paramref name="bufferSize" /> jest mniejszy niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="pipeStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do wczytania danych.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> pod którym ma rozpocząć się odczyt.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="callback">Metoda wywoływana, gdy operacja odczytu asynchronicznego zostanie ukończona.</param>
        <param name="state">Obiekt dostarczane przez użytkownika, która odróżnia to asynchroniczne żądanie odczytu z innych żądań.</param>
        <summary>Rozpoczyna operację asynchroniczną odczytu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do asynchronicznego odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przekaż zwróconego <xref:System.IAsyncResult> do obiektu <xref:System.IO.Pipes.PipeStream.EndRead%2A> metody ustalić liczbę bajtów zostały odczytane i zwolnić zasoby systemu operacyjnego używany do odczytu. <xref:System.IO.Pipes.PipeStream.EndRead%2A> musi być wywołana raz dla każdego wywołania <xref:System.IO.Pipes.PipeStream.BeginRead%2A>. Można to zrobić w taki sam kod, który wywołał <xref:System.IO.Pipes.PipeStream.BeginRead%2A> lub w wywołaniu zwrotnym są przekazywane do <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.  
  
 Użyj <xref:System.IO.Pipes.PipeStream.CanRead%2A> umożliwia określenie, czy bieżący <xref:System.IO.Pipes.PipeStream> operacje odczytu dla obiekt obsługuje.  
  
 Jeśli potok został zamknięty lub nieprawidłowy argument jest przekazywany do <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, odpowiednich wyjątków pojawienia się natychmiast. Występuje błędów występujących podczas odczytu żądania asynchronicznego na wątku puli wątków, który wykonuje żądanie. Wyjątki są zgłaszane, gdy kod wywołuje <xref:System.IO.Pipes.PipeStream.EndRead%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> jest większa niż liczba bajtów dostępnych w <paramref name="buffer" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Potok nie obsługuje operacji odczytu.</exception>
        <exception cref="T:System.InvalidOperationException">Potok został odłączony, oczekiwanie na połączenie lub dojście nie zostało ustawione.</exception>
        <exception cref="T:System.IO.IOException">Potok jest uszkodzony lub wystąpił inny błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="pipeStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Buforu, który zawiera dane do zapisania bieżącego strumienia.</param>
        <param name="offset">Zerze przesunięcie w <c>buforu</c> jaką należy zacząć kopiowanie bajtów do bieżącego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="callback">Metoda do wywołania po ukończeniu operacji zapis asynchroniczny.</param>
        <param name="state">Obiekt dostarczane przez użytkownika, która odróżnia to żądanie określonego zapis asynchroniczny od innych żądań.</param>
        <summary>Rozpoczyna operację asynchronicznego zapisu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do operację asynchronicznego zapisu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream.EndWrite%2A> musi być wywołana raz dla każdego wywołania <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>. Można to zrobić w taki sam kod, który wywołał <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> lub w wywołaniu zwrotnym są przekazywane do <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.  
  
 Użyj <xref:System.IO.Pipes.PipeStream.CanWrite%2A> właściwości, aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiektu obsługuje operacje zapisu.  
  
 Jeśli potok został zamknięty lub nieprawidłowy argument jest przekazywany do <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, odpowiednich wyjątków pojawienia się natychmiast. Błędów występujących podczas żądania asynchronicznego zapisu są dokonywane na wątku puli wątków, który wykonuje żądanie. Wyjątki są zgłaszane, gdy kod wywołuje <xref:System.IO.Pipes.PipeStream.EndWrite%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> jest większa niż liczba bajtów dostępnych w <paramref name="buffer" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Potok nie obsługuje operacji zapisu.</exception>
        <exception cref="T:System.InvalidOperationException">Potok został odłączony, oczekiwanie na połączenie lub dojście nie zostało ustawione.</exception>
        <exception cref="T:System.IO.IOException">Potok jest uszkodzony lub wystąpił inny błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Pipes.PipeStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje operacji odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli obsługuje strumień odczytu operacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Pipes.PipeStream> obiekt jest zamknięty, ta właściwość zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Pipes.PipeStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje operacji szukania.</summary>
        <value>
          <see langword="false" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Pipes.PipeStream> obiekt jest zamknięty, ta właściwość zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Pipes.PipeStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje operacji zapisu.</summary>
        <value>
          <see langword="true" /> w przypadku strumienia obsługuje operacje zapisu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Pipes.PipeStream> obiekt jest zamknięty, ta właściwość zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckPipePropertyOperations">
      <MemberSignature Language="C#" Value="protected internal virtual void CheckPipePropertyOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CheckPipePropertyOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckPipePropertyOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CheckPipePropertyOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CheckPipePropertyOperations();" />
      <MemberSignature Language="F#" Value="abstract member CheckPipePropertyOperations : unit -&gt; unit&#xA;override this.CheckPipePropertyOperations : unit -&gt; unit" Usage="pipeStream.CheckPipePropertyOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy potoku jest w odpowiednim stanie do pobierania lub ustawiania właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckReadOperations">
      <MemberSignature Language="C#" Value="protected internal void CheckReadOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckReadOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckReadOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CheckReadOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CheckReadOperations();" />
      <MemberSignature Language="F#" Value="member this.CheckReadOperations : unit -&gt; unit" Usage="pipeStream.CheckReadOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy potoku jest w stanie połączenia dla operacji odczytu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckWriteOperations">
      <MemberSignature Language="C#" Value="protected internal void CheckWriteOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckWriteOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckWriteOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CheckWriteOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CheckWriteOperations();" />
      <MemberSignature Language="F#" Value="member this.CheckWriteOperations : unit -&gt; unit" Usage="pipeStream.CheckWriteOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy potoku jest w stanie połączenia dla operacji zapisu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="pipeStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.Pipes.PipeStream" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A> — metoda i <xref:System.Object.Finalize%2A> metody. <xref:System.ComponentModel.Component.Dispose%2A> wywołuje chronioną metodę <xref:System.IO.Pipes.PipeStream.Dispose%2A> metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje <xref:System.IO.Pipes.PipeStream.Dispose%2A> z `disposing` ustawioną `false`. Jeśli parametr disposing jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.IO.Pipes.PipeStream> obiektu odwołania. Ta metoda wywołuje <xref:System.IO.Pipes.PipeStream.Dispose%2A> metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W klasach, włącz na wszystkich pochodnych <see cref="T:System.IO.Stream" /> logikę oczyszczania <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> metody.  <see cref="M:System.ComponentModel.Component.Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see cref="M:System.ComponentModel.Component.Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see cref="M:System.ComponentModel.Component.Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia się niezarządzane Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="pipeStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekującego żądania asynchronicznego.</param>
        <summary>Kończy się oczekujące żądanie odczytu asynchronicznego.</summary>
        <returns>Liczba bajtów, które zostały odczytane. Wartość zwracana 0 wskazuje koniec strumienia (potok został zamknięty).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca liczbę bajtów odczytanych do tablicy typu byte, określony przez wywołanie wcześniejszych <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.  
  
 Przekaż zwróconego <xref:System.IAsyncResult> do obiektu <xref:System.IO.Pipes.PipeStream.EndRead%2A> metody ustalić liczbę bajtów zostały odczytane i zwolnić zasoby systemu operacyjnego używany do odczytu. <xref:System.IO.Pipes.PipeStream.EndRead%2A> musi być wywołana raz dla każdego wywołania <xref:System.IO.Pipes.PipeStream.BeginRead%2A>. Można to zrobić w taki sam kod, który wywołał <xref:System.IO.Pipes.PipeStream.BeginRead%2A> lub w wywołaniu zwrotnym są przekazywane do <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.  
  
 Użyj <xref:System.IO.Pipes.PipeStream.CanRead%2A> umożliwia określenie, czy bieżący <xref:System.IO.Pipes.PipeStream> operacje odczytu dla obiekt obsługuje.  
  
 Jeśli potok został zamknięty lub nieprawidłowy argument jest przekazywany do <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, odpowiednich wyjątków pojawienia się natychmiast. Występuje błędów występujących podczas odczytu żądania asynchronicznego na wątku puli wątków, który wykonuje żądanie. Wyjątki są zgłaszane, gdy kod wywołuje <xref:System.IO.Pipes.PipeStream.EndRead%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie pochodzi z <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> metody dla bieżącej strumienia.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="pipeStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekującego żądania asynchronicznego.</param>
        <summary>Kończy żądanie oczekującego zapisu asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream.EndWrite%2A> musi być wywołana raz dla każdego wywołania <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>. Można to zrobić w taki sam kod, który wywołał <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> lub w wywołaniu zwrotnym są przekazywane do <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.  
  
 Użyj <xref:System.IO.Pipes.PipeStream.CanWrite%2A> właściwości, aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiektu obsługuje operacje zapisu.  
  
 Jeśli potok został zamknięty lub nieprawidłowy argument jest przekazywany do <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, odpowiednich wyjątków pojawienia się natychmiast. Błędów występujących podczas żądania asynchronicznego zapisu są dokonywane na wątku puli wątków, który wykonuje żądanie. Wyjątki są zgłaszane po kodzie wywołań <xref:System.IO.Pipes.PipeStream.EndWrite%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie pochodzi z <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> metody dla bieżącej strumienia.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="pipeStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści bufor dla bieżącego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream.Flush%2A> Metoda nie jest obsługiwana w <xref:System.IO.Pipes.PipeStream> klasy i nie nic, gdy jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Potok nie obsługuje operacji zapisu.</exception>
        <exception cref="T:System.IO.IOException">Potok jest uszkodzony lub wystąpił inny błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.Pipes.PipeSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Pipes.PipeSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As PipeSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Pipes::PipeSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.IO.Pipes.PipeSecurity" Usage="pipeStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.IO.Pipes.PipeSecurity" /> obiekt hermetyzujący listę kontroli dostępu (ACL) wpisy kontroli dostępu dla potoku opisanego przez bieżący <see cref="T:System.IO.Pipes.PipeStream" /> obiektu.</summary>
        <returns>A <see cref="T:System.IO.Pipes.PipeSecurity" /> obiekt hermetyzujący listę kontroli dostępu (ACL) wpisy kontroli dostępu dla potoku opisanego przez bieżący <see cref="T:System.IO.Pipes.PipeStream" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Listy kontroli dostępu (ACL) w tym artykule opisano fizycznych i/lub grup, które ma lub ma prawa do wykonania określonych działań w określonym pliku. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nie można wywołać podstawowej, można ustawić informacji o zabezpieczeniach.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można wywołać podstawowej, można ustawić informacji o zabezpieczeniach.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wywołać podstawowej, można ustawić informacji o zabezpieczeniach.</exception>
      </Docs>
    </Member>
    <Member MemberName="InBufferSize">
      <MemberSignature Language="C#" Value="public virtual int InBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.InBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property InBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int InBufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InBufferSize : int" Usage="System.IO.Pipes.PipeStream.InBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar w bajtach buforu dla ruchu przychodzącego dla potoku.</summary>
        <value>Wartość całkowitą reprezentującą rozmiar buforu dla ruchu przychodzącego, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Pipes.PipeStream.InBufferSize%2A> ma wartość 0, rozmiar buforu jest przydzielane w razie potrzeby.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Strumień jest nie można go odczytać.</exception>
        <exception cref="T:System.InvalidOperationException">Potok oczekuje na połączenie.</exception>
        <exception cref="T:System.IO.IOException">Potok jest uszkodzony lub wystąpił inny błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeHandle">
      <MemberSignature Language="C#" Value="protected void InitializeHandle (Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeHandle(class Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeHandle (handle As SafePipeHandle, isExposed As Boolean, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeHandle(Microsoft::Win32::SafeHandles::SafePipeHandle ^ handle, bool isExposed, bool isAsync);" />
      <MemberSignature Language="F#" Value="member this.InitializeHandle : Microsoft.Win32.SafeHandles.SafePipeHandle * bool * bool -&gt; unit" Usage="pipeStream.InitializeHandle (handle, isExposed, isAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
        <Parameter Name="isExposed" Type="System.Boolean" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">
          <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> Potoku można zainicjować obiektu.</param>
        <param name="isExposed">
          <see langword="true" /> Aby udostępnić dojście; w przeciwnym razie <see langword="false" />.</param>
        <param name="isAsync">
          <see langword="true" /> Aby wskazać, że dojście zostało otwarte asynchronicznie; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje <see cref="T:System.IO.Pipes.PipeStream" /> obiektu z określonego <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli potoku jest w stanie połączenia, ta metoda określa również <xref:System.IO.Pipes.PipeStream.IsConnected%2A> właściwości `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można powiązać dojścia do potoku.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.Pipes.PipeStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.IO.Pipes.PipeStream" /> obiektów otwarto asynchronicznie lub synchronicznie.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.Pipes.PipeStream" /> obiektów otwarto asynchronicznie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia kod, aby używał <xref:System.IO.Pipes.PipeStream.SafePipeHandle%2A> właściwości poprawnie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConnected">
      <MemberSignature Language="C#" Value="public bool IsConnected { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConnected" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Property IsConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:  property bool IsConnected {  public:&#xA;bool get(); protected:&#xA; void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsConnected : bool with get, set" Usage="System.IO.Pipes.PipeStream.IsConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="T:System.IO.Pipes.PipeStream" /> obiekt jest połączony.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.Pipes.PipeStream" /> obiekt jest połączonych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream.IsConnected%2A> Zwraca `true` tylko wtedy, gdy <xref:System.IO.Pipes.PipeStream> obiekt jest połączony. Jeśli ta właściwość zwraca `false`, potoku może być oczekiwanie na połączenie, lub może być odłączony, zamknięte lub uszkodzony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHandleExposed">
      <MemberSignature Language="C#" Value="protected bool IsHandleExposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleExposed" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsHandleExposed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsHandleExposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsHandleExposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHandleExposed : bool" Usage="System.IO.Pipes.PipeStream.IsHandleExposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dojścia do <see cref="T:System.IO.Pipes.PipeStream" /> obiektu jest widoczna.</summary>
        <value>
          <see langword="true" /> Jeśli dojścia do <see cref="T:System.IO.Pipes.PipeStream" /> obiekt jest narażonych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest ustawiona podczas uzyskiwania dojścia do potoku, który jest hermetyzowany przez bieżące <xref:System.IO.Pipes.PipeStream> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMessageComplete">
      <MemberSignature Language="C#" Value="public bool IsMessageComplete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMessageComplete" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsMessageComplete" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMessageComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMessageComplete { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMessageComplete : bool" Usage="System.IO.Pipes.PipeStream.IsMessageComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy komunikat zwrócony przez operację odczytu najnowszych jest więcej danych.</summary>
        <value>
          <see langword="true" /> Jeśli nie są więcej znaki do odczytu w komunikacie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość ma zastosowanie jeśli potoku <xref:System.IO.Pipes.PipeStream.ReadMode%2A> ustawiono właściwość <xref:System.IO.Pipes.PipeTransmissionMode.Message> przez najnowszej wywołanie <xref:System.IO.Pipes.PipeStream.Read%2A> lub <xref:System.IO.Pipes.PipeStream.EndRead%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Potok nie jest połączony.  - lub - dojścia potoku nie została ustawiona.  - lub - potoku <see cref="P:System.IO.Pipes.PipeStream.ReadMode" /> wartość właściwości jest <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Pipes.PipeStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość strumienia, w bajtach.</summary>
        <value>0 we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream> Klasa nie obsługuje <xref:System.IO.Pipes.PipeStream.Length%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Zawsze generowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="OutBufferSize">
      <MemberSignature Language="C#" Value="public virtual int OutBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.OutBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OutBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int OutBufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutBufferSize : int" Usage="System.IO.Pipes.PipeStream.OutBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar w bajtach buforu ruchu wychodzącego dla potoku.</summary>
        <value>Rozmiar buforu ruchu wychodzącego w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Pipes.PipeStream.OutBufferSize%2A> ma wartość 0, rozmiar buforu jest przydzielane w razie potrzeby.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Strumień jest nie do zapisania.</exception>
        <exception cref="T:System.InvalidOperationException">Potok oczekuje na połączenie.</exception>
        <exception cref="T:System.IO.IOException">Potok jest uszkodzony lub wystąpił inny błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Pipes.PipeStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą pozycję bieżącego strumienia.</summary>
        <value>0 we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream> Klasa nie obsługuje <xref:System.IO.Pipes.PipeStream.Position%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Zawsze generowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([in]unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="pipeStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Po powrocie z tej metody zawiera określonej tablicy bajtów z wartością pomiędzy <c>przesunięcie</c> i (<c>przesunięcie</c> + <c>liczba</c> - 1) zastępuje Bajty odczytane z bieżące źródło.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> tablicy, w której zostaną umieszczone bajtów, które są do odczytu.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <summary>Odczytuje blok bajtów ze strumienia i zapisuje dane w buforze określona.</summary>
        <returns>Całkowita liczba bajtów, które są do odczytu do <paramref name="buffer" />. Przyczyną może być mniejsza niż żądana liczba bajtów, jeśli podanej liczby bajtów nie jest obecnie dostępny, lub wpisz 0, gdy zostanie osiągnięty koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Pipes.PipeStream.CanRead%2A> umożliwia określenie, czy bieżący <xref:System.IO.Pipes.PipeStream> operacje odczytu dla obiekt obsługuje.  
  
 Wywoływanie <xref:System.IO.Pipes.PipeStream.Read%2A> blokuje metody do momentu `count` bajtów do odczytu lub osiągnięto koniec strumienia. Dla asynchronicznych operacji odczytu, zobacz <xref:System.IO.Pipes.PipeStream.BeginRead%2A> i <xref:System.IO.Pipes.PipeStream.EndRead%2A>.  
  
   
  
## Examples  
 Poniższy przykład tworzy potoku anonimowym klientem i serwerem potoku. Korzysta z serwerem potoku <xref:System.IO.Pipes.PipeStream.Read%2A> metody odczytać serię bajtów z klienta potoku jako kod sprawdzania poprawności. Klienta potoku i serwera potoku są częścią tego samego przykładu. Część serwera przykładu tworzy procesu klienta i przekazuje je dojścia potoku anonimowe jako argument.  
  
 [!code-cpp[System.IO.Pipes.PipeStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.io.pipes.pipestream/cpp/sample.cpp#1)]
 [!code-csharp[System.IO.Pipes.PipeStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.pipes.pipestream/cs/sample.cs#1)]
 [!code-vb[System.IO.Pipes.PipeStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.pipes.pipestream/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> jest większa niż liczba bajtów dostępnych w <paramref name="buffer" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Potok nie obsługuje operacji odczytu.</exception>
        <exception cref="T:System.InvalidOperationException">Potok został odłączony, oczekiwanie na połączenie lub dojście nie zostało ustawione.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd żadnych operacji We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="pipeStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="pipeStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bajt potoku.</summary>
        <returns>Byte, rzutować <see cref="T:System.Int32" />, lub wartość -1 wskazuje koniec strumienia (potok został zamknięty).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Pipes.PipeStream.CanRead%2A> umożliwia określenie, czy bieżący <xref:System.IO.Pipes.PipeStream> operacje odczytu dla obiekt obsługuje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Potok nie obsługuje operacji odczytu.</exception>
        <exception cref="T:System.InvalidOperationException">Potok został odłączony, oczekiwanie na połączenie lub dojście nie zostało ustawione.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd żadnych operacji We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode ReadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode ReadMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.ReadMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode ReadMode { System::IO::Pipes::PipeTransmissionMode get(); void set(System::IO::Pipes::PipeTransmissionMode value); };" />
      <MemberSignature Language="F#" Value="member this.ReadMode : System.IO.Pipes.PipeTransmissionMode with get, set" Usage="System.IO.Pipes.PipeStream.ReadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb odczyt <see cref="T:System.IO.Pipes.PipeStream" /> obiektu.</summary>
        <value>Jeden z <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartości, które wskazuje sposób <see cref="T:System.IO.Pipes.PipeStream" /> odczytuje obiekt z potoku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Potoki anonimowe nie obsługują <xref:System.IO.Pipes.PipeTransmissionMode.Message> tryb transmisję wiadomości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość nie jest prawidłową <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartość.</exception>
        <exception cref="T:System.NotSupportedException">Podana wartość nie jest obsługiwana <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartość dla tego strumienia potoku.</exception>
        <exception cref="T:System.InvalidOperationException">Dojście nie została ustawiona.  - lub - potoku oczekuje na połączenie z nazwanym klienta.</exception>
        <exception cref="T:System.IO.IOException">Potoku jest uszkodzony lub wystąpił błąd We/Wy z nazwanym klienta.</exception>
      </Docs>
    </Member>
    <Member MemberName="SafePipeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.SafePipeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafePipeHandle As SafePipeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafePipeHandle ^ SafePipeHandle { Microsoft::Win32::SafeHandles::SafePipeHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafePipeHandle : Microsoft.Win32.SafeHandles.SafePipeHandle" Usage="System.IO.Pipes.PipeStream.SafePipeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafePipeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bezpieczne dojście lokalnego końca potoku bieżącego <see cref="T:System.IO.Pipes.PipeStream" /> hermetyzuje obiektu.</summary>
        <value>A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> obiektu dla potoku, hermetyzowaną przez bieżące <see cref="T:System.IO.Pipes.PipeStream" /> obiektu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Nie ustawiono dojścia potoku.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="pipeStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Punkt, względem <c>pochodzenia</c>, aby rozpocząć wyszukiwanie z.</param>
        <param name="origin">Określa początek, końcu lub bieżącą pozycję jako punkt odniesienia dla <c>przesunięcie</c>, za pomocą wartości typu <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Ustawia bieżącą pozycję bieżącego strumienia z podaną wartością.</summary>
        <returns>Nowa pozycja w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream.Seek%2A> Metoda nie jest obsługiwana w potoków i zgłasza <xref:System.NotSupportedException> gdy jest wywoływana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.SetAccessControl(System.IO.Pipes.PipeSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::Pipes::PipeSecurity ^ pipeSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.IO.Pipes.PipeSecurity -&gt; unit" Usage="pipeStream.SetAccessControl pipeSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
      </Parameters>
      <Docs>
        <param name="pipeSecurity">A <see cref="T:System.IO.Pipes.PipeSecurity" /> obiekt, który określa wpisu listę kontroli dostępu (ACL) kontroli dostępu do zastosowania do bieżącego potoku.</param>
        <summary>Stosuje listę kontroli dostępu (ACL) wpisów kontroli dostępu określone przez <see cref="T:System.IO.Pipes.PipeSecurity" /> obiektu do potoku określony przez bieżącą <see cref="T:System.IO.Pipes.PipeStream" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Listy kontroli dostępu (ACL) w tym artykule opisano fizycznych i/lub grup, które ma lub ma prawa do wykonania określonych działań w określonym pliku. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeSecurity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Nie można wywołać podstawowej, można ustawić informacji o zabezpieczeniach.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można wywołać podstawowej, można ustawić informacji o zabezpieczeniach.</exception>
        <exception cref="T:System.NotSupportedException">Nie można wywołać podstawowej, można ustawić informacji o zabezpieczeniach.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="pipeStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nowe długość strumienia.</param>
        <summary>Ustawia długość bieżący strumień do określonej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream> Klasa nie obsługuje <xref:System.IO.Pipes.PipeStream.SetLength%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransmissionMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode TransmissionMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode TransmissionMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.TransmissionMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TransmissionMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode TransmissionMode { System::IO::Pipes::PipeTransmissionMode get(); };" />
      <MemberSignature Language="F#" Value="member this.TransmissionMode : System.IO.Pipes.PipeTransmissionMode" Usage="System.IO.Pipes.PipeStream.TransmissionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tryb transmisji potoku obsługiwane przez bieżący potoku.</summary>
        <value>Jeden z <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartości, które wskazuje tryb transmisji obsługiwane przez bieżący potoku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Potoki anonimowe nie obsługują <xref:System.IO.Pipes.PipeTransmissionMode.Message> tryb transmisję wiadomości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Dojście nie została ustawiona.  - lub - potoku oczekuje na połączenie w przypadku operacji anonimowego klienta/serwera lub za pomocą klienta o nazwie.</exception>
        <exception cref="T:System.IO.IOException">Potok jest uszkodzony lub wystąpił inny błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForPipeDrain">
      <MemberSignature Language="C#" Value="public void WaitForPipeDrain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForPipeDrain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WaitForPipeDrain" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForPipeDrain ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForPipeDrain();" />
      <MemberSignature Language="F#" Value="member this.WaitForPipeDrain : unit -&gt; unit" Usage="pipeStream.WaitForPipeDrain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka na drugim końcu potoku odczytywać wszystkie wysłane bajty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A> Metody blokuje aż po drugiej stronie potoku zapoznał wszystkie wysłane bajty.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Potok nie obsługuje operacji zapisu.</exception>
        <exception cref="T:System.IO.IOException">Potok jest uszkodzony lub wystąpił inny błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="pipeStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Buforu, który zawiera dane do zapisania do potoku.</param>
        <param name="offset">Zerze przesunięcie w <c>buforu</c> jaką należy zacząć kopiowanie bajtów do bieżącego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania w strumieniu bieżącej.</param>
        <summary>Zapisuje bieżący strumień przy użyciu danych z bufora bloku bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Pipes.PipeStream.CanWrite%2A> właściwości, aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiektu obsługuje operacje zapisu.  
  
 Wywoływanie <xref:System.IO.Pipes.PipeStream.Write%2A> blokuje metody do momentu `count` bajtów do odczytu lub osiągnięto koniec strumienia. Dla asynchronicznych operacji odczytu, zobacz <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> i <xref:System.IO.Pipes.PipeStream.EndWrite%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> jest większa niż liczba bajtów dostępnych w <paramref name="buffer" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Potok nie obsługuje operacji zapisu.</exception>
        <exception cref="T:System.IO.IOException">Potok jest uszkodzony lub wystąpił inny błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="pipeStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="pipeStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Bajtów do zapisania w strumieniu.</param>
        <summary>Zapisuje bieżący strumień bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Pipes.PipeStream.CanWrite%2A> właściwości, aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiektu obsługuje operacje zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Potok jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Potok nie obsługuje operacji zapisu.</exception>
        <exception cref="T:System.InvalidOperationException">Potok został odłączony, oczekiwanie na połączenie lub dojście nie zostało ustawione.</exception>
        <exception cref="T:System.IO.IOException">Potok jest uszkodzony lub wystąpił inny błąd We/Wy.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="PipeStream" FullName="System.IO.Pipes.PipeStream">
  <TypeSignature Language="C#" Value="public abstract class PipeStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PipeStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.PipeStream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PipeStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class PipeStream abstract : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type PipeStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="17a11-101"><see cref="T:System.IO.Stream" /> Uwidacznia obiekt wokół potoku, który obsługuje zarówno potoki anonimowe, jak i nazwane.</span><span class="sxs-lookup"><span data-stu-id="17a11-101">Exposes a <see cref="T:System.IO.Stream" /> object around a pipe, which supports both anonymous and named pipes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-102"><xref:System.IO.Pipes.PipeStream> Klasa udostępnia klasę bazową dla operacji potoków nazwanych i anonimowych w .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="17a11-102">The <xref:System.IO.Pipes.PipeStream> class provides the base class for named and anonymous pipes operations in the .NET Framework.</span></span> <span data-ttu-id="17a11-103">Użyj klas <xref:System.IO.Pipes.NamedPipeClientStream> i dla operacji nazwanych potoków. <xref:System.IO.Pipes.NamedPipeServerStream></span><span class="sxs-lookup"><span data-stu-id="17a11-103">Use the <xref:System.IO.Pipes.NamedPipeServerStream> and <xref:System.IO.Pipes.NamedPipeClientStream> classes for named pipe operations.</span></span> <span data-ttu-id="17a11-104">Użyj klas <xref:System.IO.Pipes.AnonymousPipeClientStream> i dla operacji potoku anonimowego. <xref:System.IO.Pipes.AnonymousPipeServerStream></span><span class="sxs-lookup"><span data-stu-id="17a11-104">Use the <xref:System.IO.Pipes.AnonymousPipeServerStream> and <xref:System.IO.Pipes.AnonymousPipeClientStream> classes for anonymous pipe operations.</span></span>  
  
 <span data-ttu-id="17a11-105">Aby uzyskać więcej informacji na temat potoków, zobacz [potoki](~/docs/standard/io/pipe-operations.md).</span><span class="sxs-lookup"><span data-stu-id="17a11-105">For more information about pipes, see [Pipes](~/docs/standard/io/pipe-operations.md).</span></span> <span data-ttu-id="17a11-106">Przykład anonimowych potoków można znaleźć w [temacie How to: Używaj anonimowych potoków do lokalnej komunikacji](~/docs/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication.md)międzyprocesowej.</span><span class="sxs-lookup"><span data-stu-id="17a11-106">For an example of anonymous pipes, see [How to: Use Anonymous Pipes for Local Interprocess Communication](~/docs/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication.md).</span></span> <span data-ttu-id="17a11-107">Przykład nazwanych potoków można znaleźć w [temacie How to: Użyj nazwanych potoków do komunikacji](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md)międzyprocesowej sieci.</span><span class="sxs-lookup"><span data-stu-id="17a11-107">For an example of named pipes, see [How to: Use Named Pipes for Network Interprocess Communication](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md).</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="17a11-108">aby uzyskać pełne zaufanie dla obiektów dziedziczących.</span><span class="sxs-lookup"><span data-stu-id="17a11-108">for full trust for inheritors.</span></span> <span data-ttu-id="17a11-109">Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="17a11-109">This class cannot be inherited by partially trusted code.</span></span></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="17a11-110">Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Pipes.PipeStream" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="17a11-110">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.#ctor(System.IO.Pipes.PipeDirection,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (direction As PipeDirection, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PipeStream(System::IO::Pipes::PipeDirection direction, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.PipeStream : System.IO.Pipes.PipeDirection * int -&gt; System.IO.Pipes.PipeStream" Usage="new System.IO.Pipes.PipeStream (direction, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="17a11-111">Jedna z <see cref="T:System.IO.Pipes.PipeDirection" /> wartości, która wskazuje kierunek obiektu potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-111">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="17a11-112">Wartość dodatnia <see cref="T:System.Int32" /> większa lub równa 0, która wskazuje rozmiar buforu.</span><span class="sxs-lookup"><span data-stu-id="17a11-112">A positive <see cref="T:System.Int32" /> value greater than or equal to 0 that indicates the buffer size.</span></span></param>
        <summary><span data-ttu-id="17a11-113">Inicjuje nowe wystąpienie <see cref="T:System.IO.Pipes.PipeStream" /> klasy przy użyciu określonej <see cref="T:System.IO.Pipes.PipeDirection" /> wartości i rozmiaru buforu.</span><span class="sxs-lookup"><span data-stu-id="17a11-113">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" /> value and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-114">Ten konstruktor używa trybu <xref:System.IO.Pipes.PipeTransmissionMode.Byte>transmisji potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-114">This constructor uses a pipe transmission mode of <xref:System.IO.Pipes.PipeTransmissionMode.Byte>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17a11-115"><paramref name="direction" />nie jest prawidłową <see cref="T:System.IO.Pipes.PipeDirection" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="17a11-115"><paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</span></span>  
  
<span data-ttu-id="17a11-116">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-116">-or-</span></span> 
 <span data-ttu-id="17a11-117"><paramref name="bufferSize" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="17a11-117"><paramref name="bufferSize" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, System.IO.Pipes.PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, int32 outBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeTransmissionMode,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (direction As PipeDirection, transmissionMode As PipeTransmissionMode, outBufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PipeStream(System::IO::Pipes::PipeDirection direction, System::IO::Pipes::PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.PipeStream : System.IO.Pipes.PipeDirection * System.IO.Pipes.PipeTransmissionMode * int -&gt; System.IO.Pipes.PipeStream" Usage="new System.IO.Pipes.PipeStream (direction, transmissionMode, outBufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="17a11-118">Jedna z <see cref="T:System.IO.Pipes.PipeDirection" /> wartości, która wskazuje kierunek obiektu potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-118">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</span></span></param>
        <param name="transmissionMode"><span data-ttu-id="17a11-119">Jedna z <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartości, która wskazuje tryb transmisji obiektu potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-119">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode of the pipe object.</span></span></param>
        <param name="outBufferSize"><span data-ttu-id="17a11-120">Wartość dodatnia <see cref="T:System.Int32" /> większa lub równa 0, która wskazuje rozmiar buforu.</span><span class="sxs-lookup"><span data-stu-id="17a11-120">A positive <see cref="T:System.Int32" /> value greater than or equal to 0 that indicates the buffer size.</span></span></param>
        <summary><span data-ttu-id="17a11-121">Inicjuje nowe wystąpienie <see cref="T:System.IO.Pipes.PipeStream" /> klasy przy użyciu <see cref="T:System.IO.Pipes.PipeTransmissionMode" />określonego <see cref="T:System.IO.Pipes.PipeDirection" />rozmiaru buforu i.</span><span class="sxs-lookup"><span data-stu-id="17a11-121">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" />, <see cref="T:System.IO.Pipes.PipeTransmissionMode" />, and buffer size.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17a11-122"><paramref name="direction" />nie jest prawidłową <see cref="T:System.IO.Pipes.PipeDirection" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="17a11-122"><paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</span></span>  
  
<span data-ttu-id="17a11-123">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-123">-or-</span></span> 
 <span data-ttu-id="17a11-124"><paramref name="transmissionMode" />nie jest prawidłową <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="17a11-124"><paramref name="transmissionMode" /> is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.</span></span>  
  
<span data-ttu-id="17a11-125">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-125">-or-</span></span> 
 <span data-ttu-id="17a11-126"><paramref name="bufferSize" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="17a11-126"><paramref name="bufferSize" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="pipeStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="17a11-127">Bufor, do którego mają zostać odczytane dane.</span><span class="sxs-lookup"><span data-stu-id="17a11-127">The buffer to read data into.</span></span></param>
        <param name="offset"><span data-ttu-id="17a11-128">Przesunięcie bajtu w <paramref name="buffer" /> czasie, w którym ma zostać rozpoczęte odczytywanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-128">The byte offset in <paramref name="buffer" /> at which to begin reading.</span></span></param>
        <param name="count"><span data-ttu-id="17a11-129">Maksymalna liczba bajtów do odczytania.</span><span class="sxs-lookup"><span data-stu-id="17a11-129">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="17a11-130">Metoda wywoływana po zakończeniu asynchronicznej operacji odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-130">The method to call when the asynchronous read operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="17a11-131">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie odczytu z innych żądań.</span><span class="sxs-lookup"><span data-stu-id="17a11-131">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="17a11-132">Rozpoczęcie asynchronicznej operacji odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-132">Begins an asynchronous read operation.</span></span></summary>
        <returns><span data-ttu-id="17a11-133"><see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="17a11-133">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-134">Przekaż zwracany <xref:System.IAsyncResult> obiekt <xref:System.IO.Pipes.PipeStream.EndRead%2A> do metody, aby określić, ile bajtów zostało odczytanych i aby zwolnić zasoby systemu operacyjnego używane do odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-134">Pass the returned <xref:System.IAsyncResult> object to the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="17a11-135"><xref:System.IO.Pipes.PipeStream.EndRead%2A>musi być wywoływana jednokrotnie dla każdego <xref:System.IO.Pipes.PipeStream.BeginRead%2A>wywołania do.</span><span class="sxs-lookup"><span data-stu-id="17a11-135"><xref:System.IO.Pipes.PipeStream.EndRead%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span> <span data-ttu-id="17a11-136">Można to zrobić w tym samym kodzie, który został wywołany <xref:System.IO.Pipes.PipeStream.BeginRead%2A> lub w wywołaniu zwrotnym, który jest przesyłany do. <xref:System.IO.Pipes.PipeStream.BeginRead%2A></span><span class="sxs-lookup"><span data-stu-id="17a11-136">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginRead%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="17a11-137">Użyj właściwości <xref:System.IO.Pipes.PipeStream.CanRead%2A> , aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiekt obsługuje operacje odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-137">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="17a11-138">Jeśli potok jest zamknięty lub przeszedł nieprawidłowy argument do <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, odpowiednie wyjątki są wywoływane natychmiast.</span><span class="sxs-lookup"><span data-stu-id="17a11-138">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="17a11-139">Błędy występujące podczas asynchronicznego żądania odczytu są wykonywane w wątku puli wątków, który wykonuje żądanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-139">Errors that occur during an asynchronous read request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="17a11-140">Wyjątki są wywoływane, gdy kod wywołuje <xref:System.IO.Pipes.PipeStream.EndRead%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="17a11-140">The exceptions are raised when the code calls the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17a11-141"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-141"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17a11-142"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="17a11-142"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="17a11-143">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-143">-or-</span></span> 
 <span data-ttu-id="17a11-144"><paramref name="count" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="17a11-144"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17a11-145"><paramref name="count" />jest większa niż liczba bajtów dostępnych w <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-145"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-146">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-146">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-147">Potok nie obsługuje operacji odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-147">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-148">Potok jest odłączony, oczekiwanie na połączenie lub dojście nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-148">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-149">Potok jest przerwany lub Wystąpił inny błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-149">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="pipeStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="17a11-150">Bufor zawierający dane do zapisu w bieżącym strumieniu.</span><span class="sxs-lookup"><span data-stu-id="17a11-150">The buffer that contains the data to write to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="17a11-151">Przesunięcie bajtu (liczony od zera <paramref name="buffer" /> ), w którym rozpocznie się kopiowanie bajtów do bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-151">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="17a11-152">Maksymalna liczba bajtów do zapisania.</span><span class="sxs-lookup"><span data-stu-id="17a11-152">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="17a11-153">Metoda wywoływana po zakończeniu asynchronicznej operacji zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-153">The method to call when the asynchronous write operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="17a11-154">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie zapisu z innych żądań.</span><span class="sxs-lookup"><span data-stu-id="17a11-154">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="17a11-155">Rozpoczyna asynchroniczne operacje zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-155">Begins an asynchronous write operation.</span></span></summary>
        <returns><span data-ttu-id="17a11-156"><see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do asynchronicznej operacji zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-156">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-157"><xref:System.IO.Pipes.PipeStream.EndWrite%2A>musi być wywoływana jednokrotnie dla każdego <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>wywołania do.</span><span class="sxs-lookup"><span data-stu-id="17a11-157"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span> <span data-ttu-id="17a11-158">Można to zrobić w tym samym kodzie, który został wywołany <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> lub w wywołaniu zwrotnym, który jest przesyłany do. <xref:System.IO.Pipes.PipeStream.BeginWrite%2A></span><span class="sxs-lookup"><span data-stu-id="17a11-158">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="17a11-159">Użyj właściwości <xref:System.IO.Pipes.PipeStream.CanWrite%2A> , aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiekt obsługuje operacje zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-159">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="17a11-160">Jeśli potok jest zamknięty lub przeszedł nieprawidłowy argument do <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, odpowiednie wyjątki są wywoływane natychmiast.</span><span class="sxs-lookup"><span data-stu-id="17a11-160">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="17a11-161">Błędy występujące podczas asynchronicznego żądania zapisu odbywają się w wątku puli wątków, który wykonuje żądanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-161">Errors that occur during an asynchronous write request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="17a11-162">Wyjątki są wywoływane, gdy kod wywołuje <xref:System.IO.Pipes.PipeStream.EndWrite%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="17a11-162">The exceptions are raised when the code calls the  <xref:System.IO.Pipes.PipeStream.EndWrite%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17a11-163"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-163"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17a11-164"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="17a11-164"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="17a11-165">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-165">-or-</span></span> 
 <span data-ttu-id="17a11-166"><paramref name="count" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="17a11-166"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17a11-167"><paramref name="count" />jest większa niż liczba bajtów dostępnych w <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-167"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-168">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-168">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-169">Potok nie obsługuje operacji zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-169">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-170">Potok jest odłączony, oczekiwanie na połączenie lub dojście nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-170">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-171">Potok jest przerwany lub Wystąpił inny błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-171">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Pipes.PipeStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-172">Pobiera wartość wskazującą, czy bieżący strumień obsługuje operacje odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-172">Gets a value indicating whether the current stream supports read operations.</span></span></summary>
        <value><span data-ttu-id="17a11-173"><see langword="true" />Jeśli strumień obsługuje operacje odczytu; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="17a11-173"><see langword="true" /> if the stream supports read operations; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-174">Jeśli obiekt jest zamknięty, ta właściwość zwraca wartość `false`. <xref:System.IO.Pipes.PipeStream></span><span class="sxs-lookup"><span data-stu-id="17a11-174">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Pipes.PipeStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-175">Pobiera wartość wskazującą, czy bieżący strumień obsługuje operacje wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="17a11-175">Gets a value indicating whether the current stream supports seek operations.</span></span></summary>
        <value><span data-ttu-id="17a11-176"><see langword="false" />we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="17a11-176"><see langword="false" /> in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-177">Jeśli obiekt jest zamknięty, ta właściwość zwraca wartość `false`. <xref:System.IO.Pipes.PipeStream></span><span class="sxs-lookup"><span data-stu-id="17a11-177">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Pipes.PipeStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-178">Pobiera wartość wskazującą, czy bieżący strumień obsługuje operacje zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-178">Gets a value indicating whether the current stream supports write operations.</span></span></summary>
        <value><span data-ttu-id="17a11-179"><see langword="true" />Jeśli strumień obsługuje operacje zapisu; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="17a11-179"><see langword="true" /> if the stream supports write operations; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-180">Jeśli obiekt jest zamknięty, ta właściwość zwraca wartość `false`. <xref:System.IO.Pipes.PipeStream></span><span class="sxs-lookup"><span data-stu-id="17a11-180">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckPipePropertyOperations">
      <MemberSignature Language="C#" Value="protected internal virtual void CheckPipePropertyOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CheckPipePropertyOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckPipePropertyOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CheckPipePropertyOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CheckPipePropertyOperations();" />
      <MemberSignature Language="F#" Value="abstract member CheckPipePropertyOperations : unit -&gt; unit&#xA;override this.CheckPipePropertyOperations : unit -&gt; unit" Usage="pipeStream.CheckPipePropertyOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17a11-181">Sprawdza, czy potok jest w prawidłowym stanie do pobierania lub ustawiania właściwości.</span><span class="sxs-lookup"><span data-stu-id="17a11-181">Verifies that the pipe is in a proper state for getting or setting properties.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckReadOperations">
      <MemberSignature Language="C#" Value="protected internal void CheckReadOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckReadOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckReadOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CheckReadOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CheckReadOperations();" />
      <MemberSignature Language="F#" Value="member this.CheckReadOperations : unit -&gt; unit" Usage="pipeStream.CheckReadOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17a11-182">Sprawdza, czy potok jest w stanie połączonym dla operacji odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-182">Verifies that the pipe is in a connected state for read operations.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckWriteOperations">
      <MemberSignature Language="C#" Value="protected internal void CheckWriteOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckWriteOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckWriteOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CheckWriteOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CheckWriteOperations();" />
      <MemberSignature Language="F#" Value="member this.CheckWriteOperations : unit -&gt; unit" Usage="pipeStream.CheckWriteOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17a11-183">Sprawdza, czy potok jest w stanie połączonym dla operacji zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-183">Verifies that the pipe is in a connected state for write operations.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="pipeStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="17a11-184"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="17a11-184"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="17a11-185">Zwalnia niezarządzane zasoby używane przez <see cref="T:System.IO.Pipes.PipeStream" /> klasę i opcjonalnie zwalnia zarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="17a11-185">Releases the unmanaged resources used by the <see cref="T:System.IO.Pipes.PipeStream" /> class and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-186">Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A> i metodę.</span><span class="sxs-lookup"><span data-stu-id="17a11-186">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="17a11-187"><xref:System.ComponentModel.Component.Dispose%2A>wywołuje metodę chronioną <xref:System.IO.Pipes.PipeStream.Dispose%2A> `disposing` z parametrem ustawionym `true`na.</span><span class="sxs-lookup"><span data-stu-id="17a11-187"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.Pipes.PipeStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="17a11-188"><xref:System.Object.Finalize%2A>wywołuje <xref:System.IO.Pipes.PipeStream.Dispose%2A> `false`z `disposing` ustawionym na.</span><span class="sxs-lookup"><span data-stu-id="17a11-188"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.Pipes.PipeStream.Dispose%2A> with `disposing` set to `false`.</span></span> <span data-ttu-id="17a11-189">Gdy parametr likwidacji ma `true`wartość, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, <xref:System.IO.Pipes.PipeStream> do których odwołuje się ten obiekt.</span><span class="sxs-lookup"><span data-stu-id="17a11-189">When the disposing parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.Pipes.PipeStream> object references.</span></span> <span data-ttu-id="17a11-190">Ta metoda wywołuje <xref:System.IO.Pipes.PipeStream.Dispose%2A> metodę każdego przywoływanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="17a11-190">This method invokes the <xref:System.IO.Pipes.PipeStream.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="17a11-191">W klasach pochodnych Umieść całą <see cref="T:System.IO.Stream" /> logikę oczyszczania <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> w metodzie.</span><span class="sxs-lookup"><span data-stu-id="17a11-191">In derived classes, put all <see cref="T:System.IO.Stream" /> cleanup logic in the <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> method.</span></span>  
  
 <span data-ttu-id="17a11-192"><see cref="M:System.ComponentModel.Component.Dispose" />może być wywoływana wiele razy przez inne obiekty.</span><span class="sxs-lookup"><span data-stu-id="17a11-192"><see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="17a11-193">Podczas zastępowania <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej usunięte <see cref="M:System.ComponentModel.Component.Dispose" />w ramach wcześniejszego wywołania do.</span><span class="sxs-lookup"><span data-stu-id="17a11-193">When overriding <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="17a11-194">Aby uzyskać więcej informacji na temat sposobu <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="17a11-194">For more information about how to implement <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="17a11-195">Aby uzyskać więcej informacji <see cref="M:System.ComponentModel.Component.Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="17a11-195">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="pipeStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="17a11-196">Odwołanie do oczekującego żądania asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="17a11-196">The reference to the pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="17a11-197">Zamyka oczekujące asynchroniczne żądanie odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-197">Ends a pending asynchronous read request.</span></span></summary>
        <returns><span data-ttu-id="17a11-198">Liczba odczytanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="17a11-198">The number of bytes that were read.</span></span> <span data-ttu-id="17a11-199">Wartość zwracana przez 0 wskazuje koniec strumienia (potok został zamknięty).</span><span class="sxs-lookup"><span data-stu-id="17a11-199">A return value of 0 indicates the end of the stream (the pipe has been closed).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-200">Ta metoda zwraca liczbę bajtów odczytywanych do tablicy bajtów określonej przez wcześniejszy wywołania do <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="17a11-200">This method returns the number of bytes read into the byte array specified by the earlier call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="17a11-201">Przekaż zwracany <xref:System.IAsyncResult> obiekt <xref:System.IO.Pipes.PipeStream.EndRead%2A> do metody, aby określić, ile bajtów zostało odczytanych i aby zwolnić zasoby systemu operacyjnego używane do odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-201">Pass the returned <xref:System.IAsyncResult> object to the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="17a11-202"><xref:System.IO.Pipes.PipeStream.EndRead%2A>musi być wywoływana jednokrotnie dla każdego <xref:System.IO.Pipes.PipeStream.BeginRead%2A>wywołania do.</span><span class="sxs-lookup"><span data-stu-id="17a11-202"><xref:System.IO.Pipes.PipeStream.EndRead%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span> <span data-ttu-id="17a11-203">Można to zrobić w tym samym kodzie, który został wywołany <xref:System.IO.Pipes.PipeStream.BeginRead%2A> lub w wywołaniu zwrotnym, który jest przesyłany do. <xref:System.IO.Pipes.PipeStream.BeginRead%2A></span><span class="sxs-lookup"><span data-stu-id="17a11-203">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginRead%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="17a11-204">Użyj właściwości <xref:System.IO.Pipes.PipeStream.CanRead%2A> , aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiekt obsługuje operacje odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-204">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="17a11-205">Jeśli potok jest zamknięty lub przeszedł nieprawidłowy argument do <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, odpowiednie wyjątki są wywoływane natychmiast.</span><span class="sxs-lookup"><span data-stu-id="17a11-205">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="17a11-206">Błędy występujące podczas asynchronicznego żądania odczytu są wykonywane w wątku puli wątków, który wykonuje żądanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-206">Errors that occur during an asynchronous read request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="17a11-207">Wyjątki są wywoływane, gdy kod wywołuje <xref:System.IO.Pipes.PipeStream.EndRead%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="17a11-207">The exceptions are raised when the code calls the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17a11-208"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-208"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17a11-209"><paramref name="asyncResult" />nie pochodzi z <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> metody w bieżącym strumieniu.</span><span class="sxs-lookup"><span data-stu-id="17a11-209"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-210">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</span><span class="sxs-lookup"><span data-stu-id="17a11-210">The stream is closed or an internal error has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="pipeStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="17a11-211">Odwołanie do oczekującego żądania asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="17a11-211">The reference to the pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="17a11-212">Zamyka oczekujące asynchroniczne żądanie zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-212">Ends a pending asynchronous write request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-213"><xref:System.IO.Pipes.PipeStream.EndWrite%2A>musi być wywoływana jednokrotnie dla każdego <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>wywołania do.</span><span class="sxs-lookup"><span data-stu-id="17a11-213"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span> <span data-ttu-id="17a11-214">Można to zrobić w tym samym kodzie, który został wywołany <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> lub w wywołaniu zwrotnym, który jest przesyłany do. <xref:System.IO.Pipes.PipeStream.BeginWrite%2A></span><span class="sxs-lookup"><span data-stu-id="17a11-214">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="17a11-215">Użyj właściwości <xref:System.IO.Pipes.PipeStream.CanWrite%2A> , aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiekt obsługuje operacje zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-215">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="17a11-216">Jeśli potok jest zamknięty lub przeszedł nieprawidłowy argument do <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, odpowiednie wyjątki są wywoływane natychmiast.</span><span class="sxs-lookup"><span data-stu-id="17a11-216">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="17a11-217">Błędy występujące podczas asynchronicznego żądania zapisu odbywają się w wątku puli wątków, który wykonuje żądanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-217">Errors that occur during an asynchronous write request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="17a11-218">Wyjątki są wywoływane, gdy kod wywołuje <xref:System.IO.Pipes.PipeStream.EndWrite%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="17a11-218">The exceptions are raised when the code the calls <xref:System.IO.Pipes.PipeStream.EndWrite%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17a11-219"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-219"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17a11-220"><paramref name="asyncResult" />nie pochodzi z <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> metody w bieżącym strumieniu.</span><span class="sxs-lookup"><span data-stu-id="17a11-220"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-221">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</span><span class="sxs-lookup"><span data-stu-id="17a11-221">The stream is closed or an internal error has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="pipeStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17a11-222">Czyści bufor dla bieżącego strumienia i powoduje, że wszystkie buforowane dane są zapisywane na podstawowym urządzeniu.</span><span class="sxs-lookup"><span data-stu-id="17a11-222">Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-223">Metoda nie jest obsługiwana <xref:System.IO.Pipes.PipeStream> w klasie i nie robi nic, gdy jest wywoływana. <xref:System.IO.Pipes.PipeStream.Flush%2A></span><span class="sxs-lookup"><span data-stu-id="17a11-223">The <xref:System.IO.Pipes.PipeStream.Flush%2A> method is not supported in the <xref:System.IO.Pipes.PipeStream> class and does nothing when it is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-224">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-224">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-225">Potok nie obsługuje operacji zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-225">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-226">Potok jest przerwany lub Wystąpił inny błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-226">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.Pipes.PipeSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Pipes.PipeSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As PipeSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Pipes::PipeSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.IO.Pipes.PipeSecurity" Usage="pipeStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17a11-227">Pobiera obiekt, który hermetyzuje wpisy listy kontroli dostępu (ACL) dla potoku opisanego przez bieżący <see cref="T:System.IO.Pipes.PipeStream" /> obiekt. <see cref="T:System.IO.Pipes.PipeSecurity" /></span><span class="sxs-lookup"><span data-stu-id="17a11-227">Gets a <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <returns><span data-ttu-id="17a11-228">Obiekt, który hermetyzuje wpisy listy kontroli dostępu (ACL) dla potoku opisanego przez bieżący <see cref="T:System.IO.Pipes.PipeStream" /> obiekt. <see cref="T:System.IO.Pipes.PipeSecurity" /></span><span class="sxs-lookup"><span data-stu-id="17a11-228">A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-229">Lista kontroli dostępu (ACL) opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do wykonywania określonych działań w określonym pliku.</span><span class="sxs-lookup"><span data-stu-id="17a11-229">An access control list (ACL) describes individuals and/or groups that have, or do not have, rights to perform specific actions on a specified file.</span></span> <span data-ttu-id="17a11-230">Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.</span><span class="sxs-lookup"><span data-stu-id="17a11-230">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-231">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-231">The pipe is closed.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17a11-232">Wywołanie podstawowe do ustawiania informacji o zabezpieczeniach nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="17a11-232">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-233">Wywołanie podstawowe do ustawiania informacji o zabezpieczeniach nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="17a11-233">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-234">Wywołanie podstawowe do ustawiania informacji o zabezpieczeniach nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="17a11-234">The underlying call to set security information failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="InBufferSize">
      <MemberSignature Language="C#" Value="public virtual int InBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.InBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property InBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int InBufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InBufferSize : int" Usage="System.IO.Pipes.PipeStream.InBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-235">Pobiera rozmiar (w bajtach) bufora ruchu przychodzącego dla potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-235">Gets the size, in bytes, of the inbound buffer for a pipe.</span></span></summary>
        <value><span data-ttu-id="17a11-236">Wartość całkowita reprezentująca rozmiar buforu przychodzącego w bajtach.</span><span class="sxs-lookup"><span data-stu-id="17a11-236">An integer value that represents the inbound buffer size, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-237">Jeśli <xref:System.IO.Pipes.PipeStream.InBufferSize%2A> wartość to 0, rozmiar buforu jest przypisywany zgodnie z wymaganiami.</span><span class="sxs-lookup"><span data-stu-id="17a11-237">If <xref:System.IO.Pipes.PipeStream.InBufferSize%2A> is 0, the buffer size is allocated as needed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-238">Strumień nie jest czytelny.</span><span class="sxs-lookup"><span data-stu-id="17a11-238">The stream is unreadable.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-239">Potok oczekuje na nawiązanie połączenia.</span><span class="sxs-lookup"><span data-stu-id="17a11-239">The pipe is waiting to connect.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-240">Potok jest przerwany lub Wystąpił inny błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-240">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeHandle">
      <MemberSignature Language="C#" Value="protected void InitializeHandle (Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeHandle(class Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeHandle (handle As SafePipeHandle, isExposed As Boolean, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeHandle(Microsoft::Win32::SafeHandles::SafePipeHandle ^ handle, bool isExposed, bool isAsync);" />
      <MemberSignature Language="F#" Value="member this.InitializeHandle : Microsoft.Win32.SafeHandles.SafePipeHandle * bool * bool -&gt; unit" Usage="pipeStream.InitializeHandle (handle, isExposed, isAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="isExposed" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="17a11-241"><see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> Obiekt potoku do zainicjowania.</span><span class="sxs-lookup"><span data-stu-id="17a11-241">The <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object of the pipe to initialize.</span></span></param>
        <param name="isExposed"><span data-ttu-id="17a11-242"><see langword="true" />Aby uwidocznić dojście; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="17a11-242"><see langword="true" /> to expose the handle; otherwise, <see langword="false" />.</span></span></param>
        <param name="isAsync"><span data-ttu-id="17a11-243"><see langword="true" />, aby wskazać, że dojście zostało otwarte asynchronicznie; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="17a11-243"><see langword="true" /> to indicate that the handle was opened asynchronously; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="17a11-244">Inicjuje obiekt z określonego <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> obiektu. <see cref="T:System.IO.Pipes.PipeStream" /></span><span class="sxs-lookup"><span data-stu-id="17a11-244">Initializes a <see cref="T:System.IO.Pipes.PipeStream" /> object from the specified <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-245">Jeśli potok jest w stanie połączonym, ta metoda ustawia <xref:System.IO.Pipes.PipeStream.IsConnected%2A> również właściwość na. `true`</span><span class="sxs-lookup"><span data-stu-id="17a11-245">If the pipe is in a connected state, this method also sets the <xref:System.IO.Pipes.PipeStream.IsConnected%2A> property to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-246">Dojście nie może być powiązane z potokiem.</span><span class="sxs-lookup"><span data-stu-id="17a11-246">A handle cannot be bound to the pipe.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.Pipes.PipeStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-247">Pobiera wartość wskazującą, czy <see cref="T:System.IO.Pipes.PipeStream" /> obiekt został otwarty asynchronicznie czy synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="17a11-247">Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously or synchronously.</span></span></summary>
        <value><span data-ttu-id="17a11-248"><see langword="true" />Jeśli obiekt został otwarty asynchronicznie; w przeciwnym <see langword="false" />razie,. <see cref="T:System.IO.Pipes.PipeStream" /></span><span class="sxs-lookup"><span data-stu-id="17a11-248"><see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-249">Ta właściwość umożliwia prawidłowe używanie właściwości w <xref:System.IO.Pipes.PipeStream.SafePipeHandle%2A> kodzie.</span><span class="sxs-lookup"><span data-stu-id="17a11-249">This property enables your code to use the <xref:System.IO.Pipes.PipeStream.SafePipeHandle%2A> property correctly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConnected">
      <MemberSignature Language="C#" Value="public bool IsConnected { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConnected" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Property IsConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:  property bool IsConnected {  public:&#xA;bool get(); protected:&#xA; void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsConnected : bool with get, set" Usage="System.IO.Pipes.PipeStream.IsConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-250">Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.IO.Pipes.PipeStream" /> obiekt jest połączony.</span><span class="sxs-lookup"><span data-stu-id="17a11-250">Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object is connected.</span></span></summary>
        <value><span data-ttu-id="17a11-251"><see langword="true" />Jeśli obiekt jest połączony; <see langword="false" />w przeciwnym razie. <see cref="T:System.IO.Pipes.PipeStream" /></span><span class="sxs-lookup"><span data-stu-id="17a11-251"><see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object is connected; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-252">Właściwość zwraca `true` tylko wtedy, <xref:System.IO.Pipes.PipeStream> gdy obiekt jest połączony. <xref:System.IO.Pipes.PipeStream.IsConnected%2A></span><span class="sxs-lookup"><span data-stu-id="17a11-252">The <xref:System.IO.Pipes.PipeStream.IsConnected%2A> property returns `true` only if the <xref:System.IO.Pipes.PipeStream> object is connected.</span></span> <span data-ttu-id="17a11-253">Jeśli ta właściwość zwraca `false`, potok może oczekiwać na nawiązanie połączenia lub może zostać odłączony, zamknięty lub przerwany.</span><span class="sxs-lookup"><span data-stu-id="17a11-253">If this property returns `false`, the pipe may be waiting to connect, or may be disconnected, closed, or broken.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHandleExposed">
      <MemberSignature Language="C#" Value="protected bool IsHandleExposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleExposed" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsHandleExposed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsHandleExposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsHandleExposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHandleExposed : bool" Usage="System.IO.Pipes.PipeStream.IsHandleExposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-254">Pobiera wartość wskazującą, czy dojście do <see cref="T:System.IO.Pipes.PipeStream" /> obiektu jest uwidocznione.</span><span class="sxs-lookup"><span data-stu-id="17a11-254">Gets a value indicating whether a handle to a <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed.</span></span></summary>
        <value><span data-ttu-id="17a11-255"><see langword="true" />Jeśli dojście do <see cref="T:System.IO.Pipes.PipeStream" /> obiektu jest widoczne; w przeciwnym razie <see langword="false" />,.</span><span class="sxs-lookup"><span data-stu-id="17a11-255"><see langword="true" /> if a handle to the <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-256">Wartość tej właściwości jest ustawiana podczas uzyskiwania dojścia do potoku, który jest hermetyzowany przez bieżący <xref:System.IO.Pipes.PipeStream> obiekt.</span><span class="sxs-lookup"><span data-stu-id="17a11-256">The value of this property is set when obtaining a handle to the pipe that is encapsulated by the current <xref:System.IO.Pipes.PipeStream> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMessageComplete">
      <MemberSignature Language="C#" Value="public bool IsMessageComplete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMessageComplete" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsMessageComplete" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMessageComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMessageComplete { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMessageComplete : bool" Usage="System.IO.Pipes.PipeStream.IsMessageComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-257">Pobiera wartość wskazującą, czy w komunikacie zwróconym z ostatniej operacji odczytu jest więcej danych.</span><span class="sxs-lookup"><span data-stu-id="17a11-257">Gets a value indicating whether there is more data in the message returned from the most recent read operation.</span></span></summary>
        <value><span data-ttu-id="17a11-258"><see langword="true" />Jeśli nie ma więcej znaków do odczytania w komunikacie; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="17a11-258"><see langword="true" /> if there are no more characters to read in the message; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-259">Ta <xref:System.IO.Pipes.PipeStream.ReadMode%2A> właściwość jest istotna, jeśli właściwość potoku została ustawiona na <xref:System.IO.Pipes.PipeTransmissionMode.Message> podstawie najnowszego wywołania do <xref:System.IO.Pipes.PipeStream.Read%2A> lub <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="17a11-259">This property is relevant if the pipe's <xref:System.IO.Pipes.PipeStream.ReadMode%2A> property was set to <xref:System.IO.Pipes.PipeTransmissionMode.Message> by the most recent call to <xref:System.IO.Pipes.PipeStream.Read%2A> or <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-260">Potok nie jest połączony.</span><span class="sxs-lookup"><span data-stu-id="17a11-260">The pipe is not connected.</span></span>  
  
<span data-ttu-id="17a11-261">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-261">-or-</span></span> 
<span data-ttu-id="17a11-262">Dojście potoku nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-262">The pipe handle has not been set.</span></span>  
  
<span data-ttu-id="17a11-263">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-263">-or-</span></span> 
<span data-ttu-id="17a11-264">Wartość <see cref="P:System.IO.Pipes.PipeStream.ReadMode" /> właściwości potoku nie <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />jest.</span><span class="sxs-lookup"><span data-stu-id="17a11-264">The pipe's <see cref="P:System.IO.Pipes.PipeStream.ReadMode" /> property value is not <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-265">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-265">The pipe is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Pipes.PipeStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-266">Pobiera długość strumienia w bajtach.</span><span class="sxs-lookup"><span data-stu-id="17a11-266">Gets the length of a stream, in bytes.</span></span></summary>
        <value><span data-ttu-id="17a11-267">0 we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="17a11-267">0 in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-268"><xref:System.IO.Pipes.PipeStream> Klasa nie<xref:System.IO.Pipes.PipeStream.Length%2A> obsługuje właściwości.</span><span class="sxs-lookup"><span data-stu-id="17a11-268">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.Length%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-269">Zawsze generowany.</span><span class="sxs-lookup"><span data-stu-id="17a11-269">Always thrown.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OutBufferSize">
      <MemberSignature Language="C#" Value="public virtual int OutBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.OutBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OutBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int OutBufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutBufferSize : int" Usage="System.IO.Pipes.PipeStream.OutBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-270">Pobiera rozmiar (w bajtach) bufora wychodzącego dla potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-270">Gets the size, in bytes, of the outbound buffer for a pipe.</span></span></summary>
        <value><span data-ttu-id="17a11-271">Rozmiar buforu wychodzącego w bajtach.</span><span class="sxs-lookup"><span data-stu-id="17a11-271">The outbound buffer size, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-272">Jeśli <xref:System.IO.Pipes.PipeStream.OutBufferSize%2A> wartość to 0, rozmiar buforu jest przypisywany zgodnie z wymaganiami.</span><span class="sxs-lookup"><span data-stu-id="17a11-272">If <xref:System.IO.Pipes.PipeStream.OutBufferSize%2A> is 0, the buffer size is allocated as needed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-273">Strumień jest niezapisywalny.</span><span class="sxs-lookup"><span data-stu-id="17a11-273">The stream is unwriteable.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-274">Potok oczekuje na nawiązanie połączenia.</span><span class="sxs-lookup"><span data-stu-id="17a11-274">The pipe is waiting to connect.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-275">Potok jest przerwany lub Wystąpił inny błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-275">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Pipes.PipeStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-276">Pobiera lub ustawia bieżącą pozycję bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-276">Gets or sets the current position of the current stream.</span></span></summary>
        <value><span data-ttu-id="17a11-277">0 we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="17a11-277">0 in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-278"><xref:System.IO.Pipes.PipeStream> Klasa nie<xref:System.IO.Pipes.PipeStream.Position%2A> obsługuje właściwości.</span><span class="sxs-lookup"><span data-stu-id="17a11-278">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.Position%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-279">Zawsze generowany.</span><span class="sxs-lookup"><span data-stu-id="17a11-279">Always thrown.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="pipeStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="17a11-280">Region pamięci.</span><span class="sxs-lookup"><span data-stu-id="17a11-280">A region of memory.</span></span> <span data-ttu-id="17a11-281">Gdy ta metoda zwraca, zawartość tego regionu jest zastępowana przez Bajty odczytane z bieżącego źródła.</span><span class="sxs-lookup"><span data-stu-id="17a11-281">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="17a11-282">Odczytuje sekwencję bajtów z bieżącego strumienia, zapisuje je w tablicy bajtów i przesuwa pozycję w strumieniu o liczbę odczytanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="17a11-282">Reads a sequence of bytes from the current stream, writes them to a byte array, and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="17a11-283">Całkowita liczba bajtów odczytanych do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-283">The total number of bytes read into the <paramref name="buffer" />.</span></span> <span data-ttu-id="17a11-284">Wartość ta może być mniejsza niż liczba bajtów przydzielono w <paramref name="buffer" /> przypadku, gdy liczba bajtów nie jest obecnie dostępna lub zero (0), jeśli osiągnięto koniec strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-284">This can be less than the number of bytes allocated in <paramref name="buffer" /> if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="17a11-285">Użyj właściwości <xref:System.IO.Pipes.PipeStream.CanRead%2A> , aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiekt obsługuje operacje odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-285">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>

<span data-ttu-id="17a11-286">Użyj metody <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> , aby odczytywać asynchronicznie z bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-286">Use the <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>

<span data-ttu-id="17a11-287">Ta metoda odczytuje maksymalnie `buffer.Length` bajtów z bieżącego strumienia i zapisuje je w. `buffer`</span><span class="sxs-lookup"><span data-stu-id="17a11-287">This method reads a maximum of `buffer.Length` bytes from the current stream and stores them in `buffer`.</span></span> <span data-ttu-id="17a11-288">Bieżąca pozycja w strumieniu jest zaawansowana przez liczbę odczytanych bajtów; Jeśli jednak wystąpi wyjątek, bieżąca pozycja w strumieniu pozostaje niezmieniona.</span><span class="sxs-lookup"><span data-stu-id="17a11-288">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span>

<span data-ttu-id="17a11-289">Ta metoda zostanie Zablokowani do momentu odczytania co najmniej jednego bajtu danych, w przypadku, gdy żadne dane nie są dostępne.</span><span class="sxs-lookup"><span data-stu-id="17a11-289">This method will block until at least one byte of data can be read, in the event that no data is available.</span></span>

<span data-ttu-id="17a11-290">Ta metoda zwraca wartość 0 tylko wtedy, gdy nie ma więcej danych w strumieniu i nie jest więcej niż oczekiwano (na przykład zamknięte gniazdo lub koniec pliku).</span><span class="sxs-lookup"><span data-stu-id="17a11-290">This method returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span>

<span data-ttu-id="17a11-291">Ta metoda jest bezpłatna, aby zwrócić mniejszą liczbę bajtów niż żądana, nawet jeśli nie osiągnięto końca strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-291">This method is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>

<span data-ttu-id="17a11-292">Służy `BinaryReader` do odczytywania typów danych pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="17a11-292">Use `BinaryReader` for reading primitive data types.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17a11-293">Liczba odczytanych bajtów była dłuższa niż długość buforu.</span><span class="sxs-lookup"><span data-stu-id="17a11-293">The number of bytes read was longer than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-294">Strumień nie obsługuje odczytywania.</span><span class="sxs-lookup"><span data-stu-id="17a11-294">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-295">Nie można uzyskać dostępu do zamkniętego potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-295">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-296">Potok nie został jeszcze połączony.</span><span class="sxs-lookup"><span data-stu-id="17a11-296">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="17a11-297">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-297">-or-</span></span>

<span data-ttu-id="17a11-298">Potok jest w stanie odłączonym.</span><span class="sxs-lookup"><span data-stu-id="17a11-298">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="17a11-299">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-299">-or-</span></span>

<span data-ttu-id="17a11-300">Dojście potoku nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-300">The pipe handle has not been set.</span></span>  <span data-ttu-id="17a11-301">(Czy zostało <see cref="T:System.IO.Pipes.PipeStream" /> wykonane wywołanie <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />implementacji?</span><span class="sxs-lookup"><span data-stu-id="17a11-301">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([in]unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="pipeStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="17a11-302">Gdy ta metoda zwraca, zawiera określoną tablicę bajtową z wartościami między <paramref name="offset" /> i (<paramref name="offset" />  +  <paramref name="count" /> -1) zastąpione przez Bajty odczytane z bieżącego źródła.</span><span class="sxs-lookup"><span data-stu-id="17a11-302">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source.</span></span></param>
        <param name="offset"><span data-ttu-id="17a11-303">Przesunięcie bajtu w <paramref name="buffer" /> tablicy, w której zostaną umieszczone odczytane bajty.</span><span class="sxs-lookup"><span data-stu-id="17a11-303">The byte offset in the <paramref name="buffer" /> array at which the bytes that are read will be placed.</span></span></param>
        <param name="count"><span data-ttu-id="17a11-304">Maksymalna liczba bajtów do odczytania.</span><span class="sxs-lookup"><span data-stu-id="17a11-304">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="17a11-305">Odczytuje blok bajtów ze strumienia i zapisuje dane w określonym buforze, rozpoczynając od określonego położenia o określonej długości.</span><span class="sxs-lookup"><span data-stu-id="17a11-305">Reads a block of bytes from a stream and writes the data to a specified buffer starting at a specified position for a specified length.</span></span></summary>
        <returns><span data-ttu-id="17a11-306">Całkowita liczba bajtów, do <paramref name="buffer" />których odczytano.</span><span class="sxs-lookup"><span data-stu-id="17a11-306">The total number of bytes that are read into <paramref name="buffer" />.</span></span> <span data-ttu-id="17a11-307">Może to być mniejsze niż liczba żądanych bajtów, jeśli liczba bajtów nie jest obecnie dostępna lub wartość 0, jeśli osiągnięto koniec strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-307">This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-308">Użyj właściwości <xref:System.IO.Pipes.PipeStream.CanRead%2A> , aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiekt obsługuje operacje odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-308">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="17a11-309">Wywoływanie bloków `count`metodydo odczytu bajtów lub osiągnięto koniec strumienia. <xref:System.IO.Pipes.PipeStream.Read%2A></span><span class="sxs-lookup"><span data-stu-id="17a11-309">Calling the <xref:System.IO.Pipes.PipeStream.Read%2A> method blocks until `count` bytes are read or the end of the stream is reached.</span></span> <span data-ttu-id="17a11-310">W przypadku asynchronicznych operacji odczytu <xref:System.IO.Pipes.PipeStream.BeginRead%2A> zobacz <xref:System.IO.Pipes.PipeStream.EndRead%2A>i.</span><span class="sxs-lookup"><span data-stu-id="17a11-310">For asynchronous read operations, see <xref:System.IO.Pipes.PipeStream.BeginRead%2A> and <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17a11-311">W poniższym przykładzie jest tworzony klient z potokiem anonimowym i serwer potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-311">The following example creates an anonymous pipe client and pipe server.</span></span> <span data-ttu-id="17a11-312">Serwer potoku używa metody <xref:System.IO.Pipes.PipeStream.Read%2A> , aby odczytać serię bajtów z klienta potoku jako kod weryfikacyjny.</span><span class="sxs-lookup"><span data-stu-id="17a11-312">The pipe server uses the <xref:System.IO.Pipes.PipeStream.Read%2A> method to read a series of bytes from the pipe client as a validation code.</span></span> <span data-ttu-id="17a11-313">Zarówno klient potoku, jak i serwer potoku są częścią tego samego przykładu.</span><span class="sxs-lookup"><span data-stu-id="17a11-313">Both the pipe client and the pipe server are part of the same example.</span></span> <span data-ttu-id="17a11-314">Częścią serwera tego przykładu jest tworzenie procesu klienta i przekazanie go do dojścia potoku anonimowego jako argumentu.</span><span class="sxs-lookup"><span data-stu-id="17a11-314">The server portion of the example creates a client process and passes it an anonymous pipe handle as an argument.</span></span>  
  
 [!code-cpp[System.IO.Pipes.PipeStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.io.pipes.pipestream/cpp/sample.cpp#1)]
 [!code-csharp[System.IO.Pipes.PipeStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.pipes.pipestream/cs/sample.cs#1)]
 [!code-vb[System.IO.Pipes.PipeStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.pipes.pipestream/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17a11-315"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-315"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17a11-316"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="17a11-316"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="17a11-317">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-317">-or-</span></span> 
 <span data-ttu-id="17a11-318"><paramref name="count" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="17a11-318"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17a11-319"><paramref name="count" />jest większa niż liczba bajtów dostępnych w <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-319"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-320">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-320">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-321">Potok nie obsługuje operacji odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-321">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-322">Potok jest odłączony, oczekiwanie na połączenie lub dojście nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-322">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-323">Wystąpił błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-323">Any I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="pipeStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="17a11-324">Region pamięci, w którym mają zostać zapisane dane.</span><span class="sxs-lookup"><span data-stu-id="17a11-324">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="17a11-325">Token do monitorowania żądań anulowania.</span><span class="sxs-lookup"><span data-stu-id="17a11-325">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="17a11-326">Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-326">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="17a11-327">Asynchronicznie odczytuje sekwencję bajtów z bieżącego strumienia, zapisuje je w zakresie pamięci bajtowej, przesuwa pozycję w strumieniu o liczbę odczytanych bajtów i monitoruje żądania anulowania.</span><span class="sxs-lookup"><span data-stu-id="17a11-327">Asynchronously reads a sequence of bytes from the current stream, writes them to a byte memory range, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="17a11-328">Zadanie, które reprezentuje asynchroniczną operację odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-328">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="17a11-329">Wartość jego <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> właściwości zawiera łączną liczbę bajtów odczytywanych w buforze.</span><span class="sxs-lookup"><span data-stu-id="17a11-329">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="17a11-330">Wartość wynikowa może być mniejsza niż liczba bajtów przydzieloną w buforze, jeśli liczba bajtów nie jest obecnie dostępna lub jeśli osiągnięto koniec strumienia, może być równy 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="17a11-330">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="17a11-331"><xref:System.IO.Pipes.PipeStream.ReadAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego.</span><span class="sxs-lookup"><span data-stu-id="17a11-331">The <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="17a11-332">Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać.</span><span class="sxs-lookup"><span data-stu-id="17a11-332">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="17a11-333">Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.</span><span class="sxs-lookup"><span data-stu-id="17a11-333">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  

<span data-ttu-id="17a11-334"><xref:System.IO.Pipes.PipeStream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-334">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  

<span data-ttu-id="17a11-335">Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> wartość <xref:System.Threading.Tasks.Task.Status> właściwości.</span><span class="sxs-lookup"><span data-stu-id="17a11-335">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status> property.</span></span>  

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-336">Strumień nie obsługuje odczytywania.</span><span class="sxs-lookup"><span data-stu-id="17a11-336">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-337">Nie można uzyskać dostępu do zamkniętego potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-337">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-338">Potok nie został jeszcze połączony.</span><span class="sxs-lookup"><span data-stu-id="17a11-338">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="17a11-339">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-339">-or-</span></span>

<span data-ttu-id="17a11-340">Potok jest w stanie odłączonym.</span><span class="sxs-lookup"><span data-stu-id="17a11-340">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="17a11-341">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-341">-or-</span></span>

<span data-ttu-id="17a11-342">Dojście potoku nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-342">The pipe handle has not been set.</span></span>  <span data-ttu-id="17a11-343">(Czy zostało <see cref="T:System.IO.Pipes.PipeStream" /> wykonane wywołanie <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />implementacji?</span><span class="sxs-lookup"><span data-stu-id="17a11-343">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="pipeStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="17a11-344">Bufor, w którym mają zostać zapisane dane.</span><span class="sxs-lookup"><span data-stu-id="17a11-344">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="17a11-345">Przesunięcie bajtu, <paramref name="buffer" /> w którym rozpocznie się zapisywanie danych ze strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-345">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="17a11-346">Maksymalna liczba bajtów do odczytania.</span><span class="sxs-lookup"><span data-stu-id="17a11-346">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="17a11-347">Token do monitorowania żądań anulowania.</span><span class="sxs-lookup"><span data-stu-id="17a11-347">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="17a11-348">Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-348">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="17a11-349">Asynchronicznie odczytuje sekwencję bajtów z bieżącego strumienia do tablicy bajtów, zaczynając od określonej pozycji dla określonej liczby bajtów, przesuwa pozycję w strumieniu o liczbę odczytanych bajtów i monitoruje żądania anulowania.</span><span class="sxs-lookup"><span data-stu-id="17a11-349">Asynchronously reads a sequence of bytes from the current stream to a byte array starting at a specified position for a specified number of bytes, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="17a11-350">Zadanie, które reprezentuje asynchroniczną operację odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-350">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="17a11-351">Wartość jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> właściwości zawiera łączną liczbę bajtów odczytywanych w buforze.</span><span class="sxs-lookup"><span data-stu-id="17a11-351">The value of its <see cref="P:System.Threading.Tasks.Task`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="17a11-352">Wartość wynikowa może być mniejsza niż liczba żądanych bajtów, jeśli liczba aktualnie dostępnych bajtów jest mniejsza niż żądana liczba, lub może być równa 0 (zero), jeśli osiągnięto koniec strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-352">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown">
          

## Remarks

<span data-ttu-id="17a11-353"><xref:System.IO.Pipes.PipeStream.ReadAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego.</span><span class="sxs-lookup"><span data-stu-id="17a11-353">The <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="17a11-354">Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać.</span><span class="sxs-lookup"><span data-stu-id="17a11-354">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="17a11-355">Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.</span><span class="sxs-lookup"><span data-stu-id="17a11-355">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="17a11-356"><xref:System.IO.Pipes.PipeStream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-356">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="17a11-357">Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="17a11-357">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-358">Strumień nie obsługuje odczytywania.</span><span class="sxs-lookup"><span data-stu-id="17a11-358">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-359">Nie można uzyskać dostępu do zamkniętego potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-359">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-360">Potok nie został jeszcze połączony.</span><span class="sxs-lookup"><span data-stu-id="17a11-360">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="17a11-361">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-361">-or-</span></span>

<span data-ttu-id="17a11-362">Potok jest w stanie odłączonym.</span><span class="sxs-lookup"><span data-stu-id="17a11-362">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="17a11-363">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-363">-or-</span></span>

<span data-ttu-id="17a11-364">Dojście potoku nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-364">The pipe handle has not been set.</span></span>  <span data-ttu-id="17a11-365">(Czy zostało <see cref="T:System.IO.Pipes.PipeStream" /> wykonane wywołanie <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />implementacji?</span><span class="sxs-lookup"><span data-stu-id="17a11-365">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="pipeStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17a11-366">Odczytuje bajt z potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-366">Reads a byte from a pipe.</span></span></summary>
        <returns><span data-ttu-id="17a11-367">Bajt, rzutowanie do <see cref="T:System.Int32" />lub-1 wskazuje koniec strumienia (potok został zamknięty).</span><span class="sxs-lookup"><span data-stu-id="17a11-367">The byte, cast to <see cref="T:System.Int32" />, or -1 indicates the end of the stream (the pipe has been closed).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-368">Użyj właściwości <xref:System.IO.Pipes.PipeStream.CanRead%2A> , aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiekt obsługuje operacje odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-368">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-369">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-369">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-370">Potok nie obsługuje operacji odczytu.</span><span class="sxs-lookup"><span data-stu-id="17a11-370">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-371">Potok jest odłączony, oczekiwanie na połączenie lub dojście nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-371">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-372">Wystąpił błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-372">Any I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode ReadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode ReadMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.ReadMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode ReadMode { System::IO::Pipes::PipeTransmissionMode get(); void set(System::IO::Pipes::PipeTransmissionMode value); };" />
      <MemberSignature Language="F#" Value="member this.ReadMode : System.IO.Pipes.PipeTransmissionMode with get, set" Usage="System.IO.Pipes.PipeStream.ReadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-373">Pobiera lub ustawia tryb odczytu dla <see cref="T:System.IO.Pipes.PipeStream" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="17a11-373">Gets or sets the reading mode for a <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <value><span data-ttu-id="17a11-374">Jedna z <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartości, która wskazuje, <see cref="T:System.IO.Pipes.PipeStream" /> jak obiekt odczytuje z potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-374">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates how the <see cref="T:System.IO.Pipes.PipeStream" /> object reads from the pipe.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-375">Potoki anonimowe nie <xref:System.IO.Pipes.PipeTransmissionMode.Message> obsługują przesyłania komunikatów trybu.</span><span class="sxs-lookup"><span data-stu-id="17a11-375">Anonymous pipes do not support <xref:System.IO.Pipes.PipeTransmissionMode.Message> mode message transmission.</span></span>  

 <span data-ttu-id="17a11-376">Aby uniknąć <xref:System.InvalidOperationException> dostępu `ReadMode`, można <xref:System.IO.Pipes.PipeStream.IsConnected> użyć do sprawdzenia, czy potok jest połączony.</span><span class="sxs-lookup"><span data-stu-id="17a11-376">To avoid an <xref:System.InvalidOperationException> accessing `ReadMode`, <xref:System.IO.Pipes.PipeStream.IsConnected> can be used to verify the pipe is connected.</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17a11-377">Podana wartość nie jest prawidłową <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartością.</span><span class="sxs-lookup"><span data-stu-id="17a11-377">The supplied value is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-378">Podana wartość nie jest obsługiwaną <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartością dla tego strumienia potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-378">The supplied value is not a supported <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value for this pipe stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-379">Dojście nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-379">The handle has not been set.</span></span>  
  
 <span data-ttu-id="17a11-380">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-380">-or-</span></span>  
  
 <span data-ttu-id="17a11-381">Potok oczekuje na nawiązanie połączenia z nazwanym klientem.</span><span class="sxs-lookup"><span data-stu-id="17a11-381">The pipe is waiting to connect with a named client.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-382">Potok jest przerwany lub wystąpił błąd we/wy z nazwanym klientem.</span><span class="sxs-lookup"><span data-stu-id="17a11-382">The pipe is broken or an I/O error occurred with a named client.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SafePipeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.SafePipeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafePipeHandle As SafePipeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafePipeHandle ^ SafePipeHandle { Microsoft::Win32::SafeHandles::SafePipeHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafePipeHandle : Microsoft.Win32.SafeHandles.SafePipeHandle" Usage="System.IO.Pipes.PipeStream.SafePipeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafePipeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-383">Pobiera bezpieczne dojście dla lokalnego końca potoku, które jest hermetyzowane <see cref="T:System.IO.Pipes.PipeStream" /> przez bieżący obiekt.</span><span class="sxs-lookup"><span data-stu-id="17a11-383">Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="17a11-384">Obiekt dla potoku, który jest hermetyzowany przez bieżący <see cref="T:System.IO.Pipes.PipeStream" /> obiekt. <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /></span><span class="sxs-lookup"><span data-stu-id="17a11-384">A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-385">Dojście potoku nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-385">The pipe handle has not been set.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-386">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-386">The pipe is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="pipeStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="17a11-387">Punkt, względem <paramref name="origin" />,, aby rozpocząć wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-387">The point, relative to <paramref name="origin" />, to begin seeking from.</span></span></param>
        <param name="origin"><span data-ttu-id="17a11-388">Określa początek, koniec lub bieżącą pozycję jako punkt odniesienia dla <paramref name="offset" />, przy użyciu wartości typu. <see cref="T:System.IO.SeekOrigin" /></span><span class="sxs-lookup"><span data-stu-id="17a11-388">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span></span></param>
        <summary><span data-ttu-id="17a11-389">Ustawia bieżącą pozycję bieżącego strumienia do określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="17a11-389">Sets the current position of the current stream to the specified value.</span></span></summary>
        <returns><span data-ttu-id="17a11-390">Nowa pozycja w strumieniu.</span><span class="sxs-lookup"><span data-stu-id="17a11-390">The new position in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-391">Metoda nie jest obsługiwana w potokach i <xref:System.NotSupportedException> wywołuje się, gdy jest wywoływana. <xref:System.IO.Pipes.PipeStream.Seek%2A></span><span class="sxs-lookup"><span data-stu-id="17a11-391">The <xref:System.IO.Pipes.PipeStream.Seek%2A> method is not supported in pipes and raises a <xref:System.NotSupportedException> when it is called.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.SetAccessControl(System.IO.Pipes.PipeSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::Pipes::PipeSecurity ^ pipeSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.IO.Pipes.PipeSecurity -&gt; unit" Usage="pipeStream.SetAccessControl pipeSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" Index="0" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pipeSecurity"><span data-ttu-id="17a11-392"><see cref="T:System.IO.Pipes.PipeSecurity" /> Obiekt, który określa wpis listy kontroli dostępu (ACL), który ma zostać zastosowany do bieżącego potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-392">A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that specifies an access control list (ACL) entry to apply to the current pipe.</span></span></param>
        <summary><span data-ttu-id="17a11-393">Stosuje wpisy listy kontroli dostępu (ACL) określone przez <see cref="T:System.IO.Pipes.PipeSecurity" /> obiekt do potoku określonego przez bieżący <see cref="T:System.IO.Pipes.PipeStream" /> obiekt.</span><span class="sxs-lookup"><span data-stu-id="17a11-393">Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" /> object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-394">Lista kontroli dostępu (ACL) opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do wykonywania określonych działań w określonym pliku.</span><span class="sxs-lookup"><span data-stu-id="17a11-394">An access control list (ACL) describes individuals and/or groups that have, or do not have, rights to perform specific actions on a specified file.</span></span> <span data-ttu-id="17a11-395">Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.</span><span class="sxs-lookup"><span data-stu-id="17a11-395">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-396">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-396">The pipe is closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17a11-397"><paramref name="pipeSecurity" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-397"><paramref name="pipeSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17a11-398">Wywołanie podstawowe do ustawiania informacji o zabezpieczeniach nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="17a11-398">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-399">Wywołanie podstawowe do ustawiania informacji o zabezpieczeniach nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="17a11-399">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-400">Wywołanie podstawowe do ustawiania informacji o zabezpieczeniach nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="17a11-400">The underlying call to set security information failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="pipeStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="17a11-401">Nowa długość strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-401">The new length of the stream.</span></span></param>
        <summary><span data-ttu-id="17a11-402">Ustawia długość bieżącego strumienia do określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="17a11-402">Sets the length of the current stream to the specified value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-403"><xref:System.IO.Pipes.PipeStream> Klasa nie<xref:System.IO.Pipes.PipeStream.SetLength%2A> obsługuje metody.</span><span class="sxs-lookup"><span data-stu-id="17a11-403">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.SetLength%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransmissionMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode TransmissionMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode TransmissionMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.TransmissionMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TransmissionMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode TransmissionMode { System::IO::Pipes::PipeTransmissionMode get(); };" />
      <MemberSignature Language="F#" Value="member this.TransmissionMode : System.IO.Pipes.PipeTransmissionMode" Usage="System.IO.Pipes.PipeStream.TransmissionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17a11-404">Pobiera tryb transmisji potoku obsługiwany przez bieżący potok.</span><span class="sxs-lookup"><span data-stu-id="17a11-404">Gets the pipe transmission mode supported by the current pipe.</span></span></summary>
        <value><span data-ttu-id="17a11-405">Jedna z <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> wartości wskazujących tryb transmisji obsługiwany przez bieżący potok.</span><span class="sxs-lookup"><span data-stu-id="17a11-405">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode supported by the current pipe.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-406">Potoki anonimowe nie <xref:System.IO.Pipes.PipeTransmissionMode.Message> obsługują przesyłania komunikatów trybu.</span><span class="sxs-lookup"><span data-stu-id="17a11-406">Anonymous pipes do not support <xref:System.IO.Pipes.PipeTransmissionMode.Message> mode message transmission.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-407">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-407">The pipe is closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-408">Dojście nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-408">The handle has not been set.</span></span>  
  
 <span data-ttu-id="17a11-409">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-409">-or-</span></span>  
  
 <span data-ttu-id="17a11-410">Potok oczekuje na połączenie w operacji anonimowego klienta/serwera lub z nazwą klienta.</span><span class="sxs-lookup"><span data-stu-id="17a11-410">The pipe is waiting to connect in an anonymous client/server operation or with a named client.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-411">Potok jest przerwany lub Wystąpił inny błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-411">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForPipeDrain">
      <MemberSignature Language="C#" Value="public void WaitForPipeDrain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForPipeDrain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WaitForPipeDrain" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForPipeDrain ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForPipeDrain();" />
      <MemberSignature Language="F#" Value="member this.WaitForPipeDrain : unit -&gt; unit" Usage="pipeStream.WaitForPipeDrain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17a11-412">Czeka na inne zakończenie potoku w celu odczytania wszystkich wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="17a11-412">Waits for the other end of the pipe to read all sent bytes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-413"><xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A> Metoda blokuje wszystkie wysłane bajty do drugiego końca potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-413">The <xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A> method blocks until the other end of the pipe has read all sent bytes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-414">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-414">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-415">Potok nie obsługuje operacji zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-415">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-416">Potok jest przerwany lub Wystąpił inny błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-416">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="pipeStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="17a11-417">Region pamięci.</span><span class="sxs-lookup"><span data-stu-id="17a11-417">A region of memory.</span></span> <span data-ttu-id="17a11-418">Ta metoda kopiuje zawartość tego regionu do bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-418">This method copies the contents of this region to the current stream.</span></span></param>
        <summary><span data-ttu-id="17a11-419">Zapisuje sekwencję bajtów do bieżącego strumienia i zwiększa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="17a11-419">Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <remarks><format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="17a11-420"><xref:System.IO.Pipes.PipeStream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-420">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="17a11-421">Użyj metody <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> , aby zapisać asynchronicznie w bieżącym strumieniu.</span><span class="sxs-lookup"><span data-stu-id="17a11-421">Use the <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>  

<span data-ttu-id="17a11-422">Jeśli operacja zapisu powiedzie się, pozycja w strumieniu zastąpi przez liczbę zapisanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="17a11-422">If the write operation is successful, the position within the stream advances by the number of bytes written.</span></span> <span data-ttu-id="17a11-423">Jeśli wystąpi wyjątek, pozycja w strumieniu pozostaje niezmieniona.</span><span class="sxs-lookup"><span data-stu-id="17a11-423">If an exception occurs, the position within the stream remains unchanged.</span></span>  

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-424">Strumień nie obsługuje zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-424">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-425">Nie można uzyskać dostępu do zamkniętego potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-425">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.IOException"><span data-ttu-id="17a11-426">Potok jest przerwany.</span><span class="sxs-lookup"><span data-stu-id="17a11-426">The pipe is broken.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-427">Potok nie został jeszcze połączony.</span><span class="sxs-lookup"><span data-stu-id="17a11-427">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="17a11-428">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-428">-or-</span></span>

<span data-ttu-id="17a11-429">Potok jest w stanie odłączonym.</span><span class="sxs-lookup"><span data-stu-id="17a11-429">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="17a11-430">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-430">-or-</span></span>

<span data-ttu-id="17a11-431">Dojście potoku nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-431">The pipe handle has not been set.</span></span>  <span data-ttu-id="17a11-432">(Czy zostało <see cref="T:System.IO.Pipes.PipeStream" /> wykonane wywołanie <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />implementacji?</span><span class="sxs-lookup"><span data-stu-id="17a11-432">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="pipeStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="17a11-433">Bufor zawierający dane do zapisu w potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-433">The buffer that contains data to write to the pipe.</span></span></param>
        <param name="offset"><span data-ttu-id="17a11-434">Przesunięcie bajtu (liczony od zera <paramref name="buffer" /> ), w którym rozpocznie się kopiowanie bajtów do bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-434">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="17a11-435">Maksymalna liczba bajtów do zapisu w bieżącym strumieniu.</span><span class="sxs-lookup"><span data-stu-id="17a11-435">The maximum number of bytes to write to the current stream.</span></span></param>
        <summary><span data-ttu-id="17a11-436">Zapisuje blok bajtów do bieżącego strumienia przy użyciu danych z bufora.</span><span class="sxs-lookup"><span data-stu-id="17a11-436">Writes a block of bytes to the current stream using data from a buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-437">Użyj właściwości <xref:System.IO.Pipes.PipeStream.CanWrite%2A> , aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiekt obsługuje operacje zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-437">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="17a11-438">Wywoływanie bloków `count`metodydo odczytu bajtów lub osiągnięto koniec strumienia. <xref:System.IO.Pipes.PipeStream.Write%2A></span><span class="sxs-lookup"><span data-stu-id="17a11-438">Calling the <xref:System.IO.Pipes.PipeStream.Write%2A> method blocks until `count` bytes are read or the end of the stream is reached.</span></span> <span data-ttu-id="17a11-439">W przypadku asynchronicznych operacji odczytu <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> zobacz <xref:System.IO.Pipes.PipeStream.EndWrite%2A>i.</span><span class="sxs-lookup"><span data-stu-id="17a11-439">For asynchronous read operations, see <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> and <xref:System.IO.Pipes.PipeStream.EndWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17a11-440"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-440"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17a11-441"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="17a11-441"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="17a11-442">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-442">-or-</span></span> 
 <span data-ttu-id="17a11-443"><paramref name="count" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="17a11-443"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17a11-444"><paramref name="count" />jest większa niż liczba bajtów dostępnych w <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-444"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-445">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-445">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-446">Potok nie obsługuje operacji zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-446">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-447">Potok jest przerwany lub Wystąpił inny błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-447">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="pipeStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="17a11-448">Region pamięci, z której mają zostać zapisane dane.</span><span class="sxs-lookup"><span data-stu-id="17a11-448">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="17a11-449">Token do monitorowania żądań anulowania.</span><span class="sxs-lookup"><span data-stu-id="17a11-449">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="17a11-450">Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-450">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="17a11-451">Asynchronicznie zapisuje sekwencję bajtów do bieżącego strumienia, przesuwa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów i monitoruje żądania anulowania.</span><span class="sxs-lookup"><span data-stu-id="17a11-451">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="17a11-452">Zadanie, które reprezentuje asynchroniczny zapis operacji.</span><span class="sxs-lookup"><span data-stu-id="17a11-452">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="17a11-453"><xref:System.IO.Pipes.PipeStream.WriteAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego.</span><span class="sxs-lookup"><span data-stu-id="17a11-453">The <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="17a11-454">Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać.</span><span class="sxs-lookup"><span data-stu-id="17a11-454">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="17a11-455">Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.</span><span class="sxs-lookup"><span data-stu-id="17a11-455">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="17a11-456"><xref:System.IO.Pipes.PipeStream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-456">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="17a11-457">Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithtype> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="17a11-457">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithtype> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-458">Strumień nie obsługuje zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-458">Stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-459">Nie można uzyskać dostępu do zamkniętego potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-459">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.IOException"><span data-ttu-id="17a11-460">Potok jest przerwany.</span><span class="sxs-lookup"><span data-stu-id="17a11-460">The pipe is broken.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-461">Potok nie został jeszcze połączony.</span><span class="sxs-lookup"><span data-stu-id="17a11-461">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="17a11-462">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-462">-or-</span></span>

<span data-ttu-id="17a11-463">Potok jest w stanie odłączonym.</span><span class="sxs-lookup"><span data-stu-id="17a11-463">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="17a11-464">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-464">-or-</span></span>

<span data-ttu-id="17a11-465">Dojście potoku nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-465">The pipe handle has not been set.</span></span>  <span data-ttu-id="17a11-466">(Czy zostało <see cref="T:System.IO.Pipes.PipeStream" /> wykonane wywołanie <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />implementacji?</span><span class="sxs-lookup"><span data-stu-id="17a11-466">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="pipeStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="17a11-467">Bufor, z którego mają zostać zapisane dane.</span><span class="sxs-lookup"><span data-stu-id="17a11-467">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="17a11-468">Przesunięcie bajtu (liczony <paramref name="buffer" /> od zera), od którego należy rozpocząć kopiowanie bajtów do strumienia.</span><span class="sxs-lookup"><span data-stu-id="17a11-468">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="17a11-469">Maksymalna liczba bajtów do zapisania.</span><span class="sxs-lookup"><span data-stu-id="17a11-469">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="17a11-470">Token do monitorowania żądań anulowania.</span><span class="sxs-lookup"><span data-stu-id="17a11-470">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="17a11-471">Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-471">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="17a11-472">Asynchronicznie zapisuje określoną liczbę bajtów z tablicy bajtowej, zaczynając od określonej pozycji, przesuwa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów i monitoruje żądania anulowania.</span><span class="sxs-lookup"><span data-stu-id="17a11-472">Asynchronously writes a specified number of bytes from a byte array starting at a specified position, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="17a11-473">Zadanie, które reprezentuje asynchroniczny zapis operacji.</span><span class="sxs-lookup"><span data-stu-id="17a11-473">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown">
          
  
## Remarks  

<span data-ttu-id="17a11-474"><xref:System.IO.Pipes.PipeStream.WriteAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego.</span><span class="sxs-lookup"><span data-stu-id="17a11-474">The <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="17a11-475">Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać.</span><span class="sxs-lookup"><span data-stu-id="17a11-475">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="17a11-476">Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.</span><span class="sxs-lookup"><span data-stu-id="17a11-476">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="17a11-477"><xref:System.IO.Pipes.PipeStream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.</span><span class="sxs-lookup"><span data-stu-id="17a11-477">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="17a11-478">Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="17a11-478">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17a11-479"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-479"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17a11-480">Wartość <paramref name="offset" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="17a11-480">The <paramref name="offset" /> is negative.</span></span>

<span data-ttu-id="17a11-481">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-481">-or-</span></span>

<span data-ttu-id="17a11-482">Wartość <paramref name="count" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="17a11-482">The <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17a11-483"><paramref name="buffer" />. Długość — <paramref name="offset" /> jest mniejsza niż <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="17a11-483"><paramref name="buffer" />.Length - <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-484">Strumień nie obsługuje zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-484">Stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-485">Nie można uzyskać dostępu do zamkniętego potoku.</span><span class="sxs-lookup"><span data-stu-id="17a11-485">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.IOException"><span data-ttu-id="17a11-486">Potok jest przerwany.</span><span class="sxs-lookup"><span data-stu-id="17a11-486">The pipe is broken.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-487">Potok nie został jeszcze połączony.</span><span class="sxs-lookup"><span data-stu-id="17a11-487">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="17a11-488">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-488">-or-</span></span>

<span data-ttu-id="17a11-489">Potok jest w stanie odłączonym.</span><span class="sxs-lookup"><span data-stu-id="17a11-489">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="17a11-490">—lub—</span><span class="sxs-lookup"><span data-stu-id="17a11-490">-or-</span></span>

<span data-ttu-id="17a11-491">Dojście potoku nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-491">The pipe handle has not been set.</span></span>  <span data-ttu-id="17a11-492">(Czy zostało <see cref="T:System.IO.Pipes.PipeStream" /> wykonane wywołanie <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />implementacji?</span><span class="sxs-lookup"><span data-stu-id="17a11-492">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="T:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="pipeStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="17a11-493">Bajt do zapisu w strumieniu.</span><span class="sxs-lookup"><span data-stu-id="17a11-493">The byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="17a11-494">Zapisuje bajty w bieżącym strumieniu.</span><span class="sxs-lookup"><span data-stu-id="17a11-494">Writes a byte to the current stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17a11-495">Użyj właściwości <xref:System.IO.Pipes.PipeStream.CanWrite%2A> , aby określić, czy bieżący <xref:System.IO.Pipes.PipeStream> obiekt obsługuje operacje zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-495">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17a11-496">Potok jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="17a11-496">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17a11-497">Potok nie obsługuje operacji zapisu.</span><span class="sxs-lookup"><span data-stu-id="17a11-497">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17a11-498">Potok jest odłączony, oczekiwanie na połączenie lub dojście nie zostało ustawione.</span><span class="sxs-lookup"><span data-stu-id="17a11-498">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17a11-499">Potok jest przerwany lub Wystąpił inny błąd we/wy.</span><span class="sxs-lookup"><span data-stu-id="17a11-499">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>

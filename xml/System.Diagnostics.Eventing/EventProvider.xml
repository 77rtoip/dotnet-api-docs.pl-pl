<Type Name="EventProvider" FullName="System.Diagnostics.Eventing.EventProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1290920a99e0d8973716875e98d742000b57831e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36676262" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventProvider : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventProvider extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Eventing.EventProvider" />
  <TypeSignature Language="VB.NET" Value="Public Class EventProvider&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventProvider : IDisposable" />
  <TypeSignature Language="F#" Value="type EventProvider = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Klasa używana do zapisywania zdarzeń.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby korzystanie ze zdarzeń napisane przy użyciu <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A> i <xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A> metody zdarzenia musi być zdefiniowany w manifeście; zdarzenia napisane przy użyciu <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A> — metoda nie wymagają manifestu.  
  
 Zdarzenia mogą zawierać następujące typy danych zarządzanych:  
  
-   bool  
  
-   Boolean  
  
-   byte  
  
-   char  
  
-   decimal  
  
-   double  
  
-   float  
  
-   Identyfikator GUID  
  
-   int  
  
-   IntPtr  
  
-   long  
  
-   sbyte  
  
-   short  
  
-   string  
  
-   uint  
  
-   UInt64  
  
 Jeśli używa się zdarzenia w manifeście `Boolean` w typu nie można zapisać przy użyciu elementu danych `Boolean` typ danych w kodzie zarządzanym. `Boolean` Typu w manifeście oczekuje wartości 4-bajtowych, a `Boolean` typ danych w kodzie zarządzanym to 1-bajtowego. Zamiast tego należy użyć `int` — typ danych do zapisu wartości. Jeśli chcesz rejestrować `Boolean` wartość, użyj UInt8 typu w manifeście.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProvider (Guid providerGuid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Guid providerGuid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.#ctor(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (providerGuid As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventProvider(Guid providerGuid);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Eventing.EventProvider : Guid -&gt; System.Diagnostics.Eventing.EventProvider" Usage="new System.Diagnostics.Eventing.EventProvider providerGuid" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="providerGuid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="providerGuid">Identyfikator GUID, który unikatowo identyfikuje dostawcę.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.Eventing.EventProvider" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rejestruje dostawcę. Aby usunąć rejestrację po zakończeniu operacji, należy wywołać <xref:System.Diagnostics.Eventing.EventProvider.Close%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException">Nie ma wystarczającej ilości pamięci do ukończenia tej operacji.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Klasy w <see cref="N:System.Diagnostics.Eventing" /> pracy przestrzeni nazw tylko w systemie Windows Vista.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="providerGuid" /> Parametr nie może mieć wartości null.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Błąd zwrócony przez podsystem ETW.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="eventProvider.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa rejestrację dostawcy z podsystemem ETW i zwalnia wszystkie zasoby niezarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać tę metodę po zakończeniu zamiast czekać do usuwania zasobów systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Błąd zwrócony przez podsystem ETW.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateActivityId">
      <MemberSignature Language="C#" Value="public static Guid CreateActivityId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid CreateActivityId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateActivityId () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid CreateActivityId();" />
      <MemberSignature Language="F#" Value="static member CreateActivityId : unit -&gt; Guid" Usage="System.Diagnostics.Eventing.EventProvider.CreateActivityId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy identyfikator unikatowy dla dostawcy.</summary>
        <returns>Unikatowy identyfikator Guid, który jest używany podczas wywoływania <see cref="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" /> metodę, aby ustawić identyfikator działania dla dostawcy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest metodą statyczną.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="eventProvider.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez to <see cref="T:System.Diagnostics.Eventing.EventProvider" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="eventProvider.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Ten parametr jest ignorowana przez tę metodę, ponieważ nie ma żadnych niezarządzanych zasobów.</param>
        <summary>Zwalnia zasoby używane przez to <see cref="T:System.Diagnostics.Eventing.EventProvider" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~EventProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!EventProvider ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="eventProvider.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby i wykonuje wewnętrzny oczyszczania przed wystąpienie jest odzyskana przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteEventError">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode GetLastWriteEventError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Diagnostics.Eventing.EventProvider/WriteEventErrorCode GetLastWriteEventError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteEventError () As EventProvider.WriteEventErrorCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Eventing::EventProvider::WriteEventErrorCode GetLastWriteEventError();" />
      <MemberSignature Language="F#" Value="static member GetLastWriteEventError : unit -&gt; System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode" Usage="System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Eventing.EventProvider+WriteEventErrorCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera ostatniego błędu związanego z brakiem zapisu zdarzeń.</summary>
        <returns>Użyj wartości, aby ustalić przyczynę niepowodzenia zapisu zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A>, <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A>, I <xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A> metody Ustaw tę wartość, jeśli ich nie można zapisać zdarzenia.  
  
 To jest metodą statyczną.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsEnabled">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy sesja włączony dostawca.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled();" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : unit -&gt; bool" Usage="eventProvider.IsEnabled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy dowolnej sesji włączone dostawcy, niezależnie od poziomu i słowo kluczowe wartości używane do włączenia dostawcy usług.</summary>
        <returns>Jest <see langword="true" /> Jeżeli dostawca jest włączony do dowolnej sesji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj dostawcy nie wywołuje tę metodę, aby określić, czy dostawca został włączony przez sesji. Dostawca po prostu zapisuje zdarzenia i ETW Określa, czy zdarzenie jest rejestrowane do sesji. Dostawca może być wywołanie tej funkcji, jeśli dostawca trzeba wykonywać dodatkowe zadania generować zdarzenia. W takim przypadku wywoływania tej funkcji należy najpierw może zapisać zasobów i czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled (byte level, long keywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled(unsigned int8 level, int64 keywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled(System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled (level As Byte, keywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled(System::Byte level, long keywords);" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : byte * int64 -&gt; bool" Usage="eventProvider.IsEnabled (level, keywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Byte" />
        <Parameter Name="keywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="level">Poziom szczegółowości w zdarzeniu.</param>
        <param name="keywords">Maska bitowa, która określa kategorię zdarzenia. Ta maska powinna być tej samej maski — słowo kluczowe, który jest zdefiniowany w manifeście dla zdarzenia.</param>
        <summary>Określa, czy dowolnej sesji żąda określonego zdarzenia od dostawcy.</summary>
        <returns>Jest <see langword="true" /> Jeśli dowolnej sesji żąda określonego zdarzenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj dostawcy nie wywołuje tę metodę, aby określić, czy sesja wymagane określone zdarzenie; Dostawca po prostu zapisuje zdarzenia i ETW Określa, czy zdarzenie jest rejestrowane w sesji. Dostawca może być wywołanie tej funkcji, jeśli dostawca trzeba wykonywać dodatkowe zadania generować zdarzenia. W takim przypadku wywoływania tej funkcji, aby ustalić, w przypadku sesji żądane zdarzenie, może zapisać zasobów i czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetActivityId">
      <MemberSignature Language="C#" Value="public static void SetActivityId (ref Guid id);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetActivityId(valuetype System.Guid&amp; id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetActivityId (ByRef id As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetActivityId(Guid % id);" />
      <MemberSignature Language="F#" Value="static member SetActivityId :  -&gt; unit" Usage="System.Diagnostics.Eventing.EventProvider.SetActivityId id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Guid&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="id">Identyfikator unikatowy który <see cref="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" /> zwraca metody.</param>
        <summary>Ustawia bieżący identyfikator działania używany przez <see cref="Overload:System.Diagnostics.Eventing.EventProvider.WriteEvent" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator jest przechowywana w kontekście wątku.  
  
 Należy pamiętać, że w wersji 3.5 .NET framework, trzeba było ustawić `id` parametr tej metody i <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> wartości właściwości do tej samej wartości identyfikatora. Jednak w ramach, w wersji 4.0 <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metoda automatycznie ustawia identyfikator korelacji działania dla Ciebie.  
  
 To jest metodą statyczną.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tych metod, jeśli manifest umożliwia definiowanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * obj[] -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, eventPayload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Wystąpienie <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> identyfikującym zdarzenia w celu zapisu.</param>
        <param name="eventPayload">Tablica obiektów, które zawierają dane zdarzeń do zapisania. Obiekt musi być w kolejności określonej w manifeście. Tablica jest ograniczone do 32 obiektów, w których tylko osiem może być ciągami. Maksymalnego rozmiaru danych zdarzenia jest ograniczony do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesji rozmiar buforu jest mniejszy, a sesja zawiera elementy danych rozszerzonych ze zdarzeniem.  Ten parametr może mieć wartości null.</param>
        <summary>Zapisuje zdarzenie. Dane zdarzenia jest określony jako tablica obiektów.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie jest zapisywane w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli należy wywołać <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metodę, aby określić identyfikator działania dla zdarzenia, ta metoda pobiera identyfikator w kontekście wątku i zawiera ona ze zdarzeniem.  
  
 Jeśli typ obiektu nie jest obsługiwana, metoda zapisuje wartość obiektu <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody w ładunku. Aby uzyskać listę obsługiwanych typów obiektów, zobacz uwagi dla <xref:System.Diagnostics.Eventing.EventProvider> klasy.  
  
   
  
## Examples  
  
```  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
enum Keyword  
{  
    Read = 0x1,  
    Write = 0x2,  
    Local = 0x4,  
    Remote = 0x8  
}  
  
enum Level  
{  
    Critical = 1,  
    Error,  
    Warning,  
    Information,  
    Verbose  
}  
  
    EventProvider provider = new EventProvider(providerId);  
    EventDescriptor readEvent;  
    string path = @"<PATHGOESHERE>";  
    UInt64 bytesRead = <ASSIGNVALUE>;  
  
    if (provider.IsEnabled(Level.Information, (long)Keyword.Read))  
    {  
        unchecked  
        {  
            readEvent = new EventDescriptor(0x1, 0x0, 0x10, 0x4, 0x0, 0x0, (long)0x8000000000000005);  
        }  
  
        if (!provider.WriteEvent(ref readEvent, new object[] { path, bytesRead }))  
            Console.WriteLine(EventProvider.GetLastWriteEventError());  
    }  
  
    provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="eventPayload" /> Parametr zawiera zbyt wiele obiektów lub ciągów.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, data As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, System::String ^ data);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * string -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Wystąpienie <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> identyfikującym zdarzenia w celu zapisu.</param>
        <param name="data">Ciąg do zapisania jako dane zdarzenia.</param>
        <summary>Zapisuje zdarzenie. Dane zdarzenia jest określony jako ciąg.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie jest zapisywane w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli należy wywołać <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metodę, aby określić identyfikator działania dla zdarzenia, ta metoda pobiera identyfikator w kontekście wątku i zawiera ona ze zdarzeniem.  
  
 Maksymalna długość ciągu jest ograniczona do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesji rozmiar buforu jest mniejszy, a sesja zawiera elementy danych rozszerzonych ze zdarzeniem.  
  
   
  
## Examples  
  
```  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
EventProvider provider = new EventProvider(providerId);  
EventDescriptor writeEvent;  
  
if (provider.IsEnabled())  
{  
     unchecked  
     {  
          writeEvent = new EventDescriptor(0x2, 0x0, 0x10, 0x3, 0x0, 0x0, (long)0x8000000000000006);  
     }  
  
     if (!provider.WriteEvent(ref writeEvent, "Write event."))  
          Console.WriteLine(EventProvider.GetLastWriteEventError());  
}  
  
provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jeśli <paramref name="data" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteEvent (ByRef eventDescriptor As EventDescriptor, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * int * nativeint -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, dataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Wystąpienie <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> identyfikującym zdarzenia w celu zapisu.</param>
        <param name="dataCount">Rozmiar danych zdarzeń, do których <c>danych</c> punktów parametru. Zdarzenie maksymalny rozmiar danych jest ograniczony do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesji rozmiar buforu jest mniejszy, a sesja zawiera elementy danych rozszerzonych ze zdarzeniem.</param>
        <param name="data">Wskaźnik do zapisu danych zdarzenia.</param>
        <summary>Zapisuje zdarzenie. Dane zdarzenia jest określony jako bloku pamięci.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie jest zapisywane w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli należy wywołać <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metodę, aby określić identyfikator działania dla zdarzenia, ta metoda pobiera identyfikator w kontekście wątku i zawiera ona ze zdarzeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteMessageEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje zdarzenie zawiera ciąg jako jego dane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te metody nie wymagają manifestu użycie zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage);" />
      <MemberSignature Language="F#" Value="member this.WriteMessageEvent : string -&gt; bool" Usage="eventProvider.WriteMessageEvent eventMessage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventMessage">Ciąg do zapisania jako dane zdarzenia.</param>
        <summary>Zapisuje zdarzenie zawiera ciąg jako jego dane.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie jest zapisywane w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maksymalna długość ciągu jest ograniczona do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesji rozmiar buforu jest mniejszy, a sesja zawiera elementy danych rozszerzonych ze zdarzeniem.  
  
   
  
## Examples  
  
```  
if (!provider.WriteMessageEvent("Event string."))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jeśli <paramref name="eventMessage" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage, byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage, unsigned int8 eventLevel, int64 eventKeywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String, eventLevel As Byte, eventKeywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage, System::Byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="F#" Value="member this.WriteMessageEvent : string * byte * int64 -&gt; bool" Usage="eventProvider.WriteMessageEvent (eventMessage, eventLevel, eventKeywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
        <Parameter Name="eventLevel" Type="System.Byte" />
        <Parameter Name="eventKeywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="eventMessage">Ciąg do zapisania jako dane zdarzenia.</param>
        <param name="eventLevel">Poziom szczegółowości w zdarzeniu. Jeśli dostawca używa manifestu w celu zdefiniowania zdarzenia, ta wartość do tego samego poziomu zdefiniowane w manifeście.</param>
        <param name="eventKeywords">Maska bitowa, która określa kategorię zdarzenia. Jeśli dostawca używa manifestu w celu zdefiniowania zdarzenia, ta wartość tej samej maski — słowo kluczowe zdefiniowane w manifeście.</param>
        <summary>Zapisuje zdarzenie zawiera ciąg jako jego dane, jeśli wartość poziomu i słowo kluczowe odpowiada zażądał sesji zdarzeń.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie jest zapisywane w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maksymalna długość ciągu jest ograniczona do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesji rozmiar buforu jest mniejszy, a sesja zawiera elementy danych rozszerzonych ze zdarzeniem.  
  
   
  
## Examples  
  
```  
// Calling this method with level and keyword set to zero is the same  
// as calling WriteMessageEvent(string); the event is always written.  
if (!provider.WriteMessageEvent("Event string.", 0, 0))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
  
// Event is written if the level value of the session is less than or equal to 3, and bit 1 of the session  
// keyword bit-mask is set.  
if (!provider.WriteMessageEvent("Event string.", 3, 2))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jeśli <paramref name="eventMessage" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteTransferEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zdarzenia łącza razem, gdy Śledzenie zdarzeń w scenariuszu end-to-end.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="public bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberSignature Language="F#" Value="member this.WriteTransferEvent :  * Guid * obj[] -&gt; bool" Usage="eventProvider.WriteTransferEvent (eventDescriptor, relatedActivityId, eventPayload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Wystąpienie <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> identyfikującym zdarzenia w celu zapisu.</param>
        <param name="relatedActivityId">Identyfikator działania z poprzedniego składnika. Użyj tego parametru, aby połączyć zdarzenia poprzedni składnik zdarzenia danego składnika.</param>
        <param name="eventPayload">Tablica obiektów, które zawierają dane zdarzeń do zapisania. Dane muszą być w kolejności określonej w manifeście. Tablica jest ograniczone do 32 obiektów, w których tylko osiem może być ciągami. Maksymalnego rozmiaru danych zdarzenia jest ograniczony do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesji rozmiar buforu jest mniejszy, a sesja zawiera elementy danych rozszerzonych ze zdarzeniem.</param>
        <summary>Zdarzenia łącza razem, gdy Śledzenie zdarzeń w scenariuszu end-to-end. Dane zdarzenia jest określony jako tablica obiektów.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie jest zapisywane w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda używa Identyfikatora aktywności w kontekście wątku do identyfikowania tego składnika. Aby ustawić identyfikator działania, należy wywołać <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metody.  
  
 Jeśli używasz <xref:System.Diagnostics.Trace> klasa, nie jest używana <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metodę, aby określić identyfikator działania. Zamiast tego dostępu <xref:System.Diagnostics.Trace.CorrelationManager%2A> właściwości do pobrania <xref:System.Diagnostics.CorrelationManager> obiektu. Następnie ustaw <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> dla właściwości identyfikator działania. Należy także ustawić `relatedActivityId` do <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jeśli <paramref name="eventPayload" /> zawiera zbyt wiele obiektów lub ciągów.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="protected bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="F#" Value="member this.WriteTransferEvent :  * Guid * int * nativeint -&gt; bool" Usage="eventProvider.WriteTransferEvent (eventDescriptor, relatedActivityId, dataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Wystąpienie <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> identyfikującym zdarzenia w celu zapisu.</param>
        <param name="relatedActivityId">Identyfikator działania z poprzedniego składnika. Użyj tego parametru, aby połączyć zdarzenia poprzedni składnik zdarzenia danego składnika.</param>
        <param name="dataCount">Rozmiar danych zdarzeń, do których <c>danych</c> punktów parametru. Zdarzenie maksymalny rozmiar danych jest ograniczony do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesji rozmiar buforu jest mniejszy, a sesja zawiera elementy danych rozszerzonych ze zdarzeniem.</param>
        <param name="data">Wskaźnik do zapisu danych zdarzenia.</param>
        <summary>Zdarzenia łącza razem, gdy Śledzenie zdarzeń w scenariuszu end-to-end. Dane zdarzenia jest określony jako bloku pamięci.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie jest zapisywane w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda używa Identyfikatora aktywności w kontekście wątku do identyfikowania tego składnika. Aby ustawić identyfikator działania, należy wywołać <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
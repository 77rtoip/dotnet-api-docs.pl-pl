<Type Name="EventProvider" FullName="System.Diagnostics.Eventing.EventProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cf568c757cd2245c43200314cbb3ebefb6451db8" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39886837" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventProvider : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventProvider extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Eventing.EventProvider" />
  <TypeSignature Language="VB.NET" Value="Public Class EventProvider&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventProvider : IDisposable" />
  <TypeSignature Language="F#" Value="type EventProvider = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Klasa jest używana do zapisywania zdarzeń.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używać zdarzenia zapisywane z użyciem <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A> i <xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A> metody i zdarzenia musi być zdefiniowany w manifeście; zdarzenia zapisywane z użyciem <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A> metody nie wymagają manifestu.  
  
 Zdarzenia może zawierać następujące typy zarządzanych danych:  
  
-   bool  
  
-   Boolean  
  
-   byte  
  
-   char  
  
-   decimal  
  
-   double  
  
-   float  
  
-   Identyfikator GUID  
  
-   int  
  
-   Pola IntPtr  
  
-   long  
  
-   sbyte  
  
-   short  
  
-   string  
  
-   uint  
  
-   UInt64  
  
 Jeśli zdarzenie w manifeście używa `Boolean` w typie, nie można zapisać elementu danych za pomocą `Boolean` typu danych w kodzie zarządzanym. `Boolean` Typu w manifeście oczekuje wartości 4-bajtowych, a `Boolean` typ danych w kodzie zarządzanym to 1-bajtowe. Zamiast tego należy użyć `int` typ danych, aby zapisać wartości. Jeśli chcesz rejestrować `Boolean` wartość, należy użyć UInt8 typu w manifeście.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProvider (Guid providerGuid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Guid providerGuid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.#ctor(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (providerGuid As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventProvider(Guid providerGuid);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Eventing.EventProvider : Guid -&gt; System.Diagnostics.Eventing.EventProvider" Usage="new System.Diagnostics.Eventing.EventProvider providerGuid" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="providerGuid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="providerGuid">Identyfikator GUID, który unikatowo identyfikuje dostawcę.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.Eventing.EventProvider" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rejestruje dostawcę. Aby usunąć rejestrację, po zakończeniu, należy wywołać <xref:System.Diagnostics.Eventing.EventProvider.Close%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException">Nie ma wystarczającej ilości pamięci do ukończenia tej operacji.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Klasy w <see cref="N:System.Diagnostics.Eventing" /> pracy przestrzeni nazw tylko w systemie Windows Vista.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="providerGuid" /> Parametr nie może mieć wartości null.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Błąd zwrócony przez podsystemu ETW.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="eventProvider.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa rejestrację dostawcy z podsystemu ETW i zwalnia wszystkie zasoby niezarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powinna wywołać tę metodę, po zakończeniu, zamiast czekać, aż system do usuwania zasobów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Błąd zwrócony przez podsystemu ETW.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateActivityId">
      <MemberSignature Language="C#" Value="public static Guid CreateActivityId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid CreateActivityId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateActivityId () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid CreateActivityId();" />
      <MemberSignature Language="F#" Value="static member CreateActivityId : unit -&gt; Guid" Usage="System.Diagnostics.Eventing.EventProvider.CreateActivityId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy identyfikator unikatowy dla dostawcy.</summary>
        <returns>Unikatowy identyfikator Guid, który można użyć podczas wywoływania <see cref="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" /> metodę, aby ustawić identyfikator działania dla dostawcy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda statyczna.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="eventProvider.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez to <see cref="T:System.Diagnostics.Eventing.EventProvider" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="eventProvider.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Ten parametr jest ignorowany przez tę metodę, ponieważ nie ma żadnych niezarządzanych zasobów.</param>
        <summary>Zwalnia zasoby używane przez to <see cref="T:System.Diagnostics.Eventing.EventProvider" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~EventProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!EventProvider ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="eventProvider.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby i wykonuje Oczyszczanie wewnętrzne, zanim wystąpienie jest odzyskiwane przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteEventError">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode GetLastWriteEventError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Diagnostics.Eventing.EventProvider/WriteEventErrorCode GetLastWriteEventError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteEventError () As EventProvider.WriteEventErrorCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Eventing::EventProvider::WriteEventErrorCode GetLastWriteEventError();" />
      <MemberSignature Language="F#" Value="static member GetLastWriteEventError : unit -&gt; System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode" Usage="System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Eventing.EventProvider+WriteEventErrorCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera ostatni błąd skojarzony z błędem zapisu zdarzenia.</summary>
        <returns>Użyj wartości, aby ustalić przyczynę wystąpił błąd zapisu zdarzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A>, <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A>, I <xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A> metody Ustaw tę wartość, jeśli ich nie można zapisać zdarzenia.  
  
 Jest to metoda statyczna.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsEnabled">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy sesji jest włączony dostawca.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled();" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : unit -&gt; bool" Usage="eventProvider.IsEnabled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy dowolnej sesji włączona dostawcy, niezależnie od wartości poziomu i słowo kluczowe używane w celu włączenia dostawcy usług.</summary>
        <returns>Jest <see langword="true" /> Jeżeli dostawca jest włączone do dowolnej sesji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj dostawcy nie wywołuje tę metodę w celu określenia, czy dostawca został włączony przez sesji. Dostawca po prostu zapisuje zdarzenia i zdarzeń systemu Windows określa, czy zdarzenie jest rejestrowane do sesji. Dostawca może być wywołanie tej funkcji, jeśli dostawca musi wykonać dodatkową pracę, aby wygenerować zdarzenie. W takim przypadku podczas wywoływania tej funkcji najpierw może zapisać zasobów i czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled (byte level, long keywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled(unsigned int8 level, int64 keywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled(System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled (level As Byte, keywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled(System::Byte level, long keywords);" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : byte * int64 -&gt; bool" Usage="eventProvider.IsEnabled (level, keywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Byte" />
        <Parameter Name="keywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="level">Poziom szczegółowości w zdarzeniu.</param>
        <param name="keywords">Maska bitów, który określa kategorię zdarzeń. Ta maska musi być tego samego maska — słowo kluczowe, który jest zdefiniowany w manifeście dla zdarzenia.</param>
        <summary>Określa, czy dowolnej sesji, żąda od dostawcy określonego zdarzenia.</summary>
        <returns>Jest <see langword="true" /> w przypadku dowolnej sesji żąda określonego zdarzenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj dostawcy nie wywołuje tę metodę w celu określenia, czy sesja wymagane określonego zdarzenia; Dostawca po prostu zapisuje zdarzenia i zdarzeń systemu Windows określa, czy zdarzenie jest rejestrowane do sesji. Dostawca może być wywołanie tej funkcji, jeśli dostawca musi wykonać dodatkową pracę, aby wygenerować zdarzenie. W takim przypadku podczas wywoływania tej funkcji, aby ustalić, w przypadku sesji żądane zdarzenie, może zapisać zasobów i czasu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetActivityId">
      <MemberSignature Language="C#" Value="public static void SetActivityId (ref Guid id);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetActivityId(valuetype System.Guid&amp; id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetActivityId (ByRef id As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetActivityId(Guid % id);" />
      <MemberSignature Language="F#" Value="static member SetActivityId :  -&gt; unit" Usage="System.Diagnostics.Eventing.EventProvider.SetActivityId id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Guid" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="id">Identyfikator unikatowy, <see cref="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" /> metoda zwraca.</param>
        <summary>Ustawia bieżący identyfikator działania używane przez <see cref="Overload:System.Diagnostics.Eventing.EventProvider.WriteEvent" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator znajduje się w kontekście wątku.  
  
 Należy pamiętać, że w wersji 3.5 programu .NET framework, trzeba było ustawić `id` parametr tej metody i <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> wartości właściwości do tej samej wartości identyfikatora. Jednak w wersji 4.0 framework <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metoda automatycznie ustawia identyfikator korelacji działania za Ciebie.  
  
 Jest to metoda statyczna.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tych metod, jeśli manifest można użyć do zdefiniowania zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * obj[] -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, eventPayload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Wystąpienie <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> określający zdarzeń do zapisania.</param>
        <param name="eventPayload">Tablica obiektów, które zawierają dane zdarzenia do zapisania. Obiekt musi być w kolejności określonej w manifeście. Tablica jest ograniczona do 32 obiekty, których można tylko osiem ciągów. Maksymalny rozmiar danych zdarzenia jest ograniczony do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesja rozmiar buforu jest mniejszy i sesji obejmuje zwiększoną ilość danych elementów ze zdarzeniem.  Ten parametr może mieć wartości null.</param>
        <summary>Zapisuje zdarzenie. Dane zdarzenia jest określony jako tablica obiektów.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie dotyczy napisane; w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wywołasz <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metodę, aby określić identyfikator działania do zdarzenia, ta metoda pobiera identyfikator w kontekście wątku i dołączenia go ze zdarzeniem.  
  
 Jeśli typ obiektu nie jest obsługiwany, metoda zapisuje wartość obiektu <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody w ładunku. Aby uzyskać listę obsługiwanych typów obiektów, zobacz uwagi dla <xref:System.Diagnostics.Eventing.EventProvider> klasy.  
  
   
  
## Examples  
  
```csharp  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
enum Keyword  
{  
    Read = 0x1,  
    Write = 0x2,  
    Local = 0x4,  
    Remote = 0x8  
}  
  
enum Level  
{  
    Critical = 1,  
    Error,  
    Warning,  
    Information,  
    Verbose  
}  
  
    EventProvider provider = new EventProvider(providerId);  
    EventDescriptor readEvent;  
    string path = @"<PATHGOESHERE>";  
    UInt64 bytesRead = <ASSIGNVALUE>;  
  
    if (provider.IsEnabled(Level.Information, (long)Keyword.Read))  
    {  
        unchecked  
        {  
            readEvent = new EventDescriptor(0x1, 0x0, 0x10, 0x4, 0x0, 0x0, (long)0x8000000000000005);  
        }  
  
        if (!provider.WriteEvent(ref readEvent, new object[] { path, bytesRead }))  
            Console.WriteLine(EventProvider.GetLastWriteEventError());  
    }  
  
    provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="eventPayload" /> Parametr zawiera zbyt wiele obiektów lub ciągi znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, data As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, System::String ^ data);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * string -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Wystąpienie <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> określający zdarzeń do zapisania.</param>
        <param name="data">Ciąg do zapisania jako dane zdarzenia.</param>
        <summary>Zapisuje zdarzenie. Dane zdarzenia jest określony jako ciąg.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie dotyczy napisane; w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wywołasz <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metodę, aby określić identyfikator działania do zdarzenia, ta metoda pobiera identyfikator w kontekście wątku i dołączenia go ze zdarzeniem.  
  
 Maksymalna długość ciągu jest ograniczona do 64 KB minus rozmiar nagłówki zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesja rozmiar buforu jest mniejszy i sesji obejmuje zwiększoną ilość danych elementów ze zdarzeniem.  
  
   
  
## Examples  
  
```csharp  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
EventProvider provider = new EventProvider(providerId);  
EventDescriptor writeEvent;  
  
if (provider.IsEnabled())  
{  
     unchecked  
     {  
          writeEvent = new EventDescriptor(0x2, 0x0, 0x10, 0x3, 0x0, 0x0, (long)0x8000000000000006);  
     }  
  
     if (!provider.WriteEvent(ref writeEvent, "Write event."))  
          Console.WriteLine(EventProvider.GetLastWriteEventError());  
}  
  
provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jeśli <paramref name="data" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteEvent (ByRef eventDescriptor As EventDescriptor, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * int * nativeint -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, dataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Wystąpienie <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> określający zdarzeń do zapisania.</param>
        <param name="dataCount">Rozmiar danych zdarzeń, do których <c>danych</c> punktów parametru. Zdarzenia maksymalny rozmiar danych jest ograniczony do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesja rozmiar buforu jest mniejszy i sesji obejmuje zwiększoną ilość danych elementów ze zdarzeniem.</param>
        <param name="data">Wskaźnik do danych zdarzenia do zapisania.</param>
        <summary>Zapisuje zdarzenie. Dane zdarzenia jest określony jako bloku pamięci.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie dotyczy napisane; w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wywołasz <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metodę, aby określić identyfikator działania do zdarzenia, ta metoda pobiera identyfikator w kontekście wątku i dołączenia go ze zdarzeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteMessageEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje zdarzenie, które zawiera ciąg jako jego danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te metody nie wymagają manifest zużyje zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage);" />
      <MemberSignature Language="F#" Value="member this.WriteMessageEvent : string -&gt; bool" Usage="eventProvider.WriteMessageEvent eventMessage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventMessage">Ciąg do zapisania jako dane zdarzenia.</param>
        <summary>Zapisuje zdarzenie, które zawiera ciąg jako jego danych.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie dotyczy napisane; w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maksymalna długość ciągu jest ograniczona do 64 KB minus rozmiar nagłówki zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesja rozmiar buforu jest mniejszy i sesji obejmuje zwiększoną ilość danych elementów ze zdarzeniem.  
  
   
  
## Examples  
  
```csharp  
if (!provider.WriteMessageEvent("Event string."))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jeśli <paramref name="eventMessage" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage, byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage, unsigned int8 eventLevel, int64 eventKeywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String, eventLevel As Byte, eventKeywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage, System::Byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="F#" Value="member this.WriteMessageEvent : string * byte * int64 -&gt; bool" Usage="eventProvider.WriteMessageEvent (eventMessage, eventLevel, eventKeywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
        <Parameter Name="eventLevel" Type="System.Byte" />
        <Parameter Name="eventKeywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="eventMessage">Ciąg do zapisania jako dane zdarzenia.</param>
        <param name="eventLevel">Poziom szczegółowości w zdarzeniu. Jeśli dostawca używa manifestu w celu zdefiniowania zdarzenia, należy ustawić tę wartość na tym samym poziomie zdefiniowany w manifeście.</param>
        <param name="eventKeywords">Maska bitów, który określa kategorię zdarzeń. Jeśli dostawca używa manifestu w celu zdefiniowania zdarzenia, należy ustawić tę wartość na tej samej masce — słowo kluczowe zdefiniowany w manifeście.</param>
        <summary>Zapisuje zdarzenie, który zawiera ciąg jako jej dane, jeśli wartość poziomu i słowo kluczowe odpowiada zdarzenia, żądaniem sesji.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie dotyczy napisane; w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maksymalna długość ciągu jest ograniczona do 64 KB minus rozmiar nagłówki zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesja rozmiar buforu jest mniejszy i sesji obejmuje zwiększoną ilość danych elementów ze zdarzeniem.  
  
   
  
## Examples  
  
```csharp  
// Calling this method with level and keyword set to zero is the same  
// as calling WriteMessageEvent(string); the event is always written.  
if (!provider.WriteMessageEvent("Event string.", 0, 0))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
  
// Event is written if the level value of the session is less than or equal to 3, and bit 1 of the session  
// keyword bit-mask is set.  
if (!provider.WriteMessageEvent("Event string.", 3, 2))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jeśli <paramref name="eventMessage" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteTransferEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Łączy ze sobą zdarzeń, śledzenia zdarzeń w scenariuszu end-to-end.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="public bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberSignature Language="F#" Value="member this.WriteTransferEvent :  * Guid * obj[] -&gt; bool" Usage="eventProvider.WriteTransferEvent (eventDescriptor, relatedActivityId, eventPayload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Wystąpienie <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> określający zdarzeń do zapisania.</param>
        <param name="relatedActivityId">Identyfikator działania z poprzedniego składnika. Użyj tego parametru, aby połączyć zdarzenia danego składnika poprzedniemu składnikowi zdarzenia.</param>
        <param name="eventPayload">Tablica obiektów, które zawierają dane zdarzenia do zapisania. Dane muszą być w kolejności określonej w manifeście. Tablica jest ograniczona do 32 obiekty, których można tylko osiem ciągów. Maksymalny rozmiar danych zdarzenia jest ograniczony do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesja rozmiar buforu jest mniejszy i sesji obejmuje zwiększoną ilość danych elementów ze zdarzeniem.</param>
        <summary>Łączy ze sobą zdarzeń, śledzenia zdarzeń w scenariuszu end-to-end. Dane zdarzenia jest określony jako tablica obiektów.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie dotyczy napisane; w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda używa identyfikator działania w kontekście wątku, aby zidentyfikować ten składnik. Aby ustawić identyfikator działania, należy wywołać <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metody.  
  
 Jeśli używasz <xref:System.Diagnostics.Trace> klasy, nie jest używana <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metodę, aby określić identyfikator działania. Zamiast tego dostępu <xref:System.Diagnostics.Trace.CorrelationManager%2A> właściwości do pobrania <xref:System.Diagnostics.CorrelationManager> obiektu. Następnie ustaw <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> właściwości identyfikator działania. Należy także ustawić `relatedActivityId` do <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jeśli <paramref name="eventPayload" /> zawiera zbyt wiele obiektów lub ciągi znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="protected bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="F#" Value="member this.WriteTransferEvent :  * Guid * int * nativeint -&gt; bool" Usage="eventProvider.WriteTransferEvent (eventDescriptor, relatedActivityId, dataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Wystąpienie <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> określający zdarzeń do zapisania.</param>
        <param name="relatedActivityId">Identyfikator działania z poprzedniego składnika. Użyj tego parametru, aby połączyć zdarzenia danego składnika poprzedniemu składnikowi zdarzenia.</param>
        <param name="dataCount">Rozmiar danych zdarzeń, do których <c>danych</c> punktów parametru. Zdarzenia maksymalny rozmiar danych jest ograniczony do 64 KB minus rozmiar nagłówków zdarzeń. Rozmiar zdarzenia jest mniejszy, jeśli sesja rozmiar buforu jest mniejszy i sesji obejmuje zwiększoną ilość danych elementów ze zdarzeniem.</param>
        <param name="data">Wskaźnik do danych zdarzenia do zapisania.</param>
        <summary>Łączy ze sobą zdarzeń, śledzenia zdarzeń w scenariuszu end-to-end. Dane zdarzenia jest określony jako bloku pamięci.</summary>
        <returns>Jest <see langword="true" /> Jeśli zdarzenie dotyczy napisane; w przeciwnym razie <see langword="false" />. W przypadku wartości FAŁSZ wywołać <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> metodę, aby ustalić przyczynę niepowodzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda używa identyfikator działania w kontekście wątku, aby zidentyfikować ten składnik. Aby ustawić identyfikator działania, należy wywołać <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
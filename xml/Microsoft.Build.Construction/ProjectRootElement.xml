<Type Name="ProjectRootElement" FullName="Microsoft.Build.Construction.ProjectRootElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5c33c871f1615c1afc9ba7cc5c1f424327c3e4c1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="40001113" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ProjectRootElement : Microsoft.Build.Construction.ProjectElementContainer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProjectRootElement extends Microsoft.Build.Construction.ProjectElementContainer" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Construction.ProjectRootElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ProjectRootElement&#xA;Inherits ProjectElementContainer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProjectRootElement : Microsoft::Build::Construction::ProjectElementContainer" />
  <TypeSignature Language="F#" Value="type ProjectRootElement = class&#xA;    inherit ProjectElementContainer" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.Build.Construction.ProjectElementContainer</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{FullPath} #Children={Count} DefaultTargets={DefaultTargets} ToolsVersion={ToolsVersion} InitialTargets={InitialTargets} ExplicitlyLoaded={IsExplicitlyLoaded}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{FullPath} #Children={Count} DefaultTargets={DefaultTargets} ToolsVersion={ToolsVersion} InitialTargets={InitialTargets}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje projektu programu MSBuild, plik elementów docelowych lub dowolnego innego pliku, który jest zgodny ze schematem pliku projektu MSBuild. Ta klasa i jej klasy pokrewne zezwolić na pełne MSBuild projektu lub pliku Odczyt i zapis.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komentarze i biały znak, nie można edytować za pomocą tego modelu w chwili obecnej. Każdy element główny projektu jest skojarzony z kolekcją projektów dokładnie jeden. Dzięki temu właścicielem tej kolekcji projektów, aby kontrolować jego okres istnienia i nie oczekiwano przez zmiany, które pochodzą z inną kolekcją projektów.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddImport">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectImportElement AddImport (string project);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectImportElement AddImport(string project) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddImport(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddImport (project As String) As ProjectImportElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectImportElement ^ AddImport(System::String ^ project);" />
      <MemberSignature Language="F#" Value="member this.AddImport : string -&gt; Microsoft.Build.Construction.ProjectImportElement" Usage="projectRootElement.AddImport project" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectImportElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="project" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="project">Projekt, który ma zostać zaimportowany.</param>
        <summary>Dodaje import projektu do tego projektu.</summary>
        <returns>Zwraca import dodano projektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli istnieją grupy importu, wstawia import projektu do ostatniej grupy importu o bez atrybut warunku; w przeciwnym razie tworzy importu na końcu projektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddImportGroup">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectImportGroupElement AddImportGroup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectImportGroupElement AddImportGroup() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddImportGroup" />
      <MemberSignature Language="VB.NET" Value="Public Function AddImportGroup () As ProjectImportGroupElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectImportGroupElement ^ AddImportGroup();" />
      <MemberSignature Language="F#" Value="member this.AddImportGroup : unit -&gt; Microsoft.Build.Construction.ProjectImportGroupElement" Usage="projectRootElement.AddImportGroup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectImportGroupElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy grupę importu na końcu tego projektu.</summary>
        <returns>Zwraca Importuj grupę utworzone na końcu tego projektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wygodna metoda wybiera lokalizację w MSBuild DOM w oparciu o heurystykę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddItem">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje element do tego projektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddItem">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemElement AddItem (string itemType, string include);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItem (itemType As String, include As String) As ProjectItemElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectItemElement ^ AddItem(System::String ^ itemType, System::String ^ include);" />
      <MemberSignature Language="F#" Value="member this.AddItem : string * string -&gt; Microsoft.Build.Construction.ProjectItemElement" Usage="projectRootElement.AddItem (itemType, include)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="include" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Typ elementu do dodania.</param>
        <param name="include">Wartość Uwzględnij elementu do dodania.</param>
        <summary>Dodaje element do tego projektu.</summary>
        <returns>Zwraca dodany element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy odpowiedni element, a następnie dodaje go do grupy elementów bez atrybut warunku, ale z przynajmniej jednym elementem tego samego typu. Tworzy nową grupę elementów i dodaje do niej dany element, jeśli żadna taka grupa elementów nie zostanie znaleziona. Elementy są uporządkowane według wartości Uwzględnij.  
  
 Nie działają, jeśli element pasuje do istniejącego wyrażenia z symbolami wieloznacznymi dla elementów tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItem">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemElement AddItem (string itemType, string include, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,string&gt;&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, string&gt;&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItem (itemType As String, include As String, metadata As IEnumerable(Of KeyValuePair(Of String, String))) As ProjectItemElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectItemElement ^ AddItem(System::String ^ itemType, System::String ^ include, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::String ^&gt;&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="member this.AddItem : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, string&gt;&gt; -&gt; Microsoft.Build.Construction.ProjectItemElement" Usage="projectRootElement.AddItem (itemType, include, metadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="include" Type="System.String" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.String&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="itemType">Typ elementu do dodania.</param>
        <param name="include">Wartość Uwzględnij elementu do dodania.</param>
        <param name="metadata">Metadane, które mają zostać dodane.</param>
        <summary>Dodaje element z metadanymi do tego projektu.</summary>
        <returns>Zwraca dodany element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy odpowiedni element, a następnie dodaje go do grupy elementów bez atrybut warunku, ale z przynajmniej jednym elementem tego samego typu. Tworzy nową grupę elementów i dodaje do niej dany element, jeśli żadna taka grupa elementów nie zostanie znaleziona. Elementy są uporządkowane według wartości Uwzględnij.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItemDefinition">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemDefinitionElement AddItemDefinition (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectItemDefinitionElement AddItemDefinition(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddItemDefinition(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemDefinition (itemType As String) As ProjectItemDefinitionElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectItemDefinitionElement ^ AddItemDefinition(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.AddItemDefinition : string -&gt; Microsoft.Build.Construction.ProjectItemDefinitionElement" Usage="projectRootElement.AddItemDefinition itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemDefinitionElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Typ elementu definicji elementu do dodania.</param>
        <summary>Dodaje definicję elementu do tego projektu.</summary>
        <returns>Zwraca definicję dodanego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy odpowiedni element, a następnie dodaje go do grupy elementów bez atrybut warunku, ale z przynajmniej jednym elementem tego samego typu. Tworzy nową grupę elementów i dodaje do niej dany element, jeśli żadna taka grupa elementów nie zostanie znaleziona. Elementy są uporządkowane według wartości Uwzględnij.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItemDefinitionGroup">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemDefinitionGroupElement AddItemDefinitionGroup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectItemDefinitionGroupElement AddItemDefinitionGroup() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddItemDefinitionGroup" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemDefinitionGroup () As ProjectItemDefinitionGroupElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectItemDefinitionGroupElement ^ AddItemDefinitionGroup();" />
      <MemberSignature Language="F#" Value="member this.AddItemDefinitionGroup : unit -&gt; Microsoft.Build.Construction.ProjectItemDefinitionGroupElement" Usage="projectRootElement.AddItemDefinitionGroup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemDefinitionGroupElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dodaje grupie definicji elementów do tego projektu.</summary>
        <returns>Zwraca dodany element grupy definicji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy i dodaje grupie definicji elementów po ostatnie istniejącej grupie definicji elementów, jeśli istnieje. W przeciwnym razie tworzy grupie definicji elementów po ostatniej istniejącej grupie właściwości, jeśli wszystkie. Jeśli żadna grupa właściwość istnieje, tworzy nową grupę definicji elementu, na końcu projektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItemGroup">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemGroupElement AddItemGroup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectItemGroupElement AddItemGroup() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddItemGroup" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemGroup () As ProjectItemGroupElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectItemGroupElement ^ AddItemGroup();" />
      <MemberSignature Language="F#" Value="member this.AddItemGroup : unit -&gt; Microsoft.Build.Construction.ProjectItemGroupElement" Usage="projectRootElement.AddItemGroup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemGroupElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i dodaje grupy elementów do tego projektu.</summary>
        <returns>Zwraca grupę dodanego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy i dodaje grupy elementów po ostatniej istniejące grupy elementów, jeśli istnieją. W przeciwnym razie tworzy grupy elementów po ostatniej istniejącej grupie właściwości, jeśli wszystkie. Jeśli istnieje grupa nie właściwości, tworzy nową grupę elementów na końcu projektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectPropertyElement AddProperty (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectPropertyElement AddProperty(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddProperty(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddProperty (name As String, value As String) As ProjectPropertyElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectPropertyElement ^ AddProperty(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddProperty : string * string -&gt; Microsoft.Build.Construction.ProjectPropertyElement" Usage="projectRootElement.AddProperty (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectPropertyElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości, które ma zostać zaktualizowane lub dodane.</param>
        <param name="value">Wartość właściwości, które ma zostać zaktualizowane lub dodane.</param>
        <summary>Aktualizuje lub dodaje właściwość do tego projektu.</summary>
        <returns>Zwraca właściwość zaktualizowane lub została dodana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ostatnie istniejącej właściwości zostaje zaktualizowana o określonym `name` zawierający atrybut warunku na siebie lub w grupie właściwości, która go zawiera. W przeciwnym razie tworzy właściwość i dodaje go do pierwszej grupy właściwości, która ma atrybut warunku. Jeśli żadna grupa właściwość istnieje, tworzy grupy właściwości po ostatniej istniejącej grupie właściwości, ewentualne i dodaje właściwość do niego. W przeciwnym razie tworzy dodaje grupy właściwości do rozpoczęcia projektu i dodaje właściwość do niego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPropertyGroup">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectPropertyGroupElement AddPropertyGroup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectPropertyGroupElement AddPropertyGroup() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddPropertyGroup" />
      <MemberSignature Language="VB.NET" Value="Public Function AddPropertyGroup () As ProjectPropertyGroupElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectPropertyGroupElement ^ AddPropertyGroup();" />
      <MemberSignature Language="F#" Value="member this.AddPropertyGroup : unit -&gt; Microsoft.Build.Construction.ProjectPropertyGroupElement" Usage="projectRootElement.AddPropertyGroup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectPropertyGroupElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dodaje nową grupę właściwość do tego projektu.</summary>
        <returns>Zwraca grupę dodanej właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy grupę właściwości, a następnie dodaje po ostatniej istniejącej grupie właściwości, jeśli występują. W przeciwnym razie dodaje grupy właściwości do rozpoczęcia projektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddTarget">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectTargetElement AddTarget (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectTargetElement AddTarget(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddTarget(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddTarget (name As String) As ProjectTargetElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectTargetElement ^ AddTarget(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.AddTarget : string -&gt; Microsoft.Build.Construction.ProjectTargetElement" Usage="projectRootElement.AddTarget name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectTargetElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa obiektu docelowego, który ma zostać dodana.</param>
        <summary>Dodaje obiekt docelowy projektu.</summary>
        <returns>Zwraca dodany element docelowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wygodna metoda, która wybiera lokalizację oparciu o heurystykę: tworzy element docelowy na końcu projektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddUsingTask">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectUsingTaskElement AddUsingTask (string name, string assemblyFile, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectUsingTaskElement AddUsingTask(string name, string assemblyFile, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.AddUsingTask(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddUsingTask (name As String, assemblyFile As String, assemblyName As String) As ProjectUsingTaskElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectUsingTaskElement ^ AddUsingTask(System::String ^ name, System::String ^ assemblyFile, System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.AddUsingTask : string * string * string -&gt; Microsoft.Build.Construction.ProjectUsingTaskElement" Usage="projectRootElement.AddUsingTask (name, assemblyFile, assemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectUsingTaskElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zadania.</param>
        <param name="assemblyFile">Ścieżka pliku do zestawu.</param>
        <param name="assemblyName">Nazwa zestawu do załadowania.</param>
        <summary>Dodaje [usingtask — Element (MSBuild)](http://msdn.microsoft.com/library/20247902-9446-4a1f-8253-5c7a17e4fe43) do projektu.</summary>
        <returns>Zwraca dodany element UsingTask.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Albo `assemblyName` lub `assemblyFile` musi mieć wartość null, ale nie oba.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChooseElements">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectChooseElement&gt; ChooseElements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectChooseElement&gt; ChooseElements" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ChooseElements" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChooseElements As ICollection(Of ProjectChooseElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectChooseElement ^&gt; ^ ChooseElements { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectChooseElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChooseElements : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectChooseElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.ChooseElements" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectChooseElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne [wybierz Element (MSBuild)](http://msdn.microsoft.com/library/7b8b025a-d944-4f5c-9018-c89fc2ef146d) w tym projekcie.</summary>
        <value>Zwraca wszystkie podrzędne elementy Wybierz.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public override string Condition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Condition" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.Condition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Condition As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Condition { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Condition : string with get, set" Usage="Microsoft.Build.Construction.ProjectRootElement.Condition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość null, ponieważ atrybut warunku jest nieistniejącej dla tego elementu, a nieistniejącej warunek jest niejawnie ma wartość true.</summary>
        <value>Zwraca wartość null.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConditionLocation">
      <MemberSignature Language="C#" Value="public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation ConditionLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ConditionLocation" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ConditionLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Build::Construction::ElementLocation ^ ConditionLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConditionLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Construction.ProjectRootElement.ConditionLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nie używać. Atrybut warunek jest nieistniejącej dla <see cref="T:Microsoft.Build.Construction.ProjectRootElement" />. Pobierz powoduje wystąpienie błędu wewnętrznego.</summary>
        <value>Zgłasza błąd wewnętrzny i zwraca wartość null.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy i inicjuje puste wystąpienie ProjectRootElement w pamięci i dodaje je do kolekcji projektu globalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Construction.ProjectRootElement Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Construction.ProjectRootElement Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ProjectRootElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Construction::ProjectRootElement ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Construction.ProjectRootElement.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i inicjuje puste wystąpienie ProjectRootElement w pamięci i dodaje je do kolekcji projektu globalnego.</summary>
        <returns>Zwraca katalog główny nowego projektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Construction.ProjectRootElement Create (Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Construction.ProjectRootElement Create(class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Construction::ProjectRootElement ^ Create(Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="static member Create : Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Construction.ProjectRootElement.Create projectCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="projectCollection">Kolekcja projektów, do której ma zostać dodany ten element.</param>
        <summary>Tworzy i inicjuje puste wystąpienie ProjectRootElement w pamięci i dodaje je do kolekcji określonego projektu.</summary>
        <returns>Zwraca katalog główny nowego projektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Construction.ProjectRootElement Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Construction.ProjectRootElement Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As ProjectRootElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Construction::ProjectRootElement ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Construction.ProjectRootElement.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku do danych używanych do inicjacji.</param>
        <summary>Tworzy i inicjuje puste wystąpienie ProjectRootElement w pamięci i dodaje je do kolekcji projektu globalnego. Nowy katalog główny projektu jest inicjowany z danych znalezionych w określonej ścieżce pliku.</summary>
        <returns>Zwraca katalog główny nowego projektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Construction.ProjectRootElement Create (System.Xml.XmlReader xmlReader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Construction.ProjectRootElement Create(class System.Xml.XmlReader xmlReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Construction::ProjectRootElement ^ Create(System::Xml::XmlReader ^ xmlReader);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader -&gt; Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Construction.ProjectRootElement.Create xmlReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="xmlReader">Czytnik XML użyty do inicjowania.</param>
        <summary>Tworzy i inicjuje puste wystąpienie ProjectRootElement w pamięci i dodaje je do kolekcji projektu globalnego. Nowy katalog główny projektu jest inicjowany z danych odczytanych z określonego czytnika XmlReader.</summary>
        <returns>Zwraca katalog główny nowego projektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może zgłaszać InvalidProjectFileException.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Construction.ProjectRootElement Create (string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Construction.ProjectRootElement Create(string path, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Construction::ProjectRootElement ^ Create(System::String ^ path, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="static member Create : string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Construction.ProjectRootElement.Create (path, projectCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku do danych używanych do inicjacji.</param>
        <param name="projectCollection">Kolekcja projektów, do której ma zostać dodany ten element.</param>
        <summary>Tworzy i inicjuje puste wystąpienie ProjectRootElement w pamięci i dodaje je do kolekcji określonego projektu. Nowy katalog główny projektu jest inicjowany z danych znalezionych w określonej ścieżce pliku.</summary>
        <returns>Zwraca katalog główny nowego projektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Construction.ProjectRootElement Create (System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Construction.ProjectRootElement Create(class System.Xml.XmlReader xmlReader, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Construction::ProjectRootElement ^ Create(System::Xml::XmlReader ^ xmlReader, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Construction.ProjectRootElement.Create (xmlReader, projectCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="xmlReader">Czytnik XML użyty do inicjowania.</param>
        <param name="projectCollection">Kolekcja projektów, do której ma zostać dodany ten element.</param>
        <summary>Tworzy i inicjuje puste wystąpienie ProjectRootElement w pamięci i dodaje je do kolekcji określonego projektu. Nowy katalog główny projektu jest inicjowany z danych odczytanych z określonego czytnika XmlReader.</summary>
        <returns>Zwraca katalog główny nowego projektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może zgłaszać InvalidProjectFileException.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateChooseElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectChooseElement CreateChooseElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectChooseElement CreateChooseElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateChooseElement" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateChooseElement () As ProjectChooseElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectChooseElement ^ CreateChooseElement();" />
      <MemberSignature Language="F#" Value="member this.CreateChooseElement : unit -&gt; Microsoft.Build.Construction.ProjectChooseElement" Usage="projectRootElement.CreateChooseElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectChooseElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy [Choose — Element (MSBuild)](http://msdn.microsoft.com/library/7b8b025a-d944-4f5c-9018-c89fc2ef146d).</summary>
        <returns>Element <see cref="T:Microsoft.Build.Construction.ProjectChooseElement" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać element wybierz do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateImportElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectImportElement CreateImportElement (string project);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectImportElement CreateImportElement(string project) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateImportElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateImportElement (project As String) As ProjectImportElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectImportElement ^ CreateImportElement(System::String ^ project);" />
      <MemberSignature Language="F#" Value="member this.CreateImportElement : string -&gt; Microsoft.Build.Construction.ProjectImportElement" Usage="projectRootElement.CreateImportElement project" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectImportElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="project" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="project">Projekt, który ma zostać zaimportowany.</param>
        <summary>Tworzy [Import — Element (MSBuild)](http://msdn.microsoft.com/library/3bfecaf1-69fd-4008-b651-c9dafd4389d9).</summary>
        <returns>Zwraca element Import utworzono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać Import element do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateImportGroupElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectImportGroupElement CreateImportGroupElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectImportGroupElement CreateImportGroupElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateImportGroupElement" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateImportGroupElement () As ProjectImportGroupElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectImportGroupElement ^ CreateImportGroupElement();" />
      <MemberSignature Language="F#" Value="member this.CreateImportGroupElement : unit -&gt; Microsoft.Build.Construction.ProjectImportGroupElement" Usage="projectRootElement.CreateImportGroupElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectImportGroupElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy grupę importu.</summary>
        <returns>Zwraca grupy importu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać grupy importu do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateItemDefinitionElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemDefinitionElement CreateItemDefinitionElement (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectItemDefinitionElement CreateItemDefinitionElement(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateItemDefinitionElement (itemType As String) As ProjectItemDefinitionElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectItemDefinitionElement ^ CreateItemDefinitionElement(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.CreateItemDefinitionElement : string -&gt; Microsoft.Build.Construction.ProjectItemDefinitionElement" Usage="projectRootElement.CreateItemDefinitionElement itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemDefinitionElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Typ elementu definicji elementu.</param>
        <summary>Tworzy definicję elementu.</summary>
        <returns>Zwraca definicji elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać definicję elementu do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateItemDefinitionGroupElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionGroupElement" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateItemDefinitionGroupElement () As ProjectItemDefinitionGroupElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectItemDefinitionGroupElement ^ CreateItemDefinitionGroupElement();" />
      <MemberSignature Language="F#" Value="member this.CreateItemDefinitionGroupElement : unit -&gt; Microsoft.Build.Construction.ProjectItemDefinitionGroupElement" Usage="projectRootElement.CreateItemDefinitionGroupElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemDefinitionGroupElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy grupie definicji elementów.</summary>
        <returns>Zwraca grupie definicji elementów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać grupie definicji elementów do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateItemElement">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateItemElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemElement CreateItemElement (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectItemElement CreateItemElement(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateItemElement (itemType As String) As ProjectItemElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectItemElement ^ CreateItemElement(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.CreateItemElement : string -&gt; Microsoft.Build.Construction.ProjectItemElement" Usage="projectRootElement.CreateItemElement itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Typ elementu danego elementu.</param>
        <summary>Tworzy element.</summary>
        <returns>Zwraca element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać element do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateItemElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemElement CreateItemElement (string itemType, string include);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectItemElement CreateItemElement(string itemType, string include) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateItemElement (itemType As String, include As String) As ProjectItemElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectItemElement ^ CreateItemElement(System::String ^ itemType, System::String ^ include);" />
      <MemberSignature Language="F#" Value="member this.CreateItemElement : string * string -&gt; Microsoft.Build.Construction.ProjectItemElement" Usage="projectRootElement.CreateItemElement (itemType, include)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="include" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Typ elementu danego elementu.</param>
        <param name="include">Wartość Uwzględnij elementu.</param>
        <summary>Tworzy element z określonego Włącz wartość.</summary>
        <returns>Zwraca element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać element do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateItemGroupElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemGroupElement CreateItemGroupElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectItemGroupElement CreateItemGroupElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateItemGroupElement" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateItemGroupElement () As ProjectItemGroupElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectItemGroupElement ^ CreateItemGroupElement();" />
      <MemberSignature Language="F#" Value="member this.CreateItemGroupElement : unit -&gt; Microsoft.Build.Construction.ProjectItemGroupElement" Usage="projectRootElement.CreateItemGroupElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemGroupElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy grupy elementów.</summary>
        <returns>Zwraca grupy elementów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać grupy elementów do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateMetadataElement">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy węzeł metadanych o określonej nazwie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateMetadataElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateMetadataElement (name As String) As ProjectMetadataElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectMetadataElement ^ CreateMetadataElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateMetadataElement : string -&gt; Microsoft.Build.Construction.ProjectMetadataElement" Usage="projectRootElement.CreateMetadataElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectMetadataElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metadanych.</param>
        <summary>Tworzy węzeł metadanych o określonej nazwie.</summary>
        <returns>Zwraca węzeł metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać węzeł metadanych do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMetadataElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement (string name, string unevaluatedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateMetadataElement (name As String, unevaluatedValue As String) As ProjectMetadataElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectMetadataElement ^ CreateMetadataElement(System::String ^ name, System::String ^ unevaluatedValue);" />
      <MemberSignature Language="F#" Value="member this.CreateMetadataElement : string * string -&gt; Microsoft.Build.Construction.ProjectMetadataElement" Usage="projectRootElement.CreateMetadataElement (name, unevaluatedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectMetadataElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="unevaluatedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metadanych.</param>
        <param name="unevaluatedValue">Wartość metadanych.</param>
        <summary>Tworzy węzeł metadanych z określoną nazwą i wartością.</summary>
        <returns>Zwraca element metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać węzeł metadanych do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateOnErrorElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectOnErrorElement CreateOnErrorElement (string executeTargets);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectOnErrorElement CreateOnErrorElement(string executeTargets) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateOnErrorElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateOnErrorElement (executeTargets As String) As ProjectOnErrorElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectOnErrorElement ^ CreateOnErrorElement(System::String ^ executeTargets);" />
      <MemberSignature Language="F#" Value="member this.CreateOnErrorElement : string -&gt; Microsoft.Build.Construction.ProjectOnErrorElement" Usage="projectRootElement.CreateOnErrorElement executeTargets" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectOnErrorElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="executeTargets" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="executeTargets">Cele do wykonania, jeśli zadanie nie powiedzie się.</param>
        <summary>Tworzy [OnError — Element (MSBuild)](http://msdn.microsoft.com/library/765767d3-ecb7-4cd9-ba1e-d9468964dddc).</summary>
        <returns>Zwraca OnError — element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać OnError — element do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateOtherwiseElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectOtherwiseElement CreateOtherwiseElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectOtherwiseElement CreateOtherwiseElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateOtherwiseElement" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateOtherwiseElement () As ProjectOtherwiseElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectOtherwiseElement ^ CreateOtherwiseElement();" />
      <MemberSignature Language="F#" Value="member this.CreateOtherwiseElement : unit -&gt; Microsoft.Build.Construction.ProjectOtherwiseElement" Usage="projectRootElement.CreateOtherwiseElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectOtherwiseElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy [Otherwise — Element (MSBuild)](http://msdn.microsoft.com/library/de3997e9-1595-4263-a886-95530b56a319). Obiekt wywołujący musi dodać go do wybranej lokalizacji w projekcie.</summary>
        <returns>Zwraca element przeciwnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać element przeciwnym do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateOutputElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectOutputElement CreateOutputElement (string taskParameter, string itemType, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectOutputElement CreateOutputElement(string taskParameter, string itemType, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateOutputElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateOutputElement (taskParameter As String, itemType As String, propertyName As String) As ProjectOutputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectOutputElement ^ CreateOutputElement(System::String ^ taskParameter, System::String ^ itemType, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.CreateOutputElement : string * string * string -&gt; Microsoft.Build.Construction.ProjectOutputElement" Usage="projectRootElement.CreateOutputElement (taskParameter, itemType, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectOutputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="taskParameter" Type="System.String" />
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="taskParameter">Nazwa zadania przez parametr danych wyjściowych.</param>
        <param name="itemType">Element, który odbiera zadanie danych wyjściowych wartość parametru.</param>
        <param name="propertyName">Właściwość, która odbiera zadanie danych wyjściowych wartość parametru.</param>
        <summary>Tworzy [Output, Element (MSBuild)](http://msdn.microsoft.com/library/34bc7cd1-efd3-4b57-b691-4584eeb6a0e9).</summary>
        <returns>Zwraca element danych wyjściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać element danych wyjściowych do wybranej lokalizacji w projekcie. ItemType lub propertyName musi być określony, ale nie oba.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateProjectExtensionsElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectExtensionsElement CreateProjectExtensionsElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectExtensionsElement CreateProjectExtensionsElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateProjectExtensionsElement" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectExtensionsElement () As ProjectExtensionsElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectExtensionsElement ^ CreateProjectExtensionsElement();" />
      <MemberSignature Language="F#" Value="member this.CreateProjectExtensionsElement : unit -&gt; Microsoft.Build.Construction.ProjectExtensionsElement" Usage="projectRootElement.CreateProjectExtensionsElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectExtensionsElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy [projectextensions — Element (MSBuild)](http://msdn.microsoft.com/library/f95f312f-ff92-41eb-9469-ad99e236a307).</summary>
        <returns>Zwraca projectextensions — element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać projectextensions — element do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatePropertyElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectPropertyElement CreatePropertyElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectPropertyElement CreatePropertyElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreatePropertyElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePropertyElement (name As String) As ProjectPropertyElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectPropertyElement ^ CreatePropertyElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreatePropertyElement : string -&gt; Microsoft.Build.Construction.ProjectPropertyElement" Usage="projectRootElement.CreatePropertyElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectPropertyElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości.</param>
        <summary>Tworzy właściwość.</summary>
        <returns>Zwraca właściwość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać właściwości do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatePropertyGroupElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectPropertyGroupElement CreatePropertyGroupElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectPropertyGroupElement CreatePropertyGroupElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreatePropertyGroupElement" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePropertyGroupElement () As ProjectPropertyGroupElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectPropertyGroupElement ^ CreatePropertyGroupElement();" />
      <MemberSignature Language="F#" Value="member this.CreatePropertyGroupElement : unit -&gt; Microsoft.Build.Construction.ProjectPropertyGroupElement" Usage="projectRootElement.CreatePropertyGroupElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectPropertyGroupElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy grupę właściwości.</summary>
        <returns>Zwraca właściwości grupy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać grupy właściwości do wybranej lokalizacji w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTargetElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectTargetElement CreateTargetElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectTargetElement CreateTargetElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateTargetElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTargetElement (name As String) As ProjectTargetElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectTargetElement ^ CreateTargetElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateTargetElement : string -&gt; Microsoft.Build.Construction.ProjectTargetElement" Usage="projectRootElement.CreateTargetElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectTargetElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu docelowego.</param>
        <summary>Tworzy element docelowy.</summary>
        <returns>Zwraca element docelowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać element docelowy na lokalizację, w tym projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTaskElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectTaskElement CreateTaskElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectTaskElement CreateTaskElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateTaskElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTaskElement (name As String) As ProjectTaskElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectTaskElement ^ CreateTaskElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateTaskElement : string -&gt; Microsoft.Build.Construction.ProjectTaskElement" Usage="projectRootElement.CreateTaskElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectTaskElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zadania.</param>
        <summary>Tworzy zadanie.</summary>
        <returns>Zwraca zadanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać zadanie do lokalizacji pliku wybranego w tym projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUsingTaskBodyElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectUsingTaskBodyElement CreateUsingTaskBodyElement (string evaluate, string body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectUsingTaskBodyElement CreateUsingTaskBodyElement(string evaluate, string body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskBodyElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUsingTaskBodyElement (evaluate As String, body As String) As ProjectUsingTaskBodyElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectUsingTaskBodyElement ^ CreateUsingTaskBodyElement(System::String ^ evaluate, System::String ^ body);" />
      <MemberSignature Language="F#" Value="member this.CreateUsingTaskBodyElement : string * string -&gt; Microsoft.Build.Construction.ProjectUsingTaskBodyElement" Usage="projectRootElement.CreateUsingTaskBodyElement (evaluate, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectUsingTaskBodyElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluate" Type="System.String" />
        <Parameter Name="body" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="evaluate">Ciąg do oceny.</param>
        <param name="body">Jednostka do dodania.</param>
        <summary>Tworzy zadanie, aby odwoływać się [usingtask — Element (MSBuild)](http://msdn.microsoft.com/library/20247902-9446-4a1f-8253-5c7a17e4fe43).</summary>
        <returns>Zwraca zadanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać zadanie do elementu UsingTask wybór w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateUsingTaskElement">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje [usingtask — Element (MSBuild)](http://msdn.microsoft.com/library/20247902-9446-4a1f-8253-5c7a17e4fe43) do projektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateUsingTaskElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectUsingTaskElement CreateUsingTaskElement (string taskName, string assemblyFile, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUsingTaskElement (taskName As String, assemblyFile As String, assemblyName As String) As ProjectUsingTaskElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectUsingTaskElement ^ CreateUsingTaskElement(System::String ^ taskName, System::String ^ assemblyFile, System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.CreateUsingTaskElement : string * string * string -&gt; Microsoft.Build.Construction.ProjectUsingTaskElement" Usage="projectRootElement.CreateUsingTaskElement (taskName, assemblyFile, assemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectUsingTaskElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="taskName" Type="System.String" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="taskName">Nazwa zadania.</param>
        <param name="assemblyFile">Ścieżka pliku do zestawu.</param>
        <param name="assemblyName">Nazwa zestawu do załadowania.</param>
        <summary>Dodaje [usingtask — Element (MSBuild)](http://msdn.microsoft.com/library/20247902-9446-4a1f-8253-5c7a17e4fe43) do projektu.</summary>
        <returns>Zwraca element UsingTask.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać element UsingTask do wybranej lokalizacji w projekcie. Albo `assemblyName` lub `assemblyFile` musi mieć wartość null, ale nie oba.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUsingTaskElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectUsingTaskElement CreateUsingTaskElement (string taskName, string assemblyFile, string assemblyName, string runtime, string architecture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUsingTaskElement (taskName As String, assemblyFile As String, assemblyName As String, runtime As String, architecture As String) As ProjectUsingTaskElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectUsingTaskElement ^ CreateUsingTaskElement(System::String ^ taskName, System::String ^ assemblyFile, System::String ^ assemblyName, System::String ^ runtime, System::String ^ architecture);" />
      <MemberSignature Language="F#" Value="member this.CreateUsingTaskElement : string * string * string * string * string -&gt; Microsoft.Build.Construction.ProjectUsingTaskElement" Usage="projectRootElement.CreateUsingTaskElement (taskName, assemblyFile, assemblyName, runtime, architecture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectUsingTaskElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="taskName" Type="System.String" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="runtime" Type="System.String" />
        <Parameter Name="architecture" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="taskName">Nazwa zadania.</param>
        <param name="assemblyFile">Ścieżka pliku do zestawu.</param>
        <param name="assemblyName">Nazwa zestawu do załadowania.</param>
        <param name="runtime">Specyfikator opcjonalne środowiska uruchomieniowego.</param>
        <param name="architecture">Architektura opcjonalny specyfikator.</param>
        <summary>Dodaje [usingtask — Element (MSBuild)](http://msdn.microsoft.com/library/20247902-9446-4a1f-8253-5c7a17e4fe43) do projektu.</summary>
        <returns>Zwraca element UsingTask.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać element UsingTask do wybranej lokalizacji w projekcie. Albo `assemblyName` lub `assemblyFile` musi mieć wartość null, ale nie oba. Zarówno `runtime` i `architecture` może mieć wartości null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUsingTaskParameterElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectUsingTaskParameterElement CreateUsingTaskParameterElement (string name, string output, string required, string parameterType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectUsingTaskParameterElement CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterElement(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUsingTaskParameterElement (name As String, output As String, required As String, parameterType As String) As ProjectUsingTaskParameterElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectUsingTaskParameterElement ^ CreateUsingTaskParameterElement(System::String ^ name, System::String ^ output, System::String ^ required, System::String ^ parameterType);" />
      <MemberSignature Language="F#" Value="member this.CreateUsingTaskParameterElement : string * string * string * string -&gt; Microsoft.Build.Construction.ProjectUsingTaskParameterElement" Usage="projectRootElement.CreateUsingTaskParameterElement (name, output, required, parameterType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectUsingTaskParameterElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="output" Type="System.String" />
        <Parameter Name="required" Type="System.String" />
        <Parameter Name="parameterType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa <c>UsingTask</c> elementu.</param>
        <param name="output">Magazyny danych wyjściowych z zadania w pliku projektu.</param>
        <param name="required">Parametr zadania zdefiniowane przez użytkownika, który zawiera wartość parametru jako jego wartość.</param>
        <param name="parameterType">Typ parametru.</param>
        <summary>Tworzy parametr do użycia w [usingtask — Element (MSBuild)](http://msdn.microsoft.com/library/20247902-9446-4a1f-8253-5c7a17e4fe43) grupy parametrów.</summary>
        <returns>Zwraca wartość parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać parametr do UsingTask parametru wybranej grupy w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUsingTaskParameterGroupElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterGroupElement" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUsingTaskParameterGroupElement () As UsingTaskParameterGroupElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::UsingTaskParameterGroupElement ^ CreateUsingTaskParameterGroupElement();" />
      <MemberSignature Language="F#" Value="member this.CreateUsingTaskParameterGroupElement : unit -&gt; Microsoft.Build.Construction.UsingTaskParameterGroupElement" Usage="projectRootElement.CreateUsingTaskParameterGroupElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.UsingTaskParameterGroupElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy grupę parametrów dla [usingtask — Element (MSBuild)](http://msdn.microsoft.com/library/20247902-9446-4a1f-8253-5c7a17e4fe43).</summary>
        <returns>Zwraca grupy parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać grupy parametr do elementu UsingTask wybór w projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWhenElement">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectWhenElement CreateWhenElement (string condition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Construction.ProjectWhenElement CreateWhenElement(string condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.CreateWhenElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWhenElement (condition As String) As ProjectWhenElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Construction::ProjectWhenElement ^ CreateWhenElement(System::String ^ condition);" />
      <MemberSignature Language="F#" Value="member this.CreateWhenElement : string -&gt; Microsoft.Build.Construction.ProjectWhenElement" Usage="projectRootElement.CreateWhenElement condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectWhenElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Wartość atrybutu warunku.</param>
        <summary>Tworzy [podczas — Element (MSBuild)](http://msdn.microsoft.com/library/eb27de6f-4e71-4e87-87e2-d93f7bf5899c) przy użyciu określonego atrybutu warunku.</summary>
        <returns>Zwraca po elemencie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący musi dodać po element do wybranej lokalizacji w tym projekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultTargets">
      <MemberSignature Language="C#" Value="public string DefaultTargets { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultTargets" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.DefaultTargets" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultTargets As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultTargets { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultTargets : string with get, set" Usage="Microsoft.Build.Construction.ProjectRootElement.DefaultTargets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość defaulttargets — atrybut.</summary>
        <value>Zwraca wartość defaulttargets — atrybut. Zwraca pusty ciąg, jeśli nie ma atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usuwa defaulttargets — atrybut, jeśli wartość ustawiana jest ciągiem pustym ani wartością null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultTargetsLocation">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation DefaultTargetsLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation DefaultTargetsLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.DefaultTargetsLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultTargetsLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ DefaultTargetsLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultTargetsLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Construction.ProjectRootElement.DefaultTargetsLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lokalizacja defaulttargets — atrybut w tym elemencie, jeśli istnieje.</summary>
        <value>Zwraca lokalizację defaulttargets — atrybut. Jeśli nie ma takiego atrybutu, zwracana jest wartość null.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może nie być poprawne, jeśli plik nie jest zapisywany lub został zmodyfikowany od czasu ostatniego zapisania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectoryPath">
      <MemberSignature Language="C#" Value="public string DirectoryPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.DirectoryPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectoryPath : string" Usage="Microsoft.Build.Construction.ProjectRootElement.DirectoryPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę katalogu do pliku projektu.</summary>
        <value>Zwraca ścieżkę katalogu, który nigdy nie ma wartość null. Jeśli projekt nie został załadowany z dysku, zwraca bieżący katalog, w czasie, który został załadowany projekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wymagany do oceny ścieżek względnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding" Usage="Microsoft.Build.Construction.ProjectRootElement.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa kodowanie znaków, który jest zapisana w pliku projektu.</summary>
        <value>Zwraca znak kodowania, to można zapisać w pliku projektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwraca kodowanie określone przez deklarację Xml w pliku projektu. Kodowanie nie jest określony, wartość domyślna to UTF-8.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullPath">
      <MemberSignature Language="C#" Value="public string FullPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.FullPath" />
      <MemberSignature Language="VB.NET" Value="Public Property FullPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FullPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FullPath : string with get, set" Usage="Microsoft.Build.Construction.ProjectRootElement.FullPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną ścieżkę do pliku projektu.</summary>
        <value>Zwraca pełną ścieżkę do pliku projektu. Jeśli projekt nie został załadowany z dysku, zwraca wartość null.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasUnsavedChanges">
      <MemberSignature Language="C#" Value="public bool HasUnsavedChanges { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasUnsavedChanges" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.HasUnsavedChanges" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasUnsavedChanges As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasUnsavedChanges { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasUnsavedChanges : bool" Usage="Microsoft.Build.Construction.ProjectRootElement.HasUnsavedChanges" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy projekt został zmodyfikowany, ponieważ została ostatnio ładowania lub zapisywania.</summary>
        <value>Zwraca wartość PRAWDA, jeśli projekt został zmodyfikowany; wartość false w przeciwnym razie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportGroups">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectImportGroupElement&gt; ImportGroups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectImportGroupElement&gt; ImportGroups" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ImportGroups" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ImportGroups As ICollection(Of ProjectImportGroupElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectImportGroupElement ^&gt; ^ ImportGroups { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectImportGroupElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImportGroups : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectImportGroupElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.ImportGroups" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectImportGroupElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne grupy importu w tym projekcie.</summary>
        <value>Zwraca wszystkich grup podrzędnych importu w tym projekcie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportGroupsReversed">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectImportGroupElement&gt; ImportGroupsReversed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectImportGroupElement&gt; ImportGroupsReversed" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ImportGroupsReversed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ImportGroupsReversed As ICollection(Of ProjectImportGroupElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectImportGroupElement ^&gt; ^ ImportGroupsReversed { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectImportGroupElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImportGroupsReversed : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectImportGroupElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.ImportGroupsReversed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectImportGroupElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne grupy importu w tym projekcie, rozpoczynając od ostatniego grupy.</summary>
        <value>Zwraca wszystkie podrzędne zaimportować grupy w tym projekcie, rozpoczynające się od ostatniej grupy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imports">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectImportElement&gt; Imports { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectImportElement&gt; Imports" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.Imports" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imports As ICollection(Of ProjectImportElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectImportElement ^&gt; ^ Imports { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectImportElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Imports : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectImportElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.Imports" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectImportElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne elementy importu w tym projekcie.</summary>
        <value>Pobiera wszystkie podrzędne elementy importu w tym projekcie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitialTargets">
      <MemberSignature Language="C#" Value="public string InitialTargets { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InitialTargets" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.InitialTargets" />
      <MemberSignature Language="VB.NET" Value="Public Property InitialTargets As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InitialTargets { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InitialTargets : string with get, set" Usage="Microsoft.Build.Construction.ProjectRootElement.InitialTargets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość atrybutu InitialTargets.</summary>
        <value>Zwraca wartość atrybutu InitialTargets. Zwraca pusty ciąg, jeśli nie ma atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usuwa atrybut InitialTargets, jeśli wartość ustawiana jest ciągiem pustym ani wartością null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitialTargetsLocation">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation InitialTargetsLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation InitialTargetsLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.InitialTargetsLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InitialTargetsLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ InitialTargetsLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InitialTargetsLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Construction.ProjectRootElement.InitialTargetsLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lokalizacja atrybutu InitialTargets dla tego elementu, jeśli istnieje.</summary>
        <value>Zwraca lokalizację atrybutu InitialTargets. Jeśli nie ma takiego atrybutu, zwracana jest wartość null.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemDefinitionGroups">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemDefinitionGroupElement&gt; ItemDefinitionGroups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectItemDefinitionGroupElement&gt; ItemDefinitionGroups" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroups" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemDefinitionGroups As ICollection(Of ProjectItemDefinitionGroupElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemDefinitionGroupElement ^&gt; ^ ItemDefinitionGroups { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemDefinitionGroupElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemDefinitionGroups : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemDefinitionGroupElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroups" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemDefinitionGroupElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkich podrzędnych grupach definicji elementów, w tym projekcie.</summary>
        <value>Zwraca wszystkich podrzędnych grupach definicji elementów, w tym projekcie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemDefinitionGroupsReversed">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemDefinitionGroupElement&gt; ItemDefinitionGroupsReversed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectItemDefinitionGroupElement&gt; ItemDefinitionGroupsReversed" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroupsReversed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemDefinitionGroupsReversed As ICollection(Of ProjectItemDefinitionGroupElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemDefinitionGroupElement ^&gt; ^ ItemDefinitionGroupsReversed { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemDefinitionGroupElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemDefinitionGroupsReversed : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemDefinitionGroupElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroupsReversed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemDefinitionGroupElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkich podrzędnych grupach definicji elementów, w tym projekcie, rozpoczynając od ostatniego grupy.</summary>
        <value>Zwraca podrzędny element grupy definicji w tym projekcie, rozpoczynając od ostatniego grupy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemDefinitions">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemDefinitionElement&gt; ItemDefinitions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectItemDefinitionElement&gt; ItemDefinitions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ItemDefinitions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemDefinitions As ICollection(Of ProjectItemDefinitionElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemDefinitionElement ^&gt; ^ ItemDefinitions { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemDefinitionElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemDefinitions : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemDefinitionElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.ItemDefinitions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemDefinitionElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie definicje podrzędnych elementów we wszystkich grupach definicji elementów w całym projekcie.</summary>
        <value>Pobiera wszystkie definicje podrzędnych elementów we wszystkich grupach definicji elementów w całym projekcie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemGroups">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemGroupElement&gt; ItemGroups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectItemGroupElement&gt; ItemGroups" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ItemGroups" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemGroups As ICollection(Of ProjectItemGroupElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemGroupElement ^&gt; ^ ItemGroups { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemGroupElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemGroups : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemGroupElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.ItemGroups" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemGroupElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne grupy elementów, w tym projekcie.</summary>
        <value>Zwraca wszystkie podrzędne grupy elementów, w tym projekcie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie obejmuje żadnych grup elementów zawartych w Wybierz elementy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemGroupsReversed">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemGroupElement&gt; ItemGroupsReversed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectItemGroupElement&gt; ItemGroupsReversed" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ItemGroupsReversed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemGroupsReversed As ICollection(Of ProjectItemGroupElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemGroupElement ^&gt; ^ ItemGroupsReversed { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemGroupElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemGroupsReversed : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemGroupElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.ItemGroupsReversed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemGroupElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne grupy element istnieje w tym projekcie rozpoczynające się od ostatniej grupy.</summary>
        <value>Zwraca wszystkie podrzędne grupy element istnieje w tym projekcie rozpoczynające się od ostatniej grupy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie obejmuje żadnych grup elementów zawartych w Wybierz elementy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemElement&gt; Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectItemElement&gt; Items" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ICollection(Of ProjectItemElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemElement ^&gt; ^ Items { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectItemElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectItemElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie elementy podrzędne, w tym projekcie.</summary>
        <value>Zwraca wszystkie elementy podrzędne w tym projekcie, nawet wtedy, gdy są zawarte w wybierz elementy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastWriteTimeWhenRead">
      <MemberSignature Language="C#" Value="public DateTime LastWriteTimeWhenRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastWriteTimeWhenRead" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.LastWriteTimeWhenRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastWriteTimeWhenRead As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastWriteTimeWhenRead { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastWriteTimeWhenRead : DateTime" Usage="Microsoft.Build.Construction.ProjectRootElement.LastWriteTimeWhenRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ostatni czas zapisu pliku projektu.</summary>
        <value>Pobiera ostatni czas zapisu pliku projektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może służyć do określenia, czy plik został zmieniony na dysku przez proces innej niż procesu programu MSBuild.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera główny projekt w kolekcji globalnego projektu za pomocą załadowania danych z określonej ścieżki pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Construction.ProjectRootElement Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Construction.ProjectRootElement Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As ProjectRootElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Construction::ProjectRootElement ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Construction.ProjectRootElement.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku do danych.</param>
        <summary>Pobiera główny projekt w kolekcji globalnego projektu za pomocą załadowania danych z określonej ścieżki pliku.</summary>
        <returns>Zwraca zainicjowany katalog główny projektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może zgłaszać InvalidProjectFileException.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Construction.ProjectRootElement Open (string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Construction.ProjectRootElement Open(string path, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Open(System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Construction::ProjectRootElement ^ Open(System::String ^ path, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="static member Open : string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Construction.ProjectRootElement.Open (path, projectCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku do danych.</param>
        <param name="projectCollection">Kolekcja projektów, zawierający projekt do zainicjowania.</param>
        <summary>Pobiera główny projekt w kolekcji określonego projektu za pomocą załadowania danych z określonej ścieżki pliku.</summary>
        <returns>Zwraca zainicjowany katalog główny projektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Może zgłaszać InvalidProjectFileException.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectFileLocation">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation ProjectFileLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProjectFileLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ ProjectFileLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProjectFileLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lokalizacja źródłowym pliku sam nie są ustawiane określoną zawartość w niej. Jeśli plik nie ma nazwę, jest pustą lokalizację. Jest to uzasadnione przypadku posiadanie żadnej lokalizacji.</summary>
        <value>Zwraca lokalizację pliku źródłowego lub pustą lokalizację.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectPropertyElement&gt; Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectPropertyElement&gt; Properties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As ICollection(Of ProjectPropertyElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectPropertyElement ^&gt; ^ Properties { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectPropertyElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectPropertyElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectPropertyElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne właściwości, w tym projekcie.</summary>
        <value>Zwraca wszystkie właściwości podrzędnej w tym projekcie, nawet wtedy, gdy są zawarte w wybierz elementy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyGroups">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectPropertyGroupElement&gt; PropertyGroups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectPropertyGroupElement&gt; PropertyGroups" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.PropertyGroups" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyGroups As ICollection(Of ProjectPropertyGroupElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectPropertyGroupElement ^&gt; ^ PropertyGroups { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectPropertyGroupElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyGroups : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectPropertyGroupElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.PropertyGroups" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectPropertyGroupElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne grupy właściwości, w tym projekcie.</summary>
        <value>Zwraca wszystkie podrzędne grupy właściwości, w tym projekcie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie obejmuje żadnych grup elementów zawartych w Wybierz elementy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyGroupsReversed">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectPropertyGroupElement&gt; PropertyGroupsReversed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectPropertyGroupElement&gt; PropertyGroupsReversed" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.PropertyGroupsReversed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyGroupsReversed As ICollection(Of ProjectPropertyGroupElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectPropertyGroupElement ^&gt; ^ PropertyGroupsReversed { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectPropertyGroupElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyGroupsReversed : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectPropertyGroupElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.PropertyGroupsReversed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectPropertyGroupElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne grupy właściwości obecne w tym projekcie rozpoczynające się od ostatniej grupy.</summary>
        <value>Zwraca wszystkie podrzędne grupy właściwości obecne w tym projekcie rozpoczynające się od ostatniej grupy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie obejmuje żadnych grup elementów zawartych w Wybierz elementy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RawXml">
      <MemberSignature Language="C#" Value="public string RawXml { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawXml" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.RawXml" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawXml { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawXml : string" Usage="Microsoft.Build.Construction.ProjectRootElement.RawXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dane XML zawartości, który reprezentuje ten projekt.</summary>
        <value>Plik XML zwraca zawartości, który reprezentuje tego projektu jako ciąg.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznaczaj zawartość jako niezmodyfikowany. Model obiektów programu MSBuild zapewnia jedyny sposób, aby uzyskać dostęp do zawartości XML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje projekt do systemu plików, jeśli został zmodyfikowany.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Save" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save();" />
      <MemberSignature Language="F#" Value="member this.Save : unit -&gt; unit" Usage="projectRootElement.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje projekt do systemu plików, jeśli został zmodyfikowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa znaku, kodowanie zwracana przez właściwość kodowania. Oznacza projekt jako niezmodyfikowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="projectRootElement.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Składnik zapisywania tekstu do zapisania projektu.</param>
        <summary>Zapisuje projekt określonym składniku zapisywania tekstu, czy zmodyfikowany lub nie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa kodowania znaków TextWriter. Oznacza projekt jako niezmodyfikowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="projectRootElement.Save path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku do projektu w magazynie.</param>
        <summary>Zapisuje projekt, jeśli został zmodyfikowany lub jeśli zmieniono ścieżkę pliku do przechowywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznacza projekt jako niezmodyfikowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Text.Encoding saveEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Text.Encoding saveEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Save(System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (saveEncoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Text::Encoding ^ saveEncoding);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Text.Encoding -&gt; unit" Usage="projectRootElement.Save saveEncoding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="saveEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="saveEncoding">Kodowanie znaków użyte do zapisania projektu.</param>
        <summary>Zapisuje projekt, w przypadku modyfikowania przy użyciu kodowania określonego znaku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznacza projekt jako niezmodyfikowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.Save(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Text.Encoding -&gt; unit" Usage="projectRootElement.Save (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku do projektu w magazynie.</param>
        <param name="encoding">Kodowanie znaków użyte do zapisania projektu.</param>
        <summary>Zapisuje projekt, jeśli został zmodyfikowany lub jeśli zmieniono ścieżkę pliku do przechowywania. Używa kodowania określony znak...</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznacza projekt jako niezmodyfikowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Targets">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectTargetElement&gt; Targets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectTargetElement&gt; Targets" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.Targets" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Targets As ICollection(Of ProjectTargetElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectTargetElement ^&gt; ^ Targets { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectTargetElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Targets : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectTargetElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.Targets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectTargetElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne elementy docelowe, w tym projekcie.</summary>
        <value>Zwraca wszystkie podrzędne elementy docelowe, w tym projekcie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeLastChanged">
      <MemberSignature Language="C#" Value="public DateTime TimeLastChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime TimeLastChanged" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.TimeLastChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeLastChanged As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime TimeLastChanged { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeLastChanged : DateTime" Usage="Microsoft.Build.Construction.ProjectRootElement.TimeLastChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas ostatniej modyfikacji tego projektu.</summary>
        <value>Zwraca czas ostatniej modyfikacji tego projektu. Zwraca wartość null, jeśli projekt nie został zmodyfikowany od czasu jest utworzony lub załadowany.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolsVersion">
      <MemberSignature Language="C#" Value="public string ToolsVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ToolsVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ToolsVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolsVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ToolsVersion { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolsVersion : string with get, set" Usage="Microsoft.Build.Construction.ProjectRootElement.ToolsVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość atrybutu ToolsVersion.</summary>
        <value>Zwraca wartość atrybutu ToolsVersion. Zwraca pusty ciąg, jeśli nie ma atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usuwa atrybut ToolsVersion, jeśli wartość ustawiana jest ciągiem pustym ani wartością null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolsVersionLocation">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation ToolsVersionLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation ToolsVersionLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.ToolsVersionLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ToolsVersionLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ ToolsVersionLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToolsVersionLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Construction.ProjectRootElement.ToolsVersionLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lokalizacja atrybut ToolsVersion, w tym elemencie, jeśli istnieje.</summary>
        <value>Zwraca lokalizację atrybutu ToolsVersion. Jeśli nie ma takiego atrybutu, zwracana jest wartość null.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TreatAsLocalProperty">
      <MemberSignature Language="C#" Value="public string TreatAsLocalProperty { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TreatAsLocalProperty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty" />
      <MemberSignature Language="VB.NET" Value="Public Property TreatAsLocalProperty As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TreatAsLocalProperty { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TreatAsLocalProperty : string with get, set" Usage="Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość atrybutu TreatAsLocalProperty.</summary>
        <value>Zwraca wartość atrybutu TreatAsLocalProperty. Zwraca pusty ciąg, jeśli nie ma atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usuwa atrybut TreatAsLocalProperty, jeśli wartość ustawiana jest ciągiem pustym ani wartością null.  
  
 Aby uzyskać więcej informacji na temat `TreatAsLocalProperty` atrybutów, zobacz [Project — Element (MSBuild)](http://msdn.microsoft.com/library/d1cda56a-dbef-4109-9201-39e962e3f653) i [porady: kompilacja tych samych plików źródłowych przy użyciu różnych opcji](http://msdn.microsoft.com/library/d14f1212-ddd9-434f-b138-f840011b0fb2).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TreatAsLocalPropertyLocation">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation TreatAsLocalPropertyLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation TreatAsLocalPropertyLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalPropertyLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TreatAsLocalPropertyLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ TreatAsLocalPropertyLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TreatAsLocalPropertyLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalPropertyLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lokalizacja atrybutu TreatAsLocalProperty dla tego elementu, jeśli istnieje.</summary>
        <value>Zwraca lokalizację atrybutu TreatAsLocalProperty. Jeśli nie ma takiego atrybutu, zwracana jest wartość null.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpen">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera główny projekt w kolekcji globalnego projektu, który został załadowany do pamięci z określonej ścieżki pliku. lub wartość null, jeśli nie jest aktualnie w pamięci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpen">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Construction.ProjectRootElement TryOpen (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Construction.ProjectRootElement TryOpen(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.TryOpen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpen (path As String) As ProjectRootElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Construction::ProjectRootElement ^ TryOpen(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TryOpen : string -&gt; Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Construction.ProjectRootElement.TryOpen path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka ProjectRootElement nie może mieć wartości null.</param>
        <summary>Pobiera główny projekt w kolekcji globalnego projektu, który został załadowany do pamięci z określonej ścieżki pliku. lub wartość null, jeśli nie jest aktualnie w pamięci.</summary>
        <returns>Zwraca katalog główny projektu. Zwraca wartość null, jeśli projekt nie został załadowany do pamięci z określonej ścieżki pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwe jest wprowadzenie obiektu ProjectRootElements do pamięci i jego odrzucenie w związku z nadmiernym użyciem pamięci. Jeśli TryOpen zwraca wartość null, nie oznacza to, że głównym projektu nigdy nie został załadowany, tylko, że nie znajduje się aktualnie w pamięci.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryOpen">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Construction.ProjectRootElement TryOpen (string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Construction.ProjectRootElement.TryOpen(System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Construction::ProjectRootElement ^ TryOpen(System::String ^ path, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="static member TryOpen : string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Construction.ProjectRootElement.TryOpen (path, projectCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka ProjectRootElement nie może mieć wartości null.</param>
        <param name="projectCollection">Kolekcja projektów, aby wyszukać w katalogu głównym projektu.</param>
        <summary>Pobiera główny projekt w kolekcji określonego projektu, który został załadowany do pamięci z określonej ścieżki pliku. lub wartość null, jeśli nie jest aktualnie w pamięci.</summary>
        <returns>Zwraca katalog główny projektu. Zwraca wartość null, jeśli projekt nie został załadowany do pamięci z określonej ścieżki pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwe jest wprowadzenie obiektu ProjectRootElements do pamięci i jego odrzucenie w związku z nadmiernym użyciem pamięci. Jeśli TryOpen zwraca wartość null, nie oznacza to, że głównym projektu nigdy nie został załadowany, tylko, że nie znajduje się aktualnie w pamięci.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UsingTasks">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectUsingTaskElement&gt; UsingTasks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Construction.ProjectUsingTaskElement&gt; UsingTasks" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.UsingTasks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UsingTasks As ICollection(Of ProjectUsingTaskElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectUsingTaskElement ^&gt; ^ UsingTasks { System::Collections::Generic::ICollection&lt;Microsoft::Build::Construction::ProjectUsingTaskElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UsingTasks : System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectUsingTaskElement&gt;" Usage="Microsoft.Build.Construction.ProjectRootElement.UsingTasks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Construction.ProjectUsingTaskElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wszystkie podrzędne [usingtask — Element (MSBuild)](http://msdn.microsoft.com/library/20247902-9446-4a1f-8253-5c7a17e4fe43) w tym projekcie.</summary>
        <value>Zwraca wszystkie podrzędne elementy UsingTask, w tym projekcie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public int Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Version" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Construction.ProjectRootElement.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Version { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : int" Usage="Microsoft.Build.Construction.ProjectRootElement.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer wersji tego obiektu.</summary>
        <value>Zwraca numer wersji tego obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Porównaj numer wersji do numeru wersji przechowywane, aby ustalić, czy projekt zawartość XML został zmieniony, nawet jeśli projekt jest zapisany po zmianie. Edytuj może być więcej niż raz, zwiększenie numeru wersji, więc wersji należy porównać tylko z wartości przechowywanej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
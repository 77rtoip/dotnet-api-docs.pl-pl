<Type Name="Queryable" FullName="System.Linq.Queryable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="417a4b731dea935e3c10a62df506b01216b940b6" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69117668" /></Metadata><TypeSignature Language="C#" Value="public static class Queryable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Queryable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Queryable" />
  <TypeSignature Language="VB.NET" Value="Public Module Queryable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Queryable abstract sealed" />
  <TypeSignature Language="F#" Value="type Queryable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Queryable</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera zestaw <see langword="static" /> metod (<see langword="Shared" /> w Visual Basic) służących do wykonywania zapytań dotyczących struktur danych, <see cref="T:System.Linq.IQueryable`1" />które implementują.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw metod zadeklarowanych w <xref:System.Linq.Queryable> klasie zawiera implementację standardowych operatorów zapytań na potrzeby wykonywania zapytań dotyczących źródeł danych, które implementują. <xref:System.Linq.IQueryable%601> Standardowe operatory zapytań są metodami ogólnego przeznaczenia, które są [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] zgodne ze wzorcem i umożliwiają wyrażanie operacji przechodzenia, filtrowania i projekcji danych w dowolnym z nich. Język programowania oparty na sieci.  
  
 Większość metod w tej klasie jest definiowana jako metody rozszerzające, które rozszerzają <xref:System.Linq.IQueryable%601> typ. Oznacza to, że mogą one być wywoływane jak metoda wystąpienia dla każdego obiektu, <xref:System.Linq.IQueryable%601>który implementuje. Te metody, które <xref:System.Linq.IQueryable%601> zwiększają, nie wykonują żadnych zapytań bezpośrednio. Zamiast tego, ich funkcjonalność polega na skompilowaniu <xref:System.Linq.Expressions.Expression> obiektu, który jest drzewem wyrażenia, które reprezentuje zapytanie skumulowane. Następnie metody przekazują nowe drzewo wyrażenia do <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> metody <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> lub metody danych wejściowych <xref:System.Linq.IQueryable%601>. Metoda, która jest wywoływana, zależy od tego, <xref:System.Linq.Queryable> czy metoda zwraca wartość pojedynczą, w której <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> przypadku wywoływana jest lub ma wyliczalne <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> wyniki, w której jest wywoływana.  
  
 Rzeczywiste wykonanie zapytania na danych docelowych jest wykonywane przez klasę implementującą <xref:System.Linq.IQueryable%601>. Oczekiwana liczba <xref:System.Linq.IQueryable%601> implementacji polega na tym, że wynik wykonania drzewa wyrażenia, który został skonstruowany <xref:System.Linq.Queryable> przez standardową metodę operatora zapytania, jest odpowiednikiem wyniku wywołania odpowiedniej metody w <xref:System.Linq.Enumerable> Klasa, jeśli źródło danych było <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Oprócz standardowych metod operatora zapytań, <xref:System.Linq.IQueryable%601> które działają na obiektach, ta klasa zawiera również metodę, <xref:System.Linq.Queryable.AsQueryable%2A>która określa <xref:System.Collections.IEnumerable> obiekty jako <xref:System.Linq.IQueryable> obiekty.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/a73c4aec-5d15-4e98-b962-1274021ea93d">Zapytanie o języku zintegrowanym (LINQ)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2">Standardowe operatory zapytań — przegląd</related>
    <related type="Article" href="https://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b">Drzewa wyrażeń</related>
    <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ do SQL</related>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TSource,TSource&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``0,``0}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As IQueryable(Of TSource), func As Expression(Of Func(Of TSource, TSource, TSource))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TSource, TSource&gt; ^&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Source, 'Source&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TSource,TSource&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja do agregowania.</param>
        <param name="func">Funkcja akumulowana do zastosowania do każdego elementu.</param>
        <summary>Stosuje funkcję akumulatora po sekwencji.</summary>
        <returns>Końcowa wartość akumulowana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że określona `func`funkcja,,, jest stosowana do każdej wartości w sekwencji źródłowej i zwracana jest wartość skumulowana. Pierwsza wartość w `source` jest używana jako wartość inicjatora wartości skumulowanej, która odnosi się do pierwszego parametru w `func`.  
  
 Aby uprościć Typowe operacje agregacji, zestaw standardowych operatorów zapytań zawiera również dwie <xref:System.Linq.Queryable.Count%2A> metody zliczania i <xref:System.Linq.Queryable.LongCount%2A>i cztery <xref:System.Linq.Queryable.Sum%2A>metody <xref:System.Linq.Queryable.Min%2A>agregacji liczbowej, <xref:System.Linq.Queryable.Max%2A>mianowicie,,, i <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> do kompilowania zdania z tablicy ciągów.  
  
 [!code-csharp[System.Linq.Queryable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#1)]
 [!code-vb[System.Linq.Queryable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="func" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TAccumulate seed, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``2(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As IQueryable(Of TSource), seed As TAccumulate, func As Expression(Of Func(Of TAccumulate, TSource, TAccumulate))) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, TAccumulate seed, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TSource, TAccumulate&gt; ^&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * 'Accumulate * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Source, 'Accumulate&gt;&gt; -&gt; 'Accumulate" Usage="System.Linq.Queryable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Typ wartości elementu akumulowana.</typeparam>
        <param name="source">Sekwencja do agregowania.</param>
        <param name="seed">Początkowa wartość akumulowana.</param>
        <param name="func">Funkcja akumulowana do wywołania dla każdego elementu.</param>
        <summary>Stosuje funkcję akumulatora po sekwencji. Określona wartość inicjatora jest używana jako początkowa wartość akumulowana.</summary>
        <returns>Końcowa wartość akumulowana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że określona `func`funkcja,,, jest stosowana do każdej wartości w sekwencji źródłowej i zwracana jest wartość skumulowana. Parametr jest używany jako wartość inicjatora wartości skumulowanej, która odnosi się do pierwszego parametru w `func`. `seed`  
  
 Aby uprościć Typowe operacje agregacji, zestaw standardowych operatorów zapytań zawiera również dwie <xref:System.Linq.Queryable.Count%2A> metody zliczania i <xref:System.Linq.Queryable.LongCount%2A>i cztery <xref:System.Linq.Queryable.Sum%2A>metody <xref:System.Linq.Queryable.Min%2A>agregacji liczbowej, <xref:System.Linq.Queryable.Max%2A>mianowicie,,, i <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> do zastosowania funkcji akumulowana, gdy wartość inicjatora jest dostarczana do funkcji.  
  
 [!code-csharp[System.Linq.Queryable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#2)]
 [!code-vb[System.Linq.Queryable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="func" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TAccumulate seed, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt; func, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt;&gt; func, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TAccumulate, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``3(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As IQueryable(Of TSource), seed As TAccumulate, func As Expression(Of Func(Of TAccumulate, TSource, TAccumulate)), selector As Expression(Of Func(Of TAccumulate, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, TAccumulate seed, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TSource, TAccumulate&gt; ^&gt; ^ func, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * 'Accumulate * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Source, 'Accumulate&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Aggregate (source, seed, func, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt;" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Typ wartości elementu akumulowana.</typeparam>
        <typeparam name="TResult">Typ wartości otrzymanej.</typeparam>
        <param name="source">Sekwencja do agregowania.</param>
        <param name="seed">Początkowa wartość akumulowana.</param>
        <param name="func">Funkcja akumulowana do wywołania dla każdego elementu.</param>
        <param name="selector">Funkcja Przekształć końcową wartość akumulowana na wartość wynikową.</param>
        <summary>Stosuje funkcję akumulatora po sekwencji. Określona wartość inicjatora jest używana jako początkowa wartość akumulowana, a określona funkcja jest używana do wybierania wartości wyniku.</summary>
        <returns>Przekształcona wartość końcowego akumulowana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że określona `func`funkcja,,, jest stosowana do każdej wartości w sekwencji źródłowej i zwracana jest wartość skumulowana. Parametr jest używany jako wartość inicjatora wartości skumulowanej, która odnosi się do pierwszego parametru w `func`. `seed` Końcowa wartość skumulowana jest przenoszona `selector` do w celu uzyskania wartości wyniku.  
  
 Aby uprościć Typowe operacje agregacji, zestaw standardowych operatorów zapytań zawiera również dwie <xref:System.Linq.Queryable.Count%2A> metody zliczania i <xref:System.Linq.Queryable.LongCount%2A>i cztery <xref:System.Linq.Queryable.Sum%2A>metody <xref:System.Linq.Queryable.Min%2A>agregacji liczbowej, <xref:System.Linq.Queryable.Max%2A>mianowicie,,, i <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> do zastosowania funkcji i selektora wyników.  
  
 [!code-csharp[System.Linq.Queryable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#3)]
 [!code-vb[System.Linq.Queryable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />or <paramref name="func" /> lub <paramref name="selector" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.All``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; bool" Usage="System.Linq.Queryable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja, której elementy do przetestowania dla warunku.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Określa, czy wszystkie elementy sekwencji spełniają warunek.</summary>
        <returns><see langword="true" />Jeśli każdy element sekwencji źródłowej przekazuje test w określonym predykacie lub jeśli sekwencja jest pusta; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji `source` typu parametru. Oczekiwane zachowanie polega na tym, że określa, czy wszystkie `source` elementy w spełniają warunek `predicate`w.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , aby określić, czy wszystkie elementy w sekwencji spełniają warunek.  
  
 [!code-csharp[System.Linq.Queryable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#4)]
 [!code-vb[System.Linq.Queryable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#4)]  
  
 Wartość <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> logiczna zwracana przez metodę jest zwykle używana w predykacie `where` klauzuli (`Where` klauzula w <xref:System.Linq.Queryable.Where%2A> Visual Basic) lub bezpośrednie wywołanie metody. Poniższy przykład demonstruje użycie `All` metody.  
  
 [!code-csharp[System.Linq.Queryable#134](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#134)]
 [!code-vb[System.Linq.Queryable#134](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#134)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy element <see cref="T:System.Linq.IQueryable`1" /> sekwencji istnieje, czy spełnia warunek.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IQueryable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.IQueryable&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja do sprawdzenia, czy jest pusta.</param>
        <summary>Określa, czy sekwencja zawiera dowolne elementy.</summary>
        <returns><see langword="true" />Jeśli sekwencja źródłowa zawiera jakiekolwiek elementy; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwanym zachowaniem jest określenie, czy `source` zawiera jakiekolwiek elementy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , aby określić, czy sekwencja zawiera jakiekolwiek elementy.  
  
 [!code-csharp[System.Linq.Queryable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#5)]
 [!code-vb[System.Linq.Queryable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#5)]  
  
 Wartość <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> logiczna zwracana przez metodę jest zwykle używana w predykacie `where` klauzuli (`Where` klauzula w <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Visual Basic) lub bezpośrednie wywołanie metody. Poniższy przykład demonstruje użycie `Any` metody.  
  
 [!code-csharp[System.Linq.Queryable#135](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#135)]
 [!code-vb[System.Linq.Queryable#135](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#135)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; bool" Usage="System.Linq.Queryable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja, której elementy do przetestowania dla warunku.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Określa, czy dowolny element sekwencji spełnia warunek.</summary>
        <returns><see langword="true" />Jeśli jakiekolwiek elementy w sekwencji źródłowej przekazują test w określonym predykacie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że decyduje o tym, `source` czy którykolwiek z elementów spełnia `predicate`warunek określony przez.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , aby określić, czy dowolny element w sekwencji spełnia warunek.  
  
 [!code-csharp[System.Linq.Queryable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#6)]
 [!code-vb[System.Linq.Queryable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Append``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource) (source As IQueryable(Of TSource), element As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Append(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Append : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Append (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="element" Type="TSource" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsQueryable">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable AsQueryable (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable AsQueryable(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.AsQueryable(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsQueryable (source As IEnumerable) As IQueryable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable ^ AsQueryable(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member AsQueryable : System.Collections.IEnumerable -&gt; System.Linq.IQueryable" Usage="System.Linq.Queryable.AsQueryable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja do przekonwertowania.</param>
        <summary><see cref="T:System.Collections.IEnumerable" /> Konwertuje<see cref="T:System.Linq.IQueryable" />do.</summary>
        <returns><see cref="T:System.Linq.IQueryable" /> Reprezentuje sekwencję wejściową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `source` implementuje <xref:System.Linq.IQueryable%601>, <xref:System.Linq.Queryable.AsQueryable%28System.Collections.IEnumerable%29> zwraca go bezpośrednio. W przeciwnym razie zwraca wartość <xref:System.Linq.IQueryable%601> , która wykonuje zapytania, wywołując równoważne <xref:System.Linq.Enumerable> metody operatora zapytania zamiast tych w <xref:System.Linq.Queryable>.  
  
 W tej metodzie `source` przyjęto założenie, że implementuje <xref:System.Collections.Generic.IEnumerable%601> dla niektórych `T`. W czasie wykonywania wynik jest typu <xref:System.Linq.IQueryable%601> dla tego samego. `T` Ta metoda jest przydatna w scenariuszach dynamicznych, jeśli nie znasz statycznie typu `T`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" />nie implementuje <see cref="T:System.Collections.Generic.IEnumerable`1" /> dla niektórych <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsQueryable&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TElement&gt; AsQueryable&lt;TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TElement&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TElement&gt; AsQueryable&lt;TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.AsQueryable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsQueryable(Of TElement) (source As IEnumerable(Of TElement)) As IQueryable(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TElement&gt; ^ AsQueryable(System::Collections::Generic::IEnumerable&lt;TElement&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsQueryable : seq&lt;'Element&gt; -&gt; System.Linq.IQueryable&lt;'Element&gt;" Usage="System.Linq.Queryable.AsQueryable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TElement&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja do przekonwertowania.</param>
        <summary>Konwertuje ogólny <see cref="T:System.Collections.Generic.IEnumerable`1" /> na rodzajowy <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Reprezentuje sekwencję wejściową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `source` implementuje <xref:System.Linq.IQueryable%601>, <xref:System.Linq.Queryable.AsQueryable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zwraca go bezpośrednio. W przeciwnym razie zwraca wartość <xref:System.Linq.IQueryable%601> , która wykonuje zapytania, wywołując równoważne <xref:System.Linq.Enumerable> metody operatora zapytania zamiast tych w <xref:System.Linq.Queryable>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać <xref:System.Linq.Queryable.AsQueryable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> do <xref:System.Collections.Generic.IEnumerable%601> konwersji do <xref:System.Linq.IQueryable%601>.  
  
 [!code-csharp[System.Linq.Queryable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#125)]
 [!code-vb[System.Linq.Queryable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#125)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza średnią sekwencji wartości liczbowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Linq.IQueryable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Linq.IQueryable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::IQueryable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Decimal" /> wartości, aby obliczyć średnią.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Decimal" /> wartości.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje, która reprezentuje wywoływanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29>. <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> do obliczenia średniej liczby sekwencji wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;double&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Double" /> wartości, aby obliczyć średnią.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Double" /> wartości.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje, która reprezentuje wywoływanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29>. <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> do obliczenia średniej liczby sekwencji wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;int&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int32" /> wartości, aby obliczyć średnią.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Int32" /> wartości.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje, która reprezentuje wywoływanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29>. <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> do obliczenia średniej liczby sekwencji wartości.  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;int64&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int64" /> wartości, aby obliczyć średnią.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Int64" /> wartości.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje, która reprezentuje wywoływanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29>. <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> do obliczenia średniej liczby sekwencji wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja wartości dopuszczająca wartość null <see cref="T:System.Decimal" /> , aby obliczyć średnią.</param>
        <summary>Oblicza średnią sekwencji wartości dopuszczającej wartość <see cref="T:System.Decimal" /> null.</summary>
        <returns>Średnia sekwencji wartości lub <see langword="null" /> , jeśli sekwencja źródłowa jest pusta lub zawiera tylko <see langword="null" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje, która reprezentuje wywoływanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29>. <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> do obliczenia średniej liczby sekwencji wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja wartości dopuszczająca wartość null <see cref="T:System.Double" /> , aby obliczyć średnią.</param>
        <summary>Oblicza średnią sekwencji wartości dopuszczającej wartość <see cref="T:System.Double" /> null.</summary>
        <returns>Średnia sekwencji wartości lub <see langword="null" /> , jeśli sekwencja źródłowa jest pusta lub zawiera tylko <see langword="null" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje, która reprezentuje wywoływanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>. <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> do obliczenia średniej liczby sekwencji wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja wartości dopuszczająca wartość null <see cref="T:System.Int32" /> , aby obliczyć średnią.</param>
        <summary>Oblicza średnią sekwencji wartości dopuszczającej wartość <see cref="T:System.Int32" /> null.</summary>
        <returns>Średnia sekwencji wartości lub <see langword="null" /> , jeśli sekwencja źródłowa jest pusta lub zawiera tylko <see langword="null" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje, która reprezentuje wywoływanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>. <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> do obliczenia średniej liczby sekwencji wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja wartości dopuszczająca wartość null <see cref="T:System.Int64" /> , aby obliczyć średnią.</param>
        <summary>Oblicza średnią sekwencji wartości dopuszczającej wartość <see cref="T:System.Int64" /> null.</summary>
        <returns>Średnia sekwencji wartości lub <see langword="null" /> , jeśli sekwencja źródłowa jest pusta lub zawiera tylko <see langword="null" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje, która reprezentuje wywoływanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>. <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> do obliczenia średniej liczby sekwencji wartości.  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja wartości dopuszczająca wartość null <see cref="T:System.Single" /> , aby obliczyć średnią.</param>
        <summary>Oblicza średnią sekwencji wartości dopuszczającej wartość <see cref="T:System.Single" /> null.</summary>
        <returns>Średnia sekwencji wartości lub <see langword="null" /> , jeśli sekwencja źródłowa jest pusta lub zawiera tylko <see langword="null" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje, która reprezentuje wywoływanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>. <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> do obliczenia średniej liczby sekwencji wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Linq.IQueryable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Linq.IQueryable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::IQueryable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;single&gt; -&gt; single" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Single" /> wartości, aby obliczyć średnią.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Single" /> wartości.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje, która reprezentuje wywoływanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29>. <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> do obliczenia średniej liczby sekwencji wartości.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Decimal))) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Decimal&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, decimal&gt;&gt; -&gt; decimal" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości, które są używane do obliczania średniej.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Decimal" /> wartości uzyskanych przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source` po wywołaniu `selector` każdej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> do obliczenia średniej <xref:System.String> długości w sekwencji wartości typu <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Double))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, double&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, double&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Double" /> wartości uzyskanych przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source` po wywołaniu `selector` każdej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> do obliczenia średniej <xref:System.String> długości w sekwencji wartości typu <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Int32" /> wartości uzyskanych przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source` po wywołaniu `selector` każdej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> do obliczenia średniej <xref:System.String> długości w sekwencji wartości typu <xref:System.String>.  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Long))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, long&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int64&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Int64" /> wartości uzyskanych przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source` po wywołaniu `selector` każdej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> do obliczenia średniej <xref:System.String> długości w sekwencji wartości typu <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;decimal&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Decimal)))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;decimal&gt;&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencję wartości dopuszczających <see cref="T:System.Decimal" /> wartość null, która jest uzyskiwana przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Średnia sekwencji wartości lub <see langword="null" /> , <paramref name="source" /> Jeśli sekwencja jest pusta lub zawiera tylko <see langword="null" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source` po wywołaniu `selector` każdej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> do obliczenia średniej <xref:System.String> długości w sekwencji wartości typu <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;double&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Double)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;double&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;double&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencję wartości dopuszczających <see cref="T:System.Double" /> wartość null, która jest uzyskiwana przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Średnia sekwencji wartości lub <see langword="null" /> , <paramref name="source" /> Jeśli sekwencja jest pusta lub zawiera tylko <see langword="null" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source` po wywołaniu `selector` każdej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> do obliczenia średniej <xref:System.String> długości w sekwencji wartości typu <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;int&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Integer)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;int&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencję wartości dopuszczających <see cref="T:System.Int32" /> wartość null, która jest uzyskiwana przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Średnia sekwencji wartości lub <see langword="null" /> , <paramref name="source" /> Jeśli sekwencja jest pusta lub zawiera tylko <see langword="null" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source` po wywołaniu `selector` każdej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> do obliczenia średniej <xref:System.String> długości w sekwencji wartości typu <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;long&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Long)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;long&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int64&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencję wartości dopuszczających <see cref="T:System.Int64" /> wartość null, która jest uzyskiwana przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Średnia sekwencji wartości lub <see langword="null" /> , <paramref name="source" /> Jeśli sekwencja jest pusta lub zawiera tylko <see langword="null" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source` po wywołaniu `selector` każdej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> do obliczenia średniej <xref:System.String> długości w sekwencji wartości typu <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;float&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Single)))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;float&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;single&gt;&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencję wartości dopuszczających <see cref="T:System.Single" /> wartość null, która jest uzyskiwana przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Średnia sekwencji wartości lub <see langword="null" /> , <paramref name="source" /> Jeśli sekwencja jest pusta lub zawiera tylko <see langword="null" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source` po wywołaniu `selector` każdej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> do obliczenia średniej <xref:System.String> długości w sekwencji wartości typu <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Single))) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, float&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, single&gt;&gt; -&gt; single" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do obliczenia średniej.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza średnią sekwencji <see cref="T:System.Single" /> wartości uzyskanych przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Średnia sekwencji wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że oblicza średnią wartości w `source` po wywołaniu `selector` każdej wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> do obliczenia średniej <xref:System.String> długości w sekwencji wartości typu <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie zawiera żadnych elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Linq.IQueryable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Linq.IQueryable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Cast``1(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As IQueryable) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Cast(System::Linq::IQueryable ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Linq.IQueryable -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ, do którego mają zostać przekonwertowane elementy <paramref name="source" /> .</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable" /> Zawiera elementy do przekonwertowania.</param>
        <summary>Konwertuje elementy <see cref="T:System.Linq.IQueryable" /> elementu do określonego typu.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Zawiera każdy element sekwencji źródłowej przekonwertowany na określony typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że konwertuje wartości `source` w na `TResult`typ.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> do konwertowania obiektów w sekwencji do typu. <xref:System.String>  
  
 [!code-csharp[System.Linq.Queryable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#19)]
 [!code-vb[System.Linq.Queryable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Elementu w sekwencji nie można rzutować na typ <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Concat``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Concat(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Concat : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Concat (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="source1">Pierwsza sekwencja do łączenia.</param>
        <param name="source2">Sekwencja do łączenia z pierwszą sekwencją.</param>
        <summary>Łączy dwie sekwencje.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Zawierający połączone elementy dwóch sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source1` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> , zależy od implementacji typu `source1` parametru. Oczekiwane zachowanie polega na tym, że `source2` elementy w są połączone z `source1` tymi, aby utworzyć nową sekwencję.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> do łączenia dwóch sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#20)]
 [!code-vb[System.Linq.Queryable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" />lub <paramref name="source2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, <see cref="T:System.Linq.IQueryable`1" /> czy zawiera określony element.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IQueryable(Of TSource), item As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource item);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.Queryable.Contains (source, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="item" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Lokalizację, <paramref name="item" />w której ma zostać zlokalizowany. <see cref="T:System.Linq.IQueryable`1" /></param>
        <param name="item">Obiekt, który ma zostać zlokalizowany w sekwencji.</param>
        <summary>Określa, czy sekwencja zawiera określony element przy użyciu domyślnej funkcji porównującej równość.</summary>
        <returns><see langword="true" />Jeśli sekwencja wejściowa zawiera element, który ma określoną wartość; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> , zależy od implementacji typu `source` parametru. Oczekiwanym zachowaniem jest określenie, czy `source` zawiera `item`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> , aby określić, czy sekwencja zawiera określony element.  
  
 [!code-csharp[System.Linq.Queryable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#21)]
 [!code-vb[System.Linq.Queryable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource item, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource item, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IQueryable(Of TSource), item As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource item, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.IQueryable&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.Contains (source, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="item" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Lokalizację, <paramref name="item" />w której ma zostać zlokalizowany. <see cref="T:System.Linq.IQueryable`1" /></param>
        <param name="item">Obiekt, który ma zostać zlokalizowany w sekwencji.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania wartości.</param>
        <summary>Określa, czy sekwencja zawiera określony element przy użyciu określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns><see langword="true" />Jeśli sekwencja wejściowa zawiera element, który ma określoną wartość; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że `source` określa `item` , czy `comparer` ma być używane do porównywania wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca liczbę elementów w sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IQueryable(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.IQueryable&lt;'Source&gt; -&gt; int" Usage="System.Linq.Queryable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Zawiera elementy do zliczenia.</param>
        <summary>Zwraca liczbę elementów w sekwencji.</summary>
        <returns>Liczba elementów w sekwencji wejściowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zlicza on liczbę elementów w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak za pomocą <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> policzyć elementy w sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#22)]
 [!code-vb[System.Linq.Queryable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Liczba elementów w <paramref name="source" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; int" Usage="System.Linq.Queryable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Element <see cref="T:System.Linq.IQueryable`1" /> zawierający elementy do zliczenia.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca liczbę elementów w określonej sekwencji, które spełniają warunek.</summary>
        <returns>Liczba elementów w sekwencji, które spełniają warunek w funkcji predykatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zlicza on liczbę elementów w `source` , które spełniają warunek określony przez `predicate`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> do zliczania elementów w sekwencji, która spełnia warunek.  
  
 [!code-csharp[System.Linq.Queryable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#23)]
 [!code-vb[System.Linq.Queryable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Liczba elementów w <paramref name="source" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca elementy w sekwencji lub domyślnej pojedynczej kolekcji, jeśli sekwencja jest pusta.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">W <see cref="T:System.Linq.IQueryable`1" /> celu zwrócenia wartości domyślnej dla pustej.</param>
        <summary>Zwraca elementy określonej sekwencji lub wartość domyślną parametru typu w kolekcji pojedynczej, jeśli sekwencja jest pusta.</summary>
        <returns>Element <see cref="T:System.Linq.IQueryable`1" /> zawierający <see langword="default" />( <paramref name="source" />), Jeśli<paramref name="source" /> jest pusty; w przeciwnym razie.<paramref name="TSource" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, `source` że zwraca, jeśli nie jest puste. W przeciwnym razie zwraca element <xref:System.Linq.IQueryable%601> , który `default(TSource)`zawiera.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak użyć <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , aby podać wartość domyślną w przypadku, gdy sekwencja źródłowa jest pusta.  
  
 [!code-csharp[System.Linq.Queryable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#24)]
 [!code-vb[System.Linq.Queryable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IQueryable(Of TSource), defaultValue As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">W <see cref="T:System.Linq.IQueryable`1" /> celu zwrócenia określonej wartości dla pustego elementu.</param>
        <param name="defaultValue">Wartość, która ma zostać zwrócona, jeśli sekwencja jest pusta.</param>
        <summary>Zwraca elementy określonej sekwencji lub określoną wartość w kolekcji pojedynczej, jeśli sekwencja jest pusta.</summary>
        <returns>Element <see cref="T:System.Linq.IQueryable`1" /> zawierający <paramref name="defaultValue" /> <paramref name="source" />Jeśli jestpusty;wprzeciwnymrazie<paramref name="source" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> jako metodę rodzajową. <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, `source` że zwraca, jeśli nie jest puste. W przeciwnym razie zwraca element <xref:System.Linq.IQueryable%601> , który `defaultValue`zawiera.  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia sytuację, w której jest przydatny do wywołania <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] w zapytaniu. <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> W tym przykładzie jest przenoszona wartość domyślna.  
  
 [!code-csharp[System.Linq.Queryable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#25)]
 [!code-vb[System.Linq.Queryable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca różne elementy z sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Distinct(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do usuwania duplikatów z.</param>
        <summary>Zwraca różne elementy z sekwencji przy użyciu domyślnej funkcji porównującej równość do porównywania wartości.</summary>
        <returns>Zawiera różne elementy od <paramref name="source" />. <see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca nieuporządkowaną sekwencję unikatowych elementów `source`w.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> do zwracania odrębnych elementów z sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#27)]
 [!code-vb[System.Linq.Queryable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IQueryable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Distinct(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.IQueryable&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do usuwania duplikatów z.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania wartości.</param>
        <summary>Zwraca różne elementy z sekwencji przy użyciu określonej <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> do porównywania wartości.</summary>
        <returns>Zawiera różne elementy od <paramref name="source" />. <see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca nieuporządkowaną sekwencję unikatowych elementów `source` w programie `comparer` przy użyciu do porównywania wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="comparer" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ElementAt``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As IQueryable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Linq::IQueryable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Queryable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia elementu z.</param>
        <param name="index">Indeks (liczony od zera) elementu do pobrania.</param>
        <summary>Zwraca element o określonym indeksie w sekwencji.</summary>
        <returns>Element w określonej pozycji w <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> jako metodę rodzajową. <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca element na `index` pozycji `source`w.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> do zwrócenia elementu w określonej pozycji w sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#28)]
 [!code-vb[System.Linq.Queryable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ElementAtOrDefault``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As IQueryable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Queryable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia elementu z.</param>
        <param name="index">Indeks (liczony od zera) elementu do pobrania.</param>
        <summary>Zwraca element o określonym indeksie w sekwencji lub wartości domyślnej, jeśli indeks jest poza zakresem.</summary>
        <returns><c>wartość domyślna</c> (<paramref name="TSource" />), <paramref name="index" /> jeśli znajduje się <paramref name="source" />poza granicami; w przeciwnym razie element w określonej pozycji w <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> jako metodę rodzajową. <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca element w `index` pozycji `source`w, `default(TSource)` lub `index` jeśli znajduje się poza granicami `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29>. W `index` tym przykładzie użyto wartości, która jest poza granicami sekwencji źródłowej.  
  
 [!code-csharp[System.Linq.Queryable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#29)]
 [!code-vb[System.Linq.Queryable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy różnicę dwóch sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Except(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Except (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="source1">, Których elementy, które nie są również <paramref name="source2" /> w programie, zostaną zwrócone. <see cref="T:System.Linq.IQueryable`1" /></param>
        <param name="source2"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Elementy, których również występują w pierwszej sekwencji, nie pojawią się w zwracanej sekwencji.</param>
        <summary>Tworzy różnicę dwóch sekwencji przy użyciu domyślnej funkcji porównującej równość do porównywania wartości.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Zawiera zestaw różnic między dwiema sekwencjami.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przezWłaściwość`source1` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> , zależy od implementacji typu `source1` parametru. Oczekiwane zachowanie polega na tym, że wszystkie `source1` elementy w są zwracane z wyjątkiem tych, które `source2`również znajdują się w.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> , aby zwrócić te elementy, które są wyświetlane tylko w pierwszej sekwencji źródłowej.  
  
 [!code-csharp[System.Linq.Queryable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#34)]
 [!code-vb[System.Linq.Queryable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" />lub <paramref name="source2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Except(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Except (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="source1">, Których elementy, które nie są również <paramref name="source2" /> w programie, zostaną zwrócone. <see cref="T:System.Linq.IQueryable`1" /></param>
        <param name="source2"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Elementy, których również występują w pierwszej sekwencji, nie pojawią się w zwracanej sekwencji.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania wartości.</param>
        <summary>Tworzy różnicę dwóch sekwencji przy użyciu określonej <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> do porównania wartości.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Zawiera zestaw różnic między dwiema sekwencjami.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przezWłaściwość`source1` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> , zależy od implementacji typu `source1` parametru. Oczekiwane zachowanie polega na tym, że wszystkie `source1` elementy w są zwracane z wyjątkiem tych, które `source2`znajdują `comparer` się również w, i służą do porównywania wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" />lub <paramref name="source2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca pierwszy element sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia pierwszego elementu.</param>
        <summary>Zwraca pierwszy element sekwencji.</summary>
        <returns>Pierwszy element w <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca pierwszy element `source`w.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> do zwrócenia pierwszego elementu w sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#35)]
 [!code-vb[System.Linq.Queryable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Sekwencja źródłowa jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia elementu z.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca pierwszy element sekwencji, który spełnia określony warunek.</summary>
        <returns>Pierwszy element w <paramref name="source" /> , który przekazuje test w <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca pierwszy element `source` w, który spełnia warunek określony `predicate`przez.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> do zwrócenia pierwszego elementu sekwencji, który spełnia warunek.  
  
 [!code-csharp[System.Linq.Queryable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#36)]
 [!code-vb[System.Linq.Queryable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden element nie spełnia warunku <paramref name="predicate" />w elemencie.  
  
—lub— 
Sekwencja źródłowa jest pusta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca pierwszy element sekwencji lub wartość domyślną, jeśli nie odnaleziono elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia pierwszego elementu.</param>
        <summary>Zwraca pierwszy element sekwencji lub wartość domyślną, jeśli sekwencja nie zawiera żadnych elementów.</summary>
        <returns><c>wartość domyślna</c> (<paramref name="TSource" />) Jeśli <paramref name="source" /> jest pusty; w przeciwnym razie pierwszy element w <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca pierwszy element `source`w lub wartość domyślną, jeśli `source` jest puste.  
  
 Metoda <xref:System.Linq.Queryable.FirstOrDefault%2A> nie umożliwia określenia wartości domyślnej, która ma zostać zwrócona, jeśli `source` jest pusta. Jeśli chcesz określić wartość domyślną inną niż `default(TSource)`, <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Użyj metody opisanej w sekcji przykład.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> na pustej sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#37)]
 [!code-vb[System.Linq.Queryable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#37)]  
  
 Czasami wartość `default(TSource)` nie jest wartością domyślną, która ma być używana, jeśli kolekcja nie zawiera żadnych elementów. Zamiast sprawdzać wynik niepożądanej wartości domyślnej, a następnie zmieniać ją w razie potrzeby, można użyć <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> metody, aby określić wartość domyślną, która ma być używana, jeśli kolekcja jest pusta. Następnie należy wywołać <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , aby uzyskać pierwszy element. Poniższy przykład kodu używa obu technik do uzyskania wartości domyślnej 1, jeśli kolekcja miesięcy liczbowych jest pusta. Ponieważ wartością domyślną dla liczby całkowitej jest 0, która nie odpowiada żadnemu miesiącowi, wartość domyślna musi być określona jako 1. Pierwsza zmienna wynikowa jest sprawdzana pod kątem niepożądanej wartości domyślnej po zakończeniu zapytania. Druga zmienna wynikowa jest uzyskiwana przez <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> wywołanie, aby określić wartość domyślną 1.  
  
 [!code-csharp[System.Linq.Queryable#131](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#131)]
 [!code-vb[System.Linq.Queryable#131](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#131)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia elementu z.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca pierwszy element sekwencji, który spełnia określony warunek lub wartość domyślną, jeśli taki element nie zostanie znaleziony.</summary>
        <returns><c>wartość domyślna</c> (<paramref name="TSource" />) Jeśli <paramref name="source" /> jest pusty lub żaden element nie przekazuje testu określonego przez <paramref name="predicate" />; w przeciwnym razie pierwszy element w <paramref name="source" /> , który przekazuje Test określony przez <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca pierwszy element `source` w, który spełnia warunek `predicate`w, lub wartość domyślną, jeśli żaden element nie spełnia warunku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> przez przekazanie predykatu. W drugim zapytaniu nie ma elementu w sekwencji, który spełnia warunek.  
  
 [!code-csharp[System.Linq.Queryable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#38)]
 [!code-vb[System.Linq.Queryable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grupuje elementy sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IQueryable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowanej w <paramref name="keySelector" />.</typeparam>
        <param name="source">, <see cref="T:System.Linq.IQueryable`1" /> Których elementów należy grupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną funkcją selektora kluczy.</summary>
        <returns>Interfejs <c>IQueryable&lt;&gt; IGrouping&lt;TKey,TSource&gt;</c> w C# lub <c>IQueryable (of IGrouping (TKey, TSource))</c> w Visual Basic gdzie każdy <see cref="T:System.Linq.IGrouping`2" /> obiekt zawiera sekwencję obiekty i klucz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że grupuje `source` elementy przez wartość kluczową, która jest uzyskiwana `keySelector` przez wywoływanie dla każdego elementu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> do grupowania elementów sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#14)]
 [!code-vb[System.Linq.Queryable#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowanej w <paramref name="keySelector" />.</typeparam>
        <param name="source">, <see cref="T:System.Linq.IQueryable`1" /> Których elementów należy grupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną funkcją selektora kluczy i porównuje klucze przy użyciu określonej funkcji porównującej.</summary>
        <returns>Interfejs <c>IQueryable&lt;&gt; IGrouping&lt;TKey,TSource&gt;</c> w C# lub <c>IQueryable (of IGrouping (TKey, TSource))</c> w Visual Basic gdzie każda z <see cref="T:System.Linq.IGrouping`2" /> nich zawiera sekwencję obiekty i klucz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że grupuje `source` elementy przez wartość klucza. Wartość klucza jest uzyskiwana przez wywoływanie `keySelector` dla każdego elementu, a wartości klucza są porównywane przy `comparer`użyciu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />or <paramref name="keySelector" /> lub <paramref name="comparer" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement))) As IQueryable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowanej w <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Typ elementów w każdym z nich <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">, <see cref="T:System.Linq.IQueryable`1" /> Których elementów należy grupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="elementSelector">Funkcja mapowania każdego elementu źródłowego do elementu w <see cref="T:System.Linq.IGrouping`2" />.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną funkcją selektora kluczy i tworzy projekty elementów dla każdej grupy przy użyciu określonej funkcji.</summary>
        <returns>Interfejs <c>IQueryable&lt;&gt; IGrouping&lt;TKey,tele&gt;</c> w C# lub <c>IQueryable (of IGrouping (of TKey, tele))</c> w Visual Basic, gdzie każda z <see cref="T:System.Linq.IGrouping`2" /> nich zawiera sekwencję obiekty typu <paramref name="TElement" /> i klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że grupuje `source` elementy przez wartość kluczową, która jest uzyskiwana `keySelector` przez wywoływanie dla każdego elementu. Wywołuje `elementSelector` on każdy element, aby uzyskać element wynik.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> do grupowania elementów sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#39)]
 [!code-vb[System.Linq.Queryable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />or <paramref name="keySelector" /> lub <paramref name="elementSelector" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowanej w <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Typ elementów w każdym z nich <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">, <see cref="T:System.Linq.IQueryable`1" /> Których elementów należy grupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="elementSelector">Funkcja mapowania każdego elementu źródłowego do elementu w <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Grupuje elementy sekwencji i projektuje elementy dla każdej grupy przy użyciu określonej funkcji. Wartości klucza są porównywane przy użyciu określonej funkcji porównującej.</summary>
        <returns>Interfejs <c>IQueryable&lt;&gt; IGrouping&lt;TKey,tele&gt;</c> w C# lub <c>IQueryable (of IGrouping (of TKey, tele))</c> w Visual Basic, gdzie każda z <see cref="T:System.Linq.IGrouping`2" /> nich zawiera sekwencję obiekty typu <paramref name="TElement" /> i klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że grupuje `source` elementy przez wartość kluczową, która jest uzyskiwana `keySelector` przez wywoływanie dla każdego elementu. Wartości klucza są porównywane przy `comparer`użyciu. `elementSelector` Parametr jest wywoływany dla każdego elementu w celu uzyskania elementu wynik.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /><paramref name="keySelector" /> orlub<see langword="null" />jest. <paramref name="elementSelector" /> <paramref name="comparer" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TSource), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowanej w <paramref name="keySelector" />.</typeparam>
        <typeparam name="TResult">Typ wartości wyniku zwróconej przez <paramref name="resultSelector" />.</typeparam>
        <param name="source">, <see cref="T:System.Linq.IQueryable`1" /> Których elementów należy grupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="resultSelector">Funkcja tworzenia wartości wyniku z każdej grupy.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną kluczową funkcją wyboru i tworzy wartość wyniku z każdej grupy i klucza.</summary>
        <returns><c>T:System.LINQ.IQueryable ' 1</c> , który ma argument <paramref name="TResult" /> typu i, gdzie każdy element reprezentuje projekcję w grupie i jej klucz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że grupuje `source` elementy przez wartość kluczową, która jest uzyskiwana `keySelector` przez wywoływanie dla każdego elementu. Ten `resultSelector` parametr służy do uzyskiwania wartości wyniku z poszczególnych grup i ich kluczy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> do grupowania elementów sekwencji i projektu sekwencji wyników typu. `TResult`  
  
 [!code-csharp[System.Linq.Queryable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#15)]
 [!code-vb[System.Linq.Queryable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />or <paramref name="keySelector" /> lub <paramref name="resultSelector" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TSource), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowanej w <paramref name="keySelector" />.</typeparam>
        <typeparam name="TResult">Typ wartości wyniku zwróconej przez <paramref name="resultSelector" />.</typeparam>
        <param name="source">, <see cref="T:System.Linq.IQueryable`1" /> Których elementów należy grupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="resultSelector">Funkcja tworzenia wartości wyniku z każdej grupy.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną kluczową funkcją wyboru i tworzy wartość wyniku z każdej grupy i klucza. Klucze są porównywane przy użyciu określonej funkcji porównującej.</summary>
        <returns><c>T:System.LINQ.IQueryable ' 1</c> , który ma argument <paramref name="TResult" /> typu i, gdzie każdy element reprezentuje projekcję w grupie i jej klucz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że grupuje `source` elementy przez wartości klucza, które są uzyskiwane `keySelector` przez wywoływanie dla każdego elementu. Parametr jest używany do porównywania kluczy `resultSelector` , a parametr służy do uzyskiwania wartości wyniku z każdej grupy i jej klucza. `comparer`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /><paramref name="keySelector" /> orlub<see langword="null" />jest. <paramref name="resultSelector" /> <paramref name="comparer" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TElement), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowanej w <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Typ elementów w każdym z nich <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Typ wartości wyniku zwróconej przez <paramref name="resultSelector" />.</typeparam>
        <param name="source">, <see cref="T:System.Linq.IQueryable`1" /> Których elementów należy grupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="elementSelector">Funkcja mapowania każdego elementu źródłowego do elementu w <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">Funkcja tworzenia wartości wyniku z każdej grupy.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną kluczową funkcją wyboru i tworzy wartość wyniku z każdej grupy i klucza. Elementy każdej grupy są rzutowane przy użyciu określonej funkcji.</summary>
        <returns><c>T:System.LINQ.IQueryable ' 1</c> , który ma argument <paramref name="TResult" /> typu i, gdzie każdy element reprezentuje projekcję w grupie i jej klucz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że grupuje `source` elementy przez wartości klucza, które są uzyskiwane `keySelector` przez wywoływanie dla każdego elementu. Parametr jest używany do projekcji elementów każdej grupy, `resultSelector` a parametr jest używany do uzyskania wartości wyniku z każdej grupy i jej klucza. `elementSelector`  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> do grupowania elementów sekwencji i projektu sekwencji wyników typu. `TResult`  
  
 [!code-csharp[System.Linq.Queryable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#130)]
 [!code-vb[System.Linq.Queryable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /><paramref name="keySelector" /> orlub<see langword="null" />jest. <paramref name="elementSelector" /> <paramref name="resultSelector" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TElement), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowanej w <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Typ elementów w każdym z nich <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Typ wartości wyniku zwróconej przez <paramref name="resultSelector" />.</typeparam>
        <param name="source">, <see cref="T:System.Linq.IQueryable`1" /> Których elementów należy grupować.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza do każdego elementu.</param>
        <param name="elementSelector">Funkcja mapowania każdego elementu źródłowego do elementu w <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">Funkcja tworzenia wartości wyniku z każdej grupy.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania kluczy.</param>
        <summary>Grupuje elementy sekwencji zgodnie z określoną kluczową funkcją wyboru i tworzy wartość wyniku z każdej grupy i klucza. Klucze są porównywane przy użyciu określonej funkcji porównującej, a elementy każdej grupy są rzutowane przy użyciu określonej usługi.</summary>
        <returns><c>T:System.LINQ.IQueryable ' 1</c> , który ma argument <paramref name="TResult" /> typu i, gdzie każdy element reprezentuje projekcję w grupie i jej klucz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że grupuje `source` elementy przez wartości klucza, które są uzyskiwane `keySelector` przez wywoływanie dla każdego elementu. `comparer` Parametr jest używany do porównywania wartości kluczy. Parametr jest używany do projekcji elementów każdej grupy, `resultSelector` a parametr jest używany do uzyskania wartości wyniku z każdej grupy i jej klucza. `elementSelector`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /><paramref name="keySelector" /> orlub<see langword="null" />or. <paramref name="elementSelector" /> <paramref name="resultSelector" /> <paramref name="comparer" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Skorelowanie elementów dwóch sekwencji w oparciu o równość klucza i grupuje wyniki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, IEnumerable(Of TInner), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupJoin(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Typ elementów pierwszej sekwencji.</typeparam>
        <typeparam name="TInner">Typ elementów drugiej sekwencji.</typeparam>
        <typeparam name="TKey">Typ kluczy zwracanych przez funkcje przełącznika kluczowego.</typeparam>
        <typeparam name="TResult">Typ elementów wyniku.</typeparam>
        <param name="outer">Pierwsza sekwencja do przyłączenia.</param>
        <param name="inner">Sekwencja do przyłączenia do pierwszej sekwencji.</param>
        <param name="outerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu pierwszej sekwencji.</param>
        <param name="innerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu drugiej sekwencji.</param>
        <param name="resultSelector">Funkcja do tworzenia elementu wyniku z elementu z pierwszej sekwencji i kolekcji pasujących elementów z drugiej sekwencji.</param>
        <summary>Skorelowanie elementów dwóch sekwencji w oparciu o równość klucza i grupuje wyniki. Domyślna funkcja porównująca równość jest używana do porównywania kluczy.</summary>
        <returns>Element <see cref="T:System.Linq.IQueryable`1" /> , który zawiera elementy typu <paramref name="TResult" /> uzyskane przez wykonanie zgrupowanych sprzężeń na dwie sekwencje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`outer` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> , zależy od implementacji typu `outer` parametru. Oczekiwane zachowanie polega na tym `outerKeySelector` , `innerKeySelector` że funkcje i są używane do wyodrębniania `inner`kluczy z `outer` i, odpowiednio. Te klucze są porównywane pod kątem równości, aby dopasować `outer` każdy element do `inner`elementów z. `resultSelector` Następnie funkcja jest wywoływana, aby zaprojektować obiekt wynikowy z każdej grupy skorelowanych elementów.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> do wykonywania zgrupowanych sprzężeń na dwóch sekwencjach.  
  
 [!code-csharp[System.Linq.Queryable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#40)]
 [!code-vb[System.Linq.Queryable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /><paramref name="inner" /> orlub<see langword="null" />or. <paramref name="outerKeySelector" /> <paramref name="innerKeySelector" /> <paramref name="resultSelector" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, IEnumerable(Of TInner), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupJoin(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Typ elementów pierwszej sekwencji.</typeparam>
        <typeparam name="TInner">Typ elementów drugiej sekwencji.</typeparam>
        <typeparam name="TKey">Typ kluczy zwracanych przez funkcje przełącznika kluczowego.</typeparam>
        <typeparam name="TResult">Typ elementów wyniku.</typeparam>
        <param name="outer">Pierwsza sekwencja do przyłączenia.</param>
        <param name="inner">Sekwencja do przyłączenia do pierwszej sekwencji.</param>
        <param name="outerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu pierwszej sekwencji.</param>
        <param name="innerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu drugiej sekwencji.</param>
        <param name="resultSelector">Funkcja do tworzenia elementu wyniku z elementu z pierwszej sekwencji i kolekcji pasujących elementów z drugiej sekwencji.</param>
        <param name="comparer">Funkcja porównująca do mieszania i porównywania kluczy.</param>
        <summary>Skorelowanie elementów dwóch sekwencji w oparciu o równość klucza i grupuje wyniki. Określony <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> jest używany do porównywania kluczy.</summary>
        <returns>Element <see cref="T:System.Linq.IQueryable`1" /> , który zawiera elementy typu <paramref name="TResult" /> uzyskane przez wykonanie zgrupowanych sprzężeń na dwie sekwencje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`outer` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> , zależy od implementacji typu `outer` parametru. Oczekiwane zachowanie polega na tym `outerKeySelector` , `innerKeySelector` że funkcje i są używane do wyodrębniania `inner`kluczy z `outer` i, odpowiednio. Te klucze są porównywane ze względu `comparer`na równość przy użyciu. Wynik porównania jest używany do dopasowywania każdego elementu w `outer` elemencie z. `inner` `resultSelector` Następnie funkcja jest wywoływana, aby zaprojektować obiekt wynikowy z każdej grupy skorelowanych elementów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /><paramref name="inner" /> orlub<see langword="null" />or. <paramref name="outerKeySelector" /> <paramref name="innerKeySelector" /> <paramref name="resultSelector" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy część wspólną dwóch sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Intersect(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Intersect (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="source1">Sekwencja, w której są zwracane odrębne elementy <paramref name="source2" /> , które również są wyświetlane w.</param>
        <param name="source2">Jest to sekwencja, której odrębne elementy występujące również w pierwszej sekwencji są zwracane.</param>
        <summary>Tworzy przecięcie zestawu dwóch sekwencji przy użyciu domyślnej funkcji porównującej równość do porównywania wartości.</summary>
        <returns>Sekwencja, która zawiera zestaw przecięcia dwóch sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source1` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> , zależy od implementacji typu `source1` parametru. Oczekiwane zachowanie polega na tym, że wszystkie `source1` elementy w, które `source2` znajdują się również w są zwracane.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> , aby zwrócić elementy, które pojawiają się w każdej z dwóch sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#41)]
 [!code-vb[System.Linq.Queryable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" />lub <paramref name="source2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Intersect(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Intersect (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="source1">Są zwracane różne elementy, które również pojawiają się w programie <paramref name="source2" />. <see cref="T:System.Linq.IQueryable`1" /></param>
        <param name="source2"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Są zwracane różne elementy, które również pojawiają się w pierwszej sekwencji.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania wartości.</param>
        <summary>Tworzy część wspólną dwóch sekwencji przy użyciu określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> do porównywania wartości.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Zawiera zestaw przecięcia obu sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source1` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> , zależy od implementacji typu `source1` parametru. Oczekiwane zachowanie polega na tym, że wszystkie `source1` elementy w, które `source2` znajdują się również w są zwracane. `comparer` Parametr jest używany do porównywania elementów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" />lub <paramref name="source2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Skorelowanie elementów dwóch sekwencji na podstawie pasujących kluczy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TInner,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, TInner, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Join(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TInner, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Inner, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TInner,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Typ elementów pierwszej sekwencji.</typeparam>
        <typeparam name="TInner">Typ elementów drugiej sekwencji.</typeparam>
        <typeparam name="TKey">Typ kluczy zwracanych przez funkcje przełącznika kluczowego.</typeparam>
        <typeparam name="TResult">Typ elementów wyniku.</typeparam>
        <param name="outer">Pierwsza sekwencja do przyłączenia.</param>
        <param name="inner">Sekwencja do przyłączenia do pierwszej sekwencji.</param>
        <param name="outerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu pierwszej sekwencji.</param>
        <param name="innerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu drugiej sekwencji.</param>
        <param name="resultSelector">Funkcja do tworzenia elementu wyniku z dwóch zgodnych elementów.</param>
        <summary>Skorelowanie elementów dwóch sekwencji na podstawie pasujących kluczy. Domyślna funkcja porównująca równość jest używana do porównywania kluczy.</summary>
        <returns>Element, który ma elementy typu <paramref name="TResult" /> uzyskane przez wykonywanie sprzężenia wewnętrznego na dwie sekwencje. <see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`outer` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> , zależy od implementacji typu `outer` parametru. Oczekiwane zachowanie polega na tym, że sprzężenia wewnętrznego. `outer` `inner`Funkcje `outerKeySelector` i `innerKeySelector` służą do wyodrębniania kluczy z i, odpowiednio. Te klucze są porównywane pod kątem równości, aby dopasować elementy z każdej sekwencji. Para elementów jest przechowywana dla każdego elementu w `inner` , który pasuje do elementu w. `outer` `resultSelector` Następnie funkcja jest wywoływana, aby zaprojektować obiekt wynikowy z każdej pary pasujących elementów.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> do wykonywania wewnętrznego przyłączania dwóch sekwencji na podstawie wspólnego klucza.  
  
 [!code-csharp[System.Linq.Queryable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#42)]
 [!code-vb[System.Linq.Queryable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /><paramref name="inner" /> orlub<see langword="null" />or. <paramref name="outerKeySelector" /> <paramref name="innerKeySelector" /> <paramref name="resultSelector" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TInner,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, TInner, TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Join(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TInner, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Inner, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TInner,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Typ elementów pierwszej sekwencji.</typeparam>
        <typeparam name="TInner">Typ elementów drugiej sekwencji.</typeparam>
        <typeparam name="TKey">Typ kluczy zwracanych przez funkcje przełącznika kluczowego.</typeparam>
        <typeparam name="TResult">Typ elementów wyniku.</typeparam>
        <param name="outer">Pierwsza sekwencja do przyłączenia.</param>
        <param name="inner">Sekwencja do przyłączenia do pierwszej sekwencji.</param>
        <param name="outerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu pierwszej sekwencji.</param>
        <param name="innerKeySelector">Funkcja wyodrębniania klucza łączenia z każdego elementu drugiej sekwencji.</param>
        <param name="resultSelector">Funkcja do tworzenia elementu wyniku z dwóch zgodnych elementów.</param>
        <param name="comparer">Skróty <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> do mieszania i porównywania kluczy.</param>
        <summary>Skorelowanie elementów dwóch sekwencji na podstawie pasujących kluczy. Określony <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> jest używany do porównywania kluczy.</summary>
        <returns>Element, który ma elementy typu <paramref name="TResult" /> uzyskane przez wykonywanie sprzężenia wewnętrznego na dwie sekwencje. <see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`outer` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> , zależy od implementacji typu `outer` parametru. Oczekiwane zachowanie polega na tym, że sprzężenia wewnętrznego. `outer` `inner`Funkcje `outerKeySelector` i `innerKeySelector` służą do wyodrębniania kluczy z i, odpowiednio. Te klucze są porównywane ze względu `comparer`na równość przy użyciu. Wynik porównania jest używany do tworzenia pasującej pary dla każdego elementu w `inner` , który pasuje do elementu w. `outer` `resultSelector` Następnie funkcja jest wywoływana, aby zaprojektować obiekt wynikowy z każdej pary pasujących elementów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /><paramref name="inner" /> orlub<see langword="null" />or. <paramref name="outerKeySelector" /> <paramref name="innerKeySelector" /> <paramref name="resultSelector" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ostatni element w sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia ostatniego elementu.</param>
        <summary>Zwraca ostatni element w sekwencji.</summary>
        <returns>Wartość znajdująca się na ostatniej pozycji <paramref name="source" />w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca ostatni element `source`w.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> do zwrócenia ostatniego elementu tablicy.  
  
 [!code-csharp[System.Linq.Queryable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#43)]
 [!code-vb[System.Linq.Queryable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Sekwencja źródłowa jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia elementu z.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca ostatni element sekwencji, który spełnia określony warunek.</summary>
        <returns>Ostatni element w <paramref name="source" /> , który przekazuje Test określony przez <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca ostatni element `source` w, który spełnia warunek określony `predicate`przez.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> do zwrócenia ostatniego elementu tablicy, który spełnia warunek.  
  
 [!code-csharp[System.Linq.Queryable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#44)]
 [!code-vb[System.Linq.Queryable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden element nie spełnia warunku <paramref name="predicate" />w elemencie.  
  
—lub— 
Sekwencja źródłowa jest pusta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ostatni element sekwencji lub wartość domyślną, jeśli nie odnaleziono elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia ostatniego elementu.</param>
        <summary>Zwraca ostatni element w sekwencji lub wartość domyślną, jeśli sekwencja nie zawiera żadnych elementów.</summary>
        <returns><c>wartość domyślna</c> (<paramref name="TSource" />) Jeśli <paramref name="source" /> jest pusty; w przeciwnym razie ostatni element w <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca ostatni element `source`w lub wartość domyślną, jeśli `source` jest puste.  
  
 <xref:System.Linq.Queryable.LastOrDefault%2A> Metoda nie pozwala na określenie wartości domyślnej. Jeśli chcesz określić wartość domyślną inną niż `default(TSource)`, <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Użyj metody opisanej w sekcji przykład.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> na pustej tablicy.  
  
 [!code-csharp[System.Linq.Queryable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#45)]
 [!code-vb[System.Linq.Queryable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#45)]  
  
 Czasami wartość `default(TSource)` nie jest wartością domyślną, która ma być używana, jeśli kolekcja nie zawiera żadnych elementów. Zamiast sprawdzać wynik niepożądanej wartości domyślnej, a następnie zmieniać ją w razie potrzeby, można użyć <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> metody, aby określić wartość domyślną, która ma być używana, jeśli kolekcja jest pusta. Następnie należy wywołać <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , aby uzyskać ostatni element. Poniższy przykład kodu używa obu technik do uzyskania wartości domyślnej 1, jeśli kolekcja dni miesiąca jest pusta. Ponieważ wartością domyślną dla liczby całkowitej jest 0, która nie odpowiada żadnemu dzień miesiąca, wartość domyślna musi być określona jako 1. Pierwsza zmienna wynikowa jest sprawdzana pod kątem niepożądanej wartości domyślnej po zakończeniu zapytania. Druga zmienna wynikowa jest uzyskiwana przez <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> wywołanie, aby określić wartość domyślną 1.  
  
 [!code-csharp[System.Linq.Queryable#132](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#132)]
 [!code-vb[System.Linq.Queryable#132](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#132)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia elementu z.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca ostatni element sekwencji, który spełnia warunek lub wartość domyślną, jeśli taki element nie zostanie znaleziony.</summary>
        <returns><c>wartość domyślna</c> (<paramref name="TSource" />) Jeśli <paramref name="source" /> jest pusty lub żadne elementy nie przechodzą testu w funkcji predykatu; w przeciwnym razie ostatni element <paramref name="source" /> , który przekazuje test w funkcji predykatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca ostatni element `source` w, który spełnia warunek określony `predicate`przez. Zwraca wartość domyślną, jeśli nie ma takiego elementu w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> przez przekazanie predykatu. W drugim wywołaniu metody nie ma elementu w sekwencji, który spełnia warunek.  
  
 [!code-csharp[System.Linq.Queryable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#46)]
 [!code-vb[System.Linq.Queryable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Int64" /> Zwraca wartość reprezentującą liczbę elementów w sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IQueryable(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.IQueryable&lt;'Source&gt; -&gt; int64" Usage="System.Linq.Queryable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Element <see cref="T:System.Linq.IQueryable`1" /> zawierający elementy do zliczenia.</param>
        <summary><see cref="T:System.Int64" /> Zwraca wartość reprezentującą łączną liczbę elementów w sekwencji.</summary>
        <returns>Liczba elementów w <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zlicza on liczbę elementów w `source` i <xref:System.Int64>zwraca.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> do zliczania elementów w tablicy.  
  
 [!code-csharp[System.Linq.Queryable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#47)]
 [!code-vb[System.Linq.Queryable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Liczba elementów przekracza <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; int64" Usage="System.Linq.Queryable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Element <see cref="T:System.Linq.IQueryable`1" /> zawierający elementy do zliczenia.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary><see cref="T:System.Int64" /> Zwraca wartość reprezentującą liczbę elementów w sekwencji, które spełniają warunek.</summary>
        <returns>Liczba elementów w <paramref name="source" /> , które spełniają warunek w funkcji predykatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zlicza on liczbę elementów w `source` , które spełniają warunek określony przez `predicate` , i zwraca <xref:System.Int64>wartość.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> do zliczania elementów w tablicy, które spełniają warunek.  
  
 [!code-csharp[System.Linq.Queryable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#48)]
 [!code-vb[System.Linq.Queryable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Liczba pasujących elementów przekracza <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Max``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości, aby określić wartość maksymalną.</param>
        <summary>Zwraca maksymalną wartość w ogólnym <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca wartość maksymalną `source`w.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , aby określić maksymalną wartość w sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#52)]
 [!code-vb[System.Linq.Queryable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Max``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Typ wartości zwracanej przez funkcję reprezentowanej przez <paramref name="selector" />.</typeparam>
        <param name="source">Sekwencja wartości, aby określić wartość maksymalną.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję projekcji dla każdego elementu generycznego <see cref="T:System.Linq.IQueryable`1" /> i zwraca maksymalną wartość wynikową.</summary>
        <returns>Maksymalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego elementu w `source` i zwraca wartość maksymalną.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> , aby określić maksymalną wartość w sekwencji prognozowanych wartości.  
  
 [!code-csharp[System.Linq.Queryable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#58)]
 [!code-vb[System.Linq.Queryable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Min``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do określenia minimum.</param>
        <summary>Zwraca minimalną wartość generyczną <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca wartość minimalną w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , aby określić minimalną wartość w sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#60)]
 [!code-vb[System.Linq.Queryable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Min``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Typ wartości zwracanej przez funkcję reprezentowanej przez <paramref name="selector" />.</typeparam>
        <param name="source">Sekwencja wartości do określenia minimum.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Wywołuje funkcję projekcji dla każdego elementu generycznego <see cref="T:System.Linq.IQueryable`1" /> i zwraca minimalną wartość wynikową.</summary>
        <returns>Minimalna wartość w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego elementu w `source` i zwraca wartość minimalną.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> , aby określić minimalną wartość w sekwencji prognozowanych wartości.  
  
 [!code-csharp[System.Linq.Queryable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#68)]
 [!code-vb[System.Linq.Queryable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Linq.IQueryable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Linq.IQueryable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OfType``1(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As IQueryable) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ OfType(System::Linq::IQueryable ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Linq.IQueryable -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ do filtrowania elementów sekwencji.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable" /> Których elementów do filtrowania.</param>
        <summary>Filtruje elementy <see cref="T:System.Linq.IQueryable" /> w oparciu o określony typ.</summary>
        <returns>Kolekcja zawierająca elementy z <paramref name="source" /> tego typu. <paramref name="TResult" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie `OfType` jako metodę rodzajową. `OfType` <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie `OfType` , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że filtruje wszelkie `source` elementy w, które nie `TResult`są typu.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia `OfType` do odfiltrowania elementów, które nie są typu <xref:System.Reflection.PropertyInfo> z listy elementów typu <xref:System.Reflection.MemberInfo>.  
  
 [!code-csharp[System.Linq.Queryable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#69)]
 [!code-vb[System.Linq.Queryable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje elementy sekwencji w kolejności rosnącej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję, która jest reprezentowana przez <paramref name="keySelector" />.</typeparam>
        <param name="source">Sekwencja wartości do ustawienia w kolejności.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z elementu.</param>
        <summary>Sortuje elementy sekwencji w kolejności rosnącej zgodnie z kluczem.</summary>
        <returns>, <see cref="T:System.Linq.IOrderedQueryable`1" /> Których elementy są sortowane według klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Wynikiem wywołania <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> jest rzutowanie na typ <xref:System.Linq.IOrderedQueryable%601> i zwrócenie.  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że sortuje elementy `source` na podstawie klucza uzyskanego przez wywoływanie `keySelector` dla każdego elementu `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> do sortowania elementów sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#70)]
 [!code-vb[System.Linq.Queryable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję, która jest reprezentowana przez <paramref name="keySelector" />.</typeparam>
        <param name="source">Sekwencja wartości do ustawienia w kolejności.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z elementu.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Do porównywania kluczy.</param>
        <summary>Sortuje elementy sekwencji w kolejności rosnącej przy użyciu określonej funkcji porównującej.</summary>
        <returns>, <see cref="T:System.Linq.IOrderedQueryable`1" /> Których elementy są sortowane według klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Wynikiem wywołania <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> jest rzutowanie na typ <xref:System.Linq.IOrderedQueryable%601> i zwrócenie.  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że sortuje elementy `source` na podstawie klucza uzyskanego przez wywoływanie `keySelector` dla każdego elementu `source`. `comparer` Parametr jest używany do porównywania kluczy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />or <paramref name="keySelector" /> lub <paramref name="comparer" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje elementy sekwencji w kolejności malejącej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderByDescending(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję, która jest reprezentowana przez <paramref name="keySelector" />.</typeparam>
        <param name="source">Sekwencja wartości do ustawienia w kolejności.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z elementu.</param>
        <summary>Sortuje elementy sekwencji w kolejności malejącej zgodnie z kluczem.</summary>
        <returns>, <see cref="T:System.Linq.IOrderedQueryable`1" /> Których elementy są sortowane w kolejności malejącej zgodnie z kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Wynikiem wywołania <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> jest rzutowanie na typ <xref:System.Linq.IOrderedQueryable%601> i zwrócenie.  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że sortuje elementy `source` w kolejności malejącej na podstawie klucza uzyskanego przez wywoływanie `keySelector` dla każdego elementu `source`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderByDescending(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję, która jest reprezentowana przez <paramref name="keySelector" />.</typeparam>
        <param name="source">Sekwencja wartości do ustawienia w kolejności.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z elementu.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Do porównywania kluczy.</param>
        <summary>Sortuje elementy sekwencji w kolejności malejącej przy użyciu określonej funkcji porównującej.</summary>
        <returns>, <see cref="T:System.Linq.IOrderedQueryable`1" /> Których elementy są sortowane w kolejności malejącej zgodnie z kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Wynikiem wywołania <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> jest rzutowanie na typ <xref:System.Linq.IOrderedQueryable%601> i zwrócenie.  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że sortuje elementy `source` w kolejności malejącej na podstawie klucza uzyskanego przez wywoływanie `keySelector` dla każdego elementu `source`. `comparer` Parametr jest używany do porównywania kluczy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> do sortowania elementów sekwencji w kolejności malejącej przy użyciu niestandardowej metody porównującej.  
  
 [!code-csharp[System.Linq.Queryable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#71)]
 [!code-vb[System.Linq.Queryable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />or <paramref name="keySelector" /> lub <paramref name="comparer" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Prepend``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Prepend(Of TSource) (source As IQueryable(Of TSource), element As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Prepend(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Prepend : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Prepend (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="element" Type="TSource" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Reverse``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Reverse(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości do odwrócenia.</param>
        <summary>Odwraca kolejność elementów w sekwencji.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Elementy odpowiadające ustawieniom sekwencji wejściowej w odwrotnej kolejności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że odwraca kolejność elementów w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> do odwrócenia kolejności elementów w tablicy.  
  
 [!code-csharp[System.Linq.Queryable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#74)]
 [!code-vb[System.Linq.Queryable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projektuje każdy element sekwencji w nowym formularzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Select(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Typ wartości zwracanej przez funkcję reprezentowanej przez <paramref name="selector" />.</typeparam>
        <param name="source">Sekwencja wartości do projektu.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Projektuje każdy element sekwencji w nowym formularzu, włączając indeks elementu.</summary>
        <returns>Których elementy są wynikiem wywołania funkcji projekcji na każdym <paramref name="source" />elemencie. <see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu w celu zaprojektowania go w innym formularzu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> do tworzenia projektu przez sekwencję wartości i używać indeksu każdego elementu w formularzu rzutowanym.  
  
 [!code-csharp[System.Linq.Queryable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#76)]
 [!code-vb[System.Linq.Queryable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Select(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Typ wartości zwracanej przez funkcję reprezentowanej przez <paramref name="selector" />.</typeparam>
        <param name="source">Sekwencja wartości do projektu.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Projektuje każdy element sekwencji w nowym formularzu.</summary>
        <returns>Których elementy są wynikiem wywołania funkcji projekcji na każdym <paramref name="source" />elemencie. <see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu w celu zaprojektowania go w innym formularzu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> do tworzenia projektów przez sekwencję wartości.  
  
 [!code-csharp[System.Linq.Queryable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#75)]
 [!code-vb[System.Linq.Queryable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projektuje każdy element sekwencji do <see cref="T:System.Collections.Generic.IEnumerable`1" /> i łączy wyniki sekwencji w jedną sekwencję typu. <see cref="T:System.Linq.IQueryable`1" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, IEnumerable(Of TResult)))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, seq&lt;'Result&gt;&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Typ elementów sekwencji zwracanych przez funkcję reprezentowane przez <paramref name="selector" />.</typeparam>
        <param name="source">Sekwencja wartości do projektu.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Projektuje każdy element sekwencji do <see cref="T:System.Collections.Generic.IEnumerable`1" /> i łączy wyniki sekwencji w jedną sekwencję.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Którego elementy są wynikiem wywołania funkcji projekcji jeden do wielu na każdym elemencie sekwencji wejściowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu w celu zaprojektowania go w postaci wyliczalnej. Następnie łączy wyliczalne wyniki w jedną jednowymiarową sekwencję.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> do wykonywania projekcji "jeden do wielu" na tablicy.  
  
 [!code-csharp[System.Linq.Queryable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#77)]
 [!code-vb[System.Linq.Queryable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer, IEnumerable(Of TResult)))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, seq&lt;'Result&gt;&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Typ elementów sekwencji zwracanych przez funkcję reprezentowane przez <paramref name="selector" />.</typeparam>
        <param name="source">Sekwencja wartości do projektu.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu; drugi parametr tej funkcji reprezentuje indeks elementu źródłowego.</param>
        <summary>Projektuje każdy element sekwencji do <see cref="T:System.Collections.Generic.IEnumerable`1" /> i łączy wyniki sekwencji w jedną sekwencję. Indeks każdego elementu źródłowego jest używany w przewidywanej formie tego elementu.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Którego elementy są wynikiem wywołania funkcji projekcji jeden do wielu na każdym elemencie sekwencji wejściowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu w celu zaprojektowania go w postaci wyliczalnej. Każdy wyliczalny wynik obejmuje indeks elementu źródłowego. Następnie łączy wyliczalne wyniki w jedną jednowymiarową sekwencję.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> do wykonywania projekcji jeden do wielu na tablicy i używania indeksu każdego elementu źródłowego.  
  
 [!code-csharp[System.Linq.Queryable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#78)]
 [!code-vb[System.Linq.Queryable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt; collectionSelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TCollection,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt;&gt; collectionSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IQueryable(Of TSource), collectionSelector As Expression(Of Func(Of TSource, IEnumerable(Of TCollection))), resultSelector As Expression(Of Func(Of TSource, TCollection, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^&gt; ^ collectionSelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TCollection, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, seq&lt;'Collection&gt;&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Collection, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TCollection,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TCollection">Typ elementów pośrednich zebranych przez funkcję reprezentowane przez <paramref name="collectionSelector" />.</typeparam>
        <typeparam name="TResult">Typ elementów wyniku sekwencji.</typeparam>
        <param name="source">Sekwencja wartości do projektu.</param>
        <param name="collectionSelector">Funkcja projekcji do zastosowania do każdego elementu sekwencji wejściowej.</param>
        <param name="resultSelector">Funkcja projekcji do zastosowania do każdego elementu każdej pośredniej sekwencji.</param>
        <summary>Projektuje każdy element sekwencji do <see cref="T:System.Collections.Generic.IEnumerable`1" /> i wywołuje funkcję selektora wyników dla każdego elementu w nim. Wynikowe wartości z każdej sekwencji pośredniej są łączone w jedną sekwencję jednowymiarową i zwracają.</summary>
        <returns>Których elementy są wynikiem wywołania funkcji <paramref name="collectionSelector" /> projekcji "jeden do wielu" dla każdego elementu <paramref name="source" /> , a następnie mapowania każdego z tych elementów sekwencji i ich odpowiedniego <paramref name="source" /> elementu do elementu wynikowego <see cref="T:System.Linq.IQueryable`1" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `collectionSelector` wywoływane dla każdego `source` elementu w celu zaprojektowania go w postaci wyliczalnej. Następnie funkcja reprezentowana przez `resultSelector` jest wywoływana dla każdego elementu w każdej pośredniej sekwencji. Wyniki są łączone w jedną sekwencję jednowymiarową.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> do wykonywania projekcji "jeden do wielu" na tablicy. W tym przykładzie zastosowano funkcję selektora wyniku, aby zachować element źródłowy, który odpowiada każdej pośredniej sekwencji w zakresie dla końcowego `Select`wywołania do.  
  
 [!code-csharp[System.Linq.Queryable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#124)]
 [!code-vb[System.Linq.Queryable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />or <paramref name="collectionSelector" /> lub <paramref name="resultSelector" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt; collectionSelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TCollection,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt;&gt; collectionSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IQueryable(Of TSource), collectionSelector As Expression(Of Func(Of TSource, Integer, IEnumerable(Of TCollection))), resultSelector As Expression(Of Func(Of TSource, TCollection, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^&gt; ^ collectionSelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TCollection, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, seq&lt;'Collection&gt;&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Collection, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TCollection,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TCollection">Typ elementów pośrednich zebranych przez funkcję reprezentowane przez <paramref name="collectionSelector" />.</typeparam>
        <typeparam name="TResult">Typ elementów wyniku sekwencji.</typeparam>
        <param name="source">Sekwencja wartości do projektu.</param>
        <param name="collectionSelector">Funkcja projekcji do zastosowania do każdego elementu sekwencji wejściowej; drugi parametr tej funkcji reprezentuje indeks elementu źródłowego.</param>
        <param name="resultSelector">Funkcja projekcji do zastosowania do każdego elementu każdej pośredniej sekwencji.</param>
        <summary>Projektuje każdy element sekwencji do <see cref="T:System.Collections.Generic.IEnumerable`1" /> , który zawiera indeks elementu źródłowego, który go utworzył. Funkcja selektora wyników jest wywoływana dla każdego elementu każdej pośredniej sekwencji, a wynikowe wartości są łączone w jedną sekwencję jednowymiarową i zwracają.</summary>
        <returns>Których elementy są wynikiem wywołania funkcji <paramref name="collectionSelector" /> projekcji "jeden do wielu" dla każdego elementu <paramref name="source" /> , a następnie mapowania każdego z tych elementów sekwencji i ich odpowiedniego <paramref name="source" /> elementu do elementu wynikowego <see cref="T:System.Linq.IQueryable`1" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `collectionSelector` wywoływane dla każdego `source` elementu w celu zaprojektowania go w postaci wyliczalnej. Każdy wyliczalny wynik obejmuje indeks elementu źródłowego. Następnie funkcja reprezentowana przez `resultSelector` jest wywoływana dla każdego elementu w każdej pośredniej sekwencji. Wyniki są łączone w jedną sekwencję jednowymiarową.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />or <paramref name="collectionSelector" /> lub <paramref name="resultSelector" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy dwie sekwencje są równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.SequenceEqual (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="source1">Których elementów należy porównać <paramref name="source2" />z. <see cref="T:System.Linq.IQueryable`1" /></param>
        <param name="source2"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Elementy do porównania z pierwszą sekwencją.</param>
        <summary>Określa, czy dwie sekwencje są równe przy użyciu domyślnej funkcji porównującej równość do porównywania elementów.</summary>
        <returns><see langword="true" />Jeśli dwie sekwencje źródłowe mają równą długość i odpowiadające im elementy są porównywane jako równe; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source1` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> , zależy od implementacji typu `source1` parametru. Oczekiwane zachowanie polega na tym, że decyduje o tym, czy dwie sekwencje źródłowe są równe.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> , aby określić, czy dwie sekwencje są równe. W tym przykładzie sekwencje są równe.  
  
 [!code-csharp[System.Linq.Queryable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#32)]
 [!code-vb[System.Linq.Queryable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#32)]  
  
 Poniższy przykład kodu porównuje dwie sekwencje, które nie są równe.  
  
 [!code-csharp[System.Linq.Queryable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#33)]
 [!code-vb[System.Linq.Queryable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" />lub <paramref name="source2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.SequenceEqual (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="source1">Których elementów należy porównać <paramref name="source2" />z. <see cref="T:System.Linq.IQueryable`1" /></param>
        <param name="source2"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Elementy do porównania z pierwszą sekwencją.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania elementów.</param>
        <summary>Określa, czy dwie sekwencje są równe przy użyciu <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> określonego do porównywania elementów.</summary>
        <returns><see langword="true" />Jeśli dwie sekwencje źródłowe mają równą długość i odpowiadające im elementy są porównywane jako równe; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source1` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> , zależy od implementacji typu `source1` parametru. Oczekiwane zachowanie polega na tym, że określa, czy dwie sekwencje źródłowe `comparer` są równe przy użyciu do porównywania elementów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" />lub <paramref name="source2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca pojedynczy, konkretny element sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia pojedynczego elementu.</param>
        <summary>Zwraca jedyny element sekwencji i zgłasza wyjątek, jeśli nie ma dokładnie jednego elementu w sekwencji.</summary>
        <returns>Pojedynczy element sekwencji wejściowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca tylko element `source`w.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> do wybierania tylko elementu tablicy.  
  
 [!code-csharp[System.Linq.Queryable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#79)]
 [!code-vb[System.Linq.Queryable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#79)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />ma więcej niż jeden element.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia pojedynczego elementu z.</param>
        <param name="predicate">Funkcja do testowania elementu dla warunku.</param>
        <summary>Zwraca jedyny element sekwencji, który spełnia określony warunek, i zgłasza wyjątek, jeśli istnieje więcej niż jeden taki element.</summary>
        <returns>Pojedynczy element sekwencji wejściowej, który spełnia warunek w <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca tylko element `source` w, który spełnia warunek określony `predicate`przez.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> do wybierania tylko elementu tablicy, który spełnia warunek.  
  
 [!code-csharp[System.Linq.Queryable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#81)]
 [!code-vb[System.Linq.Queryable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#81)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden element nie spełnia warunku <paramref name="predicate" />w elemencie.  
  
—lub— 
Więcej niż jeden element spełnia warunek w <paramref name="predicate" />.  
  
—lub— 
Sekwencja źródłowa jest pusta.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca pojedynczy, konkretny element sekwencji lub wartość domyślną, jeśli nie można znaleźć takiego elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia pojedynczego elementu.</param>
        <summary>Zwraca jedyny element sekwencji lub wartość domyślną, jeśli sekwencja jest pusta. Ta metoda zgłasza wyjątek, jeśli w sekwencji występuje więcej niż jeden element.</summary>
        <returns>Pojedynczy element sekwencji wejściowej lub <c>default</c>(<paramref name="TSource" />), jeśli sekwencja nie zawiera żadnych elementów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca tylko element `source`w lub wartość domyślną, jeśli `source` jest pusty.  
  
 <xref:System.Linq.Queryable.SingleOrDefault%2A> Metoda nie pozwala na określenie wartości domyślnej. Jeśli chcesz określić wartość domyślną inną niż `default(TSource)`, <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Użyj metody opisanej w sekcji przykład.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> do wybierania tylko elementu tablicy. Drugie zapytanie pokazuje, że <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> zwraca wartość domyślną, gdy sekwencja nie zawiera dokładnie jednego elementu.  
  
 [!code-csharp[System.Linq.Queryable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#83)]
 [!code-vb[System.Linq.Queryable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#83)]  
  
 Czasami wartość `default(TSource)` nie jest wartością domyślną, która ma być używana, jeśli kolekcja nie zawiera żadnych elementów. Zamiast sprawdzać wynik niepożądanej wartości domyślnej, a następnie zmieniać ją w razie potrzeby, można użyć <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> metody, aby określić wartość domyślną, która ma być używana, jeśli kolekcja jest pusta. Następnie należy wywołać <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> , aby uzyskać element. Poniższy przykład kodu używa obu technik do uzyskania wartości domyślnej 1, jeśli kolekcja numerów stron jest pusta. Ponieważ wartością domyślną dla liczby całkowitej jest 0, która nie jest zazwyczaj prawidłowym numerem strony, wartość domyślna musi być określona jako 1. Pierwsza zmienna wynikowa jest sprawdzana pod kątem niepożądanej wartości domyślnej po zakończeniu zapytania. Druga zmienna wynikowa jest uzyskiwana przez <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> wywołanie, aby określić wartość domyślną 1.  
  
 [!code-csharp[System.Linq.Queryable#133](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#133)]
 [!code-vb[System.Linq.Queryable#133](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#133)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />ma więcej niż jeden element.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia pojedynczego elementu z.</param>
        <param name="predicate">Funkcja do testowania elementu dla warunku.</param>
        <summary>Zwraca jedyny element sekwencji, który spełnia określony warunek lub wartość domyślną, jeśli taki element nie istnieje; Ta metoda zgłasza wyjątek, jeśli więcej niż jeden element spełnia warunek.</summary>
        <returns>Pojedynczy element sekwencji wejściowej, który spełnia warunek w <paramref name="predicate" />, lub <c>default</c>(<paramref name="TSource" />), jeśli taki element nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca tylko element `source` w, który spełnia warunek określony `predicate`przez, lub wartość domyślną, jeśli taki element nie istnieje.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> do wybierania tylko elementu tablicy, który spełnia warunek. Drugie zapytanie pokazuje, że <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> zwraca wartość domyślną, gdy sekwencja nie zawiera dokładnie jednego elementu, który spełnia warunek.  
  
 [!code-csharp[System.Linq.Queryable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#85)]
 [!code-vb[System.Linq.Queryable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#85)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Więcej niż jeden element spełnia warunek w <paramref name="predicate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Skip``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Skip(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia elementów z.</param>
        <param name="count">Liczba elementów do pominięcia przed zwróceniem pozostałych elementów.</param>
        <summary>Pomija określoną liczbę elementów w sekwencji, a następnie zwraca pozostałe elementy.</summary>
        <returns>Element <see cref="T:System.Linq.IQueryable`1" /> zawierający elementy występujące po określonym indeksie w sekwencji wejściowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że pomija pierwsze `count` elementy w `source` i zwraca pozostałe elementy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> , aby pominąć określoną liczbę elementów w sortowanej tablicy i zwrócić pozostałe elementy.  
  
 [!code-csharp[System.Linq.Queryable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#87)]
 [!code-vb[System.Linq.Queryable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipLast``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipLast(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipLast(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member SkipLast : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pomija elementy w sekwencji tak długo, jak określony warunek ma wartość true, a następnie zwraca pozostałe elementy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia elementów z.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Pomija elementy w sekwencji tak długo, jak określony warunek ma wartość true, a następnie zwraca pozostałe elementy.</summary>
        <returns>Zawiera elementy od <paramref name="source" /> pierwszego elementu w serii liniowej, które nie przeszły testu określonego przez <paramref name="predicate" />. <see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest stosowane `predicate` do każdego elementu w `source` , dopóki nie odnajdzie elementu, dla którego `predicate` zwraca wartość false. Ten element i wszystkie pozostałe elementy są zwracane.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> do pomijania elementów tablicy, tak długo, jak warunek ma wartość true.  
  
 [!code-csharp[System.Linq.Queryable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#88)]
 [!code-vb[System.Linq.Queryable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do zwrócenia elementów z.</param>
        <param name="predicate">Funkcja do testowania każdego elementu dla warunku; drugi parametr tej funkcji reprezentuje indeks elementu źródłowego.</param>
        <summary>Pomija elementy w sekwencji tak długo, jak określony warunek ma wartość true, a następnie zwraca pozostałe elementy. Indeks elementu jest używany w logice funkcji predykatu.</summary>
        <returns>Zawiera elementy od <paramref name="source" /> pierwszego elementu w serii liniowej, które nie przeszły testu określonego przez <paramref name="predicate" />. <see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest stosowane `predicate` do każdego elementu w `source` , dopóki nie odnajdzie elementu, dla którego `predicate` zwraca wartość false. Ten element i wszystkie pozostałe elementy są zwracane. Indeks każdego elementu źródłowego jest podany jako drugi argument `predicate`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> do pomijania elementów tablicy, o ile warunek zależny od indeksu elementu ma wartość true.  
  
 [!code-csharp[System.Linq.Queryable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#89)]
 [!code-vb[System.Linq.Queryable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza sumę sekwencji wartości liczbowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Linq.IQueryable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Linq.IQueryable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::IQueryable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Decimal" /> wartości do obliczania sumy.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Decimal" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca sumę wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> do sumowania wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Linq.IQueryable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Linq.IQueryable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::IQueryable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;double&gt; -&gt; double" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Double" /> wartości do obliczania sumy.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Double" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca sumę wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> do sumowania wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Linq.IQueryable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Linq.IQueryable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::IQueryable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;int&gt; -&gt; int" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int32" /> wartości do obliczania sumy.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Int32" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca sumę wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> do sumowania wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Linq.IQueryable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Linq.IQueryable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::IQueryable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;int64&gt; -&gt; int64" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Int64" /> wartości do obliczania sumy.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Int64" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca sumę wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> do sumowania wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja wartości dopuszczająca wartość null <see cref="T:System.Decimal" /> w celu obliczenia sumy.</param>
        <summary>Oblicza sumę sekwencji wartości dopuszczających wartość null <see cref="T:System.Decimal" /> .</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca sumę wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> do sumowania wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja wartości dopuszczająca wartość null <see cref="T:System.Double" /> w celu obliczenia sumy.</param>
        <summary>Oblicza sumę sekwencji wartości dopuszczających wartość null <see cref="T:System.Double" /> .</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca sumę wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> do sumowania wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja wartości dopuszczająca wartość null <see cref="T:System.Int32" /> w celu obliczenia sumy.</param>
        <summary>Oblicza sumę sekwencji wartości dopuszczających wartość null <see cref="T:System.Int32" /> .</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca sumę wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> do sumowania wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja wartości dopuszczająca wartość null <see cref="T:System.Int64" /> w celu obliczenia sumy.</param>
        <summary>Oblicza sumę sekwencji wartości dopuszczających wartość null <see cref="T:System.Int64" /> .</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca sumę wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> do sumowania wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja wartości dopuszczająca wartość null <see cref="T:System.Single" /> w celu obliczenia sumy.</param>
        <summary>Oblicza sumę sekwencji wartości dopuszczających wartość null <see cref="T:System.Single" /> .</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca sumę wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> do sumowania wartości sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Linq.IQueryable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Linq.IQueryable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::IQueryable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;single&gt; -&gt; single" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sekwencja <see cref="T:System.Single" /> wartości do obliczania sumy.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Single" /> wartości.</summary>
        <returns>Suma wartości w sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca sumę wartości w `source`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> do sumowania wartości sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Decimal))) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Decimal&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, decimal&gt;&gt; -&gt; decimal" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości typu <paramref name="TSource" />.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Decimal" /> wartości uzyskanych przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu i zwraca sumę wynikowych wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> do sumowania prognozowanych wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Double))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, double&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, double&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości typu <paramref name="TSource" />.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Double" /> wartości uzyskanych przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu i zwraca sumę wynikowych wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> do sumowania prognozowanych wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int&gt;&gt; -&gt; int" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości typu <paramref name="TSource" />.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Int32" /> wartości uzyskanych przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu i zwraca sumę wynikowych wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> do sumowania prognozowanych wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Long))) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, long&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int64&gt;&gt; -&gt; int64" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości typu <paramref name="TSource" />.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Int64" /> wartości uzyskanych przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu i zwraca sumę wynikowych wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> do sumowania prognozowanych wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;decimal&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Decimal)))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;decimal&gt;&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości typu <paramref name="TSource" />.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji wartości dopuszczających wartość null <see cref="T:System.Decimal" /> , która jest uzyskiwana przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu i zwraca sumę wynikowych wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> do sumowania prognozowanych wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;double&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Double)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;double&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;double&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości typu <paramref name="TSource" />.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji wartości dopuszczających wartość null <see cref="T:System.Double" /> , która jest uzyskiwana przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu i zwraca sumę wynikowych wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> do sumowania prognozowanych wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;int&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Integer)))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;int&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int&gt;&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości typu <paramref name="TSource" />.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji wartości dopuszczających wartość null <see cref="T:System.Int32" /> , która jest uzyskiwana przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu i zwraca sumę wynikowych wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> do sumowania prognozowanych wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;long&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Long)))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;long&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int64&gt;&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości typu <paramref name="TSource" />.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji wartości dopuszczających wartość null <see cref="T:System.Int64" /> , która jest uzyskiwana przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu i zwraca sumę wynikowych wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> do sumowania prognozowanych wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Suma jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;float&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Single)))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;float&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;single&gt;&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości typu <paramref name="TSource" />.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji wartości dopuszczających wartość null <see cref="T:System.Single" /> , która jest uzyskiwana przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu i zwraca sumę wynikowych wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> do sumowania prognozowanych wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Single))) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, float&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, single&gt;&gt; -&gt; single" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja wartości typu <paramref name="TSource" />.</param>
        <param name="selector">Funkcja projekcji do zastosowania do każdego elementu.</param>
        <summary>Oblicza sumę sekwencji <see cref="T:System.Single" /> wartości uzyskanych przez wywołanie funkcji projekcji na każdym elemencie sekwencji wejściowej.</summary>
        <returns>Suma przewidywanych wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `selector` wywoływane dla każdego `source` elementu i zwraca sumę wynikowych wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> do sumowania prognozowanych wartości sekwencji.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="selector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Take``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Take(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja, z której mają zostać zwrócone elementy.</param>
        <param name="count">Liczba elementów do zwrócenia.</param>
        <summary>Zwraca określoną liczbę elementów sąsiadujących od początku sekwencji.</summary>
        <returns>Element <see cref="T:System.Linq.IQueryable`1" /> zawierający określoną liczbę elementów od <paramref name="source" />początku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że pobiera `count` pierwsze elementy od `source`początku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> do zwracania elementów z początku sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#99)]
 [!code-vb[System.Linq.Queryable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeLast``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeLast(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeLast(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member TakeLast : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca elementy z sekwencji tak długo, jak określony warunek ma wartość true, a następnie pomija pozostałe elementy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja, z której mają zostać zwrócone elementy.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Zwraca elementy z sekwencji tak długo, jak określony warunek ma wartość true.</summary>
        <returns>Zawiera elementy z sekwencji wejściowej <paramref name="predicate" /> ,występującychprzedelementem,wktórymtestokreślonyprzezniejestjużprzekazywany.<see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `predicate` stosowane do każdego elementu w `source` , dopóki nie odnajdzie elementu, dla którego `predicate` zwraca `false`. Zwraca wszystkie elementy aż do tego momentu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> do zwracania elementów z początku sekwencji tak długo, jak warunek ma wartość true.  
  
 [!code-csharp[System.Linq.Queryable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#100)]
 [!code-vb[System.Linq.Queryable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source">Sekwencja, z której mają zostać zwrócone elementy.</param>
        <param name="predicate">Funkcja do testowania każdego elementu dla warunku; drugi parametr funkcji reprezentuje indeks elementu w sekwencji źródłowej.</param>
        <summary>Zwraca elementy z sekwencji tak długo, jak określony warunek ma wartość true. Indeks elementu jest używany w logice funkcji predykatu.</summary>
        <returns>Zawiera elementy z sekwencji wejściowej <paramref name="predicate" /> ,występującychprzedelementem,wktórymtestokreślonyprzezniejestjużprzekazywany.<see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie jest `predicate` stosowane do każdego elementu w `source` , dopóki nie odnajdzie elementu, dla którego `predicate` zwraca `false`. Zwraca wszystkie elementy aż do tego momentu. Indeks każdego elementu źródłowego jest podany jako drugi argument `predicate`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> do zwracania elementów z początku sekwencji tak długo, jak warunek, który używa indeksu elementu ma wartość true.  
  
 [!code-csharp[System.Linq.Queryable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#101)]
 [!code-vb[System.Linq.Queryable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje kolejne porządkowanie elementów w kolejności rosnącej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowane przez <paramref name="keySelector" />.</typeparam>
        <param name="source">Element <see cref="T:System.Linq.IOrderedQueryable`1" /> zawierający elementy do sortowania.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <summary>Wykonuje kolejne porządkowanie elementów w kolejności rosnącej według klucza.</summary>
        <returns>, <see cref="T:System.Linq.IOrderedQueryable`1" /> Których elementy są sortowane według klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Wynikiem wywołania <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> jest rzutowanie na typ <xref:System.Linq.IOrderedQueryable%601> i zwrócenie.  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że wykonuje pomocnicze sortowanie elementów `source` opartych na kluczu uzyskanym przez wywoływanie `keySelector` dla każdego elementu `source`. Wszystkie poprzednio ustanowione zamówienia sortowania są zachowywane.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> do wykonywania pomocniczej kolejności elementów w sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#102)]
 [!code-vb[System.Linq.Queryable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowane przez <paramref name="keySelector" />.</typeparam>
        <param name="source">Element <see cref="T:System.Linq.IOrderedQueryable`1" /> zawierający elementy do sortowania.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Do porównywania kluczy.</param>
        <summary>Wykonuje kolejne porządkowanie elementów w sekwencji rosnącej w kolejności przy użyciu określonej funkcji porównującej.</summary>
        <returns>, <see cref="T:System.Linq.IOrderedQueryable`1" /> Których elementy są sortowane według klucza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Wynikiem wywołania <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> jest rzutowanie na typ <xref:System.Linq.IOrderedQueryable%601> i zwrócenie.  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że wykonuje pomocnicze sortowanie elementów `source` opartych na kluczu uzyskanym przez wywoływanie `keySelector` dla każdego elementu `source`. Wszystkie poprzednio ustanowione zamówienia sortowania są zachowywane. `comparer` Parametr jest używany do porównywania wartości kluczy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />or <paramref name="keySelector" /> lub <paramref name="comparer" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje kolejne porządkowanie elementów w sekwencji w kolejności malejącej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza zwracanego przez funkcję reprezentowane przez <paramref name="keySelector" />.</typeparam>
        <param name="source">Element <see cref="T:System.Linq.IOrderedQueryable`1" /> zawierający elementy do sortowania.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <summary>Wykonuje kolejne porządkowanie elementów w sekwencji w kolejności malejącej, zgodnie z kluczem.</summary>
        <returns>, <see cref="T:System.Linq.IOrderedQueryable`1" /> Których elementy są sortowane w kolejności malejącej zgodnie z kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Wynikiem wywołania <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> jest rzutowanie na typ <xref:System.Linq.IOrderedQueryable%601> i zwrócenie.  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że wykonuje pomocnicze sortowanie elementów `source` w kolejności malejącej na podstawie klucza uzyskanego przez wywoływanie `keySelector` dla każdego elementu `source`. Wszystkie poprzednio ustanowione zamówienia sortowania są zachowywane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="keySelector" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Typ klucza, który jest zwracany przez <paramref name="keySelector" /> funkcję.</typeparam>
        <param name="source">Element <see cref="T:System.Linq.IOrderedQueryable`1" /> zawierający elementy do sortowania.</param>
        <param name="keySelector">Funkcja wyodrębniania klucza z każdego elementu.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Do porównywania kluczy.</param>
        <summary>Wykonuje kolejne porządkowanie elementów w sekwencji w kolejności malejącej przy użyciu określonej funkcji porównującej.</summary>
        <returns>Kolekcja, której elementy są sortowane w kolejności malejącej zgodnie z kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Wynikiem wywołania <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> jest rzutowanie na typ <xref:System.Linq.IOrderedQueryable%601> i zwrócenie.  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że wykonuje pomocnicze sortowanie elementów `source` w kolejności malejącej na podstawie klucza uzyskanego przez wywoływanie `keySelector` dla każdego elementu `source`. Wszystkie poprzednio ustanowione zamówienia sortowania są zachowywane. `comparer` Parametr jest używany do porównywania wartości kluczy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> do wykonywania pomocniczej kolejności elementów w sekwencji w kolejności malejącej przy użyciu niestandardowej funkcji porównującej.  
  
 [!code-csharp[System.Linq.Queryable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#103)]
 [!code-vb[System.Linq.Queryable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />or <paramref name="keySelector" /> lub <paramref name="comparer" /> is .<see langword="null" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy Unię zestawu dwóch sekwencji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Union(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Union (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="source1">Sekwencja, której odrębne elementy tworzą pierwszy zestaw dla operacji Union.</param>
        <param name="source2">Sekwencja, której odrębne elementy tworzą drugi zestaw dla operacji Union.</param>
        <summary>Tworzy Unię zestawu dwóch sekwencji przy użyciu domyślnej funkcji porównującej równość.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Zawiera elementy z obu sekwencji wejściowych, z wyjątkiem duplikatów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source1` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> , zależy od implementacji typu `source1` parametru. Oczekiwane zachowanie polega na tym, że zestaw zbiorów elementów w `source1` i `source2` jest zwracany.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> , aby uzyskać zestaw zbiorów dwóch sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#109)]
 [!code-vb[System.Linq.Queryable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#109)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" />lub <paramref name="source2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Union(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Union (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów sekwencji wejściowych.</typeparam>
        <param name="source1">Sekwencja, której odrębne elementy tworzą pierwszy zestaw dla operacji Union.</param>
        <param name="source2">Sekwencja, której odrębne elementy tworzą drugi zestaw dla operacji Union.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Do porównywania wartości.</param>
        <summary>Tworzy Unię zestawu dwóch sekwencji przy użyciu określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Zawiera elementy z obu sekwencji wejściowych, z wyjątkiem duplikatów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source1` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> , zależy od implementacji typu `source1` parametru. Oczekiwane zachowanie polega na tym, że zestaw zbiorów elementów w `source1` i `source2` jest zwracany. `comparer` Parametr jest używany do porównywania wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" />lub <paramref name="source2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Filtruje sekwencję wartości na podstawie predykatu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Where(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do filtrowania.</param>
        <param name="predicate">Funkcja testowania każdego elementu na stanie.</param>
        <summary>Filtruje sekwencję wartości na podstawie predykatu.</summary>
        <returns>Zawiera elementy z sekwencji wejściowej, które spełniają warunek określony przez <paramref name="predicate" />. <see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca elementy `source` z, które spełniają warunek określony `predicate`przez.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> do filtrowania sekwencji.  
  
 [!code-csharp[System.Linq.Queryable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#110)]
 [!code-vb[System.Linq.Queryable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Where(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.IQueryable`1" /> Do filtrowania.</param>
        <param name="predicate">Funkcja do testowania każdego elementu dla warunku; drugi parametr funkcji reprezentuje indeks elementu w sekwencji źródłowej.</param>
        <summary>Filtruje sekwencję wartości na podstawie predykatu. Indeks każdego elementu jest używany w logice funkcji predykatu.</summary>
        <returns>Zawiera elementy z sekwencji wejściowej, które spełniają warunek określony przez <paramref name="predicate" />. <see cref="T:System.Linq.IQueryable`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma co najmniej jeden parametr typu <xref:System.Linq.Expressions.Expression%601> , <xref:System.Func%602> którego argument typu jest jednym z typów. Dla tych parametrów można przekazać wyrażenie lambda i zostanie ono skompilowane do <xref:System.Linq.Expressions.Expression%601>.  
  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> jako metodę rodzajową. <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29>  
  
 Zachowanie zapytania, które występuje w wyniku wykonania drzewa wyrażenia, które reprezentuje wywołanie <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> , zależy od implementacji typu `source` parametru. Oczekiwane zachowanie polega na tym, że zwraca elementy `source` z, które spełniają warunek określony `predicate`przez. Indeks każdego elementu źródłowego jest podany jako drugi argument `predicate`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> do filtrowania sekwencji na podstawie predykatu, który zawiera indeks każdego elementu.  
  
 [!code-csharp[System.Linq.Queryable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#111)]
 [!code-vb[System.Linq.Queryable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;ValueTuple&lt;TFirst,TSecond&gt;&gt; Zip&lt;TFirst,TSecond&gt; (this System.Linq.IQueryable&lt;TFirst&gt; source1, System.Collections.Generic.IEnumerable&lt;TSecond&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;valuetype System.ValueTuple`2&lt;!!TFirst, !!TSecond&gt;&gt; Zip&lt;TFirst, TSecond&gt;(class System.Linq.IQueryable`1&lt;!!TFirst&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Zip``2(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond) (source1 As IQueryable(Of TFirst), source2 As IEnumerable(Of TSecond)) As IQueryable(Of ValueTuple(Of TFirst, TSecond))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;ValueTuple&lt;TFirst, TSecond&gt;&gt; ^ Zip(System::Linq::IQueryable&lt;TFirst&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.IQueryable&lt;'First&gt; * seq&lt;'Second&gt; -&gt; System.Linq.IQueryable&lt;ValueTuple&lt;'First, 'Second&gt;&gt;" Usage="System.Linq.Queryable.Zip (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.ValueTuple&lt;TFirst,TSecond&gt;&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "First", "Second" })</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TFirst&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Typ elementów pierwszej sekwencji wejściowej.</typeparam>
        <typeparam name="TSecond">Typ elementów drugiej sekwencji wejściowej.</typeparam>
        <param name="source1">Pierwsza sekwencja do scalenia.</param>
        <param name="source2">Druga sekwencja do scalenia.</param>
        <summary>Tworzy sekwencję krotek z elementami z dwóch określonych sekwencji.</summary>
        <returns>Sekwencja krotek z elementami pobranymi z pierwszej i drugiej sekwencji w tej kolejności.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.IQueryable&lt;TFirst&gt; source1, System.Collections.Generic.IEnumerable&lt;TSecond&gt; source2, System.Linq.Expressions.Expression&lt;Func&lt;TFirst,TSecond,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TFirst&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; source2, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Zip``3(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (source1 As IQueryable(Of TFirst), source2 As IEnumerable(Of TSecond), resultSelector As Expression(Of Func(Of TFirst, TSecond, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Zip(System::Linq::IQueryable&lt;TFirst&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ source2, System::Linq::Expressions::Expression&lt;Func&lt;TFirst, TSecond, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.IQueryable&lt;'First&gt; * seq&lt;'Second&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'First, 'Second, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Zip (source1, source2, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TFirst&gt;" RefType="this" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TFirst,TSecond,TResult&gt;&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Typ elementów pierwszej sekwencji wejściowej.</typeparam>
        <typeparam name="TSecond">Typ elementów drugiej sekwencji wejściowej.</typeparam>
        <typeparam name="TResult">Typ elementów sekwencji wyników.</typeparam>
        <param name="source1">Pierwsza sekwencja do scalenia.</param>
        <param name="source2">Druga sekwencja do scalenia.</param>
        <param name="resultSelector">Funkcja, która określa, jak scalić elementy z dwóch sekwencji.</param>
        <summary>Scala dwie sekwencje przy użyciu określonej funkcji predykatu.</summary>
        <returns><see cref="T:System.Linq.IQueryable`1" /> Zawiera scalone elementy dwóch sekwencji wejściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda generuje element <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący wywoływanie <xref:System.Linq.Queryable.Zip%2A> jako metodę rodzajową. <xref:System.Linq.Queryable.Zip%2A> <xref:System.Linq.Expressions.MethodCallExpression> Następnie przekazuje <xref:System.Linq.IQueryable.Provider%2A> do metody <xref:System.Linq.IQueryProvider> reprezentowanej przez Właściwość`source1` parametru. <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29>  
  
 Metoda Scala każdy element pierwszej sekwencji z elementem, który ma ten sam indeks w drugiej sekwencji. Jeśli sekwencje nie mają takiej samej liczby elementów, metoda scala sekwencje do momentu osiągnięcia końca jednego z nich. Na przykład jeśli jedna sekwencja ma trzy elementy, a drugi ma cztery, wynikiem sekwencji będzie tylko trzy elementy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Linq.Queryable.Zip%2A> jak za pomocą metody scalić dwie sekwencje.  
  
 [!code-csharp[System.Linq.Queryable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#200)]
 [!code-vb[System.Linq.Queryable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" />lub <paramref name="source2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

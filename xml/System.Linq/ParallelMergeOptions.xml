<Type Name="ParallelMergeOptions" FullName="System.Linq.ParallelMergeOptions">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ac2c5aac86669fa82f75f57b2322aa69fa4dc1cb" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46674573" />
  </Metadata>
  <TypeSignature Language="C#" Value="public enum ParallelMergeOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed ParallelMergeOptions extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Linq.ParallelMergeOptions" />
  <TypeSignature Language="VB.NET" Value="Public Enum ParallelMergeOptions" />
  <TypeSignature Language="C++ CLI" Value="public enum class ParallelMergeOptions" />
  <TypeSignature Language="F#" Value="type ParallelMergeOptions = " />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Określa preferowany typ *scalania danych wyjściowych* do użycia w zapytaniu. Innymi słowy oznacza to, jak program PLINQ powinno się scalać wyniki z różnych partycji do sekwencji pojedynczego wyniku. <span data-ttu-id="9d733-103">To jest tylko wskazówką i nie może być przestrzegane przez system, gdy przekształcają wszystkie zapytania.</span><span class="sxs-lookup"><span data-stu-id="9d733-103">This is a hint only, and may not be respected by the system when parallelizing all queries.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d733-104">Użyj `NotBuffered` dla zapytań, które będą używane oraz dane wyjściowe jako strumienie, to ma najniższe opóźnienie między początek wykonywania zapytania i elementy, które są uzyskane.</span><span class="sxs-lookup"><span data-stu-id="9d733-104">Use `NotBuffered` for queries that will be consumed and output as streams, this has the lowest latency between beginning query execution and elements being yielded.</span></span> <span data-ttu-id="9d733-105">Dla niektórych kwerend, takich jak te dotyczące sortowania (OrderBy, OrderByDescending), buforowania jest i wskazówkę dotyczącą NotBuffered lub AutoBuffered zostaną zignorowane.</span><span class="sxs-lookup"><span data-stu-id="9d733-105">For some queries, such as those involving a sort (OrderBy, OrderByDescending), buffering is essential and a hint of NotBuffered or AutoBuffered will be ignored.</span></span> <span data-ttu-id="9d733-106">Jednak zapytania, które są tworzone za pomocą operatora AsOrdered może być przesyłany strumieniowo tak długo, jak nie dalsze sortowanie jest wykonywane w ramach samo zapytanie.</span><span class="sxs-lookup"><span data-stu-id="9d733-106">However, queries that are created by using the AsOrdered operator can be streamed as long as no further sorting is performed within the query itself.</span></span>  
  
 <span data-ttu-id="9d733-107">Użyj `AutoBuffered` w większości przypadków; jest to opcja domyślna.</span><span class="sxs-lookup"><span data-stu-id="9d733-107">Use `AutoBuffered` for most cases; this is the default.</span></span> <span data-ttu-id="9d733-108">Trzeba je zrównoważyć opóźnienia i ogólną wydajność.</span><span class="sxs-lookup"><span data-stu-id="9d733-108">It strikes a balance between latency and overall performance.</span></span>  
  
 <span data-ttu-id="9d733-109">Użyj `FullyBuffered` dla zapytań, gdy wszystkie dane wyjściowe mogą być przetwarzane, zanim informacje te są wymagane.</span><span class="sxs-lookup"><span data-stu-id="9d733-109">Use `FullyBuffered` for queries when the entire output can be processed before the information is needed.</span></span> <span data-ttu-id="9d733-110">Ta opcja oferuje najlepszą wydajność, gdy wszystkie dane wyjściowe można zgromadzonych przed reaguje wszelkie informacje, chociaż nie jest odpowiednia do strumienia przetwarzania lub przedstawiający częściowe wyniki zapytania w środku.</span><span class="sxs-lookup"><span data-stu-id="9d733-110">This option offers the best performance when all of the output can be accumulated before yielding any information, though it is not suitable for stream processing or showing partial results mid-query.</span></span>  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">
      <span data-ttu-id="9d733-111">Równoległe LINQ (PLINQ)</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d733-111">Parallel LINQ (PLINQ)</span>
      </span>
    </related>
    <related type="Article" href="http://msdn.microsoft.com/library/e8f7be3b-88de-4f33-ab14-dc008e76c1ba">
      <span data-ttu-id="9d733-112">Opcje scalania w PLINQ</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d733-112">Merge Options in PLINQ</span>
      </span>
    </related>
    <related type="Article" href="http://msdn.microsoft.com/library/0f33b527-e91a-4550-a39a-e63e396fd831">
      <span data-ttu-id="9d733-113">Porady: określanie opcji scalania w PLINQ</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d733-113">How to: Specify Merge Options in PLINQ</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName="AutoBuffered">
      <MemberSignature Language="C#" Value="AutoBuffered" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions AutoBuffered = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.AutoBuffered" />
      <MemberSignature Language="VB.NET" Value="AutoBuffered" />
      <MemberSignature Language="C++ CLI" Value="AutoBuffered" />
      <MemberSignature Language="F#" Value="AutoBuffered = 2" Usage="System.Linq.ParallelMergeOptions.AutoBuffered" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="9d733-114">Scalanie za pomocą danych wyjściowych buforów o rozmiarze wybrany przez system.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d733-114">Use a merge with output buffers of a size chosen by the system.</span>
          </span>
          <span data-ttu-id="9d733-115">Wyniki będą gromadzone do buforu wyjściowego, zanim staną się dostępne dla klientów zapytania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d733-115">Results will accumulate into an output buffer before they are available to the consumer of the query.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="Default" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions Default = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.Default" />
      <MemberSignature Language="VB.NET" Value="Default" />
      <MemberSignature Language="C++ CLI" Value="Default" />
      <MemberSignature Language="F#" Value="Default = 0" Usage="System.Linq.ParallelMergeOptions.Default" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="9d733-116">Użyj domyślnego typu scalania, czyli AutoBuffered.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d733-116">Use the default merge type, which is AutoBuffered.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="FullyBuffered">
      <MemberSignature Language="C#" Value="FullyBuffered" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions FullyBuffered = int32(3)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.FullyBuffered" />
      <MemberSignature Language="VB.NET" Value="FullyBuffered" />
      <MemberSignature Language="C++ CLI" Value="FullyBuffered" />
      <MemberSignature Language="F#" Value="FullyBuffered = 3" Usage="System.Linq.ParallelMergeOptions.FullyBuffered" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>3</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="9d733-117">Scalanie za pomocą buforów pełne dane wyjściowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d733-117">Use a merge with full output buffers.</span>
          </span>
          <span data-ttu-id="9d733-118">System gromadzone wszystkie wyniki przed udostępnieniem ich konsumenta zapytania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d733-118">The system will accumulate all of the results before making any of them available to the consumer of the query.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NotBuffered">
      <MemberSignature Language="C#" Value="NotBuffered" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Linq.ParallelMergeOptions NotBuffered = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Linq.ParallelMergeOptions.NotBuffered" />
      <MemberSignature Language="VB.NET" Value="NotBuffered" />
      <MemberSignature Language="C++ CLI" Value="NotBuffered" />
      <MemberSignature Language="F#" Value="NotBuffered = 1" Usage="System.Linq.ParallelMergeOptions.NotBuffered" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelMergeOptions</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="9d733-119">Za pomocą scalania bez buforów danych wyjściowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d733-119">Use a merge without output buffers.</span>
          </span>
          <span data-ttu-id="9d733-120">Jak najszybciej po obliczeniu wyniku elementy udostępnić ten element konsumenta zapytania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d733-120">As soon as result elements have been computed, make that element available to the consumer of the query.</span>
          </span>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>